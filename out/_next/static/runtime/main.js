(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["static/runtime/main.js"],{

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

var isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct */ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/extends.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/extends.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/client.js":
/*!************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/client.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var Bus = __importStar(__webpack_require__(/*! ./internal/bus */ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js"));
var parseStack_1 = __webpack_require__(/*! ./internal/helpers/parseStack */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/parseStack.js");
var isRegistered = false;
var stackTraceLimit = undefined;
function onUnhandledError(ev) {
    var error = ev === null || ev === void 0 ? void 0 : ev.error;
    if (!error || !(error instanceof Error) || typeof error.stack !== 'string') {
        // A non-error was thrown, we don't have anything to show. :-(
        return;
    }
    var e = error;
    Bus.emit({
        type: Bus.TYPE_UNHANDLED_ERROR,
        reason: error,
        frames: parseStack_1.parseStack(e.stack)
    });
}
function onUnhandledRejection(ev) {
    var reason = ev === null || ev === void 0 ? void 0 : ev.reason;
    if (!reason ||
        !(reason instanceof Error) ||
        typeof reason.stack !== 'string') {
        // A non-error was thrown, we don't have anything to show. :-(
        return;
    }
    var e = reason;
    Bus.emit({
        type: Bus.TYPE_UNHANDLED_REJECTION,
        reason: reason,
        frames: parseStack_1.parseStack(e.stack)
    });
}
function register() {
    if (isRegistered) {
        return;
    }
    isRegistered = true;
    try {
        var limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 50;
        stackTraceLimit = limit;
    }
    catch (_a) { }
    window.addEventListener('error', onUnhandledError);
    window.addEventListener('unhandledrejection', onUnhandledRejection);
}
exports.register = register;
function unregister() {
    if (!isRegistered) {
        return;
    }
    isRegistered = false;
    if (stackTraceLimit !== undefined) {
        try {
            Error.stackTraceLimit = stackTraceLimit;
        }
        catch (_a) { }
        stackTraceLimit = undefined;
    }
    window.removeEventListener('error', onUnhandledError);
    window.removeEventListener('unhandledrejection', onUnhandledRejection);
}
exports.unregister = unregister;
function onBuildOk() {
    Bus.emit({ type: Bus.TYPE_BUILD_OK });
}
exports.onBuildOk = onBuildOk;
function onBuildError(message) {
    Bus.emit({ type: Bus.TYPE_BUILD_ERROR, message: message });
}
exports.onBuildError = onBuildError;
function onRefresh() {
    Bus.emit({ type: Bus.TYPE_REFFRESH });
}
exports.onRefresh = onRefresh;
var nodeStackFrames_1 = __webpack_require__(/*! ./internal/helpers/nodeStackFrames */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js");
exports.getNodeError = nodeStackFrames_1.getNodeError;
var ReactDevOverlay_1 = __webpack_require__(/*! ./internal/ReactDevOverlay */ "./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js");
exports.ReactDevOverlay = ReactDevOverlay_1["default"];


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/ErrorBoundary.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/ErrorBoundary.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var ErrorBoundary = /** @class */ (function (_super) {
    __extends(ErrorBoundary, _super);
    function ErrorBoundary() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = { error: null };
        return _this;
    }
    ErrorBoundary.prototype.componentDidCatch = function (error, 
    // Loosely typed because it depends on the React version and was
    // accidentally excluded in some versions.
    errorInfo) {
        this.props.onError(error, (errorInfo === null || errorInfo === void 0 ? void 0 : errorInfo.componentStack) || null);
        this.setState({ error: error });
    };
    ErrorBoundary.prototype.render = function () {
        return this.state.error
            ? // The component has to be unmounted or else it would continue to error
                null
            : this.props.children;
    };
    return ErrorBoundary;
}(react_1["default"].PureComponent));
exports.ErrorBoundary = ErrorBoundary;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var Bus = __importStar(__webpack_require__(/*! ./bus */ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js"));
var ShadowPortal_1 = __webpack_require__(/*! ./components/ShadowPortal */ "./node_modules/@next/react-dev-overlay/lib/internal/components/ShadowPortal.js");
var Errors_1 = __webpack_require__(/*! ./container/Errors */ "./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js");
var BuildError_1 = __webpack_require__(/*! ./container/BuildError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js");
var ErrorBoundary_1 = __webpack_require__(/*! ./ErrorBoundary */ "./node_modules/@next/react-dev-overlay/lib/internal/ErrorBoundary.js");
var Base_1 = __webpack_require__(/*! ./styles/Base */ "./node_modules/@next/react-dev-overlay/lib/internal/styles/Base.js");
var ComponentStyles_1 = __webpack_require__(/*! ./styles/ComponentStyles */ "./node_modules/@next/react-dev-overlay/lib/internal/styles/ComponentStyles.js");
var CssReset_1 = __webpack_require__(/*! ./styles/CssReset */ "./node_modules/@next/react-dev-overlay/lib/internal/styles/CssReset.js");
function reducer(state, ev) {
    switch (ev.type) {
        case Bus.TYPE_BUILD_OK: {
            return __assign(__assign({}, state), { buildError: null });
        }
        case Bus.TYPE_BUILD_ERROR: {
            return __assign(__assign({}, state), { buildError: ev.message });
        }
        case Bus.TYPE_REFFRESH: {
            return __assign(__assign({}, state), { buildError: null, errors: [] });
        }
        case Bus.TYPE_UNHANDLED_ERROR:
        case Bus.TYPE_UNHANDLED_REJECTION: {
            return __assign(__assign({}, state), { nextId: state.nextId + 1, errors: __spread(state.errors, [{ id: state.nextId, event: ev }]) });
        }
        default: {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            var _1 = ev;
            return state;
        }
    }
}
function ReactDevOverlay(_a) {
    var children = _a.children;
    var _b = __read(React.useReducer(reducer, { nextId: 1, buildError: null, errors: [] }), 2), state = _b[0], dispatch = _b[1];
    React.useEffect(function () {
        Bus.on(dispatch);
        return function () {
            Bus.off(dispatch);
        };
    }, [dispatch]);
    var onComponentError = React.useCallback(function (error, componentStack) {
        // TODO: special handling
    }, []);
    var hasBuildError = state.buildError != null;
    var hasRuntimeErrors = Boolean(state.errors.length);
    var isMounted = hasBuildError || hasRuntimeErrors;
    return (React.createElement(React.Fragment, null,
        React.createElement(ErrorBoundary_1.ErrorBoundary, { onError: onComponentError }, children !== null && children !== void 0 ? children : null),
        isMounted ? (React.createElement(ShadowPortal_1.ShadowPortal, null,
            React.createElement(CssReset_1.CssReset, null),
            React.createElement(Base_1.Base, null),
            React.createElement(ComponentStyles_1.ComponentStyles, null),
            hasBuildError ? (React.createElement(BuildError_1.BuildError, { message: state.buildError })) : hasRuntimeErrors ? (React.createElement(Errors_1.Errors, { errors: state.errors })) : (undefined))) : (undefined)));
}
exports["default"] = ReactDevOverlay;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js":
/*!******************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/bus.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
exports.TYPE_BUILD_OK = 'build-ok';
exports.TYPE_BUILD_ERROR = 'build-error';
exports.TYPE_REFFRESH = 'fast-refresh';
exports.TYPE_UNHANDLED_ERROR = 'unhandled-error';
exports.TYPE_UNHANDLED_REJECTION = 'unhandled-rejection';
var handlers = new Set();
var queue = [];
function drain() {
    // Draining should never happen synchronously in case multiple handlers are
    // registered.
    setTimeout(function () {
        var _loop_1 = function () {
            var ev = queue.shift();
            handlers.forEach(function (handler) { return handler(ev); });
        };
        while (
        // Until we are out of events:
        Boolean(queue.length) &&
            // Or, if all handlers removed themselves as a result of handling the
            // event(s)
            Boolean(handlers.size)) {
            _loop_1();
        }
    }, 1);
}
function emit(ev) {
    queue.push(Object.freeze(__assign({}, ev)));
    drain();
}
exports.emit = emit;
function on(fn) {
    if (handlers.has(fn)) {
        return false;
    }
    handlers.add(fn);
    drain();
    return true;
}
exports.on = on;
function off(fn) {
    if (handlers.has(fn)) {
        handlers["delete"](fn);
        return true;
    }
    return false;
}
exports.off = off;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var anser_1 = __importDefault(__webpack_require__(/*! anser */ "./node_modules/anser/lib/index.js"));
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var strip_ansi_1 = __importDefault(__webpack_require__(/*! strip-ansi */ "./node_modules/@next/react-dev-overlay/node_modules/strip-ansi/index.js"));
var stack_frame_1 = __webpack_require__(/*! ../../helpers/stack-frame */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js");
exports.CodeFrame = function CodeFrame(_a) {
    var stackFrame = _a.stackFrame, codeFrame = _a.codeFrame;
    // Strip leading spaces out of the code frame:
    var formattedFrame = React.useMemo(function () {
        var lines = codeFrame.split(/\r?\n/g);
        var prefixLength = lines
            .map(function (line) { return /^>? +\d+ +\| ( *)/.exec(strip_ansi_1["default"](line)); })
            .filter(Boolean)
            .map(function (v) { return v.pop(); })
            .reduce(function (c, n) { return (isNaN(c) ? n.length : Math.min(c, n.length)); }, NaN);
        if (prefixLength > 1) {
            var p_1 = ' '.repeat(prefixLength);
            return lines
                .map(function (line, a) {
                return ~(a = line.indexOf('|'))
                    ? line.substring(0, a) + line.substring(a).replace(p_1, '')
                    : line;
            })
                .join('\n');
        }
        return lines.join('\n');
    }, [codeFrame]);
    var decoded = React.useMemo(function () {
        return anser_1["default"].ansiToJson(formattedFrame, {
            json: true,
            use_classes: true,
            remove_empty: true
        });
    }, [formattedFrame]);
    var open = React.useCallback(function () {
        var _a;
        var params = new URLSearchParams();
        for (var key in stackFrame) {
            params.append(key, ((_a = stackFrame[key]) !== null && _a !== void 0 ? _a : '').toString());
        }
        self.fetch("/__nextjs_launch-editor?" + params.toString()).then(function () { }, function () {
            // TODO: report error
        });
    }, [stackFrame]);
    // TODO: make the caret absolute
    return (React.createElement("div", { "data-nextjs-codeframe": true },
        React.createElement("p", { role: "link", onClick: open, tabIndex: 1, title: "Click to open in your editor" },
            React.createElement("span", null,
                stack_frame_1.getFrameSource(stackFrame),
                " @ ",
                stackFrame.methodName),
            React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
                React.createElement("path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" }),
                React.createElement("polyline", { points: "15 3 21 3 21 9" }),
                React.createElement("line", { x1: "10", y1: "14", x2: "21", y2: "3" }))),
        React.createElement("hr", null),
        React.createElement("pre", null, decoded.map(function (entry, index) { return (React.createElement("span", { key: "frame-" + index, style: __assign({ color: entry.fg ? "var(--color-" + entry.fg + ")" : undefined }, (entry.decoration === 'bold'
                ? { fontWeight: 800 }
                : entry.decoration === 'italic'
                    ? { fontStyle: 'italic' }
                    : undefined)) }, entry.content)); }))));
};


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/index.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var CodeFrame_1 = __webpack_require__(/*! ./CodeFrame */ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js");
exports.CodeFrame = CodeFrame_1.CodeFrame;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/styles.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/styles.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-codeframe] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-codeframe]::selection,\n  [data-nextjs-codeframe] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-codeframe] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n\n  [data-nextjs-codeframe] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  [data-nextjs-codeframe] > hr {\n    margin: 0;\n    padding: 0;\n\n    border: none;\n    border-style: solid;\n    border-width: 0;\n    border-bottom-width: 1px;\n    border-color: var(--color-ansi-bright-black);\n  }\n\n  [data-nextjs-codeframe] > p {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    cursor: pointer;\n  }\n  [data-nextjs-codeframe] > p:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-codeframe] > p > svg {\n    width: auto;\n    height: 1em;\n    margin-left: 0.5rem;\n  }\n"], ["\n  [data-nextjs-codeframe] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-codeframe]::selection,\n  [data-nextjs-codeframe] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-codeframe] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n\n  [data-nextjs-codeframe] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  [data-nextjs-codeframe] > hr {\n    margin: 0;\n    padding: 0;\n\n    border: none;\n    border-style: solid;\n    border-width: 0;\n    border-bottom-width: 1px;\n    border-color: var(--color-ansi-bright-black);\n  }\n\n  [data-nextjs-codeframe] > p {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    cursor: pointer;\n  }\n  [data-nextjs-codeframe] > p:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-codeframe] > p > svg {\n    width: auto;\n    height: 1em;\n    margin-left: 0.5rem;\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/Dialog.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/Dialog.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var use_on_click_outside_1 = __webpack_require__(/*! ../../hooks/use-on-click-outside */ "./node_modules/@next/react-dev-overlay/lib/internal/hooks/use-on-click-outside.js");
var Dialog = function Dialog(_a) {
    var children = _a.children, type = _a.type, onClose = _a.onClose, props = __rest(_a, ["children", "type", "onClose"]);
    var _b = __read(React.useState(null), 2), dialog = _b[0], setDialog = _b[1];
    var onDialog = React.useCallback(function (node) {
        setDialog(node);
    }, []);
    use_on_click_outside_1.useOnClickOutside(dialog, onClose);
    // Make HTMLElements with `role=link` accessible to be triggered by the
    // keyboard, i.e. [Enter].
    React.useEffect(function () {
        if (dialog == null) {
            return;
        }
        var root = dialog.getRootNode();
        // Always true, but we do this for TypeScript:
        if (!(root instanceof ShadowRoot)) {
            return;
        }
        var shadowRoot = root;
        function handler(e) {
            var el = shadowRoot.activeElement;
            if (e.key === 'Enter' &&
                el instanceof HTMLElement &&
                el.getAttribute('role') === 'link') {
                e.preventDefault();
                e.stopPropagation();
                el.click();
            }
        }
        shadowRoot.addEventListener('keydown', handler);
        return function () { return shadowRoot.removeEventListener('keydown', handler); };
    }, [dialog]);
    return (React.createElement("div", { ref: onDialog, "data-nextjs-dialog": true, tabIndex: -1, role: "dialog", "aria-labelledby": props['aria-labelledby'], "aria-describedby": props['aria-describedby'], "aria-modal": "true" },
        React.createElement("div", { "data-nextjs-dialog-banner": true, className: "banner-" + type }),
        children));
};
exports.Dialog = Dialog;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogBody.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogBody.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var DialogBody = function DialogBody(_a) {
    var children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-dialog-body": true, className: className }, children));
};
exports.DialogBody = DialogBody;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogContent.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogContent.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var DialogContent = function DialogContent(_a) {
    var children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-dialog-content": true, className: className }, children));
};
exports.DialogContent = DialogContent;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogHeader.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogHeader.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var DialogHeader = function DialogHeader(_a) {
    var children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-dialog-header": true, className: className }, children));
};
exports.DialogHeader = DialogHeader;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Dialog_1 = __webpack_require__(/*! ./Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/Dialog.js");
exports.Dialog = Dialog_1.Dialog;
var DialogBody_1 = __webpack_require__(/*! ./DialogBody */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogBody.js");
exports.DialogBody = DialogBody_1.DialogBody;
var DialogContent_1 = __webpack_require__(/*! ./DialogContent */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogContent.js");
exports.DialogContent = DialogContent_1.DialogContent;
var DialogHeader_1 = __webpack_require__(/*! ./DialogHeader */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogHeader.js");
exports.DialogHeader = DialogHeader_1.DialogHeader;
var styles_1 = __webpack_require__(/*! ./styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/styles.js");
exports.styles = styles_1.styles;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/styles.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/styles.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-dialog] {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    margin-right: auto;\n    margin-left: auto;\n    outline: none;\n    background: white;\n    border-radius: var(--size-gap);\n    box-shadow: 0 var(--size-gap-half) var(--size-gap-double)\n      rgba(0, 0, 0, 0.25);\n    max-height: calc(100% - 3.5rem);\n    overflow-y: hidden;\n  }\n\n  @media (min-width: 576px) {\n    [data-nextjs-dialog] {\n      max-width: 540px;\n      box-shadow: 0 var(--size-gap) var(--size-gap-quad) rgba(0, 0, 0, 0.25);\n    }\n  }\n\n  @media (min-width: 768px) {\n    [data-nextjs-dialog] {\n      max-width: 720px;\n    }\n  }\n\n  @media (min-width: 992px) {\n    [data-nextjs-dialog] {\n      max-width: 960px;\n    }\n  }\n\n  [data-nextjs-dialog-banner] {\n    position: relative;\n  }\n  [data-nextjs-dialog-banner].banner-warning {\n    border-color: var(--color-ansi-yellow);\n  }\n  [data-nextjs-dialog-banner].banner-error {\n    border-color: var(--color-ansi-red);\n  }\n\n  [data-nextjs-dialog-banner]::after {\n    z-index: 2;\n    content: '';\n    position: absolute;\n    top: 0;\n    right: 0;\n    width: 100%;\n    /* banner width: */\n    border-top-width: var(--size-gap-half);\n    border-bottom-width: 0;\n    border-top-style: solid;\n    border-bottom-style: solid;\n    border-top-color: inherit;\n    border-bottom-color: transparent;\n  }\n\n  [data-nextjs-dialog-content] {\n    overflow-y: auto;\n    border: none;\n    margin: 0;\n    /* calc(padding + banner width offset) */\n    padding: calc(var(--size-gap-double) + var(--size-gap-half))\n      var(--size-gap-double);\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-header] {\n    flex-shrink: 0;\n    margin-bottom: var(--size-gap-double);\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-body] {\n    position: relative;\n    flex: 1 1 auto;\n  }\n"], ["\n  [data-nextjs-dialog] {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    margin-right: auto;\n    margin-left: auto;\n    outline: none;\n    background: white;\n    border-radius: var(--size-gap);\n    box-shadow: 0 var(--size-gap-half) var(--size-gap-double)\n      rgba(0, 0, 0, 0.25);\n    max-height: calc(100% - 3.5rem);\n    overflow-y: hidden;\n  }\n\n  @media (min-width: 576px) {\n    [data-nextjs-dialog] {\n      max-width: 540px;\n      box-shadow: 0 var(--size-gap) var(--size-gap-quad) rgba(0, 0, 0, 0.25);\n    }\n  }\n\n  @media (min-width: 768px) {\n    [data-nextjs-dialog] {\n      max-width: 720px;\n    }\n  }\n\n  @media (min-width: 992px) {\n    [data-nextjs-dialog] {\n      max-width: 960px;\n    }\n  }\n\n  [data-nextjs-dialog-banner] {\n    position: relative;\n  }\n  [data-nextjs-dialog-banner].banner-warning {\n    border-color: var(--color-ansi-yellow);\n  }\n  [data-nextjs-dialog-banner].banner-error {\n    border-color: var(--color-ansi-red);\n  }\n\n  [data-nextjs-dialog-banner]::after {\n    z-index: 2;\n    content: '';\n    position: absolute;\n    top: 0;\n    right: 0;\n    width: 100%;\n    /* banner width: */\n    border-top-width: var(--size-gap-half);\n    border-bottom-width: 0;\n    border-top-style: solid;\n    border-bottom-style: solid;\n    border-top-color: inherit;\n    border-bottom-color: transparent;\n  }\n\n  [data-nextjs-dialog-content] {\n    overflow-y: auto;\n    border: none;\n    margin: 0;\n    /* calc(padding + banner width offset) */\n    padding: calc(var(--size-gap-double) + var(--size-gap-half))\n      var(--size-gap-double);\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-header] {\n    flex-shrink: 0;\n    margin-bottom: var(--size-gap-double);\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-body] {\n    position: relative;\n    flex: 1 1 auto;\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var LeftRightDialogHeader = function LeftRightDialogHeader(_a) {
    var children = _a.children, className = _a.className, previous = _a.previous, next = _a.next, close = _a.close;
    var buttonLeft = React.useRef();
    var buttonRight = React.useRef();
    var buttonClose = React.useRef();
    var _b = __read(React.useState(null), 2), nav = _b[0], setNav = _b[1];
    var onNav = React.useCallback(function (el) {
        setNav(el);
    }, []);
    React.useEffect(function () {
        if (nav == null) {
            return;
        }
        var root = nav.getRootNode();
        var d = self.document;
        function handler(e) {
            if (e.key === 'ArrowLeft') {
                e.stopPropagation();
                if (buttonLeft.current) {
                    buttonLeft.current.focus();
                }
                previous && previous();
            }
            else if (e.key === 'ArrowRight') {
                e.stopPropagation();
                if (buttonRight.current) {
                    buttonRight.current.focus();
                }
                next && next();
            }
            else if (e.key === 'Escape') {
                e.stopPropagation();
                if (root instanceof ShadowRoot) {
                    var a = root.activeElement;
                    if (a && a !== buttonClose.current && a instanceof HTMLElement) {
                        a.blur();
                        return;
                    }
                }
                close();
            }
        }
        root.addEventListener('keydown', handler);
        if (root !== d) {
            d.addEventListener('keydown', handler);
        }
        return function () {
            root.removeEventListener('keydown', handler);
            if (root !== d) {
                d.removeEventListener('keydown', handler);
            }
        };
    }, [close, nav, next, previous]);
    // Unlock focus for browsers like Firefox, that break all user focus if the
    // currently focused item becomes disabled.
    React.useEffect(function () {
        if (nav == null) {
            return;
        }
        var root = nav.getRootNode();
        // Always true, but we do this for TypeScript:
        if (root instanceof ShadowRoot) {
            var a = root.activeElement;
            if (previous == null) {
                if (a === buttonLeft.current) {
                    buttonLeft.current.blur();
                }
            }
            else if (next == null) {
                if (a === buttonRight.current) {
                    buttonRight.current.blur();
                }
            }
        }
    }, [nav, next, previous]);
    return (React.createElement("div", { "data-nextjs-dialog-left-right": true, className: className },
        React.createElement("nav", { ref: onNav },
            React.createElement("button", { ref: buttonLeft, type: "button", disabled: previous == null ? true : undefined, "aria-disabled": previous == null ? true : undefined, onClick: previous !== null && previous !== void 0 ? previous : undefined },
                React.createElement("svg", { viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                    React.createElement("path", { d: "M6.99996 1.16666L1.16663 6.99999L6.99996 12.8333M12.8333 6.99999H1.99996H12.8333Z", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }))),
            React.createElement("button", { ref: buttonRight, type: "button", disabled: next == null ? true : undefined, "aria-disabled": next == null ? true : undefined, onClick: next !== null && next !== void 0 ? next : undefined },
                React.createElement("svg", { viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                    React.createElement("path", { d: "M6.99996 1.16666L12.8333 6.99999L6.99996 12.8333M1.16663 6.99999H12H1.16663Z", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }))),
            "\u00A0",
            children),
        React.createElement("button", { ref: buttonClose, type: "button", onClick: close, "aria-label": "Close" },
            React.createElement("span", { "aria-hidden": "true" },
                React.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                    React.createElement("path", { d: "M18 6L6 18", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }),
                    React.createElement("path", { d: "M6 6L18 18", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }))))));
};
exports.LeftRightDialogHeader = LeftRightDialogHeader;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var LeftRightDialogHeader_1 = __webpack_require__(/*! ./LeftRightDialogHeader */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js");
exports.LeftRightDialogHeader = LeftRightDialogHeader_1.LeftRightDialogHeader;
var styles_1 = __webpack_require__(/*! ./styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js");
exports.styles = styles_1.styles;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-dialog-left-right] {\n    display: flex;\n    flex-direction: row;\n    align-content: center;\n    align-items: center;\n    justify-content: space-between;\n  }\n  [data-nextjs-dialog-left-right] > nav > button {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n\n    width: calc(var(--size-gap-double) + var(--size-gap));\n    height: calc(var(--size-gap-double) + var(--size-gap));\n    font-size: 0;\n    border: none;\n    background-color: rgba(255, 85, 85, 0.1);\n    color: var(--color-ansi-red);\n    cursor: pointer;\n    transition: background-color 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > nav > button > svg {\n    width: auto;\n    height: calc(var(--size-gap) + var(--size-gap-half));\n  }\n  [data-nextjs-dialog-left-right] > nav > button:hover {\n    background-color: rgba(255, 85, 85, 0.2);\n  }\n  [data-nextjs-dialog-left-right] > nav > button:disabled {\n    background-color: rgba(255, 85, 85, 0.1);\n    color: rgba(255, 85, 85, 0.4);\n    cursor: not-allowed;\n  }\n\n  [data-nextjs-dialog-left-right] > nav > button:first-of-type {\n    border-radius: var(--size-gap-half) 0 0 var(--size-gap-half);\n    margin-right: 1px;\n  }\n  [data-nextjs-dialog-left-right] > nav > button:last-of-type {\n    border-radius: 0 var(--size-gap-half) var(--size-gap-half) 0;\n  }\n\n  [data-nextjs-dialog-left-right] > button:last-of-type {\n    border: 0;\n    padding: 0;\n\n    background-color: transparent;\n    appearance: none;\n\n    opacity: 0.4;\n    transition: opacity 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > button:last-of-type:hover {\n    opacity: 0.7;\n  }\n"], ["\n  [data-nextjs-dialog-left-right] {\n    display: flex;\n    flex-direction: row;\n    align-content: center;\n    align-items: center;\n    justify-content: space-between;\n  }\n  [data-nextjs-dialog-left-right] > nav > button {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n\n    width: calc(var(--size-gap-double) + var(--size-gap));\n    height: calc(var(--size-gap-double) + var(--size-gap));\n    font-size: 0;\n    border: none;\n    background-color: rgba(255, 85, 85, 0.1);\n    color: var(--color-ansi-red);\n    cursor: pointer;\n    transition: background-color 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > nav > button > svg {\n    width: auto;\n    height: calc(var(--size-gap) + var(--size-gap-half));\n  }\n  [data-nextjs-dialog-left-right] > nav > button:hover {\n    background-color: rgba(255, 85, 85, 0.2);\n  }\n  [data-nextjs-dialog-left-right] > nav > button:disabled {\n    background-color: rgba(255, 85, 85, 0.1);\n    color: rgba(255, 85, 85, 0.4);\n    cursor: not-allowed;\n  }\n\n  [data-nextjs-dialog-left-right] > nav > button:first-of-type {\n    border-radius: var(--size-gap-half) 0 0 var(--size-gap-half);\n    margin-right: 1px;\n  }\n  [data-nextjs-dialog-left-right] > nav > button:last-of-type {\n    border-radius: 0 var(--size-gap-half) var(--size-gap-half) 0;\n  }\n\n  [data-nextjs-dialog-left-right] > button:last-of-type {\n    border: 0;\n    padding: 0;\n\n    background-color: transparent;\n    appearance: none;\n\n    opacity: 0.4;\n    transition: opacity 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > button:last-of-type:hover {\n    opacity: 0.7;\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/Overlay.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/Overlay.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var disabled_1 = __importDefault(__webpack_require__(/*! ally.js/maintain/disabled */ "./node_modules/ally.js/maintain/disabled.js"));
var tab_focus_1 = __importDefault(__webpack_require__(/*! ally.js/maintain/tab-focus */ "./node_modules/ally.js/maintain/tab-focus.js"));
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var body_locker_1 = __webpack_require__(/*! ./body-locker */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/body-locker.js");
var Overlay = function Overlay(_a) {
    var className = _a.className, children = _a.children, fixed = _a.fixed;
    React.useEffect(function () {
        body_locker_1.lock();
        return function () {
            body_locker_1.unlock();
        };
    }, []);
    var _b = __read(React.useState(null), 2), overlay = _b[0], setOverlay = _b[1];
    var onOverlay = React.useCallback(function (el) {
        setOverlay(el);
    }, []);
    React.useEffect(function () {
        if (overlay == null) {
            return;
        }
        var handle1 = disabled_1["default"]({ filter: overlay });
        var handle2 = tab_focus_1["default"]({ context: overlay });
        return function () {
            handle1.disengage();
            handle2.disengage();
        };
    }, [overlay]);
    return (React.createElement("div", { "data-nextjs-dialog-overlay": true, className: className, ref: onOverlay },
        React.createElement("div", { "data-nextjs-dialog-backdrop": true, "data-nextjs-dialog-backdrop-fixed": fixed ? true : undefined }),
        children));
};
exports.Overlay = Overlay;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/body-locker.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/body-locker.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var previousBodyPaddingRight;
var previousBodyOverflowSetting;
var activeLocks = 0;
function lock() {
    setTimeout(function () {
        if (activeLocks++ > 0) {
            return;
        }
        var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;
        if (scrollBarGap > 0) {
            previousBodyPaddingRight = document.body.style.paddingRight;
            document.body.style.paddingRight = scrollBarGap + "px";
        }
        previousBodyOverflowSetting = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
    });
}
exports.lock = lock;
function unlock() {
    setTimeout(function () {
        if (activeLocks === 0 || --activeLocks !== 0) {
            return;
        }
        if (previousBodyPaddingRight !== undefined) {
            document.body.style.paddingRight = previousBodyPaddingRight;
            previousBodyPaddingRight = undefined;
        }
        if (previousBodyOverflowSetting !== undefined) {
            document.body.style.overflow = previousBodyOverflowSetting;
            previousBodyOverflowSetting = undefined;
        }
    });
}
exports.unlock = unlock;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Overlay_1 = __webpack_require__(/*! ./Overlay */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/Overlay.js");
exports.Overlay = Overlay_1.Overlay;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/styles.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/styles.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-dialog-overlay] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    overflow: auto;\n    z-index: 9000;\n\n    display: flex;\n    align-content: center;\n    align-items: center;\n    flex-direction: column;\n    padding: 10vh 15px 0;\n  }\n\n  [data-nextjs-dialog-backdrop] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: rgba(17, 17, 17, 0.2);\n    pointer-events: all;\n    z-index: -1;\n  }\n\n  [data-nextjs-dialog-backdrop-fixed] {\n    cursor: not-allowed;\n    -webkit-backdrop-filter: blur(8px);\n    backdrop-filter: blur(8px);\n  }\n"], ["\n  [data-nextjs-dialog-overlay] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    overflow: auto;\n    z-index: 9000;\n\n    display: flex;\n    align-content: center;\n    align-items: center;\n    flex-direction: column;\n    padding: 10vh 15px 0;\n  }\n\n  [data-nextjs-dialog-backdrop] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: rgba(17, 17, 17, 0.2);\n    pointer-events: all;\n    z-index: -1;\n  }\n\n  [data-nextjs-dialog-backdrop-fixed] {\n    cursor: not-allowed;\n    -webkit-backdrop-filter: blur(8px);\n    backdrop-filter: blur(8px);\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/ShadowPortal.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/ShadowPortal.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var react_dom_1 = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
exports.ShadowPortal = function Portal(_a) {
    var children = _a.children;
    var mountNode = React.useRef(null);
    var portalNode = React.useRef(null);
    var shadowNode = React.useRef(null);
    var _b = __read(React.useState(), 2), forceUpdate = _b[1];
    React.useLayoutEffect(function () {
        var ownerDocument = mountNode.current.ownerDocument;
        portalNode.current = ownerDocument.createElement('nextjs-portal');
        shadowNode.current = portalNode.current.attachShadow({ mode: 'open' });
        ownerDocument.body.appendChild(portalNode.current);
        forceUpdate({});
        return function () {
            if (portalNode.current && portalNode.current.ownerDocument) {
                portalNode.current.ownerDocument.body.removeChild(portalNode.current);
            }
        };
    }, []);
    return shadowNode.current ? (react_dom_1.createPortal(children, shadowNode.current)) : (React.createElement("span", { ref: mountNode }));
};


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/Terminal.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/Terminal.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var anser_1 = __importDefault(__webpack_require__(/*! anser */ "./node_modules/anser/lib/index.js"));
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
exports.Terminal = function Terminal(_a) {
    var content = _a.content;
    var decoded = React.useMemo(function () {
        return anser_1["default"].ansiToJson(content, {
            json: true,
            use_classes: true,
            remove_empty: true
        });
    }, [content]);
    return (React.createElement("div", { "data-nextjs-terminal": true },
        React.createElement("pre", null, decoded.map(function (entry, index) { return (React.createElement("span", { key: "terminal-entry-" + index, style: __assign({ color: entry.fg ? "var(--color-" + entry.fg + ")" : undefined }, (entry.decoration === 'bold'
                ? { fontWeight: 800 }
                : entry.decoration === 'italic'
                    ? { fontStyle: 'italic' }
                    : undefined)) }, entry.content)); }))));
};


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Terminal_1 = __webpack_require__(/*! ./Terminal */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/Terminal.js");
exports.Terminal = Terminal_1.Terminal;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/styles.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/styles.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-terminal] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-terminal]::selection,\n  [data-nextjs-terminal] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-terminal] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n  [data-nextjs-terminal] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n\n  [data-nextjs-terminal] pre {\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n"], ["\n  [data-nextjs-terminal] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-terminal]::selection,\n  [data-nextjs-terminal] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-terminal] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n  [data-nextjs-terminal] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n\n  [data-nextjs-terminal] pre {\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/Toast.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/Toast.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
exports.Toast = function Toast(_a) {
    var onClick = _a.onClick, children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-toast": true, onClick: onClick, className: className },
        React.createElement("div", { "data-nextjs-toast-wrapper": true }, children)));
};


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var styles_1 = __webpack_require__(/*! ./styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/styles.js");
exports.styles = styles_1.styles;
var Toast_1 = __webpack_require__(/*! ./Toast */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/Toast.js");
exports.Toast = Toast_1.Toast;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/styles.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/styles.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-toast] {\n    position: fixed;\n    bottom: var(--size-gap-double);\n    left: var(--size-gap-double);\n    max-width: 420px;\n    z-index: 9000;\n  }\n\n  @media (max-width: 440px) {\n    [data-nextjs-toast] {\n      max-width: 90vw;\n      left: 5vw;\n    }\n  }\n\n  [data-nextjs-toast-wrapper] {\n    padding: 1rem;\n    border-radius: var(--size-gap-half);\n    font-weight: 500;\n    color: var(--color-ansi-bright-white);\n    background-color: var(--color-ansi-red);\n    box-shadow: 0px var(--size-gap-double) var(--size-gap-quad)\n      rgba(0, 0, 0, 0.25);\n  }\n"], ["\n  [data-nextjs-toast] {\n    position: fixed;\n    bottom: var(--size-gap-double);\n    left: var(--size-gap-double);\n    max-width: 420px;\n    z-index: 9000;\n  }\n\n  @media (max-width: 440px) {\n    [data-nextjs-toast] {\n      max-width: 90vw;\n      left: 5vw;\n    }\n  }\n\n  [data-nextjs-toast-wrapper] {\n    padding: 1rem;\n    border-radius: var(--size-gap-half);\n    font-weight: 500;\n    color: var(--color-ansi-bright-white);\n    background-color: var(--color-ansi-red);\n    box-shadow: 0px var(--size-gap-double) var(--size-gap-quad)\n      rgba(0, 0, 0, 0.25);\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var Dialog_1 = __webpack_require__(/*! ../components/Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js");
var Overlay_1 = __webpack_require__(/*! ../components/Overlay */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js");
var Terminal_1 = __webpack_require__(/*! ../components/Terminal */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/index.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
exports.BuildError = function BuildError(_a) {
    var message = _a.message;
    var noop = React.useCallback(function () { }, []);
    return (React.createElement(Overlay_1.Overlay, { fixed: true },
        React.createElement(Dialog_1.Dialog, { type: "error", "aria-labelledby": "nextjs__container_build_error_label", "aria-describedby": "nextjs__container_build_error_desc", onClose: noop },
            React.createElement(Dialog_1.DialogContent, null,
                React.createElement(Dialog_1.DialogHeader, { className: "nextjs-container-build-error-header" },
                    React.createElement("h4", { id: "nextjs__container_build_error_label" }, "Failed to compile")),
                React.createElement(Dialog_1.DialogBody, { className: "nextjs-container-build-error-body" },
                    React.createElement(Terminal_1.Terminal, { content: message }),
                    React.createElement("footer", null,
                        React.createElement("p", { id: "nextjs__container_build_error_desc" },
                            React.createElement("small", null, "This error occured during the build process and can only be dismissed by fixing the error."))))))));
};
exports.styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  .nextjs-container-build-error-header > h4 {\n    line-height: 1.5;\n    margin: 0;\n    padding: 0;\n  }\n\n  .nextjs-container-build-error-body footer {\n    margin-top: var(--size-gap);\n  }\n  .nextjs-container-build-error-body footer p {\n    margin: 0;\n  }\n\n  .nextjs-container-build-error-body small {\n    color: #757575;\n  }\n"], ["\n  .nextjs-container-build-error-header > h4 {\n    line-height: 1.5;\n    margin: 0;\n    padding: 0;\n  }\n\n  .nextjs-container-build-error-body footer {\n    margin-top: var(--size-gap);\n  }\n  .nextjs-container-build-error-body footer p {\n    margin: 0;\n  }\n\n  .nextjs-container-build-error-body small {\n    color: #757575;\n  }\n"])));
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var bus_1 = __webpack_require__(/*! ../bus */ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js");
var Dialog_1 = __webpack_require__(/*! ../components/Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js");
var LeftRightDialogHeader_1 = __webpack_require__(/*! ../components/LeftRightDialogHeader */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/index.js");
var Overlay_1 = __webpack_require__(/*! ../components/Overlay */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js");
var Toast_1 = __webpack_require__(/*! ../components/Toast */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js");
var nodeStackFrames_1 = __webpack_require__(/*! ../helpers/nodeStackFrames */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var stack_frame_1 = __webpack_require__(/*! ../helpers/stack-frame */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js");
var RuntimeError_1 = __webpack_require__(/*! ./RuntimeError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js");
function getErrorSignature(ev) {
    var event = ev.event;
    switch (event.type) {
        case bus_1.TYPE_UNHANDLED_ERROR:
        case bus_1.TYPE_UNHANDLED_REJECTION: {
            return event.reason.name + "::" + event.reason.message + "::" + event.reason.stack;
        }
        default: {
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    var _ = event;
    return '';
}
function getErrorByType(ev) {
    return __awaiter(this, void 0, void 0, function () {
        var id, event, _a, _b, _;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    id = ev.id, event = ev.event;
                    _a = event.type;
                    switch (_a) {
                        case bus_1.TYPE_UNHANDLED_ERROR: return [3 /*break*/, 1];
                        case bus_1.TYPE_UNHANDLED_REJECTION: return [3 /*break*/, 1];
                    }
                    return [3 /*break*/, 3];
                case 1:
                    _b = {
                        id: id,
                        runtime: true,
                        error: event.reason
                    };
                    return [4 /*yield*/, stack_frame_1.getOriginalStackFrames(event.frames)];
                case 2: return [2 /*return*/, (_b.frames = _c.sent(),
                        _b)];
                case 3:
                    {
                        return [3 /*break*/, 4];
                    }
                    _c.label = 4;
                case 4:
                    _ = event;
                    throw new Error('type system invariant violation');
            }
        });
    });
}
exports.Errors = function Errors(_a) {
    var errors = _a.errors;
    var _b = __read(React.useState({}), 2), lookups = _b[0], setLookups = _b[1];
    var _c = __read(React.useMemo(function () {
        var ready = [];
        var next = null;
        // Ensure errors are displayed in the order they occurred in:
        for (var idx = 0; idx < errors.length; ++idx) {
            var e = errors[idx];
            var id = e.id;
            if (id in lookups) {
                ready.push(lookups[id]);
                continue;
            }
            // Check for duplicate errors
            if (idx > 0) {
                var prev = errors[idx - 1];
                if (getErrorSignature(prev) === getErrorSignature(e)) {
                    continue;
                }
            }
            next = e;
            break;
        }
        return [ready, next];
    }, [errors, lookups]), 2), readyErrors = _c[0], nextError = _c[1];
    var isLoading = React.useMemo(function () {
        return readyErrors.length < 1 && Boolean(errors.length);
    }, [errors.length, readyErrors.length]);
    React.useEffect(function () {
        if (nextError == null) {
            return;
        }
        getErrorByType(nextError).then(function (resolved) {
            // We don't care if the desired error changed while we were resolving,
            // thus we're not tracking it using a ref. Once the work has been done,
            // we'll store it.
            setLookups(function (m) {
                var _a;
                return (__assign(__assign({}, m), (_a = {}, _a[resolved.id] = resolved, _a)));
            });
        }, function () {
            // TODO: handle this, though an edge case
        });
    }, [nextError]);
    var _d = __read(React.useState(false), 2), isMinimized = _d[0], setMinimized = _d[1];
    var _e = __read(React.useState(0), 2), activeIdx = _e[0], setActiveIndex = _e[1];
    var previous = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setActiveIndex(function (v) { return Math.max(0, v - 1); });
    }, []);
    var next = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setActiveIndex(function (v) { return Math.max(0, Math.min(readyErrors.length - 1, v + 1)); });
    }, [readyErrors.length]);
    var activeError = React.useMemo(function () { var _a; return (_a = readyErrors[activeIdx]) !== null && _a !== void 0 ? _a : null; }, [activeIdx, readyErrors]);
    // Reset component state when there are no errors to be displayed.
    // This should never happen, but lets handle it.
    React.useEffect(function () {
        if (errors.length < 1) {
            setLookups({});
            setMinimized(false);
            setActiveIndex(0);
        }
    }, [errors.length]);
    var minimize = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setMinimized(true);
    }, []);
    var reopen = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setMinimized(false);
    }, []);
    // This component shouldn't be rendered with no errors, but if it is, let's
    // handle it gracefully by rendering nothing.
    if (errors.length < 1) {
        return null;
    }
    if (isLoading) {
        // TODO: better loading state
        return React.createElement(Overlay_1.Overlay, null);
    }
    if (isMinimized) {
        return (React.createElement(Toast_1.Toast, { className: "nextjs-toast-errors-parent", onClick: reopen },
            React.createElement("div", { className: "nextjs-toast-errors" },
                React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
                    React.createElement("circle", { cx: "12", cy: "12", r: "10" }),
                    React.createElement("line", { x1: "12", y1: "8", x2: "12", y2: "12" }),
                    React.createElement("line", { x1: "12", y1: "16", x2: "12.01", y2: "16" })),
                React.createElement("span", null,
                    readyErrors.length,
                    " error",
                    readyErrors.length > 1 ? 's' : ''))));
    }
    var isServerError = nodeStackFrames_1.isNodeError(activeError.error);
    return (React.createElement(Overlay_1.Overlay, null,
        React.createElement(Dialog_1.Dialog, { type: "error", "aria-labelledby": "nextjs__container_errors_label", "aria-describedby": "nextjs__container_errors_desc", onClose: minimize },
            React.createElement(Dialog_1.DialogContent, null,
                React.createElement(Dialog_1.DialogHeader, { className: "nextjs-container-errors-header" },
                    React.createElement(LeftRightDialogHeader_1.LeftRightDialogHeader, { previous: activeIdx > 0 ? previous : null, next: activeIdx < readyErrors.length - 1 ? next : null, close: minimize },
                        React.createElement("small", null,
                            React.createElement("span", null, activeIdx + 1),
                            " of",
                            ' ',
                            React.createElement("span", null, readyErrors.length),
                            " unhandled error",
                            readyErrors.length < 2 ? '' : 's')),
                    React.createElement("h1", { id: "nextjs__container_errors_label" }, isServerError ? 'Server Error' : 'Unhandled Runtime Error'),
                    React.createElement("p", { id: "nextjs__container_errors_desc" },
                        activeError.error.name,
                        ": ",
                        activeError.error.message),
                    isServerError ? (React.createElement("div", null,
                        React.createElement("small", null, "This error happened while generating the page. Any console logs will be displayed in the terminal window."))) : (undefined)),
                React.createElement(Dialog_1.DialogBody, { className: "nextjs-container-errors-body" },
                    React.createElement(RuntimeError_1.RuntimeError, { key: activeError.id.toString(), error: activeError }))))));
};
exports.styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  .nextjs-container-errors-header > h1 {\n    font-size: var(--size-font-big);\n    line-height: var(--size-font-bigger);\n    font-weight: bold;\n    margin: 0;\n    margin-top: calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  .nextjs-container-errors-header small {\n    font-size: var(--size-font-small);\n    color: var(--color-accents-1);\n    margin-left: var(--size-gap-double);\n  }\n  .nextjs-container-errors-header small > span {\n    font-family: var(--font-stack-monospace);\n  }\n  .nextjs-container-errors-header > p {\n    font-family: var(--font-stack-monospace);\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-big);\n    font-weight: bold;\n    margin: 0;\n    margin-top: var(--size-gap-half);\n    color: var(--color-ansi-red);\n    white-space: pre-wrap;\n  }\n  .nextjs-container-errors-header > div > small {\n    margin: 0;\n    margin-top: var(--size-gap-half);\n  }\n\n  .nextjs-container-errors-body > h5:not(:first-child) {\n    margin-top: calc(var(--size-gap-double) + var(--size-gap));\n  }\n  .nextjs-container-errors-body > h5 {\n    margin-bottom: var(--size-gap);\n  }\n\n  .nextjs-toast-errors-parent {\n    cursor: pointer;\n    transition: transform 0.2s ease;\n  }\n  .nextjs-toast-errors-parent:hover {\n    transform: scale(1.1);\n  }\n  .nextjs-toast-errors {\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n  }\n  .nextjs-toast-errors > svg {\n    margin-right: var(--size-gap);\n  }\n"], ["\n  .nextjs-container-errors-header > h1 {\n    font-size: var(--size-font-big);\n    line-height: var(--size-font-bigger);\n    font-weight: bold;\n    margin: 0;\n    margin-top: calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  .nextjs-container-errors-header small {\n    font-size: var(--size-font-small);\n    color: var(--color-accents-1);\n    margin-left: var(--size-gap-double);\n  }\n  .nextjs-container-errors-header small > span {\n    font-family: var(--font-stack-monospace);\n  }\n  .nextjs-container-errors-header > p {\n    font-family: var(--font-stack-monospace);\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-big);\n    font-weight: bold;\n    margin: 0;\n    margin-top: var(--size-gap-half);\n    color: var(--color-ansi-red);\n    white-space: pre-wrap;\n  }\n  .nextjs-container-errors-header > div > small {\n    margin: 0;\n    margin-top: var(--size-gap-half);\n  }\n\n  .nextjs-container-errors-body > h5:not(:first-child) {\n    margin-top: calc(var(--size-gap-double) + var(--size-gap));\n  }\n  .nextjs-container-errors-body > h5 {\n    margin-bottom: var(--size-gap);\n  }\n\n  .nextjs-toast-errors-parent {\n    cursor: pointer;\n    transition: transform 0.2s ease;\n  }\n  .nextjs-toast-errors-parent:hover {\n    transform: scale(1.1);\n  }\n  .nextjs-toast-errors {\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n  }\n  .nextjs-toast-errors > svg {\n    margin-right: var(--size-gap);\n  }\n"])));
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var CodeFrame_1 = __webpack_require__(/*! ../components/CodeFrame */ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/index.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var stack_frame_1 = __webpack_require__(/*! ../helpers/stack-frame */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js");
var CallStackFrame = function CallStackFrame(_a) {
    // TODO: ability to expand resolved frames
    // TODO: render error or external indicator
    var frame = _a.frame;
    var _b;
    var f = (_b = frame.originalStackFrame) !== null && _b !== void 0 ? _b : frame.sourceStackFrame;
    var hasSource = Boolean(frame.originalCodeFrame);
    var open = React.useCallback(function () {
        var _a;
        if (!hasSource)
            return;
        var params = new URLSearchParams();
        for (var key in f) {
            params.append(key, ((_a = f[key]) !== null && _a !== void 0 ? _a : '').toString());
        }
        self.fetch("/__nextjs_launch-editor?" + params.toString()).then(function () { }, function () {
            // TODO: report error
        });
    }, [hasSource, f]);
    return (React.createElement("div", { "data-nextjs-call-stack-frame": true },
        React.createElement("h6", { "data-nextjs-frame-expanded": Boolean(frame.expanded) }, f.methodName),
        React.createElement("div", { "data-has-source": hasSource ? 'true' : undefined, tabIndex: hasSource ? 10 : undefined, role: hasSource ? 'link' : undefined, onClick: open, title: hasSource ? 'Click to open in your editor' : undefined },
            React.createElement("span", null, stack_frame_1.getFrameSource(f)),
            React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
                React.createElement("path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" }),
                React.createElement("polyline", { points: "15 3 21 3 21 9" }),
                React.createElement("line", { x1: "10", y1: "14", x2: "21", y2: "3" })))));
};
var RuntimeError = function RuntimeError(_a) {
    var error = _a.error;
    var firstFirstPartyFrameIndex = React.useMemo(function () {
        return error.frames.findIndex(function (entry) {
            return entry.expanded &&
                Boolean(entry.originalCodeFrame) &&
                Boolean(entry.originalStackFrame);
        });
    }, [error.frames]);
    var firstFrame = React.useMemo(function () {
        var _a;
        return (_a = error.frames[firstFirstPartyFrameIndex]) !== null && _a !== void 0 ? _a : null;
    }, [error.frames, firstFirstPartyFrameIndex]);
    var allLeadingFrames = React.useMemo(function () {
        return firstFirstPartyFrameIndex < 0
            ? []
            : error.frames.slice(0, firstFirstPartyFrameIndex);
    }, [error.frames, firstFirstPartyFrameIndex]);
    var _b = __read(React.useState(firstFrame == null), 2), all = _b[0], setAll = _b[1];
    var toggleAll = React.useCallback(function () {
        setAll(function (v) { return !v; });
    }, []);
    var leadingFrames = React.useMemo(function () { return allLeadingFrames.filter(function (f) { return f.expanded || all; }); }, [all, allLeadingFrames]);
    var allCallStackFrames = React.useMemo(function () { return error.frames.slice(firstFirstPartyFrameIndex + 1); }, [error.frames, firstFirstPartyFrameIndex]);
    var visibleCallStackFrames = React.useMemo(function () { return allCallStackFrames.filter(function (f) { return f.expanded || all; }); }, [all, allCallStackFrames]);
    var canShowMore = React.useMemo(function () {
        return (allCallStackFrames.length !== visibleCallStackFrames.length ||
            (all && firstFrame != null));
    }, [
        all,
        allCallStackFrames.length,
        firstFrame,
        visibleCallStackFrames.length,
    ]);
    return (React.createElement(React.Fragment, null,
        firstFrame ? (React.createElement(React.Fragment, null,
            React.createElement("h5", null, "Source"),
            leadingFrames.map(function (frame, index) { return (React.createElement(CallStackFrame, { key: "leading-frame-" + index + "-" + all, frame: frame })); }),
            React.createElement(CodeFrame_1.CodeFrame, { stackFrame: firstFrame.originalStackFrame, codeFrame: firstFrame.originalCodeFrame }))) : (undefined),
        visibleCallStackFrames.length ? (React.createElement(React.Fragment, null,
            React.createElement("h5", null, "Call Stack"),
            visibleCallStackFrames.map(function (frame, index) { return (React.createElement(CallStackFrame, { key: "call-stack-" + index + "-" + all, frame: frame })); }))) : (undefined),
        canShowMore ? (React.createElement(React.Fragment, null,
            React.createElement("button", { tabIndex: 10, "data-nextjs-data-runtime-error-collapsed-action": true, type: "button", onClick: toggleAll },
                all ? 'Hide' : 'Show',
                " collapsed frames"))) : (undefined)));
};
exports.RuntimeError = RuntimeError;
exports.styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  button[data-nextjs-data-runtime-error-collapsed-action] {\n    background: none;\n    border: none;\n    padding: 0;\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-bigger);\n    color: var(--color-accents-3);\n  }\n\n  [data-nextjs-call-stack-frame]:not(:last-child) {\n    margin-bottom: var(--size-gap-double);\n  }\n\n  [data-nextjs-call-stack-frame] > h6 {\n    margin-top: 0;\n    margin-bottom: var(--size-gap);\n    font-family: var(--font-stack-monospace);\n    color: #222;\n  }\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\n    color: #666;\n  }\n  [data-nextjs-call-stack-frame] > div {\n    display: flex;\n    align-items: center;\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\n    font-size: var(--size-font-small);\n    color: #999;\n  }\n  [data-nextjs-call-stack-frame] > div > svg {\n    width: auto;\n    height: var(--size-font-small);\n    margin-left: var(--size-gap);\n\n    display: none;\n  }\n\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\n    cursor: pointer;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\n    display: unset;\n  }\n"], ["\n  button[data-nextjs-data-runtime-error-collapsed-action] {\n    background: none;\n    border: none;\n    padding: 0;\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-bigger);\n    color: var(--color-accents-3);\n  }\n\n  [data-nextjs-call-stack-frame]:not(:last-child) {\n    margin-bottom: var(--size-gap-double);\n  }\n\n  [data-nextjs-call-stack-frame] > h6 {\n    margin-top: 0;\n    margin-bottom: var(--size-gap);\n    font-family: var(--font-stack-monospace);\n    color: #222;\n  }\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\n    color: #666;\n  }\n  [data-nextjs-call-stack-frame] > div {\n    display: flex;\n    align-items: center;\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\n    font-size: var(--size-font-small);\n    color: #999;\n  }\n  [data-nextjs-call-stack-frame] > div > svg {\n    width: auto;\n    height: var(--size-font-small);\n    margin-left: var(--size-gap);\n\n    display: none;\n  }\n\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\n    cursor: pointer;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\n    display: unset;\n  }\n"])));
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var stacktrace_parser_1 = __webpack_require__(/*! stacktrace-parser */ "./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js");
function getFilesystemFrame(frame) {
    var f = __assign({}, frame);
    if (typeof f.file === 'string') {
        if (
        // Posix:
        f.file.startsWith('/') ||
            // Win32:
            /^[a-z]:\\/i.test(f.file) ||
            // Win32 UNC:
            f.file.startsWith('\\\\')) {
            f.file = "file://" + f.file;
        }
    }
    return f;
}
exports.getFilesystemFrame = getFilesystemFrame;
var symbolNodeError = Symbol('NextjsNodeError');
function isNodeError(error) {
    return symbolNodeError in error;
}
exports.isNodeError = isNodeError;
function getNodeError(error) {
    var n;
    try {
        throw new Error(error.message);
    }
    catch (e) {
        n = e;
    }
    n.name = error.name;
    try {
        n.stack = stacktrace_parser_1.parse(error.stack)
            .map(getFilesystemFrame)
            .map(function (f) {
            var str = "    at " + f.methodName;
            if (f.file) {
                var loc = f.file;
                if (f.lineNumber) {
                    loc += ":" + f.lineNumber;
                    if (f.column) {
                        loc += ":" + f.column;
                    }
                }
                str += " (" + loc + ")";
            }
            return str;
        })
            .join('\n');
    }
    catch (_a) {
        n.stack = error.stack;
    }
    Object.defineProperty(n, symbolNodeError, {
        writable: false,
        enumerable: false,
        configurable: false
    });
    return n;
}
exports.getNodeError = getNodeError;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
function noop(strings) {
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    var lastIndex = strings.length - 1;
    return (strings.slice(0, lastIndex).reduce(function (p, s, i) { return p + s + keys[i]; }, '') +
        strings[lastIndex]);
}
exports.noop = noop;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/parseStack.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/parseStack.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var stacktrace_parser_1 = __webpack_require__(/*! stacktrace-parser */ "./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js");
var regexNextStatic = /\/_next(\/static\/.+)/g;
function parseStack(stack) {
    var frames = stacktrace_parser_1.parse(stack);
    return frames.map(function (frame) {
        var _a, _b;
        try {
            var url = new URL(frame.file);
            var res = regexNextStatic.exec(url.pathname);
            if (res) {
                var distDir = (_b = (_a = "C:\\Users\\user\\projects\\vibe\\.next") === null || _a === void 0 ? void 0 : _a.replace(/\\/g, '/')) === null || _b === void 0 ? void 0 : _b.replace(/\/$/, '');
                if (distDir) {
                    frame.file = 'file://' + distDir.concat(res.pop());
                }
            }
        }
        catch (_c) { }
        return frame;
    });
}
exports.parseStack = parseStack;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
function getOriginalStackFrames(frames) {
    return Promise.all(frames.map(function (frame) { return getOriginalStackFrame(frame); }));
}
exports.getOriginalStackFrames = getOriginalStackFrames;
function getOriginalStackFrame(source) {
    var _a, _b;
    function _getOriginalStackFrame() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var params, key, controller, tm, res, _c, _d, _e, body;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        params = new URLSearchParams();
                        for (key in source) {
                            params.append(key, ((_a = source[key]) !== null && _a !== void 0 ? _a : '').toString());
                        }
                        controller = new AbortController();
                        tm = setTimeout(function () { return controller.abort(); }, 3000);
                        return [4 /*yield*/, self
                                .fetch("/__nextjs_original-stack-frame?" + params.toString(), {
                                signal: controller.signal
                            })["finally"](function () {
                                clearTimeout(tm);
                            })];
                    case 1:
                        res = _f.sent();
                        if (!(!res.ok || res.status === 204)) return [3 /*break*/, 3];
                        _d = (_c = Promise).reject;
                        _e = Error.bind;
                        return [4 /*yield*/, res.text()];
                    case 2: return [2 /*return*/, _d.apply(_c, [new (_e.apply(Error, [void 0, _f.sent()]))()])];
                    case 3: return [4 /*yield*/, res.json()];
                    case 4:
                        body = _f.sent();
                        return [2 /*return*/, {
                                error: false,
                                reason: null,
                                external: false,
                                expanded: ((_b = body.originalStackFrame) === null || _b === void 0 ? void 0 : _b.file) &&
                                    !body.originalStackFrame.file.includes('node_modules'),
                                sourceStackFrame: source,
                                originalStackFrame: body.originalStackFrame,
                                originalCodeFrame: body.originalCodeFrame || null
                            }];
                }
            });
        });
    }
    if (!(((_a = source.file) === null || _a === void 0 ? void 0 : _a.startsWith('webpack-internal:')) || ((_b = source.file) === null || _b === void 0 ? void 0 : _b.startsWith('file:')))) {
        return Promise.resolve({
            error: false,
            reason: null,
            external: true,
            expanded: false,
            sourceStackFrame: source,
            originalStackFrame: null,
            originalCodeFrame: null
        });
    }
    return _getOriginalStackFrame()["catch"](function (err) {
        var _a, _b;
        return ({
            error: true,
            reason: (_b = (_a = err === null || err === void 0 ? void 0 : err.message) !== null && _a !== void 0 ? _a : err === null || err === void 0 ? void 0 : err.toString()) !== null && _b !== void 0 ? _b : 'Unknown Error',
            external: false,
            expanded: false,
            sourceStackFrame: source,
            originalStackFrame: null,
            originalCodeFrame: null
        });
    });
}
exports.getOriginalStackFrame = getOriginalStackFrame;
function getFrameSource(frame) {
    var _a;
    var str = '';
    try {
        var u = new URL(frame.file);
        // Strip the origin for same-origin scripts.
        if (typeof globalThis !== 'undefined' &&
            ((_a = globalThis.location) === null || _a === void 0 ? void 0 : _a.origin) !== u.origin) {
            // URLs can be valid without an `origin`, so long as they have a
            // `protocol`. However, `origin` is preferred.
            if (u.origin === 'null') {
                str += u.protocol;
            }
            else {
                str += u.origin;
            }
        }
        // Strip query string information as it's typically too verbose to be
        // meaningful.
        str += u.pathname;
        str += ' ';
    }
    catch (_b) {
        str += (frame.file || '(unknown)') + ' ';
    }
    if (frame.lineNumber != null) {
        if (frame.column != null) {
            str += "(" + frame.lineNumber + ":" + frame.column + ") ";
        }
        else {
            str += "(" + frame.lineNumber + ") ";
        }
    }
    return str.slice(0, -1);
}
exports.getFrameSource = getFrameSource;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/hooks/use-on-click-outside.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/hooks/use-on-click-outside.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
function useOnClickOutside(el, handler) {
    React.useEffect(function () {
        if (el == null) {
            return;
        }
        var listener = function (e) {
            // Do nothing if clicking ref's element or descendent elements
            if (!el || el.contains(e.target)) {
                return;
            }
            handler(e);
        };
        var root = el.getRootNode();
        root.addEventListener('mousedown', listener);
        root.addEventListener('touchstart', listener);
        return function () {
            root.removeEventListener('mousedown', listener);
            root.removeEventListener('touchstart', listener);
        };
    }, [handler, el]);
}
exports.useOnClickOutside = useOnClickOutside;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/styles/Base.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/styles/Base.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
function Base() {
    return (React.createElement("style", { dangerouslySetInnerHTML: {
            __html: noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          :host {\n            --size-gap-half: 0.25rem; /* 4px */\n            --size-gap: 0.5rem; /* 8px */\n            --size-gap-double: 1rem; /* 16px */\n            --size-gap-quad: 2rem; /* 32px */\n\n            --size-font-small: 0.875rem; /* 14px */\n            --size-font: 1rem; /* 16px */\n            --size-font-big: 1.25rem; /* 20px */\n            --size-font-bigger: 1.5rem; /* 24px */\n\n            --color-accents-1: #808080;\n            --color-accents-2: #222222;\n            --color-accents-3: #404040;\n\n            --font-stack-monospace: 'SFMono-Regular', Consolas,\n              'Liberation Mono', Menlo, Courier, monospace;\n\n            --color-ansi-selection: rgba(95, 126, 151, 0.48);\n            --color-ansi-bg: #111111;\n            --color-ansi-fg: #cccccc;\n\n            --color-ansi-white: #777777;\n            --color-ansi-black: #141414;\n            --color-ansi-blue: #00aaff;\n            --color-ansi-cyan: #88ddff;\n            --color-ansi-green: #98ec65;\n            --color-ansi-magenta: #aa88ff;\n            --color-ansi-red: #ff5555;\n            --color-ansi-yellow: #ffcc33;\n            --color-ansi-bright-white: #ffffff;\n            --color-ansi-bright-black: #777777;\n            --color-ansi-bright-blue: #33bbff;\n            --color-ansi-bright-cyan: #bbecff;\n            --color-ansi-bright-green: #b6f292;\n            --color-ansi-bright-magenta: #cebbff;\n            --color-ansi-bright-red: #ff8888;\n            --color-ansi-bright-yellow: #ffd966;\n          }\n\n          .mono {\n            font-family: var(--font-stack-monospace);\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-bottom: var(--size-gap);\n            font-weight: 500;\n            line-height: 1.5;\n          }\n\n          h1 {\n            font-size: 2.5rem;\n          }\n          h2 {\n            font-size: 2rem;\n          }\n          h3 {\n            font-size: 1.75rem;\n          }\n          h4 {\n            font-size: 1.5rem;\n          }\n          h5 {\n            font-size: 1.25rem;\n          }\n          h6 {\n            font-size: 1rem;\n          }\n        "], ["\n          :host {\n            --size-gap-half: 0.25rem; /* 4px */\n            --size-gap: 0.5rem; /* 8px */\n            --size-gap-double: 1rem; /* 16px */\n            --size-gap-quad: 2rem; /* 32px */\n\n            --size-font-small: 0.875rem; /* 14px */\n            --size-font: 1rem; /* 16px */\n            --size-font-big: 1.25rem; /* 20px */\n            --size-font-bigger: 1.5rem; /* 24px */\n\n            --color-accents-1: #808080;\n            --color-accents-2: #222222;\n            --color-accents-3: #404040;\n\n            --font-stack-monospace: 'SFMono-Regular', Consolas,\n              'Liberation Mono', Menlo, Courier, monospace;\n\n            --color-ansi-selection: rgba(95, 126, 151, 0.48);\n            --color-ansi-bg: #111111;\n            --color-ansi-fg: #cccccc;\n\n            --color-ansi-white: #777777;\n            --color-ansi-black: #141414;\n            --color-ansi-blue: #00aaff;\n            --color-ansi-cyan: #88ddff;\n            --color-ansi-green: #98ec65;\n            --color-ansi-magenta: #aa88ff;\n            --color-ansi-red: #ff5555;\n            --color-ansi-yellow: #ffcc33;\n            --color-ansi-bright-white: #ffffff;\n            --color-ansi-bright-black: #777777;\n            --color-ansi-bright-blue: #33bbff;\n            --color-ansi-bright-cyan: #bbecff;\n            --color-ansi-bright-green: #b6f292;\n            --color-ansi-bright-magenta: #cebbff;\n            --color-ansi-bright-red: #ff8888;\n            --color-ansi-bright-yellow: #ffd966;\n          }\n\n          .mono {\n            font-family: var(--font-stack-monospace);\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-bottom: var(--size-gap);\n            font-weight: 500;\n            line-height: 1.5;\n          }\n\n          h1 {\n            font-size: 2.5rem;\n          }\n          h2 {\n            font-size: 2rem;\n          }\n          h3 {\n            font-size: 1.75rem;\n          }\n          h4 {\n            font-size: 1.5rem;\n          }\n          h5 {\n            font-size: 1.25rem;\n          }\n          h6 {\n            font-size: 1rem;\n          }\n        "])))
        } }));
}
exports.Base = Base;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/styles/ComponentStyles.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/styles/ComponentStyles.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var styles_1 = __webpack_require__(/*! ../components/CodeFrame/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/styles.js");
var Dialog_1 = __webpack_require__(/*! ../components/Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js");
var styles_2 = __webpack_require__(/*! ../components/LeftRightDialogHeader/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js");
var styles_3 = __webpack_require__(/*! ../components/Overlay/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/styles.js");
var styles_4 = __webpack_require__(/*! ../components/Terminal/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/styles.js");
var Toast_1 = __webpack_require__(/*! ../components/Toast */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js");
var BuildError_1 = __webpack_require__(/*! ../container/BuildError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js");
var Errors_1 = __webpack_require__(/*! ../container/Errors */ "./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js");
var RuntimeError_1 = __webpack_require__(/*! ../container/RuntimeError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
function ComponentStyles() {
    return (React.createElement("style", { dangerouslySetInnerHTML: {
            __html: noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n\n          ", "\n          ", "\n          ", "\n        "], ["\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n\n          ", "\n          ", "\n          ", "\n        "])), styles_3.styles, Toast_1.styles, Dialog_1.styles, styles_2.styles, styles_1.styles, styles_4.styles, BuildError_1.styles, Errors_1.styles, RuntimeError_1.styles)
        } }));
}
exports.ComponentStyles = ComponentStyles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/styles/CssReset.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/styles/CssReset.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
function CssReset() {
    return (React.createElement("style", { dangerouslySetInnerHTML: {
            __html: noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          :host {\n            all: initial;\n          }\n\n          /*!\n           * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\n           * Copyright 2011-2019 The Bootstrap Authors\n           * Copyright 2011-2019 Twitter, Inc.\n           * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n           * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\n           */\n          *,\n          *::before,\n          *::after {\n            box-sizing: border-box;\n          }\n\n          :host {\n            font-family: sans-serif;\n            line-height: 1.15;\n            -webkit-text-size-adjust: 100%;\n            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n          }\n\n          article,\n          aside,\n          figcaption,\n          figure,\n          footer,\n          header,\n          hgroup,\n          main,\n          nav,\n          section {\n            display: block;\n          }\n\n          :host {\n            margin: 0;\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n              'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\n              'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n              'Noto Color Emoji';\n            font-size: 1rem;\n            font-weight: 400;\n            line-height: 1.5;\n            color: #212529;\n            text-align: left;\n            background-color: #fff;\n          }\n\n          [tabindex='-1']:focus:not(:focus-visible) {\n            outline: 0 !important;\n          }\n\n          hr {\n            box-sizing: content-box;\n            height: 0;\n            overflow: visible;\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-top: 0;\n            margin-bottom: 0.5rem;\n          }\n\n          p {\n            margin-top: 0;\n            margin-bottom: 1rem;\n          }\n\n          abbr[title],\n          abbr[data-original-title] {\n            text-decoration: underline;\n            -webkit-text-decoration: underline dotted;\n            text-decoration: underline dotted;\n            cursor: help;\n            border-bottom: 0;\n            -webkit-text-decoration-skip-ink: none;\n            text-decoration-skip-ink: none;\n          }\n\n          address {\n            margin-bottom: 1rem;\n            font-style: normal;\n            line-height: inherit;\n          }\n\n          ol,\n          ul,\n          dl {\n            margin-top: 0;\n            margin-bottom: 1rem;\n          }\n\n          ol ol,\n          ul ul,\n          ol ul,\n          ul ol {\n            margin-bottom: 0;\n          }\n\n          dt {\n            font-weight: 700;\n          }\n\n          dd {\n            margin-bottom: 0.5rem;\n            margin-left: 0;\n          }\n\n          blockquote {\n            margin: 0 0 1rem;\n          }\n\n          b,\n          strong {\n            font-weight: bolder;\n          }\n\n          small {\n            font-size: 80%;\n          }\n\n          sub,\n          sup {\n            position: relative;\n            font-size: 75%;\n            line-height: 0;\n            vertical-align: baseline;\n          }\n\n          sub {\n            bottom: -0.25em;\n          }\n\n          sup {\n            top: -0.5em;\n          }\n\n          a {\n            color: #007bff;\n            text-decoration: none;\n            background-color: transparent;\n          }\n\n          a:hover {\n            color: #0056b3;\n            text-decoration: underline;\n          }\n\n          a:not([href]) {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          a:not([href]):hover {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          pre,\n          code,\n          kbd,\n          samp {\n            font-family: SFMono-Regular, Menlo, Monaco, Consolas,\n              'Liberation Mono', 'Courier New', monospace;\n            font-size: 1em;\n          }\n\n          pre {\n            margin-top: 0;\n            margin-bottom: 1rem;\n            overflow: auto;\n          }\n\n          figure {\n            margin: 0 0 1rem;\n          }\n\n          img {\n            vertical-align: middle;\n            border-style: none;\n          }\n\n          svg {\n            overflow: hidden;\n            vertical-align: middle;\n          }\n\n          table {\n            border-collapse: collapse;\n          }\n\n          caption {\n            padding-top: 0.75rem;\n            padding-bottom: 0.75rem;\n            color: #6c757d;\n            text-align: left;\n            caption-side: bottom;\n          }\n\n          th {\n            text-align: inherit;\n          }\n\n          label {\n            display: inline-block;\n            margin-bottom: 0.5rem;\n          }\n\n          button {\n            border-radius: 0;\n          }\n\n          button:focus {\n            outline: 1px dotted;\n            outline: 5px auto -webkit-focus-ring-color;\n          }\n\n          input,\n          button,\n          select,\n          optgroup,\n          textarea {\n            margin: 0;\n            font-family: inherit;\n            font-size: inherit;\n            line-height: inherit;\n          }\n\n          button,\n          input {\n            overflow: visible;\n          }\n\n          button,\n          select {\n            text-transform: none;\n          }\n\n          select {\n            word-wrap: normal;\n          }\n\n          button,\n          [type='button'],\n          [type='reset'],\n          [type='submit'] {\n            -webkit-appearance: button;\n          }\n\n          button:not(:disabled),\n          [type='button']:not(:disabled),\n          [type='reset']:not(:disabled),\n          [type='submit']:not(:disabled) {\n            cursor: pointer;\n          }\n\n          button::-moz-focus-inner,\n          [type='button']::-moz-focus-inner,\n          [type='reset']::-moz-focus-inner,\n          [type='submit']::-moz-focus-inner {\n            padding: 0;\n            border-style: none;\n          }\n\n          input[type='radio'],\n          input[type='checkbox'] {\n            box-sizing: border-box;\n            padding: 0;\n          }\n\n          input[type='date'],\n          input[type='time'],\n          input[type='datetime-local'],\n          input[type='month'] {\n            -webkit-appearance: listbox;\n          }\n\n          textarea {\n            overflow: auto;\n            resize: vertical;\n          }\n\n          fieldset {\n            min-width: 0;\n            padding: 0;\n            margin: 0;\n            border: 0;\n          }\n\n          legend {\n            display: block;\n            width: 100%;\n            max-width: 100%;\n            padding: 0;\n            margin-bottom: 0.5rem;\n            font-size: 1.5rem;\n            line-height: inherit;\n            color: inherit;\n            white-space: normal;\n          }\n\n          progress {\n            vertical-align: baseline;\n          }\n\n          [type='number']::-webkit-inner-spin-button,\n          [type='number']::-webkit-outer-spin-button {\n            height: auto;\n          }\n\n          [type='search'] {\n            outline-offset: -2px;\n            -webkit-appearance: none;\n          }\n\n          [type='search']::-webkit-search-decoration {\n            -webkit-appearance: none;\n          }\n\n          ::-webkit-file-upload-button {\n            font: inherit;\n            -webkit-appearance: button;\n          }\n\n          output {\n            display: inline-block;\n          }\n\n          summary {\n            display: list-item;\n            cursor: pointer;\n          }\n\n          template {\n            display: none;\n          }\n\n          [hidden] {\n            display: none !important;\n          }\n        "], ["\n          :host {\n            all: initial;\n          }\n\n          /*!\n           * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\n           * Copyright 2011-2019 The Bootstrap Authors\n           * Copyright 2011-2019 Twitter, Inc.\n           * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n           * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\n           */\n          *,\n          *::before,\n          *::after {\n            box-sizing: border-box;\n          }\n\n          :host {\n            font-family: sans-serif;\n            line-height: 1.15;\n            -webkit-text-size-adjust: 100%;\n            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n          }\n\n          article,\n          aside,\n          figcaption,\n          figure,\n          footer,\n          header,\n          hgroup,\n          main,\n          nav,\n          section {\n            display: block;\n          }\n\n          :host {\n            margin: 0;\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n              'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\n              'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n              'Noto Color Emoji';\n            font-size: 1rem;\n            font-weight: 400;\n            line-height: 1.5;\n            color: #212529;\n            text-align: left;\n            background-color: #fff;\n          }\n\n          [tabindex='-1']:focus:not(:focus-visible) {\n            outline: 0 !important;\n          }\n\n          hr {\n            box-sizing: content-box;\n            height: 0;\n            overflow: visible;\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-top: 0;\n            margin-bottom: 0.5rem;\n          }\n\n          p {\n            margin-top: 0;\n            margin-bottom: 1rem;\n          }\n\n          abbr[title],\n          abbr[data-original-title] {\n            text-decoration: underline;\n            -webkit-text-decoration: underline dotted;\n            text-decoration: underline dotted;\n            cursor: help;\n            border-bottom: 0;\n            -webkit-text-decoration-skip-ink: none;\n            text-decoration-skip-ink: none;\n          }\n\n          address {\n            margin-bottom: 1rem;\n            font-style: normal;\n            line-height: inherit;\n          }\n\n          ol,\n          ul,\n          dl {\n            margin-top: 0;\n            margin-bottom: 1rem;\n          }\n\n          ol ol,\n          ul ul,\n          ol ul,\n          ul ol {\n            margin-bottom: 0;\n          }\n\n          dt {\n            font-weight: 700;\n          }\n\n          dd {\n            margin-bottom: 0.5rem;\n            margin-left: 0;\n          }\n\n          blockquote {\n            margin: 0 0 1rem;\n          }\n\n          b,\n          strong {\n            font-weight: bolder;\n          }\n\n          small {\n            font-size: 80%;\n          }\n\n          sub,\n          sup {\n            position: relative;\n            font-size: 75%;\n            line-height: 0;\n            vertical-align: baseline;\n          }\n\n          sub {\n            bottom: -0.25em;\n          }\n\n          sup {\n            top: -0.5em;\n          }\n\n          a {\n            color: #007bff;\n            text-decoration: none;\n            background-color: transparent;\n          }\n\n          a:hover {\n            color: #0056b3;\n            text-decoration: underline;\n          }\n\n          a:not([href]) {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          a:not([href]):hover {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          pre,\n          code,\n          kbd,\n          samp {\n            font-family: SFMono-Regular, Menlo, Monaco, Consolas,\n              'Liberation Mono', 'Courier New', monospace;\n            font-size: 1em;\n          }\n\n          pre {\n            margin-top: 0;\n            margin-bottom: 1rem;\n            overflow: auto;\n          }\n\n          figure {\n            margin: 0 0 1rem;\n          }\n\n          img {\n            vertical-align: middle;\n            border-style: none;\n          }\n\n          svg {\n            overflow: hidden;\n            vertical-align: middle;\n          }\n\n          table {\n            border-collapse: collapse;\n          }\n\n          caption {\n            padding-top: 0.75rem;\n            padding-bottom: 0.75rem;\n            color: #6c757d;\n            text-align: left;\n            caption-side: bottom;\n          }\n\n          th {\n            text-align: inherit;\n          }\n\n          label {\n            display: inline-block;\n            margin-bottom: 0.5rem;\n          }\n\n          button {\n            border-radius: 0;\n          }\n\n          button:focus {\n            outline: 1px dotted;\n            outline: 5px auto -webkit-focus-ring-color;\n          }\n\n          input,\n          button,\n          select,\n          optgroup,\n          textarea {\n            margin: 0;\n            font-family: inherit;\n            font-size: inherit;\n            line-height: inherit;\n          }\n\n          button,\n          input {\n            overflow: visible;\n          }\n\n          button,\n          select {\n            text-transform: none;\n          }\n\n          select {\n            word-wrap: normal;\n          }\n\n          button,\n          [type='button'],\n          [type='reset'],\n          [type='submit'] {\n            -webkit-appearance: button;\n          }\n\n          button:not(:disabled),\n          [type='button']:not(:disabled),\n          [type='reset']:not(:disabled),\n          [type='submit']:not(:disabled) {\n            cursor: pointer;\n          }\n\n          button::-moz-focus-inner,\n          [type='button']::-moz-focus-inner,\n          [type='reset']::-moz-focus-inner,\n          [type='submit']::-moz-focus-inner {\n            padding: 0;\n            border-style: none;\n          }\n\n          input[type='radio'],\n          input[type='checkbox'] {\n            box-sizing: border-box;\n            padding: 0;\n          }\n\n          input[type='date'],\n          input[type='time'],\n          input[type='datetime-local'],\n          input[type='month'] {\n            -webkit-appearance: listbox;\n          }\n\n          textarea {\n            overflow: auto;\n            resize: vertical;\n          }\n\n          fieldset {\n            min-width: 0;\n            padding: 0;\n            margin: 0;\n            border: 0;\n          }\n\n          legend {\n            display: block;\n            width: 100%;\n            max-width: 100%;\n            padding: 0;\n            margin-bottom: 0.5rem;\n            font-size: 1.5rem;\n            line-height: inherit;\n            color: inherit;\n            white-space: normal;\n          }\n\n          progress {\n            vertical-align: baseline;\n          }\n\n          [type='number']::-webkit-inner-spin-button,\n          [type='number']::-webkit-outer-spin-button {\n            height: auto;\n          }\n\n          [type='search'] {\n            outline-offset: -2px;\n            -webkit-appearance: none;\n          }\n\n          [type='search']::-webkit-search-decoration {\n            -webkit-appearance: none;\n          }\n\n          ::-webkit-file-upload-button {\n            font: inherit;\n            -webkit-appearance: button;\n          }\n\n          output {\n            display: inline-block;\n          }\n\n          summary {\n            display: list-item;\n            cursor: pointer;\n          }\n\n          template {\n            display: none;\n          }\n\n          [hidden] {\n            display: none !important;\n          }\n        "])))
        } }));
}
exports.CssReset = CssReset;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/node_modules/ansi-regex/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/node_modules/ansi-regex/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

module.exports = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$onlyFirst = _ref.onlyFirst,
      onlyFirst = _ref$onlyFirst === void 0 ? false : _ref$onlyFirst;

  var pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
  return new RegExp(pattern, onlyFirst ? undefined : 'g');
};

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/node_modules/strip-ansi/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/node_modules/strip-ansi/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var ansiRegex = __webpack_require__(/*! ansi-regex */ "./node_modules/@next/react-dev-overlay/node_modules/ansi-regex/index.js");

module.exports = function (string) {
  return typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
};

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/ally.js/element/disabled.js":
/*!**************************************************!*\
  !*** ./node_modules/ally.js/element/disabled.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context, disabledState) {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'element/disabled',
    context: context
  });

  // accept truthy/falsy values
  disabledState = Boolean(disabledState);
  var currentState = element.hasAttribute('data-ally-disabled');
  // if there's no value to set, we're running as a getter
  var runningAsGetter = arguments.length === 1;

  if ((0, _nativeDisabledSupported2.default)(element)) {
    if (runningAsGetter) {
      return element.disabled;
    }

    // form elements know the disabled attribute, which we shall use instead of our poor man's copy of it
    element.disabled = disabledState;
    return element;
  }

  if (runningAsGetter) {
    return currentState;
  }

  if (currentState === disabledState) {
    // no update necessary
    return element;
  }

  setElementDisabled(element, disabledState);
  return element;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _nativeDisabledSupported = __webpack_require__(/*! ../is/native-disabled-supported */ "./node_modules/ally.js/is/native-disabled-supported.js");

var _nativeDisabledSupported2 = _interopRequireDefault(_nativeDisabledSupported);

var _toggleAttribute = __webpack_require__(/*! ../util/toggle-attribute */ "./node_modules/ally.js/util/toggle-attribute.js");

var _toggleAttribute2 = _interopRequireDefault(_toggleAttribute);

var _toggleAttributeValue = __webpack_require__(/*! ../util/toggle-attribute-value */ "./node_modules/ally.js/util/toggle-attribute-value.js");

var _toggleAttributeValue2 = _interopRequireDefault(_toggleAttributeValue);

var _logger = __webpack_require__(/*! ../util/logger */ "./node_modules/ally.js/util/logger.js");

var _logger2 = _interopRequireDefault(_logger);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;
/*
  Utility to make any element inert (disabled). Inert means the elements cannot be interacted
  with and they cannot be focused via script, pointer or keyboard - and thus not receive focus.

  Elements made inert (disabled) by this utility are given the attribute [data-ally-disabled="true"].

  ---------------

  inert attribute was [removed](https://html5.org/r/8536) [tweet by steve](https://twitter.com/stevefaulkner/status/443075900201259008)
  but definition of [inert subtrees](https://www.w3.org/html/wg/drafts/html/master/editing.html#inert-subtrees) remains.

  [implementation idea by Vasilis](https://codepen.io/vasilisvg/pen/scowI)
  [inert attribute polyfill by GoogleChrome](https://github.com/GoogleChrome/inert-polyfill)

  [Gecko Bug: Inert Attribute](https://bugzilla.mozilla.org/show_bug.cgi?id=921504)
  [Chromium Bug: Inert Attribute](https://code.google.com/p/chromium/issues/detail?id=269846)
  [Chromium Bug: Inert Subtree](https://code.google.com/p/chromium/issues/detail?id=241699)
  [WebKit Bug: Inert Subtree](https://bugs.webkit.org/show_bug.cgi?id=110952)
*/

function disabledFocus() {
  _logger2.default.warn('trying to focus inert element', this);
}

function disableTabindex(element, disabledState) {
  if (disabledState) {
    var tabIndex = (0, _tabindexValue2.default)(element);
    (0, _toggleAttributeValue2.default)({
      element: element,
      attribute: 'tabindex',
      temporaryValue: '-1',
      saveValue: tabIndex !== null ? tabIndex : ''
    });
  } else {
    (0, _toggleAttributeValue2.default)({
      element: element,
      attribute: 'tabindex'
    });
  }
}

function disableVideoControls(element, disabledState) {
  (0, _toggleAttribute2.default)({
    element: element,
    attribute: 'controls',
    remove: disabledState
  });
}

function disableSvgFocusable(element, disabledState) {
  (0, _toggleAttributeValue2.default)({
    element: element,
    attribute: 'focusable',
    temporaryValue: disabledState ? 'false' : undefined
  });
}

function disableSvgLink(element, disabledState) {
  (0, _toggleAttribute2.default)({
    element: element,
    attribute: 'xlink:href',
    remove: disabledState
  });
}

function setAriaDisabled(element, disabledState) {
  (0, _toggleAttributeValue2.default)({
    element: element,
    attribute: 'aria-disabled',
    temporaryValue: disabledState ? 'true' : undefined
  });
}

function disableScriptFocus(element, disabledState) {
  if (disabledState) {
    // make sure no script can focus the element
    element.focus = disabledFocus;
  } else {
    // restore original focus function from prototype
    delete element.focus;
  }
}

function disablePointerEvents(element, disabledState) {
  if (disabledState) {
    // remember previous pointer events status so we can restore it
    var pointerEvents = element.style.pointerEvents || '';
    element.setAttribute('data-inert-pointer-events', pointerEvents);
    // make sure no pointer interaction can access the element
    element.style.pointerEvents = 'none';
  } else {
    // restore to previous pointer interaction status
    var _pointerEvents = element.getAttribute('data-inert-pointer-events');
    element.removeAttribute('data-inert-pointer-events');
    element.style.pointerEvents = _pointerEvents;
  }
}

function setElementDisabled(element, disabledState) {
  setAriaDisabled(element, disabledState);
  disableTabindex(element, disabledState);
  disableScriptFocus(element, disabledState);
  disablePointerEvents(element, disabledState);

  var nodeName = element.nodeName.toLowerCase();
  if (nodeName === 'video' || nodeName === 'audio') {
    // Blink and Gecko leave <video controls tabindex="-1"> in document focus navigation sequence
    // Blink leaves <audio controls tabindex="-1"> in document focus navigation sequence
    disableVideoControls(element, disabledState);
  }

  if (nodeName === 'svg' || element.ownerSVGElement) {
    if (supports.focusSvgFocusableAttribute) {
      // Internet Explorer knows focusable="false" instead of tabindex="-1"
      disableSvgFocusable(element, disabledState);
    } else if (!supports.focusSvgTabindexAttribute && nodeName === 'a') {
      // Firefox neither knows focusable="false" nor tabindex="-1"
      disableSvgLink(element, disabledState);
    }
  }

  if (disabledState) {
    element.setAttribute('data-ally-disabled', 'true');
  } else {
    element.removeAttribute('data-ally-disabled');
  }
}

module.exports = exports['default'];
//# sourceMappingURL=disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/element/focus.svg-foreign-object-hack.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ally.js/element/focus.svg-foreign-object-hack.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (element) {
  // Edge13, Edge14: foreignObject focus hack
  // https://jsbin.com/kunehinugi/edit?html,js,output
  // https://jsbin.com/fajagi/3/edit?html,js,output
  var isSvgElement = element.ownerSVGElement || element.nodeName.toLowerCase() === 'svg';
  if (!isSvgElement) {
    return false;
  }

  // inject and focus an <input> element into the SVG element to receive focus
  var foreignObject = makeFocusableForeignObject();
  element.appendChild(foreignObject);
  var input = foreignObject.querySelector('input');
  input.focus();

  // upon disabling the activeElement, IE and Edge
  // will not shift focus to <body> like all the other
  // browsers, but instead find the first focusable
  // ancestor and shift focus to that
  input.disabled = true;

  // clean up
  element.removeChild(foreignObject);
  return true;
};

function makeFocusableForeignObject() {
  var fragment = document.createElement('div');
  fragment.innerHTML = '<svg><foreignObject width="30" height="30">\n      <input type="text"/>\n  </foreignObject></svg>';

  return fragment.firstChild.firstChild;
}

module.exports = exports['default'];
//# sourceMappingURL=focus.svg-foreign-object-hack.js.map

/***/ }),

/***/ "./node_modules/ally.js/get/parents.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/get/parents.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context;

  var list = [];
  var element = (0, _contextToElement2.default)({
    label: 'get/parents',
    context: context
  });

  while (element) {
    list.push(element);
    // IE does know support parentElement on SVGElement
    element = element.parentNode;
    if (element && element.nodeType !== Node.ELEMENT_NODE) {
      element = null;
    }
  }

  return list;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];

// [elem, elem.parent, elem.parent.parent, , html]
// will not contain the shadowRoot (DOCUMENT_FRAGMENT_NODE) and shadowHost
//# sourceMappingURL=parents.js.map

/***/ }),

/***/ "./node_modules/ally.js/get/shadow-host.js":
/*!*************************************************!*\
  !*** ./node_modules/ally.js/get/shadow-host.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context;

  var element = (0, _contextToElement2.default)({
    label: 'get/shadow-host',
    context: context
  });

  // walk up to the root
  var container = null;

  while (element) {
    container = element;
    element = element.parentNode;
  }

  // https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeType
  // NOTE: Firefox 34 does not expose ShadowRoot.host (but 37 does)
  if (container.nodeType === container.DOCUMENT_FRAGMENT_NODE && container.host) {
    // the root is attached to a fragment node that has a host
    return container.host;
  }

  return null;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=shadow-host.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/active-element.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/is/active-element.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  var element = (0, _contextToElement2.default)({
    label: 'is/active-element',
    resolveDocument: true,
    context: context
  });

  var _document = (0, _getDocument2.default)(element);
  if (_document.activeElement === element) {
    return true;
  }

  var shadowHost = (0, _shadowHost2.default)({ context: element });
  if (shadowHost && shadowHost.shadowRoot.activeElement === element) {
    return true;
  }

  return false;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _shadowHost = __webpack_require__(/*! ../get/shadow-host */ "./node_modules/ally.js/get/shadow-host.js");

var _shadowHost2 = _interopRequireDefault(_shadowHost);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Determines if an element is the activeElement within its context, i.e. its document iFrame or ShadowHost

module.exports = exports['default'];
//# sourceMappingURL=active-element.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/disabled.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/is/disabled.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/disabled',
    context: context
  });

  if (element.hasAttribute('data-ally-disabled')) {
    // treat ally's element/disabled like the DOM native element.disabled
    return true;
  }

  if (!(0, _nativeDisabledSupported2.default)(element)) {
    // non-form elements do not support the disabled attribute
    return false;
  }

  if (element.disabled) {
    // the element itself is disabled
    return true;
  }

  var parents = (0, _parents2.default)({ context: element });
  if (parents.some(isDisabledFieldset)) {
    // a parental <fieldset> is disabld and inherits the state onto this element
    return true;
  }

  if (!supports.focusFormDisabled && parents.some(isDisabledForm)) {
    // a parental <form> is disabld and inherits the state onto this element
    return true;
  }

  return false;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _parents = __webpack_require__(/*! ../get/parents */ "./node_modules/ally.js/get/parents.js");

var _parents2 = _interopRequireDefault(_parents);

var _nativeDisabledSupported = __webpack_require__(/*! ./native-disabled-supported */ "./node_modules/ally.js/is/native-disabled-supported.js");

var _nativeDisabledSupported2 = _interopRequireDefault(_nativeDisabledSupported);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Determine if an element is disabled (i.e. not editable)

var supports = void 0;

function isDisabledFieldset(element) {
  var nodeName = element.nodeName.toLowerCase();
  return nodeName === 'fieldset' && element.disabled;
}

function isDisabledForm(element) {
  var nodeName = element.nodeName.toLowerCase();
  return nodeName === 'form' && element.disabled;
}

module.exports = exports['default'];
//# sourceMappingURL=disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/focus-relevant.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/is/focus-relevant.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parents = __webpack_require__(/*! ../get/parents */ "./node_modules/ally.js/get/parents.js");

var _parents2 = _interopRequireDefault(_parents);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _elementMatches = __webpack_require__(/*! ../util/element-matches */ "./node_modules/ally.js/util/element-matches.js");

var _elementMatches2 = _interopRequireDefault(_elementMatches);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _validTabindex = __webpack_require__(/*! ./valid-tabindex */ "./node_modules/ally.js/is/valid-tabindex.js");

var _validTabindex2 = _interopRequireDefault(_validTabindex);

var _is = __webpack_require__(/*! ./is.util */ "./node_modules/ally.js/is/is.util.js");

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;
// determine if an element supports.can be focused by script regardless
// of the element actually being focusable at the time of execution
// i.e. <input disabled> is conisdered focus-relevant, but not focusable

function isFocusRelevantRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    flexbox: false,
    scrollable: false,
    shadow: false
  } : _ref$except;

  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/focus-relevant',
    resolveDocument: true,
    context: context
  });

  if (!except.shadow && element.shadowRoot) {
    // a ShadowDOM host receives focus when the focus moves to its content
    return true;
  }

  var nodeName = element.nodeName.toLowerCase();

  if (nodeName === 'input' && element.type === 'hidden') {
    // input[type="hidden"] supports.cannot be focused
    return false;
  }

  if (nodeName === 'input' || nodeName === 'select' || nodeName === 'button' || nodeName === 'textarea') {
    return true;
  }

  if (nodeName === 'legend' && supports.focusRedirectLegend) {
    // specifics filtered in is/focusable
    return true;
  }

  if (nodeName === 'label') {
    // specifics filtered in is/focusable
    return true;
  }

  if (nodeName === 'area') {
    // specifics filtered in is/focusable
    return true;
  }

  if (nodeName === 'a' && element.hasAttribute('href')) {
    return true;
  }

  if (nodeName === 'object' && element.hasAttribute('usemap')) {
    // object[usemap] is not focusable in any browser
    return false;
  }

  if (nodeName === 'object') {
    var svgType = element.getAttribute('type');
    if (!supports.focusObjectSvg && svgType === 'image/svg+xml') {
      // object[type="image/svg+xml"] is not focusable in Internet Explorer
      return false;
    } else if (!supports.focusObjectSwf && svgType === 'application/x-shockwave-flash') {
      // object[type="application/x-shockwave-flash"] is not focusable in Internet Explorer 9
      return false;
    }
  }

  if (nodeName === 'iframe' || nodeName === 'object') {
    // browsing context containers
    return true;
  }

  if (nodeName === 'embed' || nodeName === 'keygen') {
    // embed is considered focus-relevant but not focusable
    // see https://github.com/medialize/ally.js/issues/82
    return true;
  }

  if (element.hasAttribute('contenteditable')) {
    // also see CSS property user-modify below
    return true;
  }

  if (nodeName === 'audio' && (supports.focusAudioWithoutControls || element.hasAttribute('controls'))) {
    return true;
  }

  if (nodeName === 'video' && (supports.focusVideoWithoutControls || element.hasAttribute('controls'))) {
    return true;
  }

  if (supports.focusSummary && nodeName === 'summary') {
    return true;
  }

  var validTabindex = (0, _validTabindex2.default)(element);

  if (nodeName === 'img' && element.hasAttribute('usemap')) {
    // Gecko, Trident and Edge do not allow an image with an image map and tabindex to be focused,
    // it appears the tabindex is overruled so focus is still forwarded to the <map>
    return validTabindex && supports.focusImgUsemapTabindex || supports.focusRedirectImgUsemap;
  }

  if (supports.focusTable && (nodeName === 'table' || nodeName === 'td')) {
    // IE10-11 supports.can focus <table> and <td>
    return true;
  }

  if (supports.focusFieldset && nodeName === 'fieldset') {
    // IE10-11 supports.can focus <fieldset>
    return true;
  }

  var isSvgElement = nodeName === 'svg';
  var isSvgContent = element.ownerSVGElement;
  var focusableAttribute = element.getAttribute('focusable');
  var tabindex = (0, _tabindexValue2.default)(element);

  if (nodeName === 'use' && tabindex !== null && !supports.focusSvgUseTabindex) {
    // <use> cannot be made focusable by adding a tabindex attribute anywhere but Blink and WebKit
    return false;
  }

  if (nodeName === 'foreignobject') {
    // <use> can only be made focusable in Blink and WebKit
    return tabindex !== null && supports.focusSvgForeignobjectTabindex;
  }

  if ((0, _elementMatches2.default)(element, 'svg a') && element.hasAttribute('xlink:href')) {
    return true;
  }

  if ((isSvgElement || isSvgContent) && element.focus && !supports.focusSvgNegativeTabindexAttribute && tabindex < 0) {
    // Firefox 51 and 52 treat any natively tabbable SVG element with
    // tabindex="-1" as tabbable and everything else as inert
    // see https://bugzilla.mozilla.org/show_bug.cgi?id=1302340
    return false;
  }

  if (isSvgElement) {
    return validTabindex || supports.focusSvg || supports.focusSvgInIframe
    // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2
    || Boolean(supports.focusSvgFocusableAttribute && focusableAttribute && focusableAttribute === 'true');
  }

  if (isSvgContent) {
    if (supports.focusSvgTabindexAttribute && validTabindex) {
      return true;
    }

    if (supports.focusSvgFocusableAttribute) {
      // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2
      return focusableAttribute === 'true';
    }
  }

  // https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
  if (validTabindex) {
    return true;
  }

  var style = window.getComputedStyle(element, null);
  if ((0, _is.isUserModifyWritable)(style)) {
    return true;
  }

  if (supports.focusImgIsmap && nodeName === 'img' && element.hasAttribute('ismap')) {
    // IE10-11 considers the <img> in <a href><img ismap> focusable
    // https://github.com/medialize/ally.js/issues/20
    var hasLinkParent = (0, _parents2.default)({ context: element }).some(function (parent) {
      return parent.nodeName.toLowerCase() === 'a' && parent.hasAttribute('href');
    });

    if (hasLinkParent) {
      return true;
    }
  }

  // https://github.com/medialize/ally.js/issues/21
  if (!except.scrollable && supports.focusScrollContainer) {
    if (supports.focusScrollContainerWithoutOverflow) {
      // Internet Explorer does will consider the scrollable area focusable
      // if the element is a <div> or a <span> and it is in fact scrollable,
      // regardless of the CSS overflow property
      if ((0, _is.isScrollableContainer)(element, nodeName)) {
        return true;
      }
    } else if ((0, _is.hasCssOverflowScroll)(style)) {
      // Firefox requires proper overflow setting, IE does not necessarily
      // https://developer.mozilla.org/en-US/docs/Web/CSS/overflow
      return true;
    }
  }

  if (!except.flexbox && supports.focusFlexboxContainer && (0, _is.hasCssDisplayFlex)(style)) {
    // elements with display:flex are focusable in IE10-11
    return true;
  }

  var parent = element.parentElement;
  if (!except.scrollable && parent) {
    var parentNodeName = parent.nodeName.toLowerCase();
    var parentStyle = window.getComputedStyle(parent, null);
    if (supports.focusScrollBody && (0, _is.isScrollableContainer)(parent, nodeName, parentNodeName, parentStyle)) {
      // scrollable bodies are focusable Internet Explorer
      // https://github.com/medialize/ally.js/issues/21
      return true;
    }

    // Children of focusable elements with display:flex are focusable in IE10-11
    if (supports.focusChildrenOfFocusableFlexbox) {
      if ((0, _is.hasCssDisplayFlex)(parentStyle)) {
        return true;
      }
    }
  }

  // NOTE: elements marked as inert are not focusable,
  // but that property is not exposed to the DOM
  // https://www.w3.org/TR/html5/editing.html#inert

  return false;
}

// bind exceptions to an iterator callback
isFocusRelevantRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isFocusRelevant = function isFocusRelevant(context) {
    return isFocusRelevantRules({
      context: context,
      except: except
    });
  };

  isFocusRelevant.rules = isFocusRelevantRules;
  return isFocusRelevant;
};

// provide isFocusRelevant(context) as default iterator callback
var isFocusRelevant = isFocusRelevantRules.except({});
exports.default = isFocusRelevant;
module.exports = exports['default'];
//# sourceMappingURL=focus-relevant.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/focusable.js":
/*!**********************************************!*\
  !*** ./node_modules/ally.js/is/focusable.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _focusRelevant = __webpack_require__(/*! ./focus-relevant */ "./node_modules/ally.js/is/focus-relevant.js");

var _focusRelevant2 = _interopRequireDefault(_focusRelevant);

var _validArea = __webpack_require__(/*! ./valid-area */ "./node_modules/ally.js/is/valid-area.js");

var _validArea2 = _interopRequireDefault(_validArea);

var _visible = __webpack_require__(/*! ./visible */ "./node_modules/ally.js/is/visible.js");

var _visible2 = _interopRequireDefault(_visible);

var _disabled = __webpack_require__(/*! ./disabled */ "./node_modules/ally.js/is/disabled.js");

var _disabled2 = _interopRequireDefault(_disabled);

var _onlyTabbable = __webpack_require__(/*! ./only-tabbable */ "./node_modules/ally.js/is/only-tabbable.js");

var _onlyTabbable2 = _interopRequireDefault(_onlyTabbable);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _getFrameElement = __webpack_require__(/*! ../util/get-frame-element */ "./node_modules/ally.js/util/get-frame-element.js");

var _getFrameElement2 = _interopRequireDefault(_getFrameElement);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;
// determine if an element can be focused

// https://www.w3.org/TR/html5/editing.html#focus-management

// NOTE: The following known issues exist:
//   Gecko: `svg a[xlink|href]` is not identified as focusable (because SVGElement.prototype.focus is missing)
//   Blink, WebKit: SVGElements that have been made focusable by adding a focus event listener are not identified as focusable

function isOnlyFocusRelevant(element) {
  var nodeName = element.nodeName.toLowerCase();
  if (nodeName === 'embed' || nodeName === 'keygen') {
    // embed is considered focus-relevant but not focusable
    // see https://github.com/medialize/ally.js/issues/82
    return true;
  }

  var _tabindex = (0, _tabindexValue2.default)(element);
  if (element.shadowRoot && _tabindex === null) {
    // ShadowDOM host elements *may* receive focus
    // even though they are not considered focuable
    return true;
  }

  if (nodeName === 'label') {
    // <label tabindex="0"> is only tabbable in Firefox, not script-focusable
    // there's no way to make an element focusable other than by adding a tabindex,
    // and focus behavior of the label element seems hard-wired to ignore tabindex
    // in some browsers (like Gecko, Blink and WebKit)
    return !supports.focusLabelTabindex || _tabindex === null;
  }

  if (nodeName === 'legend') {
    return _tabindex === null;
  }

  if (supports.focusSvgFocusableAttribute && (element.ownerSVGElement || nodeName === 'svg')) {
    // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2
    var focusableAttribute = element.getAttribute('focusable');
    return focusableAttribute && focusableAttribute === 'false';
  }

  if (nodeName === 'img' && element.hasAttribute('usemap')) {
    // Gecko, Trident and Edge do not allow an image with an image map and tabindex to be focused,
    // it appears the tabindex is overruled so focus is still forwarded to the <map>
    return _tabindex === null || !supports.focusImgUsemapTabindex;
  }

  if (nodeName === 'area') {
    // all <area>s are considered relevant,
    // but only the valid <area>s are focusable
    return !(0, _validArea2.default)(element);
  }

  return false;
}

function isFocusableRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    disabled: false,
    visible: false,
    onlyTabbable: false
  } : _ref$except;

  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var _isOnlyTabbable = _onlyTabbable2.default.rules.except({
    onlyFocusableBrowsingContext: true,
    visible: except.visible
  });

  var element = (0, _contextToElement2.default)({
    label: 'is/focusable',
    resolveDocument: true,
    context: context
  });

  var focusRelevant = _focusRelevant2.default.rules({
    context: element,
    except: except
  });

  if (!focusRelevant || isOnlyFocusRelevant(element)) {
    return false;
  }

  if (!except.disabled && (0, _disabled2.default)(element)) {
    return false;
  }

  if (!except.onlyTabbable && _isOnlyTabbable(element)) {
    // some elements may be keyboard focusable, but not script focusable
    return false;
  }

  // elements that are not rendered, cannot be focused
  if (!except.visible) {
    var visibilityOptions = {
      context: element,
      except: {}
    };

    if (supports.focusInHiddenIframe) {
      // WebKit and Blink can focus content in hidden <iframe> and <object>
      visibilityOptions.except.browsingContext = true;
    }

    if (supports.focusObjectSvgHidden) {
      // Blink allows focusing the object element, even if it has visibility: hidden;
      // @browser-issue Blink https://code.google.com/p/chromium/issues/detail?id=586191
      var _nodeName2 = element.nodeName.toLowerCase();
      if (_nodeName2 === 'object') {
        visibilityOptions.except.cssVisibility = true;
      }
    }

    if (!_visible2.default.rules(visibilityOptions)) {
      return false;
    }
  }

  var frameElement = (0, _getFrameElement2.default)(element);
  if (frameElement) {
    var _nodeName = frameElement.nodeName.toLowerCase();
    if (_nodeName === 'object' && !supports.focusInZeroDimensionObject) {
      if (!frameElement.offsetWidth || !frameElement.offsetHeight) {
        // WebKit can not focus content in <object> if it doesn't have dimensions
        return false;
      }
    }
  }

  var nodeName = element.nodeName.toLowerCase();
  if (nodeName === 'svg' && supports.focusSvgInIframe && !frameElement && element.getAttribute('tabindex') === null) {
    return false;
  }

  return true;
}

// bind exceptions to an iterator callback
isFocusableRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isFocusable = function isFocusable(context) {
    return isFocusableRules({
      context: context,
      except: except
    });
  };

  isFocusable.rules = isFocusableRules;
  return isFocusable;
};

// provide isFocusRelevant(context) as default iterator callback
var isFocusable = isFocusableRules.except({});
exports.default = isFocusable;
module.exports = exports['default'];
//# sourceMappingURL=focusable.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/is.util.js":
/*!********************************************!*\
  !*** ./node_modules/ally.js/is/is.util.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isUserModifyWritable = isUserModifyWritable;
exports.hasCssOverflowScroll = hasCssOverflowScroll;
exports.hasCssDisplayFlex = hasCssDisplayFlex;
exports.isScrollableContainer = isScrollableContainer;

// this is a shared utility file for focus-relevant.js and tabbable.js
// separate testing of this file's functions is not necessary,
// as they're implicitly tested by way of the consumers

function isUserModifyWritable(style) {
  // https://www.w3.org/TR/1999/WD-css3-userint-19990916#user-modify
  // https://github.com/medialize/ally.js/issues/17
  var userModify = style.webkitUserModify || '';
  return Boolean(userModify && userModify.indexOf('write') !== -1);
}

function hasCssOverflowScroll(style) {
  return [style.getPropertyValue('overflow'), style.getPropertyValue('overflow-x'), style.getPropertyValue('overflow-y')].some(function (overflow) {
    return overflow === 'auto' || overflow === 'scroll';
  });
}

function hasCssDisplayFlex(style) {
  return style.display.indexOf('flex') > -1;
}

function isScrollableContainer(element, nodeName, parentNodeName, parentStyle) {
  if (nodeName !== 'div' && nodeName !== 'span') {
    // Internet Explorer advances scrollable containers and bodies to focusable
    // only if the scrollable container is <div> or <span> - this does *not*
    // happen for <section>, <article>, 
    return false;
  }

  if (parentNodeName && parentNodeName !== 'div' && parentNodeName !== 'span' && !hasCssOverflowScroll(parentStyle)) {
    return false;
  }

  return element.offsetHeight < element.scrollHeight || element.offsetWidth < element.scrollWidth;
}
//# sourceMappingURL=is.util.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/native-disabled-supported.js":
/*!**************************************************************!*\
  !*** ./node_modules/ally.js/is/native-disabled-supported.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  if (!supports) {
    supports = (0, _supports3.default)();

    if (supports.focusFieldsetDisabled) {
      delete disabledElements.fieldset;
    }

    if (supports.focusFormDisabled) {
      delete disabledElements.form;
    }

    disabledElementsPattern = new RegExp('^(' + Object.keys(disabledElements).join('|') + ')$');
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/native-disabled-supported',
    context: context
  });

  var nodeName = element.nodeName.toLowerCase();
  return Boolean(disabledElementsPattern.test(nodeName));
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Determine if an element supports the disabled attribute

var supports = void 0;

// https://www.w3.org/TR/html5/disabled-elements.html#concept-element-disabled
var disabledElementsPattern = void 0;
var disabledElements = {
  input: true,
  select: true,
  textarea: true,
  button: true,
  fieldset: true,
  form: true
};

module.exports = exports['default'];
//# sourceMappingURL=native-disabled-supported.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/only-tabbable.js":
/*!**************************************************!*\
  !*** ./node_modules/ally.js/is/only-tabbable.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _visible = __webpack_require__(/*! ./visible */ "./node_modules/ally.js/is/visible.js");

var _visible2 = _interopRequireDefault(_visible);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _getFrameElement = __webpack_require__(/*! ../util/get-frame-element */ "./node_modules/ally.js/util/get-frame-element.js");

var _getFrameElement2 = _interopRequireDefault(_getFrameElement);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isOnlyTabbableRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    onlyFocusableBrowsingContext: false,
    visible: false
  } : _ref$except;

  var element = (0, _contextToElement2.default)({
    label: 'is/only-tabbable',
    resolveDocument: true,
    context: context
  });

  if (!except.visible && !(0, _visible2.default)(element)) {
    return false;
  }

  if (!except.onlyFocusableBrowsingContext && (_platform2.default.is.GECKO || _platform2.default.is.TRIDENT || _platform2.default.is.EDGE)) {
    var frameElement = (0, _getFrameElement2.default)(element);
    if (frameElement) {
      if ((0, _tabindexValue2.default)(frameElement) < 0) {
        // iframe[tabindex="-1"] and object[tabindex="-1"] inherit the
        // tabbable demotion onto elements of their browsing contexts
        return false;
      }
    }
  }

  var nodeName = element.nodeName.toLowerCase();
  var tabindex = (0, _tabindexValue2.default)(element);

  if (nodeName === 'label' && _platform2.default.is.GECKO) {
    // Firefox cannot focus, but tab to: label[tabindex=0]
    return tabindex !== null && tabindex >= 0;
  }

  // SVG Elements were keyboard focusable but not script focusable before Firefox 51.
  // Firefox 51 added the focus management DOM API (.focus and .blur) to SVGElement,
  // see https://bugzilla.mozilla.org/show_bug.cgi?id=778654
  if (_platform2.default.is.GECKO && element.ownerSVGElement && !element.focus) {
    if (nodeName === 'a' && element.hasAttribute('xlink:href')) {
      // any focusable child of <svg> cannot be focused, but tabbed to
      if (_platform2.default.is.GECKO) {
        return true;
      }
    }
  }

  return false;
}

// bind exceptions to an iterator callback
isOnlyTabbableRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isOnlyTabbable = function isOnlyTabbable(context) {
    return isOnlyTabbableRules({
      context: context,
      except: except
    });
  };

  isOnlyTabbable.rules = isOnlyTabbableRules;
  return isOnlyTabbable;
};

// provide isOnlyTabbable(context) as default iterator callback
var isOnlyTabbable = isOnlyTabbableRules.except({});
exports.default = isOnlyTabbable;
module.exports = exports['default'];
//# sourceMappingURL=only-tabbable.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/tabbable.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/is/tabbable.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _visible = __webpack_require__(/*! ./visible */ "./node_modules/ally.js/is/visible.js");

var _visible2 = _interopRequireDefault(_visible);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _elementMatches = __webpack_require__(/*! ../util/element-matches */ "./node_modules/ally.js/util/element-matches.js");

var _elementMatches2 = _interopRequireDefault(_elementMatches);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _focusRelevant = __webpack_require__(/*! ./focus-relevant */ "./node_modules/ally.js/is/focus-relevant.js");

var _focusRelevant2 = _interopRequireDefault(_focusRelevant);

var _getFrameElement = __webpack_require__(/*! ../util/get-frame-element */ "./node_modules/ally.js/util/get-frame-element.js");

var _getFrameElement2 = _interopRequireDefault(_getFrameElement);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

var _imageMap = __webpack_require__(/*! ../util/image-map */ "./node_modules/ally.js/util/image-map.js");

var _is = __webpack_require__(/*! ./is.util */ "./node_modules/ally.js/is/is.util.js");

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// determine if an element can be focused by keyboard (i.e. is part of the document's sequential focus navigation order)

var supports = void 0;

// Internet Explorer 11 considers fieldset, table, td focusable, but not tabbable
// Internet Explorer 11 considers body to have [tabindex=0], but does not allow tabbing to it
var focusableElementsPattern = /^(fieldset|table|td|body)$/;

function isTabbableRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    flexbox: false,
    scrollable: false,
    shadow: false,
    visible: false,
    onlyTabbable: false
  } : _ref$except;

  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/tabbable',
    resolveDocument: true,
    context: context
  });

  if (_platform2.default.is.BLINK && _platform2.default.is.ANDROID && _platform2.default.majorVersion > 42) {
    // External keyboard support worked fine in CHrome 42, but stopped working in Chrome 45.
    // The on-screen keyboard does not provide a way to focus the next input element (like iOS does).
    // That leaves us with no option to advance focus by keyboard, ergo nothing is tabbable (keyboard focusable).
    return false;
  }

  var frameElement = (0, _getFrameElement2.default)(element);
  if (frameElement) {
    if (_platform2.default.is.WEBKIT && _platform2.default.is.IOS) {
      // iOS only does not consider anything from another browsing context keyboard focusable
      return false;
    }

    // iframe[tabindex="-1"] and object[tabindex="-1"] inherit the
    // tabbable demotion onto elements of their browsing contexts
    if ((0, _tabindexValue2.default)(frameElement) < 0) {
      return false;
    }

    if (!except.visible && (_platform2.default.is.BLINK || _platform2.default.is.WEBKIT) && !(0, _visible2.default)(frameElement)) {
      // Blink and WebKit consider elements in hidden browsing contexts focusable, but not tabbable
      return false;
    }

    // Webkit and Blink don't consider anything in <object> tabbable
    // Blink fixed that fixed in Chrome 54, Opera 41
    var frameNodeName = frameElement.nodeName.toLowerCase();
    if (frameNodeName === 'object') {
      var isFixedBlink = _platform2.default.name === 'Chrome' && _platform2.default.majorVersion >= 54 || _platform2.default.name === 'Opera' && _platform2.default.majorVersion >= 41;

      if (_platform2.default.is.WEBKIT || _platform2.default.is.BLINK && !isFixedBlink) {
        return false;
      }
    }
  }

  var nodeName = element.nodeName.toLowerCase();
  var _tabindex = (0, _tabindexValue2.default)(element);
  var tabindex = _tabindex === null ? null : _tabindex >= 0;

  if (_platform2.default.is.EDGE && _platform2.default.majorVersion >= 14 && frameElement && element.ownerSVGElement && _tabindex < 0) {
    // Edge 14+ considers <a xlink:href="" tabindex="-1"> keyboard focusable
    // if the element is in a nested browsing context
    return true;
  }

  var hasTabbableTabindexOrNone = tabindex !== false;
  var hasTabbableTabindex = _tabindex !== null && _tabindex >= 0;

  // NOTE: Firefox 31 considers [contenteditable] to have [tabindex=-1], but allows tabbing to it
  // fixed in Firefox 40 the latest - https://bugzilla.mozilla.org/show_bug.cgi?id=1185657
  if (element.hasAttribute('contenteditable')) {
    // tabbing can still be disabled by explicitly providing [tabindex="-1"]
    return hasTabbableTabindexOrNone;
  }

  if (focusableElementsPattern.test(nodeName) && tabindex !== true) {
    return false;
  }

  if (_platform2.default.is.WEBKIT && _platform2.default.is.IOS) {
    // iOS only considers a hand full of elements tabbable (keyboard focusable)
    // this holds true even with external keyboards
    var potentiallyTabbable = nodeName === 'input' && element.type === 'text' || element.type === 'password' || nodeName === 'select' || nodeName === 'textarea' || element.hasAttribute('contenteditable');

    if (!potentiallyTabbable) {
      var style = window.getComputedStyle(element, null);
      potentiallyTabbable = (0, _is.isUserModifyWritable)(style);
    }

    if (!potentiallyTabbable) {
      return false;
    }
  }

  if (nodeName === 'use' && _tabindex !== null) {
    if (_platform2.default.is.BLINK || _platform2.default.is.WEBKIT && _platform2.default.majorVersion === 9) {
      // In Chrome and Safari 9 the <use> element is keyboard focusable even for tabindex="-1"
      return true;
    }
  }

  if ((0, _elementMatches2.default)(element, 'svg a') && element.hasAttribute('xlink:href')) {
    if (hasTabbableTabindexOrNone) {
      // in Trident and Gecko SVGElement does not handle the tabIndex property properly
      return true;
    }

    if (element.focus && !supports.focusSvgNegativeTabindexAttribute) {
      // Firefox 51 and 52 treat any natively tabbable SVG element with
      // tabindex="-1" as tabbable and everything else as inert
      // see https://bugzilla.mozilla.org/show_bug.cgi?id=1302340
      return true;
    }
  }

  if (nodeName === 'svg' && supports.focusSvgInIframe && hasTabbableTabindexOrNone) {
    return true;
  }

  if (_platform2.default.is.TRIDENT || _platform2.default.is.EDGE) {
    if (nodeName === 'svg') {
      if (supports.focusSvg) {
        // older Internet Explorers consider <svg> keyboard focusable
        // unless they have focsable="false", but then they wouldn't
        // be focusable and thus not even reach this filter
        return true;
      }

      // elements that have [focusable] are automatically keyboard focusable regardless of the attribute's value
      return element.hasAttribute('focusable') || hasTabbableTabindex;
    }

    if (element.ownerSVGElement) {
      if (supports.focusSvgTabindexAttribute && hasTabbableTabindex) {
        return true;
      }

      // elements that have [focusable] are automatically keyboard focusable regardless of the attribute's value
      return element.hasAttribute('focusable');
    }
  }
  if (element.tabIndex === undefined) {
    return Boolean(except.onlyTabbable);
  }

  if (nodeName === 'audio') {
    if (!element.hasAttribute('controls')) {
      // In Internet Explorer the <audio> element is focusable, but not tabbable, and tabIndex property is wrong
      return false;
    } else if (_platform2.default.is.BLINK) {
      // In Chrome <audio controls tabindex="-1"> remains keyboard focusable
      return true;
    }
  }

  if (nodeName === 'video') {
    if (!element.hasAttribute('controls')) {
      if (_platform2.default.is.TRIDENT || _platform2.default.is.EDGE) {
        // In Internet Explorer and Edge the <video> element is focusable, but not tabbable, and tabIndex property is wrong
        return false;
      }
    } else if (_platform2.default.is.BLINK || _platform2.default.is.GECKO) {
      // In Chrome and Firefox <video controls tabindex="-1"> remains keyboard focusable
      return true;
    }
  }

  if (nodeName === 'object') {
    if (_platform2.default.is.BLINK || _platform2.default.is.WEBKIT) {
      // In all Blink and WebKit based browsers <embed> and <object> are never keyboard focusable, even with tabindex="0" set
      return false;
    }
  }

  if (nodeName === 'iframe') {
    // In Internet Explorer all iframes are only focusable
    // In WebKit, Blink and Gecko iframes may be tabbable depending on content.
    // Since we can't reliably investigate iframe documents because of the
    // SameOriginPolicy, we're declaring everything only focusable.
    return false;
  }

  if (!except.scrollable && _platform2.default.is.GECKO) {
    // Firefox considers scrollable containers keyboard focusable,
    // even though their tabIndex property is -1
    var _style = window.getComputedStyle(element, null);
    if ((0, _is.hasCssOverflowScroll)(_style)) {
      return hasTabbableTabindexOrNone;
    }
  }

  if (_platform2.default.is.TRIDENT || _platform2.default.is.EDGE) {
    // IE and Edge degrade <area> to script focusable, if the image
    // using the <map> has been given tabindex="-1"
    if (nodeName === 'area') {
      var img = (0, _imageMap.getImageOfArea)(element);
      if (img && (0, _tabindexValue2.default)(img) < 0) {
        return false;
      }
    }

    var _style2 = window.getComputedStyle(element, null);
    if ((0, _is.isUserModifyWritable)(_style2)) {
      // prevent being swallowed by the overzealous isScrollableContainer() below
      return element.tabIndex >= 0;
    }

    if (!except.flexbox && (0, _is.hasCssDisplayFlex)(_style2)) {
      if (_tabindex !== null) {
        return hasTabbableTabindex;
      }

      return isFocusRelevantWithoutFlexbox(element) && isTabbableWithoutFlexbox(element);
    }

    // IE considers scrollable containers script focusable only,
    // even though their tabIndex property is 0
    if ((0, _is.isScrollableContainer)(element, nodeName)) {
      return false;
    }

    var parent = element.parentElement;
    if (parent) {
      var parentNodeName = parent.nodeName.toLowerCase();
      var parentStyle = window.getComputedStyle(parent, null);
      // IE considers scrollable bodies script focusable only,
      if ((0, _is.isScrollableContainer)(parent, nodeName, parentNodeName, parentStyle)) {
        return false;
      }

      // Children of focusable elements with display:flex are focusable in IE10-11,
      // even though their tabIndex property suggests otherwise
      if ((0, _is.hasCssDisplayFlex)(parentStyle)) {
        // value of tabindex takes precedence
        return hasTabbableTabindex;
      }
    }
  }

  // https://www.w3.org/WAI/PF/aria-practices/#focus_tabindex
  return element.tabIndex >= 0;
}

// bind exceptions to an iterator callback
isTabbableRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isTabbable = function isTabbable(context) {
    return isTabbableRules({
      context: context,
      except: except
    });
  };

  isTabbable.rules = isTabbableRules;
  return isTabbable;
};

var isFocusRelevantWithoutFlexbox = _focusRelevant2.default.rules.except({ flexbox: true });
var isTabbableWithoutFlexbox = isTabbableRules.except({ flexbox: true });

// provide isTabbable(context) as default iterator callback
var isTabbable = isTabbableRules.except({});
exports.default = isTabbable;
module.exports = exports['default'];
//# sourceMappingURL=tabbable.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/valid-area.js":
/*!***********************************************!*\
  !*** ./node_modules/ally.js/is/valid-area.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/valid-area',
    context: context
  });

  var nodeName = element.nodeName.toLowerCase();
  if (nodeName !== 'area') {
    return false;
  }

  var hasTabindex = element.hasAttribute('tabindex');
  if (!supports.focusAreaTabindex && hasTabindex) {
    // Blink and WebKit do not consider <area tabindex="-1" href="#void"> focusable
    return false;
  }

  var img = (0, _imageMap.getImageOfArea)(element);
  if (!img || !(0, _visible2.default)(img)) {
    return false;
  }

  // Firefox only allows fully loaded images to reference image maps
  // https://stereochro.me/ideas/detecting-broken-images-js
  if (!supports.focusBrokenImageMap && (!img.complete || !img.naturalHeight || img.offsetWidth <= 0 || img.offsetHeight <= 0)) {
    return false;
  }

  // Firefox supports.can focus area elements even if they don't have an href attribute
  if (!supports.focusAreaWithoutHref && !element.href) {
    // Internet explorer supports.can focus area elements without href if either
    // the area element or the image element has a tabindex attribute
    return supports.focusAreaTabindex && hasTabindex || supports.focusAreaImgTabindex && img.hasAttribute('tabindex');
  }

  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
  var childOfInteractive = (0, _parents2.default)({ context: img }).slice(1).some(function (_element) {
    var name = _element.nodeName.toLowerCase();
    return name === 'button' || name === 'a';
  });

  if (childOfInteractive) {
    return false;
  }

  return true;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _visible = __webpack_require__(/*! ./visible */ "./node_modules/ally.js/is/visible.js");

var _visible2 = _interopRequireDefault(_visible);

var _parents = __webpack_require__(/*! ../get/parents */ "./node_modules/ally.js/get/parents.js");

var _parents2 = _interopRequireDefault(_parents);

var _imageMap = __webpack_require__(/*! ../util/image-map */ "./node_modules/ally.js/util/image-map.js");

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
// https://github.com/jquery/jquery-ui/blob/master/ui/core.js#L88-L107

// determine if an <area> element is being properly used by and <img> via a <map>

module.exports = exports['default'];
//# sourceMappingURL=valid-area.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/valid-tabindex.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/is/valid-tabindex.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var validIntegerPattern = supports.focusTabindexTrailingCharacters ? validIntegerPatternWithTrailing : validIntegerPatternNoTrailing;

  var element = (0, _contextToElement2.default)({
    label: 'is/valid-tabindex',
    resolveDocument: true,
    context: context
  });

  // Edge 14 has a capitalization problem on SVG elements,
  // see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9282058/
  var hasTabindex = element.hasAttribute('tabindex');
  var hasTabIndex = element.hasAttribute('tabIndex');

  if (!hasTabindex && !hasTabIndex) {
    return false;
  }

  // older Firefox and Internet Explorer don't support tabindex on SVG elements
  var isSvgElement = element.ownerSVGElement || element.nodeName.toLowerCase() === 'svg';
  if (isSvgElement && !supports.focusSvgTabindexAttribute) {
    return false;
  }

  // @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
  if (supports.focusInvalidTabindex) {
    return true;
  }

  // an element matches the tabindex selector even if its value is invalid
  var tabindex = element.getAttribute(hasTabindex ? 'tabindex' : 'tabIndex');
  // IE11 parses tabindex="" as the value "-32768"
  // @browser-issue Trident https://connect.microsoft.com/IE/feedback/details/1072965
  if (tabindex === '-32768') {
    return false;
  }

  return Boolean(tabindex && validIntegerPattern.test(tabindex));
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// determine if an element's tabindex attribute has a valid value

var supports = void 0;

// https://www.w3.org/TR/html5/infrastructure.html#rules-for-parsing-integers
// NOTE: all browsers agree to allow trailing spaces as well
var validIntegerPatternNoTrailing = /^\s*(-|\+)?[0-9]+\s*$/;
var validIntegerPatternWithTrailing = /^\s*(-|\+)?[0-9]+.*$/;

module.exports = exports['default'];
//# sourceMappingURL=valid-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/visible.js":
/*!********************************************!*\
  !*** ./node_modules/ally.js/is/visible.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _arrayFindIndex = __webpack_require__(/*! ../util/array-find-index */ "./node_modules/ally.js/util/array-find-index.js");

var _arrayFindIndex2 = _interopRequireDefault(_arrayFindIndex);

var _parents = __webpack_require__(/*! ../get/parents */ "./node_modules/ally.js/get/parents.js");

var _parents2 = _interopRequireDefault(_parents);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _getFrameElement = __webpack_require__(/*! ../util/get-frame-element */ "./node_modules/ally.js/util/get-frame-element.js");

var _getFrameElement2 = _interopRequireDefault(_getFrameElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://www.w3.org/TR/html5/rendering.html#being-rendered
// <area> is not rendered, but we *consider* it visible to simplfiy this function's usage

// determine if an element is rendered
// NOTE: that does not mean an element is visible in the viewport, see util/visible-area

var notRenderedElementsPattern = /^(area)$/;

function computedStyle(element, property) {
  return window.getComputedStyle(element, null).getPropertyValue(property);
}

function notDisplayed(_path) {
  return _path.some(function (element) {
    // display:none is not visible (optimized away at layout)
    return computedStyle(element, 'display') === 'none';
  });
}

function notVisible(_path) {
  // https://github.com/jquery/jquery-ui/blob/master/ui/core.js#L109-L114
  // NOTE: a nested element can reverse visibility:hidden|collapse by explicitly setting visibility:visible
  // NOTE: visibility can be ["", "visible", "hidden", "collapse"]
  var hidden = (0, _arrayFindIndex2.default)(_path, function (element) {
    var visibility = computedStyle(element, 'visibility');
    return visibility === 'hidden' || visibility === 'collapse';
  });

  if (hidden === -1) {
    // there is no hidden element
    return false;
  }

  var visible = (0, _arrayFindIndex2.default)(_path, function (element) {
    return computedStyle(element, 'visibility') === 'visible';
  });

  if (visible === -1) {
    // there is no visible element (but a hidden element)
    return true;
  }

  if (hidden < visible) {
    // there is a hidden element and it's closer than the first visible element
    return true;
  }

  // there may be a hidden element, but the closest element is visible
  return false;
}

function collapsedParent(_path) {
  var offset = 1;
  if (_path[0].nodeName.toLowerCase() === 'summary') {
    offset = 2;
  }

  return _path.slice(offset).some(function (element) {
    // "content children" of a closed details element are not visible
    return element.nodeName.toLowerCase() === 'details' && element.open === false;
  });
}

function isVisibleRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    notRendered: false,
    cssDisplay: false,
    cssVisibility: false,
    detailsElement: false,
    browsingContext: false
  } : _ref$except;

  var element = (0, _contextToElement2.default)({
    label: 'is/visible',
    resolveDocument: true,
    context: context
  });

  var nodeName = element.nodeName.toLowerCase();
  if (!except.notRendered && notRenderedElementsPattern.test(nodeName)) {
    return true;
  }

  var _path = (0, _parents2.default)({ context: element });

  // in Internet Explorer <audio> has a default display: none, where others have display: inline
  // but IE allows focusing <audio style="display:none">, but not <div display:none><audio>
  // this is irrelevant to other browsers, as the controls attribute is required to make <audio> focusable
  var isAudioWithoutControls = nodeName === 'audio' && !element.hasAttribute('controls');
  if (!except.cssDisplay && notDisplayed(isAudioWithoutControls ? _path.slice(1) : _path)) {
    return false;
  }

  if (!except.cssVisibility && notVisible(_path)) {
    return false;
  }

  if (!except.detailsElement && collapsedParent(_path)) {
    return false;
  }

  if (!except.browsingContext) {
    // elements within a browsing context are affected by the
    // browsing context host element's visibility and tabindex
    var frameElement = (0, _getFrameElement2.default)(element);
    var _isVisible = isVisibleRules.except(except);
    if (frameElement && !_isVisible(frameElement)) {
      return false;
    }
  }

  return true;
}

// bind exceptions to an iterator callback
isVisibleRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isVisible = function isVisible(context) {
    return isVisibleRules({
      context: context,
      except: except
    });
  };

  isVisible.rules = isVisibleRules;
  return isVisible;
};

// provide isVisible(context) as default iterator callback
var isVisible = isVisibleRules.except({});
exports.default = isVisible;
module.exports = exports['default'];
//# sourceMappingURL=visible.js.map

/***/ }),

/***/ "./node_modules/ally.js/maintain/disabled.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/maintain/disabled.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
/*
  Utility to make a sub-tree of the DOM inert. Inert means the elements cannot be interacted
  with and they cannot be focused via script, pointer or keyboard.

  inert attribute was [removed](https://html5.org/r/8536) [tweet by steve](https://twitter.com/stevefaulkner/status/443075900201259008)
  but definition of [inert subtrees](https://www.w3.org/html/wg/drafts/html/master/editing.html#inert-subtrees) remains.

  [implementation idea by Vasilis](https://codepen.io/vasilisvg/pen/scowI)
  [inert attribute polyfill by GoogleChrome](https://github.com/GoogleChrome/inert-polyfill)

  [Gecko Bug: Inert Attribute](https://bugzilla.mozilla.org/show_bug.cgi?id=921504)
  [Chromium Bug: Inert Attribute](https://code.google.com/p/chromium/issues/detail?id=269846)
  [Chromium Bug: Inert Subtree](https://code.google.com/p/chromium/issues/detail?id=241699)
  [WebKit Bug: Inert Subtree](https://bugs.webkit.org/show_bug.cgi?id=110952)
*/

exports.default = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref2.context,
      filter = _ref2.filter;

  var service = new InertSubtree({ context: context, filter: filter });
  return { disengage: service.disengage };
};

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _focusable = __webpack_require__(/*! ../query/focusable */ "./node_modules/ally.js/query/focusable.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _disabled = __webpack_require__(/*! ../element/disabled */ "./node_modules/ally.js/element/disabled.js");

var _disabled2 = _interopRequireDefault(_disabled);

var _shadowMutations = __webpack_require__(/*! ../observe/shadow-mutations */ "./node_modules/ally.js/observe/shadow-mutations.js");

var _shadowMutations2 = _interopRequireDefault(_shadowMutations);

var _comparePosition = __webpack_require__(/*! ../util/compare-position */ "./node_modules/ally.js/util/compare-position.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function makeElementInert(element) {
  return (0, _disabled2.default)(element, true);
}

function undoElementInert(element) {
  return (0, _disabled2.default)(element, false);
}

var observerConfig = {
  attributes: true,
  childList: true,
  subtree: true,
  attributeFilter: ['tabindex', 'disabled', 'data-ally-disabled']
};

var InertSubtree = function () {
  function InertSubtree() {
    var _this = this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        context = _ref.context,
        filter = _ref.filter;

    _classCallCheck(this, InertSubtree);

    this._context = (0, _nodeArray2.default)(context || document.documentElement)[0];
    this._filter = (0, _nodeArray2.default)(filter);
    this._inertElementCache = [];

    this.disengage = this.disengage.bind(this);
    this.handleMutation = this.handleMutation.bind(this);
    this.renderInert = this.renderInert.bind(this);
    this.filterElements = this.filterElements.bind(this);
    this.filterParentElements = this.filterParentElements.bind(this);

    var focusable = (0, _focusable2.default)({
      context: this._context,
      includeContext: true,
      strategy: 'all'
    });

    this.renderInert(focusable);

    this.shadowObserver = (0, _shadowMutations2.default)({
      context: this._context,
      config: observerConfig,
      callback: function callback(mutations) {
        return mutations.forEach(_this.handleMutation);
      }
    });
  }

  _createClass(InertSubtree, [{
    key: 'disengage',
    value: function disengage() {
      if (!this._context) {
        return;
      }

      undoElementInert(this._context);
      this._inertElementCache.forEach(function (element) {
        return undoElementInert(element);
      });

      this._inertElementCache = null;
      this._filter = null;
      this._context = null;
      this.shadowObserver && this.shadowObserver.disengage();
      this.shadowObserver = null;
    }
  }, {
    key: 'listQueryFocusable',
    value: function listQueryFocusable(list) {
      return list
      // find all focusable elements within the given contexts
      .map(function (element) {
        return (0, _focusable2.default)({ context: element, includeContext: true, strategy: 'all' });
      })
      // flatten nested arrays
      .reduce(function (previous, current) {
        return previous.concat(current);
      }, []);
    }
  }, {
    key: 'renderInert',
    value: function renderInert(elements) {
      var _this2 = this;

      var makeInert = function makeInert(element) {
        _this2._inertElementCache.push(element);
        makeElementInert(element);
      };

      elements.filter(this.filterElements).filter(this.filterParentElements)
      // ignore elements that already are disabled
      // so we don't enable them on disengage()
      .filter(function (element) {
        return !(0, _disabled2.default)(element);
      }).forEach(makeInert);
    }
  }, {
    key: 'filterElements',
    value: function filterElements(element) {
      // ignore elements within the exempted sub-trees
      var isParentOfElement = (0, _comparePosition.getParentComparator)({ element: element, includeSelf: true });
      return !this._filter.some(isParentOfElement);
    }
  }, {
    key: 'filterParentElements',
    value: function filterParentElements(element) {
      // ignore ancestors of the exempted sub-trees
      var isParentOfElement = (0, _comparePosition.getParentComparator)({ parent: element });
      return !this._filter.some(isParentOfElement);
    }
  }, {
    key: 'handleMutation',
    value: function handleMutation(mutation) {
      if (mutation.type === 'childList') {
        var addedElements = (0, _nodeArray2.default)(mutation.addedNodes).filter(function (element) {
          return element.nodeType === Node.ELEMENT_NODE;
        });
        if (!addedElements.length) {
          return;
        }

        var addedFocusableElements = this.listQueryFocusable(addedElements);
        this.renderInert(addedFocusableElements);
      } else if (mutation.type === 'attributes') {
        this.renderInert([mutation.target]);
      }
    }
  }]);

  return InertSubtree;
}();

module.exports = exports['default'];
//# sourceMappingURL=disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/maintain/tab-focus.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/maintain/tab-focus.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context;

  if (!context) {
    context = document.documentElement;
  }

  // Make sure the supports tests are run before intercepting the Tab key,
  // or IE10 and IE11 will fail to process the first Tab key event. Not
  // limiting this warm-up to IE because it may be a problem elsewhere, too.
  (0, _tabsequence2.default)();

  return (0, _key2.default)({
    // Safari on OSX may require ALT+TAB to reach links,
    // see https://github.com/medialize/ally.js/issues/146
    '?alt+?shift+tab': function altShiftTab(event) {
      // we're completely taking over the Tab key handling
      event.preventDefault();

      var sequence = (0, _tabsequence2.default)({
        context: context
      });

      var backward = event.shiftKey;
      var first = sequence[0];
      var last = sequence[sequence.length - 1];

      // wrap around first to last, last to first
      var source = backward ? first : last;
      var target = backward ? last : first;
      if ((0, _activeElement2.default)(source)) {
        target.focus();
        return;
      }

      // find current position in tabsequence
      var currentIndex = void 0;
      var found = sequence.some(function (element, index) {
        if (!(0, _activeElement2.default)(element)) {
          return false;
        }

        currentIndex = index;
        return true;
      });

      if (!found) {
        // redirect to first as we're not in our tabsequence
        first.focus();
        return;
      }

      // shift focus to previous/next element in the sequence
      var offset = backward ? -1 : 1;
      sequence[currentIndex + offset].focus();
    }
  });
};

var _activeElement = __webpack_require__(/*! ../is/active-element */ "./node_modules/ally.js/is/active-element.js");

var _activeElement2 = _interopRequireDefault(_activeElement);

var _tabsequence = __webpack_require__(/*! ../query/tabsequence */ "./node_modules/ally.js/query/tabsequence.js");

var _tabsequence2 = _interopRequireDefault(_tabsequence);

var _key = __webpack_require__(/*! ../when/key */ "./node_modules/ally.js/when/key.js");

var _key2 = _interopRequireDefault(_key);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=tab-focus.js.map

/***/ }),

/***/ "./node_modules/ally.js/map/keycode.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/map/keycode.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// codes mostly cloned from https://github.com/keithamus/jwerty/blob/master/jwerty.js
// deliberately not exposing characters like <,.-#* because they vary *wildly*
// across keyboard layouts and may cause various problems
// (e.g. "*" is "Shift +" on a German Mac keyboard)
// (e.g. "@" is "Alt L" on a German Mac keyboard)

var keycode = {
  // Element Focus
  tab: 9,

  // Navigation
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  pageUp: 33,
  'page-up': 33,
  pageDown: 34,
  'page-down': 34,
  end: 35,
  home: 36,

  // Action
  enter: 13,
  escape: 27,
  space: 32,

  // Modifier
  shift: 16,
  capsLock: 20,
  'caps-lock': 20,
  ctrl: 17,
  alt: 18,
  meta: 91,
  // in firefox: 224
  // on mac (chrome): meta-left=91, meta-right=93
  // on win (IE11): meta-left=91, meta-right=92
  pause: 19,

  // Content Manipulation
  insert: 45,
  'delete': 46,
  backspace: 8,

  // the same logical key may be identified through different keyCodes
  _alias: {
    91: [92, 93, 224]
  }
};

// Function keys (112 - 137)
// NOTE: not every keyboard knows F13+
for (var n = 1; n < 26; n++) {
  keycode['f' + n] = n + 111;
}

// Number keys (48-57, numpad 96-105)
// NOTE: not every keyboard knows num-0+
for (var _n = 0; _n < 10; _n++) {
  var code = _n + 48;
  var numCode = _n + 96;
  keycode[_n] = code;
  keycode['num-' + _n] = numCode;
  keycode._alias[code] = [numCode];
}

// Latin characters (65 - 90)
for (var _n2 = 0; _n2 < 26; _n2++) {
  var _code = _n2 + 65;
  var name = String.fromCharCode(_code).toLowerCase();
  keycode[name] = _code;
}

exports.default = keycode;
module.exports = exports['default'];
//# sourceMappingURL=keycode.js.map

/***/ }),

/***/ "./node_modules/ally.js/observe/shadow-mutations.js":
/*!**********************************************************!*\
  !*** ./node_modules/ally.js/observe/shadow-mutations.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref2.context,
      callback = _ref2.callback,
      config = _ref2.config;

  if (typeof callback !== 'function') {
    throw new TypeError('observe/shadow-mutations requires options.callback to be a function');
  }

  if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) !== 'object') {
    throw new TypeError('observe/shadow-mutations requires options.config to be an object');
  }

  if (!window.MutationObserver) {
    // not supporting IE10 via Mutation Events, because they're too expensive
    // https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Mutation_events
    return {
      disengage: function disengage() {}
    };
  }

  var element = (0, _contextToElement2.default)({
    label: 'observe/shadow-mutations',
    resolveDocument: true,
    defaultToDocument: true,
    context: context
  });

  var service = new ShadowMutationObserver({
    context: element,
    callback: callback,
    config: config
  });

  return {
    disengage: service.disengage
  };
};

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _shadowHosts = __webpack_require__(/*! ../query/shadow-hosts */ "./node_modules/ally.js/query/shadow-hosts.js");

var _shadowHosts2 = _interopRequireDefault(_shadowHosts);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var shadowObserverConfig = {
  childList: true,
  subtree: true
};

var ShadowMutationObserver = function () {
  function ShadowMutationObserver() {
    var _this = this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        context = _ref.context,
        callback = _ref.callback,
        config = _ref.config;

    _classCallCheck(this, ShadowMutationObserver);

    this.config = config;

    this.disengage = this.disengage.bind(this);

    this.clientObserver = new MutationObserver(callback);
    this.hostObserver = new MutationObserver(function (mutations) {
      return mutations.forEach(_this.handleHostMutation, _this);
    });

    this.observeContext(context);
    this.observeShadowHosts(context);
  }

  _createClass(ShadowMutationObserver, [{
    key: 'disengage',
    value: function disengage() {
      this.clientObserver && this.clientObserver.disconnect();
      this.clientObserver = null;
      this.hostObserver && this.hostObserver.disconnect();
      this.hostObserver = null;
    }
  }, {
    key: 'observeShadowHosts',
    value: function observeShadowHosts(context) {
      var _this2 = this;

      var hosts = (0, _shadowHosts2.default)({
        context: context
      });

      hosts.forEach(function (element) {
        return _this2.observeContext(element.shadowRoot);
      });
    }
  }, {
    key: 'observeContext',
    value: function observeContext(context) {
      this.clientObserver.observe(context, this.config);
      this.hostObserver.observe(context, shadowObserverConfig);
    }
  }, {
    key: 'handleHostMutation',
    value: function handleHostMutation(mutation) {
      if (mutation.type !== 'childList') {
        return;
      }

      var addedElements = (0, _nodeArray2.default)(mutation.addedNodes).filter(function (element) {
        return element.nodeType === Node.ELEMENT_NODE;
      });
      addedElements.forEach(this.observeShadowHosts, this);
    }
  }]);

  return ShadowMutationObserver;
}();

module.exports = exports['default'];
//# sourceMappingURL=shadow-mutations.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/focusable.js":
/*!*************************************************!*\
  !*** ./node_modules/ally.js/query/focusable.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable,
      _ref$strategy = _ref.strategy,
      strategy = _ref$strategy === undefined ? 'quick' : _ref$strategy;

  var element = (0, _contextToElement2.default)({
    label: 'query/focusable',
    resolveDocument: true,
    defaultToDocument: true,
    context: context
  });

  var options = {
    context: element,
    includeContext: includeContext,
    includeOnlyTabbable: includeOnlyTabbable,
    strategy: strategy
  };

  if (strategy === 'quick') {
    return (0, _focusable4.default)(options);
  } else if (strategy === 'strict' || strategy === 'all') {
    return (0, _focusable2.default)(options);
  }

  throw new TypeError('query/focusable requires option.strategy to be one of ["quick", "strict", "all"]');
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _focusable = __webpack_require__(/*! ./focusable.strict */ "./node_modules/ally.js/query/focusable.strict.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _focusable3 = __webpack_require__(/*! ./focusable.quick */ "./node_modules/ally.js/query/focusable.quick.js");

var _focusable4 = _interopRequireDefault(_focusable3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://www.w3.org/TR/html5/editing.html#focusable
// https://www.w3.org/WAI/PF/aria-practices/#keyboard

module.exports = exports['default'];
//# sourceMappingURL=focusable.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/focusable.quick.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/query/focusable.quick.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = queryFocusableQuick;

var _focusable = __webpack_require__(/*! ../selector/focusable */ "./node_modules/ally.js/selector/focusable.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _focusable3 = __webpack_require__(/*! ../is/focusable */ "./node_modules/ally.js/is/focusable.js");

var _focusable4 = _interopRequireDefault(_focusable3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://www.w3.org/TR/html5/editing.html#focusable
// https://www.w3.org/WAI/PF/aria-practices/#keyboard

function queryFocusableQuick() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable;

  var _selector = (0, _focusable2.default)();
  var elements = context.querySelectorAll(_selector);
  // the selector potentially matches more than really is focusable

  var _isFocusable = _focusable4.default.rules.except({
    onlyTabbable: includeOnlyTabbable
  });

  var result = [].filter.call(elements, _isFocusable);

  // add context if requested and focusable
  if (includeContext && _isFocusable(context)) {
    result.unshift(context);
  }

  return result;
}
module.exports = exports['default'];
//# sourceMappingURL=focusable.quick.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/focusable.strict.js":
/*!********************************************************!*\
  !*** ./node_modules/ally.js/query/focusable.strict.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = queryFocusableStrict;

var _focusable = __webpack_require__(/*! ../is/focusable */ "./node_modules/ally.js/is/focusable.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _focusRelevant = __webpack_require__(/*! ../is/focus-relevant */ "./node_modules/ally.js/is/focus-relevant.js");

var _focusRelevant2 = _interopRequireDefault(_focusRelevant);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createFilter(condition) {
  // see https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter
  var filter = function filter(node) {
    if (node.shadowRoot) {
      // return ShadowRoot elements regardless of them being focusable,
      // so they can be walked recursively later
      return NodeFilter.FILTER_ACCEPT;
    }

    if (condition(node)) {
      // finds elements that could have been found by document.querySelectorAll()
      return NodeFilter.FILTER_ACCEPT;
    }

    return NodeFilter.FILTER_SKIP;
  };
  // IE requires a function, Browsers require {acceptNode: function}
  // see http://www.bennadel.com/blog/2607-finding-html-comment-nodes-in-the-dom-using-treewalker.htm
  filter.acceptNode = filter;
  return filter;
}
// https://www.w3.org/TR/html5/editing.html#focusable
// https://www.w3.org/WAI/PF/aria-practices/#keyboard

var PossiblyFocusableFilter = createFilter(_focusRelevant2.default);

function queryFocusableStrict() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable,
      strategy = _ref.strategy;

  if (!context) {
    context = document.documentElement;
  }

  var _isFocusable = _focusable2.default.rules.except({
    onlyTabbable: includeOnlyTabbable
  });

  var _document = (0, _getDocument2.default)(context);
  // see https://developer.mozilla.org/en-US/docs/Web/API/Document/createTreeWalker
  var walker = _document.createTreeWalker(
  // root element to start search in
  context,
  // element type filter
  NodeFilter.SHOW_ELEMENT,
  // custom NodeFilter filter
  strategy === 'all' ? PossiblyFocusableFilter : createFilter(_isFocusable),
  // deprecated, but IE requires it
  false);

  var list = [];

  while (walker.nextNode()) {
    if (walker.currentNode.shadowRoot) {
      if (_isFocusable(walker.currentNode)) {
        list.push(walker.currentNode);
      }

      list = list.concat(queryFocusableStrict({
        context: walker.currentNode.shadowRoot,
        includeOnlyTabbable: includeOnlyTabbable,
        strategy: strategy
      }));
    } else {
      list.push(walker.currentNode);
    }
  }

  // add context if requested and focusable
  if (includeContext) {
    if (strategy === 'all') {
      if ((0, _focusRelevant2.default)(context)) {
        list.unshift(context);
      }
    } else if (_isFocusable(context)) {
      list.unshift(context);
    }
  }

  return list;
}
module.exports = exports['default'];
//# sourceMappingURL=focusable.strict.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/shadow-hosts.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/query/shadow-hosts.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = queryShadowHosts;

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// see https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter
var filter = function filter(node) {
  if (node.shadowRoot) {
    return NodeFilter.FILTER_ACCEPT;
  }

  return NodeFilter.FILTER_SKIP;
};
// IE requires a function, Browsers require {acceptNode: function}
// see http://www.bennadel.com/blog/2607-finding-html-comment-nodes-in-the-dom-using-treewalker.htm
filter.acceptNode = filter;

function queryShadowHosts() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context;

  var element = (0, _contextToElement2.default)({
    label: 'query/shadow-hosts',
    resolveDocument: true,
    defaultToDocument: true,
    context: context
  });

  var _document = (0, _getDocument2.default)(context);
  // see https://developer.mozilla.org/en-US/docs/Web/API/Document/createTreeWalker
  var walker = _document.createTreeWalker(
  // root element to start search in
  element,
  // element type filter
  NodeFilter.SHOW_ELEMENT,
  // custom NodeFilter filter
  filter,
  // deprecated, but IE requires it
  false);

  var list = [];

  if (element.shadowRoot) {
    // TreeWalker does not run the filter on the context element
    list.push(element);
    list = list.concat(queryShadowHosts({
      context: element.shadowRoot
    }));
  }

  while (walker.nextNode()) {
    list.push(walker.currentNode);
    list = list.concat(queryShadowHosts({
      context: walker.currentNode.shadowRoot
    }));
  }

  return list;
}
module.exports = exports['default'];
//# sourceMappingURL=shadow-hosts.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabbable.js":
/*!************************************************!*\
  !*** ./node_modules/ally.js/query/tabbable.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable,
      strategy = _ref.strategy;

  var _isTabbable = _tabbable2.default.rules.except({
    onlyTabbable: includeOnlyTabbable
  });

  return (0, _focusable2.default)({
    context: context,
    includeContext: includeContext,
    includeOnlyTabbable: includeOnlyTabbable,
    strategy: strategy
  }).filter(_isTabbable);
};

var _focusable = __webpack_require__(/*! ./focusable */ "./node_modules/ally.js/query/focusable.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _tabbable = __webpack_require__(/*! ../is/tabbable */ "./node_modules/ally.js/is/tabbable.js");

var _tabbable2 = _interopRequireDefault(_tabbable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
// https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
// https://www.w3.org/WAI/PF/aria-practices/#keyboard
//# sourceMappingURL=tabbable.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabsequence.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/query/tabsequence.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable,
      strategy = _ref.strategy;

  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var _context = (0, _nodeArray2.default)(context)[0] || document.documentElement;
  var elements = (0, _tabbable2.default)({
    context: _context,
    includeContext: includeContext,
    includeOnlyTabbable: includeOnlyTabbable,
    strategy: strategy
  });

  if (document.body.createShadowRoot && _platform2.default.is.BLINK) {
    // sort tabindex localized to shadow dom
    // see https://github.com/medialize/ally.js/issues/6
    elements = (0, _tabsequence4.default)(elements, _context, sortElements);
  } else {
    elements = sortElements(elements, _context);
  }

  if (includeContext) {
    // if we include the context itself, it has to be the first
    // element of the sequence
    elements = moveContextToBeginning(elements, _context);
  }

  return elements;
};

var _tabbable = __webpack_require__(/*! ./tabbable */ "./node_modules/ally.js/query/tabbable.js");

var _tabbable2 = _interopRequireDefault(_tabbable);

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

var _tabsequence = __webpack_require__(/*! ./tabsequence.sort-area */ "./node_modules/ally.js/query/tabsequence.sort-area.js");

var _tabsequence2 = _interopRequireDefault(_tabsequence);

var _tabsequence3 = __webpack_require__(/*! ./tabsequence.sort-shadowed */ "./node_modules/ally.js/query/tabsequence.sort-shadowed.js");

var _tabsequence4 = _interopRequireDefault(_tabsequence3);

var _tabsequence5 = __webpack_require__(/*! ./tabsequence.sort-tabindex */ "./node_modules/ally.js/query/tabsequence.sort-tabindex.js");

var _tabsequence6 = _interopRequireDefault(_tabsequence5);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;
// https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
// https://www.w3.org/WAI/PF/aria-practices/#keyboard

function moveContextToBeginning(elements, context) {
  var pos = elements.indexOf(context);
  if (pos > 0) {
    var tmp = elements.splice(pos, 1);
    return tmp.concat(elements);
  }

  return elements;
}

function sortElements(elements, _context) {
  if (supports.tabsequenceAreaAtImgPosition) {
    // Some browsers sort <area> in DOM order, some place the <area>s
    // where the <img> referecing them would've been in DOM order.
    // https://github.com/medialize/ally.js/issues/5
    elements = (0, _tabsequence2.default)(elements, _context);
  }

  elements = (0, _tabsequence6.default)(elements);
  return elements;
}

module.exports = exports['default'];
//# sourceMappingURL=tabsequence.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabsequence.sort-area.js":
/*!*************************************************************!*\
  !*** ./node_modules/ally.js/query/tabsequence.sort-area.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
// move <area> elements to the location of the <img> elements that reference them

exports.default = function (elements, context) {
  // images - unless they are focusable themselves, likely not
  // part of the elements list, so we'll have to find them and
  // sort them into the elements list manually
  var usemaps = context.querySelectorAll('img[usemap]');
  var maps = new Maps(context);

  // remove all <area> elements from the elements list,
  // but put them the map for later retrieval
  var _elements = maps.extractAreasFromList(elements);

  if (!usemaps.length) {
    // the context does not contain any <area>s so no need
    // to replace anything, just remove any maps
    return _elements;
  }

  return (0, _mergeDomOrder2.default)({
    list: _elements,
    elements: usemaps,
    resolveElement: function resolveElement(image) {
      var name = image.getAttribute('usemap').slice(1);
      return maps.getAreasFor(name);
    }
  });
};

var _tabbable = __webpack_require__(/*! ./tabbable */ "./node_modules/ally.js/query/tabbable.js");

var _tabbable2 = _interopRequireDefault(_tabbable);

var _mergeDomOrder = __webpack_require__(/*! ../util/merge-dom-order */ "./node_modules/ally.js/util/merge-dom-order.js");

var _mergeDomOrder2 = _interopRequireDefault(_mergeDomOrder);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

var _imageMap = __webpack_require__(/*! ../util/image-map */ "./node_modules/ally.js/util/image-map.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Maps = function () {
  function Maps(context) {
    _classCallCheck(this, Maps);

    this._document = (0, _getDocument2.default)(context);
    this.maps = {};
  }

  _createClass(Maps, [{
    key: 'getAreasFor',
    value: function getAreasFor(name) {
      if (!this.maps[name]) {
        // the map is not defined within the context, so we
        // have to go find it elsewhere in the document
        this.addMapByName(name);
      }

      return this.maps[name];
    }
  }, {
    key: 'addMapByName',
    value: function addMapByName(name) {
      var map = (0, _imageMap.getMapByName)(name, this._document);
      if (!map) {
        // if there is no map, the img[usemap] wasn't doing anything anyway
        return;
      }

      this.maps[map.name] = (0, _tabbable2.default)({ context: map });
    }
  }, {
    key: 'extractAreasFromList',
    value: function extractAreasFromList(elements) {
      // remove all <area> elements from the elements list,
      // but put them the map for later retrieval
      return elements.filter(function (element) {
        var nodeName = element.nodeName.toLowerCase();
        if (nodeName !== 'area') {
          return true;
        }

        var map = element.parentNode;
        if (!this.maps[map.name]) {
          this.maps[map.name] = [];
        }

        this.maps[map.name].push(element);
        return false;
      }, this);
    }
  }]);

  return Maps;
}();

module.exports = exports['default'];
//# sourceMappingURL=tabsequence.sort-area.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabsequence.sort-shadowed.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/query/tabsequence.sort-shadowed.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = function (elements, context, sortElements) {
  var shadows = new Shadows(context, sortElements);
  var _elements = shadows.extractElements(elements);

  if (_elements.length === elements.length) {
    // no shadowed content found, no need to continue
    return sortElements(elements);
  }

  return shadows.sort(_elements);
};

var _shadowHost = __webpack_require__(/*! ../get/shadow-host */ "./node_modules/ally.js/get/shadow-host.js");

var _shadowHost2 = _interopRequireDefault(_shadowHost);

var _mergeDomOrder = __webpack_require__(/*! ../util/merge-dom-order */ "./node_modules/ally.js/util/merge-dom-order.js");

var _mergeDomOrder2 = _interopRequireDefault(_mergeDomOrder);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Shadows = function () {
  function Shadows(context, sortElements) {
    _classCallCheck(this, Shadows);

    // document context we're working with
    this.context = context;
    // callback that sorts an array of elements
    this.sortElements = sortElements;
    // reference to create unique IDs for each ShadowHost
    this.hostCounter = 1;
    // reference map for child-ShadowHosts of a ShadowHost
    this.inHost = {};
    // reference map for child-ShadowHost of the document
    this.inDocument = [];
    // reference map for ShadowHosts
    this.hosts = {};
    // reference map for tabbable elements of a ShadowHost
    this.elements = {};
  }

  // remember which hosts we have to sort within later


  _createClass(Shadows, [{
    key: '_registerHost',
    value: function _registerHost(host) {
      if (host._sortingId) {
        return;
      }

      // make the ShadowHost identifiable (see cleanup() for undo)
      host._sortingId = 'shadow-' + this.hostCounter++;
      this.hosts[host._sortingId] = host;

      // hosts may contain other hosts
      var parentHost = (0, _shadowHost2.default)({ context: host });
      if (parentHost) {
        this._registerHost(parentHost);
        this._registerHostParent(host, parentHost);
      } else {
        this.inDocument.push(host);
      }
    }

    // remember which host is the child of which other host

  }, {
    key: '_registerHostParent',
    value: function _registerHostParent(host, parent) {
      if (!this.inHost[parent._sortingId]) {
        this.inHost[parent._sortingId] = [];
      }

      this.inHost[parent._sortingId].push(host);
    }

    // remember which elements a host contains

  }, {
    key: '_registerElement',
    value: function _registerElement(element, host) {
      if (!this.elements[host._sortingId]) {
        this.elements[host._sortingId] = [];
      }

      this.elements[host._sortingId].push(element);
    }

    // remove shadowed elements from the sequence and register
    // the ShadowHosts they belong to so we know what to sort
    // later on

  }, {
    key: 'extractElements',
    value: function extractElements(elements) {
      return elements.filter(function (element) {
        var host = (0, _shadowHost2.default)({ context: element });
        if (!host) {
          return true;
        }

        this._registerHost(host);
        this._registerElement(element, host);
        return false;
      }, this);
    }

    // inject hosts into the sequence, sort everything,
    // and recoursively replace hosts by its descendants

  }, {
    key: 'sort',
    value: function sort(elements) {
      var _elements = this._injectHosts(elements);
      _elements = this._replaceHosts(_elements);
      this._cleanup();
      return _elements;
    }

    // merge ShadowHosts into the element lists of other ShadowHosts
    // or the document, then sort the individual lists

  }, {
    key: '_injectHosts',
    value: function _injectHosts(elements) {
      Object.keys(this.hosts).forEach(function (_sortingId) {
        var _list = this.elements[_sortingId];
        var _elements = this.inHost[_sortingId];
        var _context = this.hosts[_sortingId].shadowRoot;
        this.elements[_sortingId] = this._merge(_list, _elements, _context);
      }, this);

      return this._merge(elements, this.inDocument, this.context);
    }
  }, {
    key: '_merge',
    value: function _merge(list, elements, context) {
      var merged = (0, _mergeDomOrder2.default)({
        list: list,
        elements: elements
      });

      return this.sortElements(merged, context);
    }
  }, {
    key: '_replaceHosts',
    value: function _replaceHosts(elements) {
      return (0, _mergeDomOrder2.default)({
        list: elements,
        elements: this.inDocument,
        resolveElement: this._resolveHostElement.bind(this)
      });
    }
  }, {
    key: '_resolveHostElement',
    value: function _resolveHostElement(host) {
      var merged = (0, _mergeDomOrder2.default)({
        list: this.elements[host._sortingId],
        elements: this.inHost[host._sortingId],
        resolveElement: this._resolveHostElement.bind(this)
      });

      var _tabindex = (0, _tabindexValue2.default)(host);
      if (_tabindex !== null && _tabindex > -1) {
        return [host].concat(merged);
      }

      return merged;
    }
  }, {
    key: '_cleanup',
    value: function _cleanup() {
      // remove those identifers we put on the ShadowHost to avoid using Map()
      Object.keys(this.hosts).forEach(function (key) {
        delete this.hosts[key]._sortingId;
      }, this);
    }
  }]);

  return Shadows;
}();

module.exports = exports['default'];
//# sourceMappingURL=tabsequence.sort-shadowed.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabsequence.sort-tabindex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/query/tabsequence.sort-tabindex.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (elements) {
  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement.tabIndex
  // elements with tabIndex "0" (including tabbableElements without tabIndex) should be navigated in the order they appear.
  // elements with a positive tabIndex:
  //   Elements that have identical tabIndexes should be navigated in the order they appear.
  //   Navigation proceeds from the lowest tabIndex to the highest tabIndex.

  // NOTE: sort implementation may be unstable and thus mess up DOM order,
  // that's why we build a map that's being sorted instead. If we were able to rely
  // on a stable sorting algorithm, sortTabindex() could be as simple as
  // elements.sort(function(a, b) { return a.tabIndex - b.tabIndex; });
  // at this time Chrome does not use a stable sorting algorithm
  // see http://blog.rodneyrehm.de/archives/14-Sorting-Were-Doing-It-Wrong.html#stability

  // NOTE: compareDocumentPosition seemed like more overhead than just sorting this with buckets
  // https://developer.mozilla.org/en-US/docs/Web/API/Node.compareDocumentPosition

  var map = {};
  var indexes = [];
  var normal = elements.filter(function (element) {
    // in Trident and Gecko SVGElement does not know about the tabIndex property
    var tabIndex = element.tabIndex;
    if (tabIndex === undefined) {
      tabIndex = (0, _tabindexValue2.default)(element);
    }

    // extract elements that don't need sorting
    if (tabIndex <= 0 || tabIndex === null || tabIndex === undefined) {
      return true;
    }

    if (!map[tabIndex]) {
      // create sortable bucket for dom-order-preservation of elements with the same tabIndex
      map[tabIndex] = [];
      // maintain a list of unique tabIndexes
      indexes.push(tabIndex);
    }

    // sort element into the proper bucket
    map[tabIndex].push(element);
    // element moved to sorting map, so not "normal" anymore
    return false;
  });

  // sort the tabindex ascending,
  // then resolve them to their appropriate buckets,
  // then flatten the array of arrays to an array
  var _elements = indexes.sort().map(function (tabIndex) {
    return map[tabIndex];
  }).reduceRight(function (previous, current) {
    return current.concat(previous);
  }, normal);

  return _elements;
};

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=tabsequence.sort-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/selector/focusable.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/selector/focusable.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  if (typeof selector === 'string') {
    return selector;
  }

  // https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
  selector = ''
  // IE11 supports.can focus <table> and <td>
  + (supports.focusTable ? 'table, td,' : '')
  // IE11 supports.can focus <fieldset>
  + (supports.focusFieldset ? 'fieldset,' : '')
  // Namespace problems of [xlink:href] explained in https://stackoverflow.com/a/23047888/515124
  // svg a[*|href] does not match in IE9, but since we're filtering
  // through is/focusable we can include all <a> from SVG
  + 'svg a,'
  // may behave as 'svg, svg *,' in chrome as *every* svg element with a focus event listener is focusable
  // navigational elements
  + 'a[href],'
  // validity determined by is/valid-area.js
  + 'area[href],'
  // validity determined by is/disabled.js
  + 'input, select, textarea, button,'
  // browsing context containers
  + 'iframe, object, embed,'
  // interactive content
  + 'keygen,' + (supports.focusAudioWithoutControls ? 'audio,' : 'audio[controls],') + (supports.focusVideoWithoutControls ? 'video,' : 'video[controls],') + (supports.focusSummary ? 'summary,' : '')
  // validity determined by is/valid-tabindex.js
  + '[tabindex],'
  // editing hosts
  + '[contenteditable]';

  // where ShadowDOM is supported, we also want the shadowed focusable elements (via ">>>" or "/deep/")
  selector = (0, _selectInShadows2.default)(selector);

  return selector;
};

var _selectInShadows = __webpack_require__(/*! ../util/select-in-shadows */ "./node_modules/ally.js/util/select-in-shadows.js");

var _selectInShadows2 = _interopRequireDefault(_selectInShadows);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: this selector MUST *never* be used directly,
// always go through query/focusable or is/focusable.js
// there are too many edge cases that they could be covered in
// a simple CSS selector

var supports = void 0;

var selector = void 0;

module.exports = exports['default'];
//# sourceMappingURL=focusable.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/css-shadow-piercing-deep-combinator.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ally.js/supports/css-shadow-piercing-deep-combinator.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var combinator = void 0;

  // see https://dev.w3.org/csswg/css-scoping-1/#deep-combinator
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1117572
  // https://code.google.com/p/chromium/issues/detail?id=446051
  try {
    document.querySelector('html >>> :first-child');
    combinator = '>>>';
  } catch (noArrowArrowArrow) {
    try {
      // old syntax supported at least up to Chrome 41
      // https://code.google.com/p/chromium/issues/detail?id=446051
      document.querySelector('html /deep/ :first-child');
      combinator = '/deep/';
    } catch (noDeep) {
      combinator = '';
    }
  }

  return combinator;
};

module.exports = exports['default'];
//# sourceMappingURL=css-shadow-piercing-deep-combinator.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/detect-focus.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/supports/detect-focus.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (tests) {
  var data = before();

  var results = {};
  Object.keys(tests).map(function (key) {
    results[key] = test(data, tests[key]);
  });

  after(data);
  return results;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function before() {
  var data = {
    // remember what had focus to restore after test
    activeElement: document.activeElement,
    // remember scroll positions to restore after test
    windowScrollTop: window.scrollTop,
    windowScrollLeft: window.scrollLeft,
    bodyScrollTop: document.body.scrollTop,
    bodyScrollLeft: document.body.scrollLeft
  };

  // wrap tests in an element hidden from screen readers to prevent them
  // from announcing focus, which can be quite irritating to the user
  var iframe = document.createElement('iframe');
  iframe.setAttribute('style', 'position:absolute; position:fixed; top:0; left:-2px; width:1px; height:1px; overflow:hidden;');
  iframe.setAttribute('aria-live', 'off');
  iframe.setAttribute('aria-busy', 'true');
  iframe.setAttribute('aria-hidden', 'true');
  document.body.appendChild(iframe);

  var _window = iframe.contentWindow;
  var _document = _window.document;

  _document.open();
  _document.close();
  var wrapper = _document.createElement('div');
  _document.body.appendChild(wrapper);

  data.iframe = iframe;
  data.wrapper = wrapper;
  data.window = _window;
  data.document = _document;

  return data;
}

// options.element:
//  {string} element name
//  {function} callback(wrapper, document) to generate an element
// options.mutate: (optional)
//  {function} callback(element, wrapper, document) to manipulate element prior to focus-test.
//             Can return DOMElement to define focus target (default: element)
// options.validate: (optional)
//  {function} callback(element, focusTarget, document) to manipulate test-result
function test(data, options) {
  // make sure we operate on a clean slate
  data.wrapper.innerHTML = '';
  // create dummy element to test focusability of
  var element = typeof options.element === 'string' ? data.document.createElement(options.element) : options.element(data.wrapper, data.document);
  // allow callback to further specify dummy element
  // and optionally define element to focus
  var focus = options.mutate && options.mutate(element, data.wrapper, data.document);
  if (!focus && focus !== false) {
    focus = element;
  }
  // element needs to be part of the DOM to be focusable
  !element.parentNode && data.wrapper.appendChild(element);
  // test if the element with invalid tabindex can be focused
  focus && focus.focus && focus.focus();
  // validate test's result
  return options.validate ? options.validate(element, focus, data.document) : data.document.activeElement === focus;
}

function after(data) {
  // restore focus to what it was before test and cleanup
  if (data.activeElement === document.body) {
    document.activeElement && document.activeElement.blur && document.activeElement.blur();
    if (_platform2.default.is.IE10) {
      // IE10 does not redirect focus to <body> when the activeElement is removed
      document.body.focus();
    }
  } else {
    data.activeElement && data.activeElement.focus && data.activeElement.focus();
  }

  document.body.removeChild(data.iframe);

  // restore scroll position
  window.scrollTop = data.windowScrollTop;
  window.scrollLeft = data.windowScrollLeft;
  document.body.scrollTop = data.bodyScrollTop;
  document.body.scrollLeft = data.bodyScrollLeft;
}

module.exports = exports['default'];
//# sourceMappingURL=detect-focus.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-area-img-tabindex.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-area-img-tabindex.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="image-map-tabindex-test">' + '<area shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-tabindex-test" tabindex="-1" alt="" src="' + _gif2.default + '">';

    return element.querySelector('area');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-area-img-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-area-tabindex.js":
/*!**************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-area-tabindex.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="image-map-tabindex-test">' + '<area href="#void" tabindex="-1" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-tabindex-test" alt="" src="' + _gif2.default + '">';

    return false;
  },
  validate: function validate(element, focusTarget, _document) {
    if (_platform2.default.is.GECKO) {
      // fixes https://github.com/medialize/ally.js/issues/35
      // Firefox loads the DataURI asynchronously, causing a false-negative
      return true;
    }

    var focus = element.querySelector('area');
    focus.focus();
    return _document.activeElement === focus;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-area-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-area-without-href.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-area-without-href.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="image-map-area-href-test">' + '<area shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-area-href-test" alt="" src="' + _gif2.default + '">';

    return element.querySelector('area');
  },
  validate: function validate(element, focusTarget, _document) {
    if (_platform2.default.is.GECKO) {
      // fixes https://github.com/medialize/ally.js/issues/35
      // Firefox loads the DataURI asynchronously, causing a false-negative
      return true;
    }

    return _document.activeElement === focusTarget;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-area-without-href.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-audio-without-controls.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-audio-without-controls.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mp = __webpack_require__(/*! ./media/mp3 */ "./node_modules/ally.js/supports/media/mp3.js");

var _mp2 = _interopRequireDefault(_mp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'can-focus-audio-without-controls',
  element: 'audio',
  mutate: function mutate(element) {
    try {
      // invalid media file can trigger warning in console, data-uri to prevent HTTP request
      element.setAttribute('src', _mp2.default);
    } catch (e) {
      // IE9 may throw "Error: Not implemented"
    }
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-audio-without-controls.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-broken-image-map.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-broken-image-map.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif.invalid */ "./node_modules/ally.js/supports/media/gif.invalid.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: https://github.com/medialize/ally.js/issues/35
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="broken-image-map-test"><area href="#void" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#broken-image-map-test" alt="" src="' + _gif2.default + '">';

    return element.querySelector('area');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-broken-image-map.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-children-of-focusable-flexbox.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-children-of-focusable-flexbox.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// Children of focusable elements with display:flex are focusable in IE10-11
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', '-1');
    element.setAttribute('style', 'display: -webkit-flex; display: -ms-flexbox; display: flex;');
    element.innerHTML = '<span style="display: block;">hello</span>';
    return element.querySelector('span');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-children-of-focusable-flexbox.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-fieldset-disabled.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-fieldset-disabled.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// fieldset[tabindex=0][disabled] should not be focusable, but Blink and WebKit disagree
// @specification https://www.w3.org/TR/html5/disabled-elements.html#concept-element-disabled
// @browser-issue Chromium https://crbug.com/453847
// @browser-issue WebKit https://bugs.webkit.org/show_bug.cgi?id=141086
exports.default = {
  element: 'fieldset',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', 0);
    element.setAttribute('disabled', 'disabled');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-fieldset-disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-fieldset.js":
/*!*********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-fieldset.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: 'fieldset',
  mutate: function mutate(element) {
    element.innerHTML = '<legend>legend</legend><p>content</p>';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-fieldset.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-flexbox-container.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-flexbox-container.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// elements with display:flex are focusable in IE10-11
exports.default = {
  element: 'span',
  mutate: function mutate(element) {
    element.setAttribute('style', 'display: -webkit-flex; display: -ms-flexbox; display: flex;');
    element.innerHTML = '<span style="display: block;">hello</span>';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-flexbox-container.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-form-disabled.js":
/*!**************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-form-disabled.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// form[tabindex=0][disabled] should be focusable as the
// specification doesn't know the disabled attribute on the form element
// @specification https://www.w3.org/TR/html5/forms.html#the-form-element
exports.default = {
  element: 'form',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', 0);
    element.setAttribute('disabled', 'disabled');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-form-disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-img-ismap.js":
/*!**********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-img-ismap.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: https://github.com/medialize/ally.js/issues/35
// fixes https://github.com/medialize/ally.js/issues/20
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-ismap
exports.default = {
  element: 'a',
  mutate: function mutate(element) {
    element.href = '#void';
    element.innerHTML = '<img ismap src="' + _gif2.default + '" alt="">';
    return element.querySelector('img');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-img-ismap.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-img-usemap-tabindex.js":
/*!********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-img-usemap-tabindex.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: https://github.com/medialize/ally.js/issues/35
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="image-map-tabindex-test"><area href="#void" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-tabindex-test" tabindex="-1" alt="" ' + 'src="' + _gif2.default + '">';

    return element.querySelector('img');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-img-usemap-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-in-hidden-iframe.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-in-hidden-iframe.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: function element(wrapper, _document) {
    var iframe = _document.createElement('iframe');

    // iframe must be part of the DOM before accessing the contentWindow is possible
    wrapper.appendChild(iframe);

    // create the iframe's default document (<html><head></head><body></body></html>)
    var iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.close();
    return iframe;
  },
  mutate: function mutate(iframe) {
    iframe.style.visibility = 'hidden';

    var iframeDocument = iframe.contentWindow.document;
    var input = iframeDocument.createElement('input');
    iframeDocument.body.appendChild(input);
    return input;
  },
  validate: function validate(iframe) {
    var iframeDocument = iframe.contentWindow.document;
    var focus = iframeDocument.querySelector('input');
    return iframeDocument.activeElement === focus;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-in-hidden-iframe.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-in-zero-dimension-object.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-in-zero-dimension-object.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  return result;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var result = !_platform2.default.is.WEBKIT;

module.exports = exports['default'];
//# sourceMappingURL=focus-in-zero-dimension-object.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-invalid-tabindex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-invalid-tabindex.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// Firefox allows *any* value and treats invalid values like tabindex="-1"
// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', 'invalid-value');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-invalid-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-label-tabindex.js":
/*!***************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-label-tabindex.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: 'label',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', '-1');
  },
  validate: function validate(element, focusTarget, _document) {
    // force layout in Chrome 49, otherwise the element won't be focusable
    /* eslint-disable no-unused-vars */
    var variableToPreventDeadCodeElimination = element.offsetHeight;
    /* eslint-enable no-unused-vars */
    element.focus();
    return _document.activeElement === element;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-label-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-object-svg-hidden.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-object-svg-hidden.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./media/svg */ "./node_modules/ally.js/supports/media/svg.js");

var _svg2 = _interopRequireDefault(_svg);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Note: IE10 on BrowserStack does not like this test

exports.default = {
  element: 'object',
  mutate: function mutate(element) {
    element.setAttribute('type', 'image/svg+xml');
    element.setAttribute('data', _svg2.default);
    element.setAttribute('width', '200');
    element.setAttribute('height', '50');
    element.style.visibility = 'hidden';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-object-svg-hidden.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-object-svg.js":
/*!***********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-object-svg.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./media/svg */ "./node_modules/ally.js/supports/media/svg.js");

var _svg2 = _interopRequireDefault(_svg);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Note: IE10 on BrowserStack does not like this test

exports.default = {
  name: 'can-focus-object-svg',
  element: 'object',
  mutate: function mutate(element) {
    element.setAttribute('type', 'image/svg+xml');
    element.setAttribute('data', _svg2.default);
    element.setAttribute('width', '200');
    element.setAttribute('height', '50');
  },
  validate: function validate(element, focusTarget, _document) {
    if (_platform2.default.is.GECKO) {
      // Firefox seems to be handling the object creation asynchronously and thereby produces a false negative test result.
      // Because we know Firefox is able to focus object elements referencing SVGs, we simply cheat by sniffing the user agent string
      return true;
    }

    return _document.activeElement === element;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-object-svg.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-object-swf.js":
/*!***********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-object-swf.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  return result;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Every Environment except IE9 considers SWF objects focusable
var result = !_platform2.default.is.IE9;

module.exports = exports['default'];
//# sourceMappingURL=focus-object-swf.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-redirect-img-usemap.js":
/*!********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-redirect-img-usemap.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="focus-redirect-img-usemap"><area href="#void" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#focus-redirect-img-usemap" alt="" ' + 'src="' + _gif2.default + '">';

    // focus the <img>, not the <div>
    return element.querySelector('img');
  },
  validate: function validate(element, focusTarget, _document) {
    var target = element.querySelector('area');
    return _document.activeElement === target;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-redirect-img-usemap.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-redirect-legend.js":
/*!****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-redirect-legend.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// see https://jsbin.com/nenirisage/edit?html,js,console,output

exports.default = {
  element: 'fieldset',
  mutate: function mutate(element) {
    element.innerHTML = '<legend>legend</legend><input tabindex="-1"><input tabindex="0">';
    // take care of focus in validate();
    return false;
  },
  validate: function validate(element, focusTarget, _document) {
    var focusable = element.querySelector('input[tabindex="-1"]');
    var tabbable = element.querySelector('input[tabindex="0"]');

    // Firefox requires this test to focus the <fieldset> first, while this is not necessary in
    // https://jsbin.com/nenirisage/edit?html,js,console,output
    element.focus();

    element.querySelector('legend').focus();
    return _document.activeElement === focusable && 'focusable' || _document.activeElement === tabbable && 'tabbable' || '';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-redirect-legend.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-scroll-body.js":
/*!************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-scroll-body.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// https://github.com/medialize/ally.js/issues/21
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('style', 'width: 100px; height: 50px; overflow: auto;');
    element.innerHTML = '<div style="width: 500px; height: 40px;">scrollable content</div>';
    return element.querySelector('div');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-scroll-body.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-scroll-container-without-overflow.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-scroll-container-without-overflow.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// https://github.com/medialize/ally.js/issues/21
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('style', 'width: 100px; height: 50px;');
    element.innerHTML = '<div style="width: 500px; height: 40px;">scrollable content</div>';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-scroll-container-without-overflow.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-scroll-container.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-scroll-container.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// https://github.com/medialize/ally.js/issues/21
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('style', 'width: 100px; height: 50px; overflow: auto;');
    element.innerHTML = '<div style="width: 500px; height: 40px;">scrollable content</div>';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-scroll-container.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-summary.js":
/*!********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-summary.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: 'details',
  mutate: function mutate(element) {
    element.innerHTML = '<summary>foo</summary><p>content</p>';
    return element.firstElementChild;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-summary.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-focusable-attribute.js":
/*!************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-focusable-attribute.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('<text focusable="true">a</text>');
    return element.querySelector('text');
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-focusable-attribute.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-foreignobject-tabindex.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-foreignobject-tabindex.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('<foreignObject tabindex="-1"><input type="text" /></foreignObject>');
    // Safari 8's quersSelector() can't identify foreignObject, but getElementyByTagName() can
    return element.querySelector('foreignObject') || element.getElementsByTagName('foreignObject')[0];
  },
  validate: _svg.validate

};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-foreignobject-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-in-iframe.js":
/*!**************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-in-iframe.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  return result;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Firefox seems to be handling the SVG-document-in-iframe creation asynchronously
// and thereby produces a false negative test result. Thus the test is pointless
// and we resort to UA sniffing once again.
// see http://jsbin.com/vunadohoko/1/edit?js,console,output

var result = Boolean(_platform2.default.is.GECKO && typeof SVGElement !== 'undefined' && SVGElement.prototype.focus);

module.exports = exports['default'];
//# sourceMappingURL=focus-svg-in-iframe.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-negative-tabindex-attribute.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-negative-tabindex-attribute.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('<text tabindex="-1">a</text>');
    return element.querySelector('text');
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-negative-tabindex-attribute.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-tabindex-attribute.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-tabindex-attribute.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('<text tabindex="0">a</text>');
    return element.querySelector('text');
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-tabindex-attribute.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-use-tabindex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-use-tabindex.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)(['<g id="ally-test-target"><a xlink:href="#void"><text>link</text></a></g>', '<use xlink:href="#ally-test-target" x="0" y="0" tabindex="-1" />'].join(''));

    return element.querySelector('use');
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-use-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('');
    return element.firstChild;
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-tabindex-trailing-characters.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-tabindex-trailing-characters.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// Firefox allows *any* value and treats invalid values like tabindex="-1"
// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', '3x');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-tabindex-trailing-characters.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-table.js":
/*!******************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-table.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: 'table',
  mutate: function mutate(element, wrapper, _document) {
    // IE9 has a problem replacing TBODY contents with innerHTML.
    // https://stackoverflow.com/a/8097055/515124
    // element.innerHTML = '<tr><td>cell</td></tr>';
    var fragment = _document.createDocumentFragment();
    fragment.innerHTML = '<tr><td>cell</td></tr>';
    element.appendChild(fragment);
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-table.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-video-without-controls.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-video-without-controls.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mp = __webpack_require__(/*! ./media/mp4 */ "./node_modules/ally.js/supports/media/mp4.js");

var _mp2 = _interopRequireDefault(_mp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  element: 'video',
  mutate: function mutate(element) {
    try {
      // invalid media file can trigger warning in console, data-uri to prevent HTTP request
      element.setAttribute('src', _mp2.default);
    } catch (e) {
      // IE9 may throw "Error: Not implemented"
    }
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-video-without-controls.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/helper/svg.js":
/*!*****************************************************!*\
  !*** ./node_modules/ally.js/supports/helper/svg.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generate = generate;
exports.focus = focus;
exports.validate = validate;

var _focus = __webpack_require__(/*! ../../element/focus.svg-foreign-object-hack */ "./node_modules/ally.js/element/focus.svg-foreign-object-hack.js");

var _focus2 = _interopRequireDefault(_focus);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function generate(element) {
  return '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' + element + '</svg>';
}

function focus(element) {
  if (element.focus) {
    return;
  }

  try {
    HTMLElement.prototype.focus.call(element);
  } catch (e) {
    (0, _focus2.default)(element);
  }
}

function validate(element, focusTarget, _document) {
  focus(focusTarget);
  return _document.activeElement === focusTarget;
}
//# sourceMappingURL=svg.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/gif.invalid.js":
/*!************************************************************!*\
  !*** ./node_modules/ally.js/supports/media/gif.invalid.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ';
module.exports = exports['default'];
//# sourceMappingURL=gif.invalid.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/gif.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/media/gif.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
module.exports = exports['default'];
//# sourceMappingURL=gif.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/mp3.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/media/mp3.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _gif2.default;
// export default 'data:audio/mp3;base64,audio-focus-test';

module.exports = exports['default'];
//# sourceMappingURL=mp3.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/mp4.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/media/mp4.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _gif2.default;
// export default 'data:video/mp4;base64,video-focus-test';

module.exports = exports['default'];
//# sourceMappingURL=mp4.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/svg.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/media/svg.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtb' + 'G5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0ic3ZnIj48dGV4dCB4PSIxMCIgeT0iMjAiIGlkPSJ' + 'zdmctbGluay10ZXh0Ij50ZXh0PC90ZXh0Pjwvc3ZnPg==';
module.exports = exports['default'];
//# sourceMappingURL=svg.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/supports-cache.js":
/*!*********************************************************!*\
  !*** ./node_modules/ally.js/supports/supports-cache.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _version = __webpack_require__(/*! ../version */ "./node_modules/ally.js/version.js");

var _version2 = _interopRequireDefault(_version);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function readLocalStorage(key) {
  // allow reading from storage to retrieve previous support results
  // even while the document does not have focus
  var data = void 0;

  try {
    data = window.localStorage && window.localStorage.getItem(key);
    data = data ? JSON.parse(data) : {};
  } catch (e) {
    data = {};
  }

  return data;
} /*
      Facility to cache test results in localStorage.
  
      USAGE:
        cache.get('key');
        cache.set('key', 'value');
   */

function writeLocalStorage(key, value) {
  if (!document.hasFocus()) {
    // if the document does not have focus when tests are executed, focus() may
    // not be handled properly and events may not be dispatched immediately.
    // This can happen when a document is reloaded while Developer Tools have focus.
    try {
      window.localStorage && window.localStorage.removeItem(key);
    } catch (e) {
      // ignore
    }

    return;
  }

  try {
    window.localStorage && window.localStorage.setItem(key, JSON.stringify(value));
  } catch (e) {
    // ignore
  }
}

var userAgent = typeof window !== 'undefined' && window.navigator.userAgent || '';
var cacheKey = 'ally-supports-cache';
var cache = readLocalStorage(cacheKey);

// update the cache if ally or the user agent changed (newer version, etc)
if (cache.userAgent !== userAgent || cache.version !== _version2.default) {
  cache = {};
}

cache.userAgent = userAgent;
cache.version = _version2.default;

exports.default = {
  get: function get() {
    return cache;
  },
  set: function set(values) {
    Object.keys(values).forEach(function (key) {
      cache[key] = values[key];
    });

    cache.time = new Date().toISOString();
    writeLocalStorage(cacheKey, cache);
  }
};
module.exports = exports['default'];
//# sourceMappingURL=supports-cache.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/supports.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/supports/supports.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  if (supportsCache) {
    return supportsCache;
  }

  supportsCache = _supportsCache2.default.get();
  if (!supportsCache.time) {
    _supportsCache2.default.set(executeTests());
    supportsCache = _supportsCache2.default.get();
  }

  return supportsCache;
};

var _detectFocus = __webpack_require__(/*! ./detect-focus */ "./node_modules/ally.js/supports/detect-focus.js");

var _detectFocus2 = _interopRequireDefault(_detectFocus);

var _supportsCache = __webpack_require__(/*! ./supports-cache */ "./node_modules/ally.js/supports/supports-cache.js");

var _supportsCache2 = _interopRequireDefault(_supportsCache);

var _cssShadowPiercingDeepCombinator = __webpack_require__(/*! ./css-shadow-piercing-deep-combinator */ "./node_modules/ally.js/supports/css-shadow-piercing-deep-combinator.js");

var _cssShadowPiercingDeepCombinator2 = _interopRequireDefault(_cssShadowPiercingDeepCombinator);

var _focusAreaImgTabindex = __webpack_require__(/*! ./focus-area-img-tabindex */ "./node_modules/ally.js/supports/focus-area-img-tabindex.js");

var _focusAreaImgTabindex2 = _interopRequireDefault(_focusAreaImgTabindex);

var _focusAreaTabindex = __webpack_require__(/*! ./focus-area-tabindex */ "./node_modules/ally.js/supports/focus-area-tabindex.js");

var _focusAreaTabindex2 = _interopRequireDefault(_focusAreaTabindex);

var _focusAreaWithoutHref = __webpack_require__(/*! ./focus-area-without-href */ "./node_modules/ally.js/supports/focus-area-without-href.js");

var _focusAreaWithoutHref2 = _interopRequireDefault(_focusAreaWithoutHref);

var _focusAudioWithoutControls = __webpack_require__(/*! ./focus-audio-without-controls */ "./node_modules/ally.js/supports/focus-audio-without-controls.js");

var _focusAudioWithoutControls2 = _interopRequireDefault(_focusAudioWithoutControls);

var _focusBrokenImageMap = __webpack_require__(/*! ./focus-broken-image-map */ "./node_modules/ally.js/supports/focus-broken-image-map.js");

var _focusBrokenImageMap2 = _interopRequireDefault(_focusBrokenImageMap);

var _focusChildrenOfFocusableFlexbox = __webpack_require__(/*! ./focus-children-of-focusable-flexbox */ "./node_modules/ally.js/supports/focus-children-of-focusable-flexbox.js");

var _focusChildrenOfFocusableFlexbox2 = _interopRequireDefault(_focusChildrenOfFocusableFlexbox);

var _focusFieldsetDisabled = __webpack_require__(/*! ./focus-fieldset-disabled */ "./node_modules/ally.js/supports/focus-fieldset-disabled.js");

var _focusFieldsetDisabled2 = _interopRequireDefault(_focusFieldsetDisabled);

var _focusFieldset = __webpack_require__(/*! ./focus-fieldset */ "./node_modules/ally.js/supports/focus-fieldset.js");

var _focusFieldset2 = _interopRequireDefault(_focusFieldset);

var _focusFlexboxContainer = __webpack_require__(/*! ./focus-flexbox-container */ "./node_modules/ally.js/supports/focus-flexbox-container.js");

var _focusFlexboxContainer2 = _interopRequireDefault(_focusFlexboxContainer);

var _focusFormDisabled = __webpack_require__(/*! ./focus-form-disabled */ "./node_modules/ally.js/supports/focus-form-disabled.js");

var _focusFormDisabled2 = _interopRequireDefault(_focusFormDisabled);

var _focusImgIsmap = __webpack_require__(/*! ./focus-img-ismap */ "./node_modules/ally.js/supports/focus-img-ismap.js");

var _focusImgIsmap2 = _interopRequireDefault(_focusImgIsmap);

var _focusImgUsemapTabindex = __webpack_require__(/*! ./focus-img-usemap-tabindex */ "./node_modules/ally.js/supports/focus-img-usemap-tabindex.js");

var _focusImgUsemapTabindex2 = _interopRequireDefault(_focusImgUsemapTabindex);

var _focusInHiddenIframe = __webpack_require__(/*! ./focus-in-hidden-iframe */ "./node_modules/ally.js/supports/focus-in-hidden-iframe.js");

var _focusInHiddenIframe2 = _interopRequireDefault(_focusInHiddenIframe);

var _focusInZeroDimensionObject = __webpack_require__(/*! ./focus-in-zero-dimension-object */ "./node_modules/ally.js/supports/focus-in-zero-dimension-object.js");

var _focusInZeroDimensionObject2 = _interopRequireDefault(_focusInZeroDimensionObject);

var _focusInvalidTabindex = __webpack_require__(/*! ./focus-invalid-tabindex */ "./node_modules/ally.js/supports/focus-invalid-tabindex.js");

var _focusInvalidTabindex2 = _interopRequireDefault(_focusInvalidTabindex);

var _focusLabelTabindex = __webpack_require__(/*! ./focus-label-tabindex */ "./node_modules/ally.js/supports/focus-label-tabindex.js");

var _focusLabelTabindex2 = _interopRequireDefault(_focusLabelTabindex);

var _focusObjectSvgHidden = __webpack_require__(/*! ./focus-object-svg-hidden */ "./node_modules/ally.js/supports/focus-object-svg-hidden.js");

var _focusObjectSvgHidden2 = _interopRequireDefault(_focusObjectSvgHidden);

var _focusObjectSvg = __webpack_require__(/*! ./focus-object-svg */ "./node_modules/ally.js/supports/focus-object-svg.js");

var _focusObjectSvg2 = _interopRequireDefault(_focusObjectSvg);

var _focusObjectSwf = __webpack_require__(/*! ./focus-object-swf */ "./node_modules/ally.js/supports/focus-object-swf.js");

var _focusObjectSwf2 = _interopRequireDefault(_focusObjectSwf);

var _focusRedirectImgUsemap = __webpack_require__(/*! ./focus-redirect-img-usemap */ "./node_modules/ally.js/supports/focus-redirect-img-usemap.js");

var _focusRedirectImgUsemap2 = _interopRequireDefault(_focusRedirectImgUsemap);

var _focusRedirectLegend = __webpack_require__(/*! ./focus-redirect-legend */ "./node_modules/ally.js/supports/focus-redirect-legend.js");

var _focusRedirectLegend2 = _interopRequireDefault(_focusRedirectLegend);

var _focusScrollBody = __webpack_require__(/*! ./focus-scroll-body */ "./node_modules/ally.js/supports/focus-scroll-body.js");

var _focusScrollBody2 = _interopRequireDefault(_focusScrollBody);

var _focusScrollContainerWithoutOverflow = __webpack_require__(/*! ./focus-scroll-container-without-overflow */ "./node_modules/ally.js/supports/focus-scroll-container-without-overflow.js");

var _focusScrollContainerWithoutOverflow2 = _interopRequireDefault(_focusScrollContainerWithoutOverflow);

var _focusScrollContainer = __webpack_require__(/*! ./focus-scroll-container */ "./node_modules/ally.js/supports/focus-scroll-container.js");

var _focusScrollContainer2 = _interopRequireDefault(_focusScrollContainer);

var _focusSummary = __webpack_require__(/*! ./focus-summary */ "./node_modules/ally.js/supports/focus-summary.js");

var _focusSummary2 = _interopRequireDefault(_focusSummary);

var _focusSvgFocusableAttribute = __webpack_require__(/*! ./focus-svg-focusable-attribute */ "./node_modules/ally.js/supports/focus-svg-focusable-attribute.js");

var _focusSvgFocusableAttribute2 = _interopRequireDefault(_focusSvgFocusableAttribute);

var _focusSvgTabindexAttribute = __webpack_require__(/*! ./focus-svg-tabindex-attribute */ "./node_modules/ally.js/supports/focus-svg-tabindex-attribute.js");

var _focusSvgTabindexAttribute2 = _interopRequireDefault(_focusSvgTabindexAttribute);

var _focusSvgNegativeTabindexAttribute = __webpack_require__(/*! ./focus-svg-negative-tabindex-attribute */ "./node_modules/ally.js/supports/focus-svg-negative-tabindex-attribute.js");

var _focusSvgNegativeTabindexAttribute2 = _interopRequireDefault(_focusSvgNegativeTabindexAttribute);

var _focusSvgUseTabindex = __webpack_require__(/*! ./focus-svg-use-tabindex */ "./node_modules/ally.js/supports/focus-svg-use-tabindex.js");

var _focusSvgUseTabindex2 = _interopRequireDefault(_focusSvgUseTabindex);

var _focusSvgForeignobjectTabindex = __webpack_require__(/*! ./focus-svg-foreignobject-tabindex */ "./node_modules/ally.js/supports/focus-svg-foreignobject-tabindex.js");

var _focusSvgForeignobjectTabindex2 = _interopRequireDefault(_focusSvgForeignobjectTabindex);

var _focusSvgInIframe = __webpack_require__(/*! ./focus-svg-in-iframe */ "./node_modules/ally.js/supports/focus-svg-in-iframe.js");

var _focusSvgInIframe2 = _interopRequireDefault(_focusSvgInIframe);

var _focusSvg = __webpack_require__(/*! ./focus-svg */ "./node_modules/ally.js/supports/focus-svg.js");

var _focusSvg2 = _interopRequireDefault(_focusSvg);

var _focusTabindexTrailingCharacters = __webpack_require__(/*! ./focus-tabindex-trailing-characters */ "./node_modules/ally.js/supports/focus-tabindex-trailing-characters.js");

var _focusTabindexTrailingCharacters2 = _interopRequireDefault(_focusTabindexTrailingCharacters);

var _focusTable = __webpack_require__(/*! ./focus-table */ "./node_modules/ally.js/supports/focus-table.js");

var _focusTable2 = _interopRequireDefault(_focusTable);

var _focusVideoWithoutControls = __webpack_require__(/*! ./focus-video-without-controls */ "./node_modules/ally.js/supports/focus-video-without-controls.js");

var _focusVideoWithoutControls2 = _interopRequireDefault(_focusVideoWithoutControls);

var _tabsequenceAreaAtImgPosition = __webpack_require__(/*! ./tabsequence-area-at-img-position */ "./node_modules/ally.js/supports/tabsequence-area-at-img-position.js");

var _tabsequenceAreaAtImgPosition2 = _interopRequireDefault(_tabsequenceAreaAtImgPosition);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var testCallbacks = {
  cssShadowPiercingDeepCombinator: _cssShadowPiercingDeepCombinator2.default,
  focusInZeroDimensionObject: _focusInZeroDimensionObject2.default,
  focusObjectSwf: _focusObjectSwf2.default,
  focusSvgInIframe: _focusSvgInIframe2.default,
  tabsequenceAreaAtImgPosition: _tabsequenceAreaAtImgPosition2.default
};

var testDescriptions = {
  focusAreaImgTabindex: _focusAreaImgTabindex2.default,
  focusAreaTabindex: _focusAreaTabindex2.default,
  focusAreaWithoutHref: _focusAreaWithoutHref2.default,
  focusAudioWithoutControls: _focusAudioWithoutControls2.default,
  focusBrokenImageMap: _focusBrokenImageMap2.default,
  focusChildrenOfFocusableFlexbox: _focusChildrenOfFocusableFlexbox2.default,
  focusFieldsetDisabled: _focusFieldsetDisabled2.default,
  focusFieldset: _focusFieldset2.default,
  focusFlexboxContainer: _focusFlexboxContainer2.default,
  focusFormDisabled: _focusFormDisabled2.default,
  focusImgIsmap: _focusImgIsmap2.default,
  focusImgUsemapTabindex: _focusImgUsemapTabindex2.default,
  focusInHiddenIframe: _focusInHiddenIframe2.default,
  focusInvalidTabindex: _focusInvalidTabindex2.default,
  focusLabelTabindex: _focusLabelTabindex2.default,
  focusObjectSvg: _focusObjectSvg2.default,
  focusObjectSvgHidden: _focusObjectSvgHidden2.default,
  focusRedirectImgUsemap: _focusRedirectImgUsemap2.default,
  focusRedirectLegend: _focusRedirectLegend2.default,
  focusScrollBody: _focusScrollBody2.default,
  focusScrollContainerWithoutOverflow: _focusScrollContainerWithoutOverflow2.default,
  focusScrollContainer: _focusScrollContainer2.default,
  focusSummary: _focusSummary2.default,
  focusSvgFocusableAttribute: _focusSvgFocusableAttribute2.default,
  focusSvgTabindexAttribute: _focusSvgTabindexAttribute2.default,
  focusSvgNegativeTabindexAttribute: _focusSvgNegativeTabindexAttribute2.default,
  focusSvgUseTabindex: _focusSvgUseTabindex2.default,
  focusSvgForeignobjectTabindex: _focusSvgForeignobjectTabindex2.default,
  focusSvg: _focusSvg2.default,
  focusTabindexTrailingCharacters: _focusTabindexTrailingCharacters2.default,
  focusTable: _focusTable2.default,
  focusVideoWithoutControls: _focusVideoWithoutControls2.default
};

function executeTests() {
  var results = (0, _detectFocus2.default)(testDescriptions);
  Object.keys(testCallbacks).forEach(function (key) {
    results[key] = testCallbacks[key]();
  });

  return results;
}

var supportsCache = null;

module.exports = exports['default'];
//# sourceMappingURL=supports.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/tabsequence-area-at-img-position.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ally.js/supports/tabsequence-area-at-img-position.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  return result;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://jsbin.com/vafaba/3/edit?html,js,console,output
var result = _platform2.default.is.GECKO || _platform2.default.is.TRIDENT || _platform2.default.is.EDGE;

module.exports = exports['default'];
//# sourceMappingURL=tabsequence-area-at-img-position.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/array-find-index.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/util/array-find-index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = findIndex;
function findIndex(array, callback) {
  // attempt to use native or polyfilled Array#findIndex first
  if (array.findIndex) {
    return array.findIndex(callback);
  }

  var length = array.length;

  // shortcut if the array is empty
  if (length === 0) {
    return -1;
  }

  // otherwise loop over array
  for (var i = 0; i < length; i++) {
    if (callback(array[i], i, array)) {
      return i;
    }
  }

  return -1;
}
module.exports = exports["default"];
//# sourceMappingURL=array-find-index.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/compare-position.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/util/compare-position.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParentComparator = getParentComparator;

// Node.compareDocumentPosition is available since IE9
// see https://developer.mozilla.org/en-US/docs/Web/API/Node.compareDocumentPosition

// callback returns true when element is contained by parent or is the parent suited for use with Array.some()
/*
  USAGE:
    var isChildOf = getParentComparator({parent: someNode});
    listOfElements.some(isChildOf)
*/

function getParentComparator() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      parent = _ref.parent,
      element = _ref.element,
      includeSelf = _ref.includeSelf;

  if (parent) {
    return function isChildOf(node) {
      return Boolean(includeSelf && node === parent || parent.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY);
    };
  } else if (element) {
    return function isParentOf(node) {
      return Boolean(includeSelf && element === node || node.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_CONTAINED_BY);
    };
  }

  throw new TypeError('util/compare-position#getParentComparator required either options.parent or options.element');
}
//# sourceMappingURL=compare-position.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/context-to-element.js":
/*!*********************************************************!*\
  !*** ./node_modules/ally.js/util/context-to-element.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (_ref) {
  var context = _ref.context,
      _ref$label = _ref.label,
      label = _ref$label === undefined ? 'context-to-element' : _ref$label,
      resolveDocument = _ref.resolveDocument,
      defaultToDocument = _ref.defaultToDocument;

  var element = (0, _nodeArray2.default)(context)[0];

  if (resolveDocument && element && element.nodeType === Node.DOCUMENT_NODE) {
    element = element.documentElement;
  }

  if (!element && defaultToDocument) {
    return document.documentElement;
  }

  if (!element) {
    throw new TypeError(label + ' requires valid options.context');
  }

  if (element.nodeType !== Node.ELEMENT_NODE && element.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
    throw new TypeError(label + ' requires options.context to be an Element');
  }

  return element;
};

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=context-to-element.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/element-matches.js":
/*!******************************************************!*\
  !*** ./node_modules/ally.js/util/element-matches.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = elementMatches;

// Element.prototype.matches may be available at a different name
// https://developer.mozilla.org/en/docs/Web/API/Element/matches

var names = ['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector'];
var name = null;

function findMethodName(element) {
  names.some(function (_name) {
    if (!element[_name]) {
      return false;
    }

    name = _name;
    return true;
  });
}

function elementMatches(element, selector) {
  if (!name) {
    findMethodName(element);
  }

  return element[name](selector);
}
module.exports = exports['default'];
//# sourceMappingURL=element-matches.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/get-content-document.js":
/*!***********************************************************!*\
  !*** ./node_modules/ally.js/util/get-content-document.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (node) {
  try {
    // works on <object> and <iframe>
    return node.contentDocument
    // works on <object> and <iframe>
    || node.contentWindow && node.contentWindow.document
    // works on <object> and <iframe> that contain SVG
    || node.getSVGDocument && node.getSVGDocument() || null;
  } catch (e) {
    // SecurityError: Failed to read the 'contentDocument' property from 'HTMLObjectElement'
    // also IE may throw member not found exception e.g. on <object type="image/png">
    return null;
  }
};

module.exports = exports["default"];
//# sourceMappingURL=get-content-document.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/get-document.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/util/get-document.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (node) {
  if (!node) {
    return document;
  }

  if (node.nodeType === Node.DOCUMENT_NODE) {
    return node;
  }

  return node.ownerDocument || document;
};

module.exports = exports["default"];
//# sourceMappingURL=get-document.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/get-frame-element.js":
/*!********************************************************!*\
  !*** ./node_modules/ally.js/util/get-frame-element.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getFrameElement;

var _getContentDocument = __webpack_require__(/*! ./get-content-document */ "./node_modules/ally.js/util/get-content-document.js");

var _getContentDocument2 = _interopRequireDefault(_getContentDocument);

var _getWindow = __webpack_require__(/*! ./get-window */ "./node_modules/ally.js/util/get-window.js");

var _getWindow2 = _interopRequireDefault(_getWindow);

var _selectInShadows = __webpack_require__(/*! ./select-in-shadows */ "./node_modules/ally.js/util/select-in-shadows.js");

var _selectInShadows2 = _interopRequireDefault(_selectInShadows);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var selector = void 0;

function findDocumentHostElement(_window) {
  if (!selector) {
    selector = (0, _selectInShadows2.default)('object, iframe');
  }

  if (_window._frameElement !== undefined) {
    return _window._frameElement;
  }

  _window._frameElement = null;

  var potentialHosts = _window.parent.document.querySelectorAll(selector);
  [].some.call(potentialHosts, function (element) {
    var _document = (0, _getContentDocument2.default)(element);
    if (_document !== _window.document) {
      return false;
    }

    _window._frameElement = element;
    return true;
  });

  return _window._frameElement;
}

function getFrameElement(element) {
  var _window = (0, _getWindow2.default)(element);
  if (!_window.parent || _window.parent === _window) {
    // if there is no parent browsing context,
    // we're not going to get a frameElement either way
    return null;
  }

  try {
    // see https://developer.mozilla.org/en-US/docs/Web/API/Window/frameElement
    // does not work within <embed> anywhere, and not within in <object> in IE
    return _window.frameElement || findDocumentHostElement(_window);
  } catch (e) {
    return null;
  }
}
module.exports = exports['default'];
//# sourceMappingURL=get-frame-element.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/get-window.js":
/*!*************************************************!*\
  !*** ./node_modules/ally.js/util/get-window.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (node) {
  var _document = (0, _getDocument2.default)(node);
  return _document.defaultView || window;
};

var _getDocument = __webpack_require__(/*! ./get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=get-window.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/image-map.js":
/*!************************************************!*\
  !*** ./node_modules/ally.js/util/image-map.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMapByName = getMapByName;
exports.getMapOfImage = getMapOfImage;
exports.getImageOfArea = getImageOfArea;

var _css = __webpack_require__(/*! css.escape */ "./node_modules/css.escape/css.escape.js");

var _css2 = _interopRequireDefault(_css);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getMapByName(name, _document) {
  // apparently getElementsByName() also considers id attribute in IE & opera
  // https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName
  var map = _document.querySelector('map[name="' + (0, _css2.default)(name) + '"]');
  return map || null;
}

function getMapOfImage(element) {
  var usemap = element.getAttribute('usemap');
  if (!usemap) {
    return null;
  }

  var _document = (0, _getDocument2.default)(element);
  return getMapByName(usemap.slice(1), _document);
}

function getImageOfArea(element) {
  var map = element.parentElement;

  if (!map.name || map.nodeName.toLowerCase() !== 'map') {
    return null;
  }

  // NOTE: image maps can also be applied to <object> with image content,
  // but no browser supports this at the moment

  // HTML5 specifies HTMLMapElement.images to be an HTMLCollection of all
  // <img> and <object> referencing the <map> element, but no browser implements this
  //   https://www.w3.org/TR/html5/embedded-content-0.html#the-map-element
  //   https://developer.mozilla.org/en-US/docs/Web/API/HTMLMapElement
  // the image must be valid and loaded for the map to take effect
  var _document = (0, _getDocument2.default)(element);
  return _document.querySelector('img[usemap="#' + (0, _css2.default)(map.name) + '"]') || null;
}
//# sourceMappingURL=image-map.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/logger.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/util/logger.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var noop = function noop() {};
var _console = {
  log: noop,
  debug: noop,
  info: noop,
  warn: noop,
  error: noop
};

exports.default = typeof console !== 'undefined' ? console : _console;
module.exports = exports['default'];
//# sourceMappingURL=logger.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/merge-dom-order.js":
/*!******************************************************!*\
  !*** ./node_modules/ally.js/util/merge-dom-order.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      list = _ref.list,
      elements = _ref.elements,
      resolveElement = _ref.resolveElement;

  // operate on a copy so we don't mutate the original array
  var _list = list.slice(0);
  // make sure the elements we're injecting are provided in DOM order
  var _elements = (0, _nodeArray2.default)(elements).slice(0);
  (0, _sortDomOrder2.default)(_elements);
  // find the offsets within the target array (list) at which to inject
  // each individual element (from elements)
  var insertions = findInsertionOffsets(_list, _elements, resolveElement);
  // actually inject the elements into the target array at the identified positions
  insertElementsAtOffsets(_list, insertions);
  return _list;
};

var _arrayFindIndex = __webpack_require__(/*! ../util/array-find-index */ "./node_modules/ally.js/util/array-find-index.js");

var _arrayFindIndex2 = _interopRequireDefault(_arrayFindIndex);

var _nodeArray = __webpack_require__(/*! ./node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _sortDomOrder = __webpack_require__(/*! ./sort-dom-order */ "./node_modules/ally.js/util/sort-dom-order.js");

var _sortDomOrder2 = _interopRequireDefault(_sortDomOrder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getFirstSuccessorOffset(list, target) {
  // find the first element that comes AFTER the target element
  return (0, _arrayFindIndex2.default)(list, function (element) {
    return target.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_FOLLOWING;
  });
}
// sort a list of elements into another list of elements in DOM order

/*
  USAGE:
    mergeDomOrder({
      // DOM ordered array of elements to use as base of merge
      list: [],
      // unordered array of elements to merge into base list
      elements: [],
      // callback function to resolve an element
      resolveElement: function(element) {
        // return null to skip
        // return element to replace insertion
        // return [element1, element2, ] to replace insertion with multiple elements
        return element;
      },
    })
*/

function findInsertionOffsets(list, elements, resolveElement) {
  // instead of mutating the elements list directly, remember position and map
  // to inject later, when we can do this more efficiently
  var insertions = [];
  elements.forEach(function (element) {
    var replace = true;
    var offset = list.indexOf(element);

    if (offset === -1) {
      // element is not in target list
      offset = getFirstSuccessorOffset(list, element);
      replace = false;
    }

    if (offset === -1) {
      // there is no successor in the tabsequence,
      // meaning the image must be the last element
      offset = list.length;
    }

    // allow the consumer to replace the injected element
    var injections = (0, _nodeArray2.default)(resolveElement ? resolveElement(element) : element);
    if (!injections.length) {
      // we can't inject zero elements
      return;
    }

    insertions.push({
      offset: offset,
      replace: replace,
      elements: injections
    });
  });

  return insertions;
}

function insertElementsAtOffsets(list, insertions) {
  // remember the number of elements we have already injected
  // so we account for the caused index offset
  var inserted = 0;
  // make sure that we insert the elements in sequence,
  // otherwise the offset compensation won't work
  insertions.sort(function (a, b) {
    return a.offset - b.offset;
  });
  insertions.forEach(function (insertion) {
    // array.splice has an annoying function signature :(
    var remove = insertion.replace ? 1 : 0;
    var args = [insertion.offset + inserted, remove].concat(insertion.elements);
    list.splice.apply(list, args);
    inserted += insertion.elements.length - remove;
  });
}

module.exports = exports['default'];
//# sourceMappingURL=merge-dom-order.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/node-array.js":
/*!*************************************************!*\
  !*** ./node_modules/ally.js/util/node-array.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (input) {
  if (!input) {
    return [];
  }

  if (Array.isArray(input)) {
    return input;
  }

  // instanceof Node - does not work with iframes
  if (input.nodeType !== undefined) {
    return [input];
  }

  if (typeof input === 'string') {
    input = document.querySelectorAll(input);
  }

  if (input.length !== undefined) {
    return [].slice.call(input, 0);
  }

  throw new TypeError('unexpected input ' + String(input));
};

module.exports = exports['default'];
// input may be undefined, selector-tring, Node, NodeList, HTMLCollection, array of Nodes
// yes, to some extent this is a bad replica of jQuery's constructor function
//# sourceMappingURL=node-array.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/platform.js":
/*!***********************************************!*\
  !*** ./node_modules/ally.js/util/platform.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _platform2 = __webpack_require__(/*! platform */ "./node_modules/platform/platform.js");

var _platform3 = _interopRequireDefault(_platform2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// deep clone of original platform
var platform = JSON.parse(JSON.stringify(_platform3.default));

// operating system

// sugar for https://github.com/bestiejs/platform.js
// make sure to ALWAYS reference the layout engine,
// even if it is not necessary for the condition,
// as this makes grepping for this stuff simpler

var os = platform.os.family || '';
var ANDROID = os === 'Android';
var WINDOWS = os.slice(0, 7) === 'Windows';
var OSX = os === 'OS X';
var IOS = os === 'iOS';

// layout
var BLINK = platform.layout === 'Blink';
var GECKO = platform.layout === 'Gecko';
var TRIDENT = platform.layout === 'Trident';
var EDGE = platform.layout === 'EdgeHTML';
var WEBKIT = platform.layout === 'WebKit';

// browser version (not layout engine version!)
var version = parseFloat(platform.version);
var majorVersion = Math.floor(version);
platform.majorVersion = majorVersion;

platform.is = {
  // operating system
  ANDROID: ANDROID,
  WINDOWS: WINDOWS,
  OSX: OSX,
  IOS: IOS,
  // layout
  BLINK: BLINK, // "Chrome", "Chrome Mobile", "Opera"
  GECKO: GECKO, // "Firefox"
  TRIDENT: TRIDENT, // "Internet Explorer"
  EDGE: EDGE, // "Microsoft Edge"
  WEBKIT: WEBKIT, // "Safari"
  // INTERNET EXPLORERS
  IE9: TRIDENT && majorVersion === 9,
  IE10: TRIDENT && majorVersion === 10,
  IE11: TRIDENT && majorVersion === 11
};

exports.default = platform;
module.exports = exports['default'];
//# sourceMappingURL=platform.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/select-in-shadows.js":
/*!********************************************************!*\
  !*** ./node_modules/ally.js/util/select-in-shadows.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (selector) {
  if (typeof shadowPrefix !== 'string') {
    var operator = (0, _cssShadowPiercingDeepCombinator2.default)();
    if (operator) {
      shadowPrefix = ', html ' + operator + ' ';
    }
  }

  if (!shadowPrefix) {
    return selector;
  }

  return selector + shadowPrefix + selector.replace(/\s*,\s*/g, ',').split(',').join(shadowPrefix);
};

var _cssShadowPiercingDeepCombinator = __webpack_require__(/*! ../supports/css-shadow-piercing-deep-combinator */ "./node_modules/ally.js/supports/css-shadow-piercing-deep-combinator.js");

var _cssShadowPiercingDeepCombinator2 = _interopRequireDefault(_cssShadowPiercingDeepCombinator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var shadowPrefix = void 0;
// convert a CSS selector so that it also pierces ShadowDOM
// takes ".a, #b" and turns it into ".a, #b, html >>> .a, html >>> #b"

module.exports = exports['default'];
//# sourceMappingURL=select-in-shadows.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/sort-dom-order.js":
/*!*****************************************************!*\
  !*** ./node_modules/ally.js/util/sort-dom-order.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (elements) {
  return elements.sort(compareDomPosition);
};

// sorts a list of elements according to their order in the DOM

function compareDomPosition(a, b) {
  return a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
}

module.exports = exports["default"];
//# sourceMappingURL=sort-dom-order.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/tabindex-value.js":
/*!*****************************************************!*\
  !*** ./node_modules/ally.js/util/tabindex-value.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (element) {
  if (!(0, _validTabindex2.default)(element)) {
    return null;
  }

  // Edge 14 has a capitalization problem on SVG elements,
  // see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9282058/
  var hasTabindex = element.hasAttribute('tabindex');
  var attributeName = hasTabindex ? 'tabindex' : 'tabIndex';

  // @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
  var tabindex = parseInt(element.getAttribute(attributeName), 10);
  return isNaN(tabindex) ? -1 : tabindex;
};

var _validTabindex = __webpack_require__(/*! ../is/valid-tabindex */ "./node_modules/ally.js/is/valid-tabindex.js");

var _validTabindex2 = _interopRequireDefault(_validTabindex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=tabindex-value.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/toggle-attribute-value.js":
/*!*************************************************************!*\
  !*** ./node_modules/ally.js/util/toggle-attribute-value.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (_ref) {
  var element = _ref.element,
      attribute = _ref.attribute,
      temporaryValue = _ref.temporaryValue,
      saveValue = _ref.saveValue;

  var temporaryAttribute = 'data-cached-' + attribute;

  if (temporaryValue !== undefined) {
    var _value = saveValue || element.getAttribute(attribute);
    element.setAttribute(temporaryAttribute, _value || '');
    element.setAttribute(attribute, temporaryValue);
  } else {
    var _value2 = element.getAttribute(temporaryAttribute);
    element.removeAttribute(temporaryAttribute);
    if (_value2 === '') {
      element.removeAttribute(attribute);
    } else {
      element.setAttribute(attribute, _value2);
    }
  }
};

module.exports = exports['default'];
// helper to turn
//  <div some-attribute="original">
// into
//  <div some-attribute="new" data-cached-some-attribute="original">
// and back
//# sourceMappingURL=toggle-attribute-value.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/toggle-attribute.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/util/toggle-attribute.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (_ref) {
  var element = _ref.element,
      attribute = _ref.attribute;

  var temporaryAttribute = 'data-cached-' + attribute;
  var temporaryAttributeValue = element.getAttribute(temporaryAttribute);

  if (temporaryAttributeValue === null) {
    var _value = element.getAttribute(attribute);
    if (_value === null) {
      // can't remove what's not there
      return;
    }

    element.setAttribute(temporaryAttribute, _value || '');
    element.removeAttribute(attribute);
  } else {
    var _value2 = element.getAttribute(temporaryAttribute);
    element.removeAttribute(temporaryAttribute);
    element.setAttribute(attribute, _value2);
  }
};

module.exports = exports['default'];
// helper to turn
//  <div some-attribute="original">
// into
//  <div data-cached-some-attribute="original">
// and back
//# sourceMappingURL=toggle-attribute.js.map

/***/ }),

/***/ "./node_modules/ally.js/version.js":
/*!*****************************************!*\
  !*** ./node_modules/ally.js/version.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// this file is overwritten by `npm run build:pre`
var version = '1.4.1';
exports.default = version;
module.exports = exports['default'];
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "./node_modules/ally.js/when/key.binding.js":
/*!**************************************************!*\
  !*** ./node_modules/ally.js/when/key.binding.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (text) {
  return text.split(/\s+/).map(function (_text) {
    var tokens = _text.split('+');
    var _modifiers = resolveModifiers(tokens.slice(0, -1));
    var _keyCodes = resolveKey(tokens.slice(-1));
    return {
      keyCodes: _keyCodes,
      modifiers: _modifiers,
      matchModifiers: matchModifiers.bind(null, _modifiers)
    };
  });
};

var _keycode = __webpack_require__(/*! ../map/keycode */ "./node_modules/ally.js/map/keycode.js");

var _keycode2 = _interopRequireDefault(_keycode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var modifier = {
  alt: 'altKey',
  ctrl: 'ctrlKey',
  meta: 'metaKey',
  shift: 'shiftKey'
};
/*
  decodes a key binding token to a JavaScript structure

  returns an array of objects:
    {
      // key name translated to keyCode (possibly more than one)
      keyCodes: [<number>],
      // translated modifiers
      modifiers: {
        altKey: null,   // ignore
        ctrKey: false,  // expect not pressed
        metaKey: true,  // expect pressed
        shiftKey: true, // expect pressed
      },
      // callback that returns true if event's
      // modifier keys match the expected state
      matchModifiers: function(event){},
    }
*/

var modifierSequence = Object.keys(modifier).map(function (name) {
  return modifier[name];
});

function createExpectedModifiers(ignoreModifiers) {
  var value = ignoreModifiers ? null : false;
  return {
    altKey: value,
    ctrlKey: value,
    metaKey: value,
    shiftKey: value
  };
}

function resolveModifiers(modifiers) {
  var ignoreModifiers = modifiers.indexOf('*') !== -1;
  var expected = createExpectedModifiers(ignoreModifiers);

  modifiers.forEach(function (token) {
    if (token === '*') {
      // we've already covered the all-in operator
      return;
    }

    // we want the modifier pressed
    var value = true;
    var operator = token.slice(0, 1);
    if (operator === '?') {
      // we don't care if the modifier is pressed
      value = null;
    } else if (operator === '!') {
      // we do not want the modifier pressed
      value = false;
    }

    if (value !== true) {
      // compensate for the modifier's operator
      token = token.slice(1);
    }

    var propertyName = modifier[token];
    if (!propertyName) {
      throw new TypeError('Unknown modifier "' + token + '"');
    }

    expected[propertyName] = value;
  });

  return expected;
}

function resolveKey(key) {
  var code = _keycode2.default[key] || parseInt(key, 10);
  if (!code || typeof code !== 'number' || isNaN(code)) {
    throw new TypeError('Unknown key "' + key + '"');
  }

  return [code].concat(_keycode2.default._alias[code] || []);
}

function matchModifiers(expected, event) {
  // returns true on match
  return !modifierSequence.some(function (prop) {
    // returns true on mismatch
    return typeof expected[prop] === 'boolean' && Boolean(event[prop]) !== expected[prop];
  });
}

module.exports = exports['default'];
//# sourceMappingURL=key.binding.js.map

/***/ }),

/***/ "./node_modules/ally.js/when/key.js":
/*!******************************************!*\
  !*** ./node_modules/ally.js/when/key.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var bindings = {};

  var context = (0, _nodeArray2.default)(map.context)[0] || document.documentElement;
  delete map.context;
  var filter = (0, _nodeArray2.default)(map.filter);
  delete map.filter;

  var mapKeys = Object.keys(map);
  if (!mapKeys.length) {
    throw new TypeError('when/key requires at least one option key');
  }

  var registerBinding = function registerBinding(event) {
    event.keyCodes.forEach(function (code) {
      if (!bindings[code]) {
        bindings[code] = [];
      }

      bindings[code].push(event);
    });
  };

  mapKeys.forEach(function (text) {
    if (typeof map[text] !== 'function') {
      throw new TypeError('when/key requires option["' + text + '"] to be a function');
    }

    var addCallback = function addCallback(event) {
      event.callback = map[text];
      return event;
    };

    (0, _key2.default)(text).map(addCallback).forEach(registerBinding);
  });

  var handleKeyDown = function handleKeyDown(event) {
    if (event.defaultPrevented) {
      return;
    }

    if (filter.length) {
      // ignore elements within the exempted sub-trees
      var isParentOfElement = (0, _comparePosition.getParentComparator)({ element: event.target, includeSelf: true });
      if (filter.some(isParentOfElement)) {
        return;
      }
    }

    var key = event.keyCode || event.which;
    if (!bindings[key]) {
      return;
    }

    bindings[key].forEach(function (_event) {
      if (!_event.matchModifiers(event)) {
        return;
      }

      _event.callback.call(context, event, disengage);
    });
  };

  context.addEventListener('keydown', handleKeyDown, false);

  var disengage = function disengage() {
    context.removeEventListener('keydown', handleKeyDown, false);
  };

  return { disengage: disengage };
};

var _key = __webpack_require__(/*! ./key.binding */ "./node_modules/ally.js/when/key.binding.js");

var _key2 = _interopRequireDefault(_key);

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _comparePosition = __webpack_require__(/*! ../util/compare-position */ "./node_modules/ally.js/util/compare-position.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];

// Bug 286933 - Key events in the autocomplete popup should be hidden from page scripts
// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=286933
//# sourceMappingURL=key.js.map

/***/ }),

/***/ "./node_modules/anser/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/anser/lib/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This file was originally written by @drudru (https://github.com/drudru/ansi_up), MIT, 2011

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ANSI_COLORS = [[{ color: "0, 0, 0", "class": "ansi-black" }, { color: "187, 0, 0", "class": "ansi-red" }, { color: "0, 187, 0", "class": "ansi-green" }, { color: "187, 187, 0", "class": "ansi-yellow" }, { color: "0, 0, 187", "class": "ansi-blue" }, { color: "187, 0, 187", "class": "ansi-magenta" }, { color: "0, 187, 187", "class": "ansi-cyan" }, { color: "255,255,255", "class": "ansi-white" }], [{ color: "85, 85, 85", "class": "ansi-bright-black" }, { color: "255, 85, 85", "class": "ansi-bright-red" }, { color: "0, 255, 0", "class": "ansi-bright-green" }, { color: "255, 255, 85", "class": "ansi-bright-yellow" }, { color: "85, 85, 255", "class": "ansi-bright-blue" }, { color: "255, 85, 255", "class": "ansi-bright-magenta" }, { color: "85, 255, 255", "class": "ansi-bright-cyan" }, { color: "255, 255, 255", "class": "ansi-bright-white" }]];

var Anser = function () {
    _createClass(Anser, null, [{
        key: "escapeForHtml",


        /**
         * Anser.escapeForHtml
         * Escape the input HTML.
         *
         * This does the minimum escaping of text to make it compliant with HTML.
         * In particular, the '&','<', and '>' characters are escaped. This should
         * be run prior to `ansiToHtml`.
         *
         * @name Anser.escapeForHtml
         * @function
         * @param {String} txt The input text (containing the ANSI snippets).
         * @returns {String} The escaped html.
         */
        value: function escapeForHtml(txt) {
            return new Anser().escapeForHtml(txt);
        }

        /**
         * Anser.linkify
         * Adds the links in the HTML.
         *
         * This replaces any links in the text with anchor tags that display the
         * link. The links should have at least one whitespace character
         * surrounding it. Also, you should apply this after you have run
         * `ansiToHtml` on the text.
         *
         * @name Anser.linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML containing the <a> tags (unescaped).
         */

    }, {
        key: "linkify",
        value: function linkify(txt) {
            return new Anser().linkify(txt);
        }

        /**
         * Anser.ansiToHtml
         * This replaces ANSI terminal escape codes with SPAN tags that wrap the
         * content.
         *
         * This function only interprets ANSI SGR (Select Graphic Rendition) codes
         * that can be represented in HTML.
         * For example, cursor movement codes are ignored and hidden from output.
         * The default style uses colors that are very close to the prescribed
         * standard. The standard assumes that the text will have a black
         * background. These colors are set as inline styles on the SPAN tags.
         *
         * Another option is to set `use_classes: true` in the options argument.
         * This will instead set classes on the spans so the colors can be set via
         * CSS. The class names used are of the format `ansi-*-fg/bg` and
         * `ansi-bright-*-fg/bg` where `*` is the color name,
         * i.e black/red/green/yellow/blue/magenta/cyan/white.
         *
         * @name Anser.ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
            return new Anser().ansiToHtml(txt, options);
        }

        /**
         * Anser.ansiToJson
         * Converts ANSI input into JSON output.
         *
         * @name Anser.ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
            return new Anser().ansiToJson(txt, options);
        }

        /**
         * Anser.ansiToText
         * Converts ANSI input into text output.
         *
         * @name Anser.ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */

    }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
            return new Anser().ansiToText(txt);
        }

        /**
         * Anser
         * The `Anser` class.
         *
         * @name Anser
         * @function
         * @returns {Anser}
         */

    }]);

    function Anser() {
        _classCallCheck(this, Anser);

        this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;
        this.bright = 0;
    }

    /**
     * setupPalette
     * Sets up the palette.
     *
     * @name setupPalette
     * @function
     */


    _createClass(Anser, [{
        key: "setupPalette",
        value: function setupPalette() {
            this.PALETTE_COLORS = [];

            // Index 0..15 : System color
            for (var i = 0; i < 2; ++i) {
                for (var j = 0; j < 8; ++j) {
                    this.PALETTE_COLORS.push(ANSI_COLORS[i][j].color);
                }
            }

            // Index 16..231 : RGB 6x6x6
            // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml
            var levels = [0, 95, 135, 175, 215, 255];
            var format = function format(r, g, b) {
                return levels[r] + ", " + levels[g] + ", " + levels[b];
            };
            var r = void 0,
                g = void 0,
                b = void 0;
            for (var _r = 0; _r < 6; ++_r) {
                for (var _g = 0; _g < 6; ++_g) {
                    for (var _b = 0; _b < 6; ++_b) {
                        this.PALETTE_COLORS.push(format(_r, _g, _b));
                    }
                }
            }

            // Index 232..255 : Grayscale
            var level = 8;
            for (var _i = 0; _i < 24; ++_i, level += 10) {
                this.PALETTE_COLORS.push(format(level, level, level));
            }
        }

        /**
         * escapeForHtml
         * Escapes the input text.
         *
         * @name escapeForHtml
         * @function
         * @param {String} txt The input text.
         * @returns {String} The escpaed HTML output.
         */

    }, {
        key: "escapeForHtml",
        value: function escapeForHtml(txt) {
            return txt.replace(/[&<>]/gm, function (str) {
                return str == "&" ? "&amp;" : str == "<" ? "&lt;" : str == ">" ? "&gt;" : "";
            });
        }

        /**
         * linkify
         * Adds HTML link elements.
         *
         * @name linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML output containing link elements.
         */

    }, {
        key: "linkify",
        value: function linkify(txt) {
            return txt.replace(/(https?:\/\/[^\s]+)/gm, function (str) {
                return "<a href=\"" + str + "\">" + str + "</a>";
            });
        }

        /**
         * ansiToHtml
         * Converts ANSI input into HTML output.
         *
         * @name ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
            return this.process(txt, options, true);
        }

        /**
         * ansiToJson
         * Converts ANSI input into HTML output.
         *
         * @name ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The JSON output.
         */

    }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
            options = options || {};
            options.json = true;
            options.clearLine = false;
            return this.process(txt, options, true);
        }

        /**
         * ansiToText
         * Converts ANSI input into HTML output.
         *
         * @name ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */

    }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
            return this.process(txt, {}, false);
        }

        /**
         * process
         * Processes the input.
         *
         * @name process
         * @function
         * @param {String} txt The input text.
         * @param {Object} options An object passed to `processChunk` method, extended with:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup
         */

    }, {
        key: "process",
        value: function process(txt, options, markup) {
            var _this = this;

            var self = this;
            var raw_text_chunks = txt.split(/\033\[/);
            var first_chunk = raw_text_chunks.shift(); // the first chunk is not the result of the split

            if (options === undefined || options === null) {
                options = {};
            }
            options.clearLine = /\r/.test(txt); // check for Carriage Return
            var color_chunks = raw_text_chunks.map(function (chunk) {
                return _this.processChunk(chunk, options, markup);
            });

            if (options && options.json) {
                var first = self.processChunkJson("");
                first.content = first_chunk;
                first.clearLine = options.clearLine;
                color_chunks.unshift(first);
                if (options.remove_empty) {
                    color_chunks = color_chunks.filter(function (c) {
                        return !c.isEmpty();
                    });
                }
                return color_chunks;
            } else {
                color_chunks.unshift(first_chunk);
            }

            return color_chunks.join("");
        }

        /**
         * processChunkJson
         * Processes the current chunk into json output.
         *
         * @name processChunkJson
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object} The result object:
         *
         *  - `content` (String): The text.
         *  - `fg` (String|null): The foreground color.
         *  - `bg` (String|null): The background color.
         *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).
         *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).
         *  - `clearLine` (Boolean): `true` if a carriageReturn \r was fount at end of line.
         *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.
         *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.
         *
         */

    }, {
        key: "processChunkJson",
        value: function processChunkJson(text, options, markup) {

            // Are we using classes or styles?
            options = typeof options == "undefined" ? {} : options;
            var use_classes = options.use_classes = typeof options.use_classes != "undefined" && options.use_classes;
            var key = options.key = use_classes ? "class" : "color";

            var result = {
                content: text,
                fg: null,
                bg: null,
                fg_truecolor: null,
                bg_truecolor: null,
                clearLine: options.clearLine,
                decoration: null,
                was_processed: false,
                isEmpty: function isEmpty() {
                    return !result.content;
                }
            };

            // Each "chunk" is the text after the CSI (ESC + "[") and before the next CSI/EOF.
            //
            // This regex matches four groups within a chunk.
            //
            // The first and third groups match code type.
            // We supported only SGR command. It has empty first group and "m" in third.
            //
            // The second group matches all of the number+semicolon command sequences
            // before the "m" (or other trailing) character.
            // These are the graphics or SGR commands.
            //
            // The last group is the text (including newlines) that is colored by
            // the other group"s commands.
            var matches = text.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);

            if (!matches) return result;

            var orig_txt = result.content = matches[4];
            var nums = matches[2].split(";");

            // We currently support only "SGR" (Select Graphic Rendition)
            // Simply ignore if not a SGR command.
            if (matches[1] !== "" || matches[3] !== "m") {
                return result;
            }

            if (!markup) {
                return result;
            }

            var self = this;

            self.decoration = null;

            while (nums.length > 0) {
                var num_str = nums.shift();
                var num = parseInt(num_str);

                if (isNaN(num) || num === 0) {
                    self.fg = self.bg = self.decoration = null;
                } else if (num === 1) {
                    self.decoration = "bold";
                } else if (num === 2) {
                    self.decoration = "dim";
                    // Enable code 2 to get string
                } else if (num == 3) {
                    self.decoration = "italic";
                } else if (num == 4) {
                    self.decoration = "underline";
                } else if (num == 5) {
                    self.decoration = "blink";
                } else if (num === 7) {
                    self.decoration = "reverse";
                } else if (num === 8) {
                    self.decoration = "hidden";
                    // Enable code 9 to get strikethrough
                } else if (num === 9) {
                    self.decoration = "strikethrough";
                } else if (num == 39) {
                    self.fg = null;
                } else if (num == 49) {
                    self.bg = null;
                    // Foreground color
                } else if (num >= 30 && num < 38) {
                    self.fg = ANSI_COLORS[0][num % 10][key];
                    // Foreground bright color
                } else if (num >= 90 && num < 98) {
                    self.fg = ANSI_COLORS[1][num % 10][key];
                    // Background color
                } else if (num >= 40 && num < 48) {
                    self.bg = ANSI_COLORS[0][num % 10][key];
                    // Background bright color
                } else if (num >= 100 && num < 108) {
                    self.bg = ANSI_COLORS[1][num % 10][key];
                } else if (num === 38 || num === 48) {
                    // extend color (38=fg, 48=bg)
                    var is_foreground = num === 38;
                    if (nums.length >= 1) {
                        var mode = nums.shift();
                        if (mode === "5" && nums.length >= 1) {
                            // palette color
                            var palette_index = parseInt(nums.shift());
                            if (palette_index >= 0 && palette_index <= 255) {
                                if (!use_classes) {
                                    if (!this.PALETTE_COLORS) {
                                        self.setupPalette();
                                    }
                                    if (is_foreground) {
                                        self.fg = this.PALETTE_COLORS[palette_index];
                                    } else {
                                        self.bg = this.PALETTE_COLORS[palette_index];
                                    }
                                } else {
                                    var klass = palette_index >= 16 ? "ansi-palette-" + palette_index : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8]["class"];
                                    if (is_foreground) {
                                        self.fg = klass;
                                    } else {
                                        self.bg = klass;
                                    }
                                }
                            }
                        } else if (mode === "2" && nums.length >= 3) {
                            // true color
                            var r = parseInt(nums.shift());
                            var g = parseInt(nums.shift());
                            var b = parseInt(nums.shift());
                            if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
                                var color = r + ", " + g + ", " + b;
                                if (!use_classes) {
                                    if (is_foreground) {
                                        self.fg = color;
                                    } else {
                                        self.bg = color;
                                    }
                                } else {
                                    if (is_foreground) {
                                        self.fg = "ansi-truecolor";
                                        self.fg_truecolor = color;
                                    } else {
                                        self.bg = "ansi-truecolor";
                                        self.bg_truecolor = color;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (self.fg === null && self.bg === null && self.decoration === null) {
                return result;
            } else {
                var styles = [];
                var classes = [];
                var data = {};

                result.fg = self.fg;
                result.bg = self.bg;
                result.fg_truecolor = self.fg_truecolor;
                result.bg_truecolor = self.bg_truecolor;
                result.decoration = self.decoration;
                result.was_processed = true;

                return result;
            }
        }

        /**
         * processChunk
         * Processes the current chunk of text.
         *
         * @name processChunk
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object|String} The result (object if `json` is wanted back or string otherwise).
         */

    }, {
        key: "processChunk",
        value: function processChunk(text, options, markup) {
            var _this2 = this;

            var self = this;
            options = options || {};
            var jsonChunk = this.processChunkJson(text, options, markup);

            if (options.json) {
                return jsonChunk;
            }
            if (jsonChunk.isEmpty()) {
                return "";
            }
            if (!jsonChunk.was_processed) {
                return jsonChunk.content;
            }

            var use_classes = options.use_classes;

            var styles = [];
            var classes = [];
            var data = {};
            var render_data = function render_data(data) {
                var fragments = [];
                var key = void 0;
                for (key in data) {
                    if (data.hasOwnProperty(key)) {
                        fragments.push("data-" + key + "=\"" + _this2.escapeForHtml(data[key]) + "\"");
                    }
                }
                return fragments.length > 0 ? " " + fragments.join(" ") : "";
            };

            if (jsonChunk.fg) {
                if (use_classes) {
                    classes.push(jsonChunk.fg + "-fg");
                    if (jsonChunk.fg_truecolor !== null) {
                        data["ansi-truecolor-fg"] = jsonChunk.fg_truecolor;
                        jsonChunk.fg_truecolor = null;
                    }
                } else {
                    styles.push("color:rgb(" + jsonChunk.fg + ")");
                }
            }

            if (jsonChunk.bg) {
                if (use_classes) {
                    classes.push(jsonChunk.bg + "-bg");
                    if (jsonChunk.bg_truecolor !== null) {
                        data["ansi-truecolor-bg"] = jsonChunk.bg_truecolor;
                        jsonChunk.bg_truecolor = null;
                    }
                } else {
                    styles.push("background-color:rgb(" + jsonChunk.bg + ")");
                }
            }

            if (jsonChunk.decoration) {
                if (use_classes) {
                    classes.push("ansi-" + jsonChunk.decoration);
                } else if (jsonChunk.decoration === "bold") {
                    styles.push("font-weight:bold");
                } else if (jsonChunk.decoration === "dim") {
                    styles.push("opacity:0.5");
                } else if (jsonChunk.decoration === "italic") {
                    styles.push("font-style:italic");
                    // underline and blink are treated bellow
                } else if (jsonChunk.decoration === "reverse") {
                    styles.push("filter:invert(100%)");
                } else if (jsonChunk.decoration === "hidden") {
                    styles.push("visibility:hidden");
                } else if (jsonChunk.decoration === "strikethrough") {
                    styles.push("text-decoration:line-through");
                } else {
                    styles.push("text-decoration:" + jsonChunk.decoration);
                }
            }

            if (use_classes) {
                return "<span class=\"" + classes.join(" ") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
            } else {
                return "<span style=\"" + styles.join(";") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
            }
        }
    }]);

    return Anser;
}();

;

module.exports = Anser;

/***/ }),

/***/ "./node_modules/css.escape/css.escape.js":
/*!***********************************************!*\
  !*** ./node_modules/css.escape/css.escape.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */
;(function(root, factory) {
	// https://github.com/umdjs/umd/blob/master/returnExports.js
	if (true) {
		// For Node.js.
		module.exports = factory(root);
	} else {}
}(typeof global != 'undefined' ? global : this, function(root) {

	if (root.CSS && root.CSS.escape) {
		return root.CSS.escape;
	}

	// https://drafts.csswg.org/cssom/#serialize-an-identifier
	var cssEscape = function(value) {
		if (arguments.length == 0) {
			throw new TypeError('`CSS.escape` requires an argument.');
		}
		var string = String(value);
		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = '';
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);
			// Note: theres no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += '\uFFFD';
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, []
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), []
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), []
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += '\\' + codeUnit.toString(16) + ' ';
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, []
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += '\\' + string.charAt(index);
				continue;
			}

			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), []
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += '\\' + string.charAt(index);

		}
		return result;
	};

	if (!root.CSS) {
		root.CSS = {};
	}

	root.CSS.escape = cssEscape;
	return cssEscape;

}));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/native-url/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/native-url/dist/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var e,t=(e=__webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js"))&&"object"==typeof e&&"default"in e?e.default:e,r=/https?|ftp|gopher|file/;function o(e){"string"==typeof e&&(e=g(e));var o=function(e,t,r){var o=e.auth,a=e.hostname,s=e.protocol||"",c=e.pathname||"",h=e.hash||"",p=e.query||"",n=!1;o=o?encodeURIComponent(o).replace(/%3A/i,":")+"@":"",e.host?n=o+e.host:a&&(n=o+(~a.indexOf(":")?"["+a+"]":a),e.port&&(n+=":"+e.port)),p&&"object"==typeof p&&(p=t.encode(p));var l=e.search||p&&"?"+p||"";return s&&":"!==s.substr(-1)&&(s+=":"),e.slashes||(!s||r.test(s))&&!1!==n?(n="//"+(n||""),c&&"/"!==c[0]&&(c="/"+c)):n||(n=""),h&&"#"!==h[0]&&(h="#"+h),l&&"?"!==l[0]&&(l="?"+l),{protocol:s,host:n,pathname:c=c.replace(/[?#]/g,encodeURIComponent),search:l=l.replace("#","%23"),hash:h}}(e,t,r);return""+o.protocol+o.host+o.pathname+o.search+o.hash}var a="http://",s="w.w",c=a+s,h=/^([a-z0-9.+-]*:\/\/\/)([a-z0-9.+-]:\/*)?/i,p=/https?|ftp|gopher|file/;function n(e,t){var r="string"==typeof e?g(e):e;e="object"==typeof e?o(e):e;var s=g(t),n="";r.protocol&&!r.slashes&&(n=r.protocol,e=e.replace(r.protocol,""),n+="/"===t[0]||"/"===e[0]?"/":""),n&&s.protocol&&(n="",s.slashes||(n=s.protocol,t=t.replace(s.protocol,"")));var l=e.match(h);l&&!s.protocol&&(e=e.substr((n=l[1]+(l[2]||"")).length),/^\/\/[^/]/.test(t)&&(n=n.slice(0,-1)));var i=new URL(e,c+"/"),f=new URL(t,i).toString().replace(c,""),u=s.protocol||r.protocol;return u+=r.slashes||s.slashes?"//":"",!n&&u?f=f.replace(a,u):n&&(f=f.replace(a,"")),p.test(f)||~t.indexOf(".")||"/"===e.slice(-1)||"/"===t.slice(-1)||"/"!==f.slice(-1)||(f=f.slice(0,-1)),n&&(f=n+("/"===f[0]?f.substr(1):f)),f}function l(){}l.parse=g,l.format=o,l.resolve=n,l.resolveObject=n;var i=/^https?|ftp|gopher|file/,f=/^(.*?)([#?].*)/,u=/^([a-z0-9.+-]*:)(\/{0,3})(.*)/i,m=/^([a-z0-9.+-]*:)?\/\/\/*/i,v=/^([a-z0-9.+-]*:)(\/{0,2})\[(.*)\]$/i;function d(e){try{return decodeURI(e)}catch(t){return e}}function g(e,r,a){if(void 0===r&&(r=!1),void 0===a&&(a=!1),e&&"object"==typeof e&&e instanceof l)return e;var h=(e=e.trim()).match(f);e=h?d(h[1]).replace(/\\/g,"/")+h[2]:d(e).replace(/\\/g,"/"),v.test(e)&&"/"!==e.slice(-1)&&(e+="/");var p=!/(^javascript)/.test(e)&&e.match(u),n=m.test(e),g="";p&&(i.test(p[1])||(g=p[1].toLowerCase(),e=""+p[2]+p[3]),p[2]||(n=!1,i.test(p[1])?(g=p[1],e=""+p[3]):e="//"+p[3]),3!==p[2].length&&1!==p[2].length||(g=p[1],e="/"+p[3]));var b,y=(h?h[1]:e).match(/(:[0-9]+)/),j="";y&&y[1]&&3===y[1].length&&(e=e.replace(j=y[1],j+"00"));var w=new l,x="",U="";try{b=new URL(e)}catch(t){x=t,g||a||!/^\/\//.test(e)||/^\/\/.+[@.]/.test(e)||(U="/",e=e.substr(1));try{b=new URL(e,c)}catch(e){return w.protocol=g,w.href=g,w}}w.slashes=n&&!U,w.host=b.host===s?"":b.host,w.hostname=b.hostname===s?"":b.hostname.replace(/(\[|\])/g,""),w.protocol=x?g||null:b.protocol,w.search=b.search.replace(/\\/g,"%5C"),w.hash=b.hash.replace(/\\/g,"%5C");var R=e.split("#");!w.search&&~R[0].indexOf("?")&&(w.search="?"),w.hash||""!==R[1]||(w.hash="#"),w.query=r?t.decode(b.search.substr(1)):w.search.substr(1),w.pathname=U+d(b.pathname).replace(/"/g,"%22"),"about:"===w.protocol&&"blank"===w.pathname&&(w.protocol="",w.pathname=""),x&&"/"!==e[0]&&(w.pathname=w.pathname.substr(1)),g&&!i.test(g)&&"/"!==e.slice(-1)&&"/"===w.pathname&&(w.pathname=""),w.path=w.pathname+w.search,w.auth=[b.username,b.password].map(decodeURIComponent).filter(Boolean).join(":"),w.port=b.port,j&&(w.host=w.host.replace(j+"00",j),w.port=w.port.slice(0,-2)),w.href=U?""+w.pathname+w.search+w.hash:o(w);var O=/^(file)/.test(w.href)?["host","hostname"]:[];return Object.keys(w).forEach(function(e){~O.indexOf(e)||(w[e]=w[e]||null)}),w}exports.parse=g,exports.format=o,exports.resolve=n,exports.resolveObject=function(e,t){return g(n(e,t))},exports.Url=l;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/next-pwa/register.js":
/*!*******************************************!*\
  !*** ./node_modules/next-pwa/register.js ***!
  \*******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var workbox_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-window */ "./node_modules/workbox-window/build/workbox-window.prod.es5.mjs");


if (typeof window !== 'undefined' && 'serviceWorker' in navigator) {
  window.workbox = new workbox_window__WEBPACK_IMPORTED_MODULE_0__["Workbox"]("/sw.js", { scope: "/" })
  if(true) window.workbox.register()
}


/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/finally-polyfill.min.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/finally-polyfill.min.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

Promise.prototype.finally=function(n){if("function"!=typeof n)return this.then(n,n);var t=this.constructor||Promise;return this.then(function(r){return t.resolve(n()).then(function(){return r})},function(r){return t.resolve(n()).then(function(){throw r})})};

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/unfetch.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/unfetch.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports=function(e,n){return n=n||{},new Promise(function(t,r){var s=new XMLHttpRequest,o=[],u=[],i={},a=function(){return{ok:2==(s.status/100|0),statusText:s.statusText,status:s.status,url:s.responseURL,text:function(){return Promise.resolve(s.responseText)},json:function(){return Promise.resolve(JSON.parse(s.responseText))},blob:function(){return Promise.resolve(new Blob([s.response]))},clone:a,headers:{keys:function(){return o},entries:function(){return u},get:function(e){return i[e.toLowerCase()]},has:function(e){return e.toLowerCase()in i}}}};for(var l in s.open(n.method||"get",e,!0),s.onload=function(){s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm,function(e,n,t){o.push(n=n.toLowerCase()),u.push([n,t]),i[n]=i[n]?i[n]+","+t:t}),t(a())},s.onerror=r,s.withCredentials="include"==n.credentials,n.headers)s.setRequestHeader(l,n.headers[l]);s.send(n.body||null)})};
//# sourceMappingURL=unfetch.js.map


/***/ }),

/***/ "./node_modules/next/dist/client/dev/dev-build-watcher.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/dev-build-watcher.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = initializeBuildWatcher;

var _eventsource = __webpack_require__(/*! ./error-overlay/eventsource */ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js");

function initializeBuildWatcher() {
  var shadowHost = document.createElement('div');
  shadowHost.id = '__next-build-watcher'; // Make sure container is fixed and on a high zIndex so it shows

  shadowHost.style.position = 'fixed';
  shadowHost.style.bottom = '10px';
  shadowHost.style.right = '20px';
  shadowHost.style.width = 0;
  shadowHost.style.height = 0;
  shadowHost.style.zIndex = 99999;
  document.body.appendChild(shadowHost);
  var shadowRoot;
  var prefix = '';

  if (shadowHost.attachShadow) {
    shadowRoot = shadowHost.attachShadow({
      mode: 'open'
    });
  } else {
    // If attachShadow is undefined then the browser does not support
    // the Shadow DOM, we need to prefix all the names so there
    // will be no conflicts
    shadowRoot = shadowHost;
    prefix = '__next-build-watcher-';
  } // Container


  var container = createContainer(prefix);
  shadowRoot.appendChild(container); // CSS

  var css = createCss(prefix);
  shadowRoot.appendChild(css); // State

  var isVisible = false;
  var isBuilding = false;
  var timeoutId = null; // Handle events

  var evtSource = (0, _eventsource.getEventSourceWrapper)({
    path: '/_next/webpack-hmr'
  });
  evtSource.addMessageListener(function (event) {
    // This is the heartbeat event
    if (event.data === "\uD83D\uDC93") {
      return;
    }

    try {
      handleMessage(event);
    } catch (_unused) {}
  });

  function handleMessage(event) {
    var obj = JSON.parse(event.data); // eslint-disable-next-line default-case

    switch (obj.action) {
      case 'building':
        timeoutId && clearTimeout(timeoutId);
        isVisible = true;
        isBuilding = true;
        updateContainer();
        break;

      case 'built':
      case 'sync':
        isBuilding = false; // Wait for the fade out transtion to complete

        timeoutId = setTimeout(function () {
          isVisible = false;
          updateContainer();
        }, 100);
        updateContainer();
        break;
    }
  }

  function updateContainer() {
    if (isBuilding) {
      container.classList.add(prefix + "building");
    } else {
      container.classList.remove(prefix + "building");
    }

    if (isVisible) {
      container.classList.add(prefix + "visible");
    } else {
      container.classList.remove(prefix + "visible");
    }
  }
}

function createContainer(prefix) {
  var container = document.createElement('div');
  container.id = prefix + "container";
  container.innerHTML = "\n    <div id=\"" + prefix + "icon-wrapper\">\n      <svg viewBox=\"0 0 226 200\">\n        <defs>\n          <linearGradient\n            x1=\"114.720775%\"\n            y1=\"181.283245%\"\n            x2=\"39.5399306%\"\n            y2=\"100%\"\n            id=\"" + prefix + "linear-gradient\"\n          >\n            <stop stop-color=\"#FFFFFF\" offset=\"0%\" />\n            <stop stop-color=\"#000000\" offset=\"100%\" />\n          </linearGradient>\n        </defs>\n        <g id=\"" + prefix + "icon-group\" fill=\"none\" stroke=\"url(#" + prefix + "linear-gradient)\" stroke-width=\"18\">\n          <path d=\"M113,5.08219117 L4.28393801,197.5 L221.716062,197.5 L113,5.08219117 Z\" />\n        </g>\n      </svg>\n    </div>\n  ";
  return container;
}

function createCss(prefix) {
  var css = document.createElement('style');
  css.textContent = "\n    #" + prefix + "container {\n      position: absolute;\n      bottom: 10px;\n      right: 30px;\n\n      background: #fff;\n      color: #000;\n      font: initial;\n      cursor: initial;\n      letter-spacing: initial;\n      text-shadow: initial;\n      text-transform: initial;\n      visibility: initial;\n\n      padding: 8px 10px;\n      align-items: center;\n      box-shadow: 0 11px 40px 0 rgba(0, 0, 0, 0.25), 0 2px 10px 0 rgba(0, 0, 0, 0.12);\n\n      display: none;\n      opacity: 0;\n      transition: opacity 0.1s ease, bottom 0.1s ease;\n      animation: " + prefix + "fade-in 0.1s ease-in-out;\n    }\n\n    #" + prefix + "container." + prefix + "visible {\n      display: flex;\n    }\n\n    #" + prefix + "container." + prefix + "building {\n      bottom: 20px;\n      opacity: 1;\n    }\n\n    #" + prefix + "icon-wrapper {\n      width: 16px;\n      height: 16px;\n    }\n\n    #" + prefix + "icon-wrapper > svg {\n      width: 100%;\n      height: 100%;\n    }\n\n    #" + prefix + "icon-group {\n      animation: " + prefix + "strokedash 1s ease-in-out both infinite;\n    }\n\n    @keyframes " + prefix + "fade-in {\n      from {\n        bottom: 10px;\n        opacity: 0;\n      }\n      to {\n        bottom: 20px;\n        opacity: 1;\n      }\n    }\n\n    @keyframes " + prefix + "strokedash {\n      0% {\n        stroke-dasharray: 0 226;\n      }\n      80%,\n      100% {\n        stroke-dasharray: 659 226;\n      }\n    }\n  ";
  return css;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/eventsource.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getEventSourceWrapper = getEventSourceWrapper;
var eventCallbacks = [];

function EventSourceWrapper(options) {
  var source;
  var lastActivity = new Date();
  var listeners = [];

  if (!options.timeout) {
    options.timeout = 20 * 1000;
  }

  init();
  var timer = setInterval(function () {
    if (new Date() - lastActivity > options.timeout) {
      handleDisconnect();
    }
  }, options.timeout / 2);

  function init() {
    source = new window.EventSource(options.path);
    source.onopen = handleOnline;
    source.onerror = handleDisconnect;
    source.onmessage = handleMessage;
  }

  function handleOnline() {
    if (options.log) console.log('[HMR] connected');
    lastActivity = new Date();
  }

  function handleMessage(event) {
    lastActivity = new Date();

    for (var i = 0; i < listeners.length; i++) {
      listeners[i](event);
    }

    if (event.data.indexOf('action') !== -1) {
      eventCallbacks.forEach(function (cb) {
        return cb(event);
      });
    }
  }

  function handleDisconnect() {
    clearInterval(timer);
    source.close();
    setTimeout(init, options.timeout);
  }

  return {
    close: function close() {
      clearInterval(timer);
      source.close();
    },
    addMessageListener: function addMessageListener(fn) {
      listeners.push(fn);
    }
  };
}

_c = EventSourceWrapper;

function getEventSourceWrapper(options) {
  if (!options.ondemand) {
    return {
      addMessageListener: function addMessageListener(cb) {
        eventCallbacks.push(cb);
      }
    };
  }

  return EventSourceWrapper(options);
}

var _c;

$RefreshReg$(_c, "EventSourceWrapper");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
/**
MIT License
Copyright (c) 2015-present, Facebook, Inc.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
// This file is based on https://github.com/facebook/create-react-app/blob/7b1a32be6ec9f99a6c9a3c66813f3ac09c4736b9/packages/react-dev-utils/formatWebpackMessages.js
// It's been edited to remove chalk and CRA-specific logic

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var friendlySyntaxErrorLabel = 'Syntax error:';

function isLikelyASyntaxError(message) {
  return message.indexOf(friendlySyntaxErrorLabel) !== -1;
} // Cleans up webpack error messages.


function formatMessage(message) {
  var lines = message.split('\n'); // Strip Webpack-added headers off errors/warnings
  // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js

  lines = lines.filter(function (line) {
    return !/Module [A-z ]+\(from/.test(line);
  }); // Transform parsing error into syntax error
  // TODO: move this to our ESLint formatter?

  lines = lines.map(function (line) {
    var parsingError = /Line (\d+):(?:(\d+):)?\s*Parsing error: (.+)$/.exec(line);

    if (!parsingError) {
      return line;
    }

    var _parsingError = _slicedToArray(parsingError, 4),
        errorLine = _parsingError[1],
        errorColumn = _parsingError[2],
        errorMessage = _parsingError[3];

    return friendlySyntaxErrorLabel + " " + errorMessage + " (" + errorLine + ":" + errorColumn + ")";
  });
  message = lines.join('\n'); // Smoosh syntax errors (commonly found in CSS)

  message = message.replace(/SyntaxError\s+\((\d+):(\d+)\)\s*(.+?)\n/g, friendlySyntaxErrorLabel + " $3 ($1:$2)\n"); // Clean up export errors

  message = message.replace(/^.*export '(.+?)' was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$2'.");
  message = message.replace(/^.*export 'default' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$2' does not contain a default export (imported as '$1').");
  message = message.replace(/^.*export '(.+?)' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$3' (imported as '$2').");
  lines = message.split('\n'); // Remove leading newline

  if (lines.length > 2 && lines[1].trim() === '') {
    lines.splice(1, 1);
  } // Clean up file name


  lines[0] = lines[0].replace(/^(.*) \d+:\d+-\d+$/, '$1'); // Cleans up verbose "module not found" messages for files and packages.

  if (lines[1] && lines[1].indexOf('Module not found: ') === 0) {
    lines = [lines[0], lines[1].replace('Error: ', '').replace('Module not found: Cannot find file:', 'Cannot find file:')];
  } // Add helpful message for users trying to use Sass for the first time


  if (lines[1] && lines[1].match(/Cannot find module.+node-sass/)) {
    // ./file.module.scss (<<loader info>>) => ./file.module.scss
    lines[0] = lines[0].replace(/(.+) \(.+?(?=\?\?).+?\)/, '$1');
    lines[1] = "To use Next.js' built-in Sass support, you first need to install `sass`.\n";
    lines[1] += 'Run `npm i sass` or `yarn add sass` inside your workspace.\n';
    lines[1] += '\nLearn more: https://err.sh/next.js/install-sass';
  }

  message = lines.join('\n'); // Internal stacks are generally useless so we strip them... with the
  // exception of stacks containing `webpack:` because they're normally
  // from user code generated by Webpack. For more information see
  // https://github.com/facebook/create-react-app/pull/1050

  message = message.replace(/^\s*at\s((?!webpack:).)*:\d+:\d+[\s)]*(\n|$)/gm, ''); // at ... ...:x:y

  message = message.replace(/^\s*at\s<anonymous>(\n|$)/gm, ''); // at <anonymous>

  lines = message.split('\n'); // Remove duplicated newlines

  lines = lines.filter(function (line, index, arr) {
    return index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim();
  }); // Reassemble the message

  message = lines.join('\n');
  return message.trim();
}

function formatWebpackMessages(json) {
  var formattedErrors = json.errors.map(function (message) {
    return formatMessage(message, true);
  });
  var formattedWarnings = json.warnings.map(function (message) {
    return formatMessage(message, false);
  });
  var result = {
    errors: formattedErrors,
    warnings: formattedWarnings
  };

  if (result.errors.some(isLikelyASyntaxError)) {
    // If there are any syntax errors, show just them.
    result.errors = result.errors.filter(isLikelyASyntaxError);
  }

  return result;
}

module.exports = formatWebpackMessages;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;
exports["default"] = connect;

var DevOverlay = _interopRequireWildcard(__webpack_require__(/*! @next/react-dev-overlay/lib/client */ "./node_modules/@next/react-dev-overlay/lib/client.js"));

var _stripAnsi = _interopRequireDefault(__webpack_require__(/*! next/dist/compiled/strip-ansi */ "./node_modules/next/dist/compiled/strip-ansi/index.js"));

var _eventsource = __webpack_require__(/*! ./eventsource */ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js");

var _formatWebpackMessages = _interopRequireDefault(__webpack_require__(/*! ./format-webpack-messages */ "./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js"));
/**
* MIT License
*
* Copyright (c) 2013-present, Facebook, Inc.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/
// This file is a modified version of the Create React App HMR dev client that
// can be found here:
// https://github.com/facebook/create-react-app/blob/v3.4.1/packages/react-dev-utils/webpackHotDevClient.js
// This alternative WebpackDevServer combines the functionality of:
// https://github.com/webpack/webpack-dev-server/blob/webpack-1/client/index.js
// https://github.com/webpack/webpack/blob/webpack-1/hot/dev-server.js
// It only supports their simplest configuration (hot updates on same server).
// It makes some opinionated choices on top, like adding a syntax error overlay
// that looks similar to our console output. The error overlay is inspired by:
// https://github.com/glenjamin/webpack-hot-middleware


var hadRuntimeError = false;
var customHmrEventHandler;

function connect(options) {
  DevOverlay.register();
  (0, _eventsource.getEventSourceWrapper)(options).addMessageListener(function (event) {
    // This is the heartbeat event
    if (event.data === "\uD83D\uDC93") {
      return;
    }

    try {
      processMessage(event);
    } catch (ex) {
      console.warn('Invalid HMR message: ' + event.data + '\n' + ex);
    }
  });
  return {
    subscribeToHmrEvent: function subscribeToHmrEvent(handler) {
      customHmrEventHandler = handler;
    },
    onUnrecoverableError: function onUnrecoverableError() {
      hadRuntimeError = true;
    }
  };
} // Remember some state related to hot module replacement.


var isFirstCompilation = true;
var mostRecentCompilationHash = null;
var hasCompileErrors = false;

function clearOutdatedErrors() {
  // Clean up outdated compile errors, if any.
  if (typeof console !== 'undefined' && typeof console.clear === 'function') {
    if (hasCompileErrors) {
      console.clear();
    }
  }
} // Successful compilation.


function handleSuccess() {
  clearOutdatedErrors();
  var isHotUpdate = !isFirstCompilation;
  isFirstCompilation = false;
  hasCompileErrors = false; // Attempt to apply hot updates or reload.

  if (isHotUpdate) {
    tryApplyUpdates(function onSuccessfulHotUpdate(hasUpdates) {
      // Only dismiss it when we're sure it's a hot update.
      // Otherwise it would flicker right before the reload.
      onFastRefresh(hasUpdates);
    });
  }
} // Compilation with warnings (e.g. ESLint).


function handleWarnings(warnings) {
  clearOutdatedErrors();
  var isHotUpdate = !isFirstCompilation;
  isFirstCompilation = false;
  hasCompileErrors = false;

  function printWarnings() {
    // Print warnings to the console.
    var formatted = (0, _formatWebpackMessages["default"])({
      warnings: warnings,
      errors: []
    });

    if (typeof console !== 'undefined' && typeof console.warn === 'function') {
      for (var i = 0; i < formatted.warnings.length; i++) {
        if (i === 5) {
          console.warn('There were more warnings in other files.\n' + 'You can find a complete log in the terminal.');
          break;
        }

        console.warn((0, _stripAnsi["default"])(formatted.warnings[i]));
      }
    }
  }

  printWarnings(); // Attempt to apply hot updates or reload.

  if (isHotUpdate) {
    tryApplyUpdates(function onSuccessfulHotUpdate(hasUpdates) {
      // Only dismiss it when we're sure it's a hot update.
      // Otherwise it would flicker right before the reload.
      onFastRefresh(hasUpdates);
    });
  }
} // Compilation with errors (e.g. syntax error or missing modules).


function handleErrors(errors) {
  clearOutdatedErrors();
  isFirstCompilation = false;
  hasCompileErrors = true; // "Massage" webpack messages.

  var formatted = (0, _formatWebpackMessages["default"])({
    errors: errors,
    warnings: []
  }); // Only show the first error.

  DevOverlay.onBuildError(formatted.errors[0]); // Also log them to the console.

  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    for (var i = 0; i < formatted.errors.length; i++) {
      console.error((0, _stripAnsi["default"])(formatted.errors[i]));
    }
  } // Do not attempt to reload now.
  // We will reload on next success instead.


  if (undefined) {
    if (self.__NEXT_HMR_CB) {
      self.__NEXT_HMR_CB(formatted.errors[0]);

      self.__NEXT_HMR_CB = null;
    }
  }
}

function onFastRefresh(hasUpdates) {
  DevOverlay.onBuildOk();

  if (hasUpdates) {
    DevOverlay.onRefresh();
  }

  console.log('[Fast Refresh] done');
} // There is a newer version of the code available.


function handleAvailableHash(hash) {
  // Update last known compilation hash.
  mostRecentCompilationHash = hash;
} // Handle messages from the server.


function processMessage(e) {
  var obj = JSON.parse(e.data);

  switch (obj.action) {
    case 'building':
      {
        console.log('[Fast Refresh] rebuilding');
        break;
      }

    case 'built':
    case 'sync':
      {
        if (obj.hash) {
          handleAvailableHash(obj.hash);
        }

        var errors = obj.errors,
            warnings = obj.warnings;
        var hasErrors = Boolean(errors && errors.length);

        if (hasErrors) {
          return handleErrors(errors);
        }

        var hasWarnings = Boolean(warnings && warnings.length);

        if (hasWarnings) {
          return handleWarnings(warnings);
        }

        return handleSuccess();
      }

    default:
      {
        if (customHmrEventHandler) {
          customHmrEventHandler(obj);
          break;
        }

        break;
      }
  }
} // Is there a newer version of this code available?


function isUpdateAvailable() {
  /* globals __webpack_hash__ */
  // __webpack_hash__ is the hash of the current compilation.
  // It's a global variable injected by Webpack.
  return mostRecentCompilationHash !== __webpack_require__.h();
} // Webpack disallows updates in other states.


function canApplyUpdates() {
  return module.hot.status() === 'idle';
}

function afterApplyUpdates(fn) {
  if (canApplyUpdates()) {
    fn();
  } else {
    var handler = function handler(status) {
      if (status === 'idle') {
        module.hot.removeStatusHandler(handler);
        fn();
      }
    };

    module.hot.addStatusHandler(handler);
  }
} // Attempt to update code on the fly, fall back to a hard reload.


function tryApplyUpdates(onHotUpdateSuccess) {
  if (false) {}

  if (!isUpdateAvailable() || !canApplyUpdates()) {
    return;
  }

  function handleApplyUpdates(err, updatedModules) {
    if (err || hadRuntimeError || !updatedModules) {
      if (err) {
        console.warn('[Fast Refresh] performing full reload\n\n' + "Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React tree.\n" + 'You might have a file which renders a React component but also exports a value that is imported by a non-React component.\n' + 'Consider migrating the non-React component export to a separate file and importing it into both files.\n\n' + 'It is also possible you are using class components at the top-level of your application, which disables Fast Refresh.\n' + 'Fast Refresh requires at least one function component in your React tree.');
      } else if (hadRuntimeError) {
        console.warn('[Fast Refresh] performing full reload because your application had an unrecoverable error');
      }

      window.location.reload();
      return;
    }

    var hasUpdates = Boolean(updatedModules.length);

    if (typeof onHotUpdateSuccess === 'function') {
      // Maybe we want to do something.
      onHotUpdateSuccess(hasUpdates);
    }

    if (isUpdateAvailable()) {
      // While we were updating, there was a new update! Do it again.
      tryApplyUpdates(hasUpdates ? undefined : onHotUpdateSuccess);
    } else {
      if (undefined) {
        afterApplyUpdates(function () {
          if (self.__NEXT_HMR_CB) {
            self.__NEXT_HMR_CB();

            self.__NEXT_HMR_CB = null;
          }
        });
      }
    }
  } // https://webpack.js.org/api/hot-module-replacement/#check


  module.hot.check(
  /* autoApply */
  true).then(function (updatedModules) {
    handleApplyUpdates(null, updatedModules);
  }, function (err) {
    handleApplyUpdates(err, null);
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/event-source-polyfill.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/event-source-polyfill.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _unfetch = _interopRequireDefault(__webpack_require__(/*! next/dist/build/polyfills/unfetch */ "./node_modules/next/dist/build/polyfills/unfetch.js"));
/* eslint-disable */
// Improved version of https://github.com/Yaffle/EventSource/
// Available under MIT License (MIT)
// Only tries to support IE11 and nothing below


var document = window.document;
var Response = window.Response;
var TextDecoder = window.TextDecoder;
var TextEncoder = window.TextEncoder;
var AbortController = window.AbortController;

if (AbortController == undefined) {
  AbortController = function AbortController() {
    this.signal = null;

    this.abort = function () {};
  };
}

function TextDecoderPolyfill() {
  this.bitsNeeded = 0;
  this.codePoint = 0;
}

_c = TextDecoderPolyfill;

TextDecoderPolyfill.prototype.decode = function (octets) {
  function valid(codePoint, shift, octetsCount) {
    if (octetsCount === 1) {
      return codePoint >= 0x0080 >> shift && codePoint << shift <= 0x07ff;
    }

    if (octetsCount === 2) {
      return codePoint >= 0x0800 >> shift && codePoint << shift <= 0xd7ff || codePoint >= 0xe000 >> shift && codePoint << shift <= 0xffff;
    }

    if (octetsCount === 3) {
      return codePoint >= 0x010000 >> shift && codePoint << shift <= 0x10ffff;
    }

    throw new Error();
  }

  function octetsCount(bitsNeeded, codePoint) {
    if (bitsNeeded === 6 * 1) {
      return codePoint >> 6 > 15 ? 3 : codePoint > 31 ? 2 : 1;
    }

    if (bitsNeeded === 6 * 2) {
      return codePoint > 15 ? 3 : 2;
    }

    if (bitsNeeded === 6 * 3) {
      return 3;
    }

    throw new Error();
  }

  var REPLACER = 0xfffd;
  var string = '';
  var bitsNeeded = this.bitsNeeded;
  var codePoint = this.codePoint;

  for (var i = 0; i < octets.length; i += 1) {
    var octet = octets[i];

    if (bitsNeeded !== 0) {
      if (octet < 128 || octet > 191 || !valid(codePoint << 6 | octet & 63, bitsNeeded - 6, octetsCount(bitsNeeded, codePoint))) {
        bitsNeeded = 0;
        codePoint = REPLACER;
        string += String.fromCharCode(codePoint);
      }
    }

    if (bitsNeeded === 0) {
      if (octet >= 0 && octet <= 127) {
        bitsNeeded = 0;
        codePoint = octet;
      } else if (octet >= 192 && octet <= 223) {
        bitsNeeded = 6 * 1;
        codePoint = octet & 31;
      } else if (octet >= 224 && octet <= 239) {
        bitsNeeded = 6 * 2;
        codePoint = octet & 15;
      } else if (octet >= 240 && octet <= 247) {
        bitsNeeded = 6 * 3;
        codePoint = octet & 7;
      } else {
        bitsNeeded = 0;
        codePoint = REPLACER;
      }

      if (bitsNeeded !== 0 && !valid(codePoint, bitsNeeded, octetsCount(bitsNeeded, codePoint))) {
        bitsNeeded = 0;
        codePoint = REPLACER;
      }
    } else {
      bitsNeeded -= 6;
      codePoint = codePoint << 6 | octet & 63;
    }

    if (bitsNeeded === 0) {
      if (codePoint <= 0xffff) {
        string += String.fromCharCode(codePoint);
      } else {
        string += String.fromCharCode(0xd800 + (codePoint - 0xffff - 1 >> 10));
        string += String.fromCharCode(0xdc00 + (codePoint - 0xffff - 1 & 0x3ff));
      }
    }
  }

  this.bitsNeeded = bitsNeeded;
  this.codePoint = codePoint;
  return string;
}; // Firefox < 38 throws an error with stream option


var supportsStreamOption = function supportsStreamOption() {
  try {
    return new TextDecoder().decode(new TextEncoder().encode('test'), {
      stream: true
    }) === 'test';
  } catch (error) {
    console.log(error);
  }

  return false;
}; // IE, Edge


if (TextDecoder == undefined || TextEncoder == undefined || !supportsStreamOption()) {
  TextDecoder = TextDecoderPolyfill;
}

var k = function k() {};

function XHRWrapper(xhr) {
  this.withCredentials = false;
  this.responseType = '';
  this.readyState = 0;
  this.status = 0;
  this.statusText = '';
  this.responseText = '';
  this.onprogress = k;
  this.onreadystatechange = k;
  this._contentType = '';
  this._xhr = xhr;
  this._sendTimeout = 0;
  this._abort = k;
}

_c2 = XHRWrapper;

XHRWrapper.prototype.open = function (method, url) {
  this._abort(true);

  var that = this;
  var xhr = this._xhr;
  var state = 1;
  var timeout = 0;

  this._abort = function (silent) {
    if (that._sendTimeout !== 0) {
      clearTimeout(that._sendTimeout);
      that._sendTimeout = 0;
    }

    if (state === 1 || state === 2 || state === 3) {
      state = 4;
      xhr.onload = k;
      xhr.onerror = k;
      xhr.onabort = k;
      xhr.onprogress = k;
      xhr.onreadystatechange = k; // IE 8 - 9: XDomainRequest#abort() does not fire any event
      // Opera < 10: XMLHttpRequest#abort() does not fire any event

      xhr.abort();

      if (timeout !== 0) {
        clearTimeout(timeout);
        timeout = 0;
      }

      if (!silent) {
        that.readyState = 4;
        that.onreadystatechange();
      }
    }

    state = 0;
  };

  var onStart = function onStart() {
    if (state === 1) {
      // state = 2;
      var status = 0;
      var statusText = '';
      var contentType = undefined;

      if (!('contentType' in xhr)) {
        try {
          status = xhr.status;
          statusText = xhr.statusText;
          contentType = xhr.getResponseHeader('Content-Type');
        } catch (error) {
          // IE < 10 throws exception for `xhr.status` when xhr.readyState === 2 || xhr.readyState === 3
          // Opera < 11 throws exception for `xhr.status` when xhr.readyState === 2
          // https://bugs.webkit.org/show_bug.cgi?id=29121
          status = 0;
          statusText = '';
          contentType = undefined; // Firefox < 14, Chrome ?, Safari ?
          // https://bugs.webkit.org/show_bug.cgi?id=29658
          // https://bugs.webkit.org/show_bug.cgi?id=77854
        }
      } else {
        status = 200;
        statusText = 'OK';
        contentType = xhr.contentType;
      }

      if (status !== 0) {
        state = 2;
        that.readyState = 2;
        that.status = status;
        that.statusText = statusText;
        that._contentType = contentType;
        that.onreadystatechange();
      }
    }
  };

  var onProgress = function onProgress() {
    onStart();

    if (state === 2 || state === 3) {
      state = 3;
      var responseText = '';

      try {
        responseText = xhr.responseText;
      } catch (error) {// IE 8 - 9 with XMLHttpRequest
      }

      that.readyState = 3;
      that.responseText = responseText;
      that.onprogress();
    }
  };

  var onFinish = function onFinish() {
    // Firefox 52 fires "readystatechange" (xhr.readyState === 4) without final "readystatechange" (xhr.readyState === 3)
    // IE 8 fires "onload" without "onprogress"
    onProgress();

    if (state === 1 || state === 2 || state === 3) {
      state = 4;

      if (timeout !== 0) {
        clearTimeout(timeout);
        timeout = 0;
      }

      that.readyState = 4;
      that.onreadystatechange();
    }
  };

  var onReadyStateChange = function onReadyStateChange() {
    if (xhr != undefined) {
      // Opera 12
      if (xhr.readyState === 4) {
        onFinish();
      } else if (xhr.readyState === 3) {
        onProgress();
      } else if (xhr.readyState === 2) {
        onStart();
      }
    }
  };

  var onTimeout = function onTimeout() {
    timeout = setTimeout(function () {
      onTimeout();
    }, 500);

    if (xhr.readyState === 3) {
      onProgress();
    }
  }; // XDomainRequest#abort removes onprogress, onerror, onload


  xhr.onload = onFinish;
  xhr.onerror = onFinish; // improper fix to match Firefox behaviour, but it is better than just ignore abort
  // see https://bugzilla.mozilla.org/show_bug.cgi?id=768596
  // https://bugzilla.mozilla.org/show_bug.cgi?id=880200
  // https://code.google.com/p/chromium/issues/detail?id=153570
  // IE 8 fires "onload" without "onprogress

  xhr.onabort = onFinish; // https://bugzilla.mozilla.org/show_bug.cgi?id=736723

  if (!('sendAsBinary' in XMLHttpRequest.prototype) && !('mozAnon' in XMLHttpRequest.prototype)) {
    xhr.onprogress = onProgress;
  } // IE 8 - 9 (XMLHTTPRequest)
  // Opera < 12
  // Firefox < 3.5
  // Firefox 3.5 - 3.6 - ? < 9.0
  // onprogress is not fired sometimes or delayed
  // see also #64


  xhr.onreadystatechange = onReadyStateChange;

  if ('contentType' in xhr) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + 'padding=true';
  }

  xhr.open(method, url, true);

  if ('readyState' in xhr) {
    // workaround for Opera 12 issue with "progress" events
    // #91
    timeout = setTimeout(function () {
      onTimeout();
    }, 0);
  }
};

XHRWrapper.prototype.abort = function () {
  this._abort(false);
};

XHRWrapper.prototype.getResponseHeader = function (name) {
  return this._contentType;
};

XHRWrapper.prototype.setRequestHeader = function (name, value) {
  var xhr = this._xhr;

  if ('setRequestHeader' in xhr) {
    xhr.setRequestHeader(name, value);
  }
};

XHRWrapper.prototype.getAllResponseHeaders = function () {
  return this._xhr.getAllResponseHeaders != undefined ? this._xhr.getAllResponseHeaders() : '';
};

XHRWrapper.prototype.send = function () {
  // loading indicator in Safari < ? (6), Chrome < 14, Firefox
  if (!('ontimeout' in XMLHttpRequest.prototype) && document != undefined && document.readyState != undefined && document.readyState !== 'complete') {
    var that = this;
    that._sendTimeout = setTimeout(function () {
      that._sendTimeout = 0;
      that.send();
    }, 4);
    return;
  }

  var xhr = this._xhr; // withCredentials should be set after "open" for Safari and Chrome (< 19 ?)

  xhr.withCredentials = this.withCredentials;
  xhr.responseType = this.responseType;

  try {
    // xhr.send(); throws "Not enough arguments" in Firefox 3.0
    xhr.send(undefined);
  } catch (error1) {
    // Safari 5.1.7, Opera 12
    throw error1;
  }
};

function toLowerCase(name) {
  return name.replace(/[A-Z]/g, function (c) {
    return String.fromCharCode(c.charCodeAt(0) + 0x20);
  });
}

function HeadersPolyfill(all) {
  // Get headers: implemented according to mozilla's example code: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders#Example
  var map = Object.create(null);
  var array = all.split('\r\n');

  for (var i = 0; i < array.length; i += 1) {
    var line = array[i];
    var parts = line.split(': ');
    var name = parts.shift();
    var value = parts.join(': ');
    map[toLowerCase(name)] = value;
  }

  this._map = map;
}

_c3 = HeadersPolyfill;

HeadersPolyfill.prototype.get = function (name) {
  return this._map[toLowerCase(name)];
};

function XHRTransport() {}

_c4 = XHRTransport;

XHRTransport.prototype.open = function (xhr, onStartCallback, onProgressCallback, onFinishCallback, url, withCredentials, headers) {
  xhr.open('GET', url);
  var offset = 0;

  xhr.onprogress = function () {
    var responseText = xhr.responseText;
    var chunk = responseText.slice(offset);
    offset += chunk.length;
    onProgressCallback(chunk);
  };

  xhr.onreadystatechange = function () {
    if (xhr.readyState === 2) {
      var status = xhr.status;
      var statusText = xhr.statusText;
      var contentType = xhr.getResponseHeader('Content-Type');
      var headers = xhr.getAllResponseHeaders();
      onStartCallback(status, statusText, contentType, new HeadersPolyfill(headers), function () {
        xhr.abort();
      });
    } else if (xhr.readyState === 4) {
      onFinishCallback();
    }
  };

  xhr.withCredentials = withCredentials;
  xhr.responseType = 'text';

  for (var name in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, name)) {
      xhr.setRequestHeader(name, headers[name]);
    }
  }

  xhr.send();
};

function HeadersWrapper(headers) {
  this._headers = headers;
}

_c5 = HeadersWrapper;

HeadersWrapper.prototype.get = function (name) {
  return this._headers.get(name);
};

function FetchTransport() {}

_c6 = FetchTransport;

FetchTransport.prototype.open = function (xhr, onStartCallback, onProgressCallback, onFinishCallback, url, withCredentials, headers) {
  var controller = new AbortController();
  var signal = controller.signal; // see #120

  var textDecoder = new TextDecoder();
  (0, _unfetch["default"])(url, {
    headers: headers,
    credentials: withCredentials ? 'include' : 'same-origin',
    signal: signal,
    cache: 'no-store'
  }).then(function (response) {
    var reader = response.body.getReader();
    onStartCallback(response.status, response.statusText, response.headers.get('Content-Type'), new HeadersWrapper(response.headers), function () {
      controller.abort();
      reader.cancel();
    });
    return new Promise(function (resolve, reject) {
      var readNextChunk = function readNextChunk() {
        reader.read().then(function (result) {
          if (result.done) {
            // Note: bytes in textDecoder are ignored
            resolve(undefined);
          } else {
            var chunk = textDecoder.decode(result.value, {
              stream: true
            });
            onProgressCallback(chunk);
            readNextChunk();
          }
        })['catch'](function (error) {
          reject(error);
        });
      };

      readNextChunk();
    });
  }).then(function (result) {
    onFinishCallback();
    return result;
  }, function (error) {
    onFinishCallback();
    return Promise.reject(error);
  });
};

function EventTarget() {
  this._listeners = Object.create(null);
}

_c7 = EventTarget;

function throwError(e) {
  setTimeout(function () {
    throw e;
  }, 0);
}

EventTarget.prototype.dispatchEvent = function (event) {
  event.target = this;
  var typeListeners = this._listeners[event.type];

  if (typeListeners != undefined) {
    var length = typeListeners.length;

    for (var i = 0; i < length; i += 1) {
      var listener = typeListeners[i];

      try {
        if (typeof listener.handleEvent === 'function') {
          listener.handleEvent(event);
        } else {
          listener.call(this, event);
        }
      } catch (e) {
        throwError(e);
      }
    }
  }
};

EventTarget.prototype.addEventListener = function (type, listener) {
  type = String(type);
  var listeners = this._listeners;
  var typeListeners = listeners[type];

  if (typeListeners == undefined) {
    typeListeners = [];
    listeners[type] = typeListeners;
  }

  var found = false;

  for (var i = 0; i < typeListeners.length; i += 1) {
    if (typeListeners[i] === listener) {
      found = true;
    }
  }

  if (!found) {
    typeListeners.push(listener);
  }
};

EventTarget.prototype.removeEventListener = function (type, listener) {
  type = String(type);
  var listeners = this._listeners;
  var typeListeners = listeners[type];

  if (typeListeners != undefined) {
    var filtered = [];

    for (var i = 0; i < typeListeners.length; i += 1) {
      if (typeListeners[i] !== listener) {
        filtered.push(typeListeners[i]);
      }
    }

    if (filtered.length === 0) {
      delete listeners[type];
    } else {
      listeners[type] = filtered;
    }
  }
};

function Event(type) {
  this.type = type;
  this.target = undefined;
}

_c8 = Event;

function MessageEvent(type, options) {
  Event.call(this, type);
  this.data = options.data;
  this.lastEventId = options.lastEventId;
}

_c9 = MessageEvent;
MessageEvent.prototype = Object.create(Event.prototype);

function ConnectionEvent(type, options) {
  Event.call(this, type);
  this.status = options.status;
  this.statusText = options.statusText;
  this.headers = options.headers;
}

_c10 = ConnectionEvent;
ConnectionEvent.prototype = Object.create(Event.prototype);
var WAITING = -1;
var CONNECTING = 0;
var OPEN = 1;
var CLOSED = 2;
var AFTER_CR = -1;
var FIELD_START = 0;
var FIELD = 1;
var VALUE_START = 2;
var VALUE = 3;
var contentTypeRegExp = /^text\/event\-stream;?(\s*charset\=utf\-8)?$/i;
var MINIMUM_DURATION = 1000;
var MAXIMUM_DURATION = 18000000;

var parseDuration = function parseDuration(value, def) {
  var n = parseInt(value, 10);

  if (n !== n) {
    n = def;
  }

  return clampDuration(n);
};

var clampDuration = function clampDuration(n) {
  return Math.min(Math.max(n, MINIMUM_DURATION), MAXIMUM_DURATION);
};

var fire = function fire(that, f, event) {
  try {
    if (typeof f === 'function') {
      f.call(that, event);
    }
  } catch (e) {
    throwError(e);
  }
};

function EventSourcePolyfill(url, options) {
  EventTarget.call(this);
  this.onopen = undefined;
  this.onmessage = undefined;
  this.onerror = undefined;
  this.url = undefined;
  this.readyState = undefined;
  this.withCredentials = undefined;
  this._close = undefined;
  start(this, url, options);
}

_c11 = EventSourcePolyfill;
var isFetchSupported = _unfetch["default"] != undefined && Response != undefined && 'body' in Response.prototype;

function start(es, url, options) {
  url = String(url);
  var withCredentials = options != undefined && Boolean(options.withCredentials);
  var initialRetry = clampDuration(1000);
  var heartbeatTimeout = options != undefined && options.heartbeatTimeout != undefined ? parseDuration(options.heartbeatTimeout, 45000) : clampDuration(45000);
  var lastEventId = '';
  var retry = initialRetry;
  var wasActivity = false;
  var headers = options != undefined && options.headers != undefined ? JSON.parse(JSON.stringify(options.headers)) : undefined;
  var CurrentTransport = options != undefined && options.Transport != undefined ? options.Transport : XMLHttpRequest;
  var xhr = isFetchSupported && !(options != undefined && options.Transport != undefined) ? undefined : new XHRWrapper(new CurrentTransport());
  var transport = xhr == undefined ? new FetchTransport() : new XHRTransport();
  var cancelFunction = undefined;
  var timeout = 0;
  var currentState = WAITING;
  var dataBuffer = '';
  var lastEventIdBuffer = '';
  var eventTypeBuffer = '';
  var textBuffer = '';
  var state = FIELD_START;
  var fieldStart = 0;
  var valueStart = 0;

  var onStart = function onStart(status, statusText, contentType, headers, cancel) {
    if (currentState === CONNECTING) {
      cancelFunction = cancel;

      if (status === 200 && contentType != undefined && contentTypeRegExp.test(contentType)) {
        currentState = OPEN;
        wasActivity = true;
        retry = initialRetry;
        es.readyState = OPEN;
        var event = new ConnectionEvent('open', {
          status: status,
          statusText: statusText,
          headers: headers
        });
        es.dispatchEvent(event);
        fire(es, es.onopen, event);
      } else {
        var message = '';

        if (status !== 200) {
          if (statusText) {
            statusText = statusText.replace(/\s+/g, ' ');
          }

          message = "EventSource's response has a status " + status + ' ' + statusText + ' that is not 200. Aborting the connection.';
        } else {
          message = "EventSource's response has a Content-Type specifying an unsupported type: " + (contentType == undefined ? '-' : contentType.replace(/\s+/g, ' ')) + '. Aborting the connection.';
        }

        throwError(new Error(message));
        close();
        var event = new ConnectionEvent('error', {
          status: status,
          statusText: statusText,
          headers: headers
        });
        es.dispatchEvent(event);
        fire(es, es.onerror, event);
      }
    }
  };

  var onProgress = function onProgress(textChunk) {
    if (currentState === OPEN) {
      var n = -1;

      for (var i = 0; i < textChunk.length; i += 1) {
        var c = textChunk.charCodeAt(i);

        if (c === '\n'.charCodeAt(0) || c === '\r'.charCodeAt(0)) {
          n = i;
        }
      }

      var chunk = (n !== -1 ? textBuffer : '') + textChunk.slice(0, n + 1);
      textBuffer = (n === -1 ? textBuffer : '') + textChunk.slice(n + 1);

      if (chunk !== '') {
        wasActivity = true;
      }

      for (var position = 0; position < chunk.length; position += 1) {
        var c = chunk.charCodeAt(position);

        if (state === AFTER_CR && c === '\n'.charCodeAt(0)) {
          state = FIELD_START;
        } else {
          if (state === AFTER_CR) {
            state = FIELD_START;
          }

          if (c === '\r'.charCodeAt(0) || c === '\n'.charCodeAt(0)) {
            if (state !== FIELD_START) {
              if (state === FIELD) {
                valueStart = position + 1;
              }

              var field = chunk.slice(fieldStart, valueStart - 1);
              var value = chunk.slice(valueStart + (valueStart < position && chunk.charCodeAt(valueStart) === ' '.charCodeAt(0) ? 1 : 0), position);

              if (field === 'data') {
                dataBuffer += '\n';
                dataBuffer += value;
              } else if (field === 'id') {
                lastEventIdBuffer = value;
              } else if (field === 'event') {
                eventTypeBuffer = value;
              } else if (field === 'retry') {
                initialRetry = parseDuration(value, initialRetry);
                retry = initialRetry;
              } else if (field === 'heartbeatTimeout') {
                heartbeatTimeout = parseDuration(value, heartbeatTimeout);

                if (timeout !== 0) {
                  clearTimeout(timeout);
                  timeout = setTimeout(function () {
                    onTimeout();
                  }, heartbeatTimeout);
                }
              }
            }

            if (state === FIELD_START) {
              if (dataBuffer !== '') {
                lastEventId = lastEventIdBuffer;

                if (eventTypeBuffer === '') {
                  eventTypeBuffer = 'message';
                }

                var event = new MessageEvent(eventTypeBuffer, {
                  data: dataBuffer.slice(1),
                  lastEventId: lastEventIdBuffer
                });
                es.dispatchEvent(event);

                if (eventTypeBuffer === 'message') {
                  fire(es, es.onmessage, event);
                }

                if (currentState === CLOSED) {
                  return;
                }
              }

              dataBuffer = '';
              eventTypeBuffer = '';
            }

            state = c === '\r'.charCodeAt(0) ? AFTER_CR : FIELD_START;
          } else {
            if (state === FIELD_START) {
              fieldStart = position;
              state = FIELD;
            }

            if (state === FIELD) {
              if (c === ':'.charCodeAt(0)) {
                valueStart = position + 1;
                state = VALUE_START;
              }
            } else if (state === VALUE_START) {
              state = VALUE;
            }
          }
        }
      }
    }
  };

  var onFinish = function onFinish() {
    if (currentState === OPEN || currentState === CONNECTING) {
      currentState = WAITING;

      if (timeout !== 0) {
        clearTimeout(timeout);
        timeout = 0;
      }

      timeout = setTimeout(function () {
        onTimeout();
      }, retry);
      retry = clampDuration(Math.min(initialRetry * 16, retry * 2));
      es.readyState = CONNECTING;
      var event = new Event('error');
      es.dispatchEvent(event);
      fire(es, es.onerror, event);
    }
  };

  var close = function close() {
    currentState = CLOSED;

    if (cancelFunction != undefined) {
      cancelFunction();
      cancelFunction = undefined;
    }

    if (timeout !== 0) {
      clearTimeout(timeout);
      timeout = 0;
    }

    es.readyState = CLOSED;
  };

  var onTimeout = function onTimeout() {
    timeout = 0;

    if (currentState !== WAITING) {
      if (!wasActivity && cancelFunction != undefined) {
        throwError(new Error('No activity within ' + heartbeatTimeout + ' milliseconds. Reconnecting.'));
        cancelFunction();
        cancelFunction = undefined;
      } else {
        wasActivity = false;
        timeout = setTimeout(function () {
          onTimeout();
        }, heartbeatTimeout);
      }

      return;
    }

    wasActivity = false;
    timeout = setTimeout(function () {
      onTimeout();
    }, heartbeatTimeout);
    currentState = CONNECTING;
    dataBuffer = '';
    eventTypeBuffer = '';
    lastEventIdBuffer = lastEventId;
    textBuffer = '';
    fieldStart = 0;
    valueStart = 0;
    state = FIELD_START; // https://bugzilla.mozilla.org/show_bug.cgi?id=428916
    // Request header field Last-Event-ID is not allowed by Access-Control-Allow-Headers.

    var requestURL = url;

    if (url.slice(0, 5) !== 'data:' && url.slice(0, 5) !== 'blob:') {
      if (lastEventId !== '') {
        requestURL += (url.indexOf('?') === -1 ? '?' : '&') + 'lastEventId=' + encodeURIComponent(lastEventId);
      }
    }

    var requestHeaders = {};
    requestHeaders['Accept'] = 'text/event-stream';

    if (headers != undefined) {
      for (var name in headers) {
        if (Object.prototype.hasOwnProperty.call(headers, name)) {
          requestHeaders[name] = headers[name];
        }
      }
    }

    try {
      transport.open(xhr, onStart, onProgress, onFinish, requestURL, withCredentials, requestHeaders);
    } catch (error) {
      close();
      throw error;
    }
  };

  es.url = url;
  es.readyState = CONNECTING;
  es.withCredentials = withCredentials;
  es._close = close;
  onTimeout();
}

EventSourcePolyfill.prototype = Object.create(EventTarget.prototype);
EventSourcePolyfill.prototype.CONNECTING = CONNECTING;
EventSourcePolyfill.prototype.OPEN = OPEN;
EventSourcePolyfill.prototype.CLOSED = CLOSED;

EventSourcePolyfill.prototype.close = function () {
  this._close();
};

EventSourcePolyfill.CONNECTING = CONNECTING;
EventSourcePolyfill.OPEN = OPEN;
EventSourcePolyfill.CLOSED = CLOSED;
EventSourcePolyfill.prototype.withCredentials = undefined;
var _default = EventSourcePolyfill;
exports["default"] = _default;

var _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11;

$RefreshReg$(_c, "TextDecoderPolyfill");
$RefreshReg$(_c2, "XHRWrapper");
$RefreshReg$(_c3, "HeadersPolyfill");
$RefreshReg$(_c4, "XHRTransport");
$RefreshReg$(_c5, "HeadersWrapper");
$RefreshReg$(_c6, "FetchTransport");
$RefreshReg$(_c7, "EventTarget");
$RefreshReg$(_c8, "Event");
$RefreshReg$(_c9, "MessageEvent");
$RefreshReg$(_c10, "ConnectionEvent");
$RefreshReg$(_c11, "EventSourcePolyfill");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/fouc.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/dev/fouc.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.displayContent = displayContent;

function displayContent(callback) {
  // This is the fallback helper that removes Next.js' no-FOUC styles when
  // CSS mode is enabled. This only really activates if you haven't created
  // _any_ styles in your application yet.
  ;
  (window.requestAnimationFrame || setTimeout)(function () {
    for (var x = document.querySelectorAll('[data-next-hide-fouc]'), i = x.length; i--;) {
      x[i].parentNode.removeChild(x[i]);
    }

    if (callback) {
      callback();
    }
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/on-demand-entries-client.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/on-demand-entries-client.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _router = _interopRequireDefault(__webpack_require__(/*! next/router */ "./node_modules/next/dist/client/router.js"));

var _onDemandEntriesUtils = __webpack_require__(/*! ./on-demand-entries-utils */ "./node_modules/next/dist/client/dev/on-demand-entries-utils.js");

var _default = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {
    var assetPrefix;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            assetPrefix = _ref.assetPrefix;

            _router["default"].ready(function () {
              _router["default"].events.on('routeChangeComplete', _onDemandEntriesUtils.setupPing.bind(void 0, assetPrefix, function () {
                return _router["default"].pathname;
              }));
            });

            (0, _onDemandEntriesUtils.setupPing)(assetPrefix, function () {
              return _router["default"].pathname;
            }, _onDemandEntriesUtils.currentPage); // prevent HMR connection from being closed when running tests

            if (!undefined) {
              document.addEventListener('visibilitychange', function (event) {
                var state = document.visibilityState;

                if (state === 'visible') {
                  (0, _onDemandEntriesUtils.setupPing)(assetPrefix, function () {
                    return _router["default"].pathname;
                  }, true);
                } else {
                  (0, _onDemandEntriesUtils.closePing)();
                }
              });
              window.addEventListener('beforeunload', function () {
                (0, _onDemandEntriesUtils.closePing)();
              });
            }

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function _default(_x) {
    return _ref2.apply(this, arguments);
  };
}();

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/on-demand-entries-utils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/on-demand-entries-utils.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.closePing = closePing;
exports.setupPing = setupPing;
exports.currentPage = void 0;

var _unfetch = _interopRequireDefault(__webpack_require__(/*! next/dist/build/polyfills/unfetch */ "./node_modules/next/dist/build/polyfills/unfetch.js"));

var _eventsource = __webpack_require__(/*! ./error-overlay/eventsource */ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js");
/* global location */


var evtSource;
var currentPage;
exports.currentPage = currentPage;

function closePing() {
  if (evtSource) evtSource.close();
  evtSource = null;
}

function setupPing(assetPrefix, pathnameFn, retry) {
  var pathname = pathnameFn(); // Make sure to only create new EventSource request if page has changed

  if (pathname === currentPage && !retry) return;
  exports.currentPage = currentPage = pathname; // close current EventSource connection

  closePing();
  var url = assetPrefix + "/_next/webpack-hmr?page=" + currentPage;
  evtSource = (0, _eventsource.getEventSourceWrapper)({
    path: url,
    timeout: 5000,
    ondemand: 1
  });
  evtSource.addMessageListener(function (event) {
    if (event.data.indexOf('{') === -1) return;

    try {
      var payload = JSON.parse(event.data);

      if (payload.invalid) {
        // Payload can be invalid even if the page does not exist.
        // So, we need to make sure it exists before reloading.
        (0, _unfetch["default"])(location.href, {
          credentials: 'same-origin'
        }).then(function (pageRes) {
          if (pageRes.status === 200) {
            location.reload();
          }
        });
      }
    } catch (err) {
      console.error('on-demand-entries failed to parse response', err);
    }
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/prerender-indicator.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/prerender-indicator.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = initializeBuildWatcher;

var _router = _interopRequireDefault(__webpack_require__(/*! ../router */ "./node_modules/next/dist/client/router.js"));

function initializeBuildWatcher() {
  var shadowHost = document.createElement('div');
  shadowHost.id = '__next-prerender-indicator'; // Make sure container is fixed and on a high zIndex so it shows

  shadowHost.style.position = 'fixed';
  shadowHost.style.bottom = '20px';
  shadowHost.style.right = '10px';
  shadowHost.style.width = 0;
  shadowHost.style.height = 0;
  shadowHost.style.zIndex = 99998;
  shadowHost.style.transition = 'all 100ms ease';
  document.body.appendChild(shadowHost);
  var shadowRoot;
  var prefix = '';

  if (shadowHost.attachShadow) {
    shadowRoot = shadowHost.attachShadow({
      mode: 'open'
    });
  } else {
    // If attachShadow is undefined then the browser does not support
    // the Shadow DOM, we need to prefix all the names so there
    // will be no conflicts
    shadowRoot = shadowHost;
    prefix = '__next-prerender-indicator-';
  } // Container


  var container = createContainer(prefix);
  shadowRoot.appendChild(container); // CSS

  var css = createCss(prefix);
  shadowRoot.appendChild(css);
  var expandEl = container.querySelector('a');
  var closeEl = container.querySelector("#" + prefix + "close"); // State

  var dismissKey = '__NEXT_DISMISS_PRERENDER_INDICATOR';
  var dismissUntil = parseInt(window.localStorage.getItem(dismissKey), 10);
  var dismissed = dismissUntil > new Date().getTime();
  var isVisible = !dismissed && window.__NEXT_DATA__.nextExport;

  function updateContainer() {
    if (isVisible) {
      container.classList.add(prefix + "visible");
    } else {
      container.classList.remove(prefix + "visible");
    }
  }

  var expandedClass = prefix + "expanded";
  var toggleTimeout;

  var toggleExpand = function toggleExpand(expand) {
    if (expand === void 0) {
      expand = true;
    }

    clearTimeout(toggleTimeout);
    toggleTimeout = setTimeout(function () {
      if (expand) {
        expandEl.classList.add(expandedClass);
        closeEl.style.display = 'flex';
      } else {
        expandEl.classList.remove(expandedClass);
        closeEl.style.display = 'none';
      }
    }, 50);
  };

  closeEl.addEventListener('click', function () {
    var oneHourAway = new Date().getTime() + 1 * 60 * 60 * 1000;
    window.localStorage.setItem(dismissKey, oneHourAway + '');
    isVisible = false;
    updateContainer();
  });
  closeEl.addEventListener('mouseenter', function () {
    return toggleExpand();
  });
  closeEl.addEventListener('mouseleave', function () {
    return toggleExpand(false);
  });
  expandEl.addEventListener('mouseenter', function () {
    return toggleExpand();
  });
  expandEl.addEventListener('mouseleave', function () {
    return toggleExpand(false);
  });

  _router["default"].events.on('routeChangeComplete', function () {
    isVisible = window.next.isPrerendered;
    updateContainer();
  });

  updateContainer();
}

function createContainer(prefix) {
  var container = document.createElement('div');
  container.id = prefix + "container";
  container.innerHTML = "\n    <button id=\"" + prefix + "close\" title=\"Hide indicator for session\">\n      <span>\xD7</span>\n    </button>\n    <a href=\"https://nextjs.org/docs#automatic-static-optimization-indicator\" target=\"_blank\" rel=\"noreferrer\">\n      <div id=\"" + prefix + "icon-wrapper\">\n          <svg width=\"15\" height=\"20\" viewBox=\"0 0 60 80\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n          <path d=\"M36 3L30.74 41H8L36 3Z\" fill=\"black\"/>\n          <path d=\"M25 77L30.26 39H53L25 77Z\" fill=\"black\"/>\n          <path d=\"M13.5 33.5L53 39L47.5 46.5L7 41.25L13.5 33.5Z\" fill=\"black\"/>\n          </svg>\n          Prerendered Page\n      </div>\n    </a>\n  ";
  return container;
}

function createCss(prefix) {
  var css = document.createElement('style');
  css.textContent = "\n    #" + prefix + "container {\n      position: absolute;\n      display: none;\n      bottom: 10px;\n      right: 15px;\n    }\n\n    #" + prefix + "close {\n      top: -10px;\n      right: -10px;\n      border: none;\n      width: 18px;\n      height: 18px;\n      color: #333333;\n      font-size: 16px;\n      cursor: pointer;\n      display: none;\n      position: absolute;\n      background: #ffffff;\n      border-radius: 100%;\n      align-items: center;\n      flex-direction: column;\n      justify-content: center;\n    }\n\n    #" + prefix + "container a {\n      color: inherit;\n      text-decoration: none;\n      width: 15px;\n      height: 23px;\n      overflow: hidden;\n\n      border-radius: 3px;\n      background: #fff;\n      color: #000;\n      font: initial;\n      cursor: pointer;\n      letter-spacing: initial;\n      text-shadow: initial;\n      text-transform: initial;\n      visibility: initial;\n      font-size: 14px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n\n      padding: 4px 2px;\n      align-items: center;\n      box-shadow: 0 11px 40px 0 rgba(0, 0, 0, 0.25), 0 2px 10px 0 rgba(0, 0, 0, 0.12);\n\n      display: flex;\n      transition: opacity 0.1s ease, bottom 0.1s ease, width 0.3s ease;\n      animation: " + prefix + "fade-in 0.1s ease-in-out;\n    }\n\n    #" + prefix + "icon-wrapper {\n      width: 140px;\n      height: 20px;\n      display: flex;\n      flex-shrink: 0;\n      align-items: center;\n      position: relative;\n    }\n\n    #" + prefix + "icon-wrapper svg {\n      flex-shrink: 0;\n      margin-right: 3px;\n    }\n\n    #" + prefix + "container a." + prefix + "expanded {\n      width: 135px;\n    }\n\n    #" + prefix + "container." + prefix + "visible {\n      display: flex;\n      bottom: 10px;\n      opacity: 1;\n    }\n\n    @keyframes " + prefix + "fade-in {\n      from {\n        bottom: 0px;\n        opacity: 0;\n      }\n      to {\n        bottom: 10px;\n        opacity: 1;\n      }\n    }\n  ";
  return css;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _hotDevClient = _interopRequireDefault(__webpack_require__(/*! ./error-overlay/hot-dev-client */ "./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js"));

var _default = function _default(_ref) {
  var assetPrefix = _ref.assetPrefix;
  var options = {
    path: assetPrefix + "/_next/webpack-hmr"
  };
  var devClient = (0, _hotDevClient["default"])(options);
  devClient.subscribeToHmrEvent(function (obj) {
    if (obj.action === 'reloadPage') {
      return window.location.reload();
    }

    if (obj.action === 'removedPage') {
      var _obj$data = _slicedToArray(obj.data, 1),
          page = _obj$data[0];

      if (page === window.next.router.pathname) {
        return window.location.reload();
      }

      return;
    }

    if (obj.action === 'addedPage') {
      var _obj$data2 = _slicedToArray(obj.data, 1),
          _page = _obj$data2[0];

      if (_page === window.next.router.pathname && typeof window.next.router.components[_page] === 'undefined') {
        return window.location.reload();
      }

      return;
    }

    throw new Error('Unexpected action ' + obj.action);
  });
  return devClient;
};

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/head-manager.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/head-manager.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = initHeadManager;
var DOMAttributeNames = {
  acceptCharset: 'accept-charset',
  className: 'class',
  htmlFor: 'for',
  httpEquiv: 'http-equiv'
};

function reactElementToDOM(_ref) {
  var type = _ref.type,
      props = _ref.props;
  var el = document.createElement(type);

  for (var p in props) {
    if (!props.hasOwnProperty(p)) continue;
    if (p === 'children' || p === 'dangerouslySetInnerHTML') continue; // we don't render undefined props to the DOM

    if (props[p] === undefined) continue;
    var attr = DOMAttributeNames[p] || p.toLowerCase();
    el.setAttribute(attr, props[p]);
  }

  var children = props.children,
      dangerouslySetInnerHTML = props.dangerouslySetInnerHTML;

  if (dangerouslySetInnerHTML) {
    el.innerHTML = dangerouslySetInnerHTML.__html || '';
  } else if (children) {
    el.textContent = typeof children === 'string' ? children : children.join('');
  }

  return el;
}

function updateElements(type, components) {
  var headEl = document.getElementsByTagName('head')[0];
  var headCountEl = headEl.querySelector('meta[name=next-head-count]');

  if (true) {
    if (!headCountEl) {
      console.error('Warning: next-head-count is missing. https://err.sh/next.js/next-head-count-missing');
      return;
    }
  }

  var headCount = Number(headCountEl.content);
  var oldTags = [];

  for (var i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = j.previousElementSibling) {
    if (j.tagName.toLowerCase() === type) {
      oldTags.push(j);
    }
  }

  var newTags = components.map(reactElementToDOM).filter(function (newTag) {
    for (var k = 0, len = oldTags.length; k < len; k++) {
      var oldTag = oldTags[k];

      if (oldTag.isEqualNode(newTag)) {
        oldTags.splice(k, 1);
        return false;
      }
    }

    return true;
  });
  oldTags.forEach(function (t) {
    return t.parentNode.removeChild(t);
  });
  newTags.forEach(function (t) {
    return headEl.insertBefore(t, headCountEl);
  });
  headCountEl.content = (headCount - oldTags.length + newTags.length).toString();
}

function initHeadManager() {
  var updatePromise = null;
  return function (head) {
    var promise = updatePromise = Promise.resolve().then(function () {
      if (promise !== updatePromise) return;
      updatePromise = null;
      var tags = {};
      head.forEach(function (h) {
        var components = tags[h.type] || [];
        components.push(h);
        tags[h.type] = components;
      });
      var titleComponent = tags.title ? tags.title[0] : null;
      var title = '';

      if (titleComponent) {
        var children = titleComponent.props.children;
        title = typeof children === 'string' ? children : children.join('');
      }

      if (title !== document.title) document.title = title;
      ['meta', 'base', 'link', 'style', 'script'].forEach(function (type) {
        updateElements(type, tags[type] || []);
      });
    });
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _inherits = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");

var _possibleConstructorReturn = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");

var _getPrototypeOf = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var _interopRequireWildcard3 = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.render = render;
exports.renderError = renderError;
exports["default"] = exports.emitter = exports.router = exports.version = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js"));

var _interopRequireWildcard2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js"));

var _router = __webpack_require__(/*! next/router */ "./node_modules/next/dist/client/router.js");

var _querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js");

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"));

var _headManagerContext = __webpack_require__(/*! ../next-server/lib/head-manager-context */ "./node_modules/next/dist/next-server/lib/head-manager-context.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _isDynamic = __webpack_require__(/*! ../next-server/lib/router/utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var envConfig = _interopRequireWildcard3(__webpack_require__(/*! ../next-server/lib/runtime-config */ "./node_modules/next/dist/next-server/lib/runtime-config.js"));

var _utils = __webpack_require__(/*! ../next-server/lib/utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _headManager = _interopRequireDefault(__webpack_require__(/*! ./head-manager */ "./node_modules/next/dist/client/head-manager.js"));

var _pageLoader = _interopRequireDefault(__webpack_require__(/*! ./page-loader */ "./node_modules/next/dist/client/page-loader.js"));

var _performanceRelayer = _interopRequireDefault(__webpack_require__(/*! ./performance-relayer */ "./node_modules/next/dist/client/performance-relayer.js"));
/* global location */
/// <reference types="react-dom/experimental" />


if (!('finally' in Promise.prototype)) {
  // eslint-disable-next-line no-extend-native
  Promise.prototype["finally"] = __webpack_require__(/*! next/dist/build/polyfills/finally-polyfill.min */ "./node_modules/next/dist/build/polyfills/finally-polyfill.min.js");
}

var data = JSON.parse(document.getElementById('__NEXT_DATA__').textContent);
window.__NEXT_DATA__ = data;
var version = "9.4.1";
exports.version = version;
var props = data.props,
    err = data.err,
    page = data.page,
    query = data.query,
    buildId = data.buildId,
    assetPrefix = data.assetPrefix,
    runtimeConfig = data.runtimeConfig,
    dynamicIds = data.dynamicIds,
    isFallback = data.isFallback;
var prefix = assetPrefix || ''; // With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time
// So, this is how we do it in the client side at runtime

__webpack_require__.p = prefix + "/_next/"; //eslint-disable-line
// Initialize next/config with the environment configuration

envConfig.setConfig({
  serverRuntimeConfig: {},
  publicRuntimeConfig: runtimeConfig || {}
});
var asPath = (0, _utils.getURL)();
var pageLoader = new _pageLoader["default"](buildId, prefix);

var register = function register(_ref) {
  var _ref7 = _slicedToArray(_ref, 2),
      r = _ref7[0],
      f = _ref7[1];

  return pageLoader.registerPage(r, f);
};

if (window.__NEXT_P) {
  window.__NEXT_P.map(register);
}

window.__NEXT_P = [];
window.__NEXT_P.push = register;
var updateHead = (0, _headManager["default"])();
var appElement = document.getElementById('__next');
var lastAppProps;
var webpackHMR;
var router;
exports.router = router;
var ErrorComponent;
var Component;
var App, onPerfEntry;

var Container = /*#__PURE__*/function (_react$default$Compon) {
  _inherits(Container, _react$default$Compon);

  var _super = _createSuper(Container);

  function Container() {
    _classCallCheck(this, Container);

    return _super.apply(this, arguments);
  }

  _createClass(Container, [{
    key: "componentDidCatch",
    value: function componentDidCatch(err, info) {
      this.props.fn(err, info);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.scrollToHash();

      if (false) {} // We need to replace the router state if:
      // - the page was (auto) exported and has a query string or search (hash)
      // - it was auto exported and is a dynamic route (to provide params)
      // - if it is a client-side skeleton (fallback render)


      if (router.isSsr && (isFallback || data.nextExport && ((0, _isDynamic.isDynamicRoute)(router.pathname) || location.search) || props && props.__N_SSG && location.search)) {
        // update query on mount for exported pages
        router.replace(router.pathname + '?' + (0, _querystring.stringify)((0, _extends2["default"])((0, _extends2["default"])({}, router.query), (0, _querystring.parse)(location.search.substr(1)))), asPath, {
          // WARNING: `_h` is an internal option for handing Next.js
          // client-side hydration. Your app should _never_ use this property.
          // It may change at any time without notice.
          _h: 1,
          // Fallback pages must trigger the data fetch, so the transition is
          // not shallow.
          // Other pages (strictly updating query) happens shallowly, as data
          // requirements would already be present.
          shallow: !isFallback
        });
      }

      if (undefined) {
        window.__NEXT_HYDRATED = true;

        if (window.__NEXT_HYDRATED_CB) {
          window.__NEXT_HYDRATED_CB();
        }
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.scrollToHash();
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash() {
      var _location = location,
          hash = _location.hash;
      hash = hash && hash.substring(1);
      if (!hash) return;
      var el = document.getElementById(hash);
      if (!el) return; // If we call scrollIntoView() in here without a setTimeout
      // it won't scroll properly.

      setTimeout(function () {
        return el.scrollIntoView();
      }, 0);
    }
  }, {
    key: "render",
    value: function render() {
      if (false) {}

      if (true) {
        var _require = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ "./node_modules/@next/react-dev-overlay/lib/client.js"),
            ReactDevOverlay = _require.ReactDevOverlay;

        return /*#__PURE__*/_react["default"].createElement(ReactDevOverlay, null, this.props.children);
      }
    }
  }]);

  return Container;
}(_react["default"].Component);

var emitter = (0, _mitt["default"])();
exports.emitter = emitter;

var _default = /*#__PURE__*/function () {
  var _default2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_temp) {
    var _ref8, passedWebpackHMR, _yield$pageLoader$loa, app, mod, initialErr, _yield$pageLoader$loa2, _require2, isValidElementType, _require3, getNodeError, renderCtx;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _ref8 = _temp === void 0 ? {} : _temp, passedWebpackHMR = _ref8.webpackHMR; // This makes sure this specific lines are removed in production

            if (true) {
              webpackHMR = passedWebpackHMR;
            }

            _context.next = 4;
            return pageLoader.loadPageScript('/_app');

          case 4:
            _yield$pageLoader$loa = _context.sent;
            app = _yield$pageLoader$loa.page;
            mod = _yield$pageLoader$loa.mod;
            App = app;

            if (mod && mod.reportWebVitals) {
              onPerfEntry = function onPerfEntry(_ref2) {
                var id = _ref2.id,
                    name = _ref2.name,
                    startTime = _ref2.startTime,
                    value = _ref2.value,
                    duration = _ref2.duration,
                    entryType = _ref2.entryType,
                    entries = _ref2.entries; // Combines timestamp with random number for unique ID

                var uniqueID = Date.now() + "-" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);
                var perfStartEntry;

                if (entries && entries.length) {
                  perfStartEntry = entries[0].startTime;
                }

                mod.reportWebVitals({
                  id: id || uniqueID,
                  name: name,
                  startTime: startTime || perfStartEntry,
                  value: value == null ? duration : value,
                  label: entryType === 'mark' || entryType === 'measure' ? 'custom' : 'web-vital'
                });
              };
            }

            initialErr = err;
            _context.prev = 10;
            ;
            _context.next = 14;
            return pageLoader.loadPage(page);

          case 14:
            _yield$pageLoader$loa2 = _context.sent;
            Component = _yield$pageLoader$loa2.page;

            if (false) {}

            _require2 = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"), isValidElementType = _require2.isValidElementType;

            if (isValidElementType(Component)) {
              _context.next = 20;
              break;
            }

            throw new Error("The default export is not a React Component in page: \"" + page + "\"");

          case 20:
            _context.next = 25;
            break;

          case 22:
            _context.prev = 22;
            _context.t0 = _context["catch"](10);
            // This catches errors like throwing in the top level of a module
            initialErr = _context.t0;

          case 25:
            if (true) {
              _require3 = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ "./node_modules/@next/react-dev-overlay/lib/client.js"), getNodeError = _require3.getNodeError; // Server-side runtime errors need to be re-thrown on the client-side so
              // that the overlay is rendered.

              if (initialErr) {
                if (initialErr === err) {
                  setTimeout(function () {
                    var error;

                    try {
                      // Generate a new error object. We `throw` it because some browsers
                      // will set the `stack` when thrown, and we want to ensure ours is
                      // not overridden when we re-throw it below.
                      throw new Error(initialErr.message);
                    } catch (e) {
                      error = e;
                    }

                    error.name = initialErr.name;
                    error.stack = initialErr.stack;
                    var node = getNodeError(error);
                    throw node;
                  });
                } // We replaced the server-side error with a client-side error, and should
                // no longer rewrite the stack trace to a Node error.
                else {
                    setTimeout(function () {
                      throw initialErr;
                    });
                  }
              }
            }

            if (!window.__NEXT_PRELOADREADY) {
              _context.next = 29;
              break;
            }

            _context.next = 29;
            return window.__NEXT_PRELOADREADY(dynamicIds);

          case 29:
            exports.router = router = (0, _router.createRouter)(page, query, asPath, {
              initialProps: props,
              pageLoader: pageLoader,
              App: App,
              Component: Component,
              wrapApp: wrapApp,
              err: initialErr,
              isFallback: isFallback,
              subscription: function subscription(_ref3, App) {
                var Component = _ref3.Component,
                    props = _ref3.props,
                    err = _ref3.err;
                render({
                  App: App,
                  Component: Component,
                  props: props,
                  err: err
                });
              }
            }); // call init-client middleware

            if (false) {}

            renderCtx = {
              App: App,
              Component: Component,
              props: props,
              err: initialErr
            };

            if (true) {
              _context.next = 35;
              break;
            }

            render(renderCtx);
            return _context.abrupt("return", emitter);

          case 35:
            if (false) {}

            return _context.abrupt("return", {
              emitter: emitter,
              render: render,
              renderCtx: renderCtx
            });

          case 37:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[10, 22]]);
  }));

  function _default(_x) {
    return _default2.apply(this, arguments);
  }

  return _default;
}();

exports["default"] = _default;

function render(_x2) {
  return _render.apply(this, arguments);
} // This method handles all runtime and debug errors.
// 404 and 500 errors are special kind of errors
// and they are still handle via the main render method.


function _render() {
  _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(props) {
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!props.err) {
              _context2.next = 4;
              break;
            }

            _context2.next = 3;
            return renderError(props);

          case 3:
            return _context2.abrupt("return");

          case 4:
            _context2.prev = 4;
            _context2.next = 7;
            return doRender(props);

          case 7:
            _context2.next = 14;
            break;

          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](4);

            if (true) {
              // Ensure this error is displayed in the overlay in development
              setTimeout(function () {
                throw _context2.t0;
              });
            }

            _context2.next = 14;
            return renderError((0, _extends2["default"])((0, _extends2["default"])({}, props), {}, {
              err: _context2.t0
            }));

          case 14:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[4, 9]]);
  }));
  return _render.apply(this, arguments);
}

function renderError(props) {
  var App = props.App,
      err = props.err; // In development runtime errors are caught by our overlay
  // In production we catch runtime errors using componentDidCatch which will trigger renderError

  if (true) {
    // A Next.js rendering runtime error is always unrecoverable
    // FIXME: let's make this recoverable (error in GIP client-transition)
    webpackHMR.onUnrecoverableError(); // We need to render an empty <App> so that the `<ReactDevOverlay>` can
    // render itself.

    return doRender({
      App: function App() {
        return null;
      },
      props: {},
      Component: function Component() {
        return null;
      },
      err: null
    });
  }

  if (false) {} // Make sure we log the error to the console, otherwise users can't track down issues.


  console.error(err);
  return pageLoader.loadPage('/_error').then(function (_ref4) {
    var ErrorComponent = _ref4.page; // In production we do a normal render with the `ErrorComponent` as component.
    // If we've gotten here upon initial render, we can use the props from the server.
    // Otherwise, we need to call `getInitialProps` on `App` before mounting.

    var AppTree = wrapApp(App);
    var appCtx = {
      Component: ErrorComponent,
      AppTree: AppTree,
      router: router,
      ctx: {
        err: err,
        pathname: page,
        query: query,
        asPath: asPath,
        AppTree: AppTree
      }
    };
    return Promise.resolve(props.props ? props.props : (0, _utils.loadGetInitialProps)(App, appCtx)).then(function (initProps) {
      return doRender((0, _extends2["default"])((0, _extends2["default"])({}, props), {}, {
        err: err,
        Component: ErrorComponent,
        props: initProps
      }));
    });
  });
} // If hydrate does not exist, eg in preact.


var isInitialRender = typeof _reactDom["default"].hydrate === 'function';
var reactRoot = null;

function renderReactElement(reactEl, domEl) {
  if (false) { var opts; } else {
    // mark start of hydrate/render
    if (_utils.ST) {
      performance.mark('beforeRender');
    } // The check for `.hydrate` is there to support React alternatives like preact


    if (isInitialRender) {
      _reactDom["default"].hydrate(reactEl, domEl, markHydrateComplete);

      isInitialRender = false;

      if (onPerfEntry && _utils.ST) {
        (0, _performanceRelayer["default"])(onPerfEntry);
      }
    } else {
      _reactDom["default"].render(reactEl, domEl, markRenderComplete);
    }
  }
}

function markHydrateComplete() {
  if (!_utils.ST) return;
  performance.mark('afterHydrate'); // mark end of hydration

  performance.measure('Next.js-before-hydration', 'navigationStart', 'beforeRender');
  performance.measure('Next.js-hydration', 'beforeRender', 'afterHydrate');

  if (onPerfEntry) {
    performance.getEntriesByName('Next.js-hydration').forEach(onPerfEntry);
  }

  clearMarks();
}

function markRenderComplete() {
  if (!_utils.ST) return;
  performance.mark('afterRender'); // mark end of render

  var navStartEntries = performance.getEntriesByName('routeChange', 'mark');

  if (!navStartEntries.length) {
    return;
  }

  performance.measure('Next.js-route-change-to-render', navStartEntries[0].name, 'beforeRender');
  performance.measure('Next.js-render', 'beforeRender', 'afterRender');

  if (onPerfEntry) {
    performance.getEntriesByName('Next.js-render').forEach(onPerfEntry);
    performance.getEntriesByName('Next.js-route-change-to-render').forEach(onPerfEntry);
  }

  clearMarks();
  ['Next.js-route-change-to-render', 'Next.js-render'].forEach(function (measure) {
    return performance.clearMeasures(measure);
  });
}

function clearMarks() {
  ;
  ['beforeRender', 'afterHydrate', 'afterRender', 'routeChange'].forEach(function (mark) {
    return performance.clearMarks(mark);
  });
}

function AppContainer(_ref5) {
  var children = _ref5.children;
  return /*#__PURE__*/_react["default"].createElement(Container, {
    fn: function fn(error) {
      return renderError({
        App: App,
        err: error
      })["catch"](function (err) {
        return console.error('Error rendering page: ', err);
      });
    }
  }, /*#__PURE__*/_react["default"].createElement(_routerContext.RouterContext.Provider, {
    value: (0, _router.makePublicRouterInstance)(router)
  }, /*#__PURE__*/_react["default"].createElement(_headManagerContext.HeadManagerContext.Provider, {
    value: updateHead
  }, children)));
}

_c = AppContainer;

var wrapApp = function wrapApp(App) {
  return function (props) {
    var appProps = (0, _extends2["default"])((0, _extends2["default"])({}, props), {}, {
      Component: Component,
      err: err,
      router: router
    });
    return /*#__PURE__*/_react["default"].createElement(AppContainer, null, /*#__PURE__*/_react["default"].createElement(App, appProps));
  };
};

function doRender(_x3) {
  return _doRender.apply(this, arguments);
}

function _doRender() {
  _doRender = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref6) {
    var App, Component, props, err, _router2, pathname, _query, _asPath, AppTree, appCtx, appProps, elem;

    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            App = _ref6.App, Component = _ref6.Component, props = _ref6.props, err = _ref6.err; // Usual getInitialProps fetching is handled in next/router
            // this is for when ErrorComponent gets replaced by Component by HMR

            if (!(!props && Component && Component !== ErrorComponent && lastAppProps.Component === ErrorComponent)) {
              _context3.next = 8;
              break;
            }

            _router2 = router, pathname = _router2.pathname, _query = _router2.query, _asPath = _router2.asPath;
            AppTree = wrapApp(App);
            appCtx = {
              router: router,
              AppTree: AppTree,
              Component: ErrorComponent,
              ctx: {
                err: err,
                pathname: pathname,
                query: _query,
                asPath: _asPath,
                AppTree: AppTree
              }
            };
            _context3.next = 7;
            return (0, _utils.loadGetInitialProps)(App, appCtx);

          case 7:
            props = _context3.sent;

          case 8:
            Component = Component || lastAppProps.Component;
            props = props || lastAppProps.props;
            appProps = (0, _extends2["default"])((0, _extends2["default"])({}, props), {}, {
              Component: Component,
              err: err,
              router: router
            }); // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.

            lastAppProps = appProps;
            emitter.emit('before-reactdom-render', {
              Component: Component,
              ErrorComponent: ErrorComponent,
              appProps: appProps
            });
            elem = /*#__PURE__*/_react["default"].createElement(AppContainer, null, /*#__PURE__*/_react["default"].createElement(App, appProps)); // We catch runtime errors using componentDidCatch which will trigger renderError

            renderReactElement( false ? /*#__PURE__*/undefined : elem, appElement);
            emitter.emit('after-reactdom-render', {
              Component: Component,
              ErrorComponent: ErrorComponent,
              appProps: appProps
            });

          case 16:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _doRender.apply(this, arguments);
}

var _c;

$RefreshReg$(_c, "AppContainer");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/next-dev.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/next-dev.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var next = _interopRequireWildcard(__webpack_require__(/*! ./ */ "./node_modules/next/dist/client/index.js"));

var _eventSourcePolyfill = _interopRequireDefault(__webpack_require__(/*! ./dev/event-source-polyfill */ "./node_modules/next/dist/client/dev/event-source-polyfill.js"));

var _onDemandEntriesClient = _interopRequireDefault(__webpack_require__(/*! ./dev/on-demand-entries-client */ "./node_modules/next/dist/client/dev/on-demand-entries-client.js"));

var _webpackHotMiddlewareClient = _interopRequireDefault(__webpack_require__(/*! ./dev/webpack-hot-middleware-client */ "./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js"));

var _devBuildWatcher = _interopRequireDefault(__webpack_require__(/*! ./dev/dev-build-watcher */ "./node_modules/next/dist/client/dev/dev-build-watcher.js"));

var _prerenderIndicator = _interopRequireDefault(__webpack_require__(/*! ./dev/prerender-indicator */ "./node_modules/next/dist/client/dev/prerender-indicator.js"));

var _fouc = __webpack_require__(/*! ./dev/fouc */ "./node_modules/next/dist/client/dev/fouc.js");
/* globals import('./dev/noop'); */
// Temporary workaround for the issue described here:
// https://github.com/zeit/next.js/issues/3775#issuecomment-407438123
// The runtimeChunk doesn't have dynamic import handling code when there hasn't been a dynamic import
// The runtimeChunk can't hot reload itself currently to correct it when adding pages using on-demand-entries
// eslint-disable-next-line no-unused-expressions


__webpack_require__.e(/*! import() */ 0).then(__webpack_require__.t.bind(null, /*! ./dev/noop */ "./node_modules/next/dist/client/dev/noop.js", 7));
; // Support EventSource on Internet Explorer 11

if (!window.EventSource) {
  window.EventSource = _eventSourcePolyfill["default"];
}

var _window = window,
    assetPrefix = _window.__NEXT_DATA__.assetPrefix;
var prefix = assetPrefix || '';
var webpackHMR = (0, _webpackHotMiddlewareClient["default"])({
  assetPrefix: prefix
});
window.next = next;
(0, next["default"])({
  webpackHMR: webpackHMR
}).then(function (_ref) {
  var emitter = _ref.emitter,
      renderCtx = _ref.renderCtx,
      render = _ref.render;
  (0, _onDemandEntriesClient["default"])({
    assetPrefix: prefix
  });
  if (true) (0, _devBuildWatcher["default"])();

  if ( true && // disable by default in electron
  !(typeof process !== 'undefined' && 'electron' in process.versions)) {
    (0, _prerenderIndicator["default"])();
  } // delay rendering until after styles have been applied in development


  (0, _fouc.displayContent)(function () {
    render(renderCtx);
  });
  var lastScroll;
  emitter.on('before-reactdom-render', function (_ref2) {
    var Component = _ref2.Component,
        ErrorComponent = _ref2.ErrorComponent; // Remember scroll when ErrorComponent is being rendered to later restore it

    if (!lastScroll && Component === ErrorComponent) {
      var _window2 = window,
          pageXOffset = _window2.pageXOffset,
          pageYOffset = _window2.pageYOffset;
      lastScroll = {
        x: pageXOffset,
        y: pageYOffset
      };
    }
  });
  emitter.on('after-reactdom-render', function (_ref3) {
    var Component = _ref3.Component,
        ErrorComponent = _ref3.ErrorComponent;

    if (lastScroll && Component !== ErrorComponent) {
      // Restore scroll after ErrorComponent was replaced with a page component by HMR
      var _lastScroll = lastScroll,
          x = _lastScroll.x,
          y = _lastScroll.y;
      window.scroll(x, y);
      lastScroll = null;
    }
  });
})["catch"](function (err) {
  console.error('Error was not caught', err);
});

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/page-loader.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/page-loader.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _url = __webpack_require__(/*! url */ "./node_modules/native-url/dist/index.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _isDynamic = __webpack_require__(/*! ./../next-server/lib/router/utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _routeMatcher = __webpack_require__(/*! ./../next-server/lib/router/utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./../next-server/lib/router/utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

var _router = __webpack_require__(/*! ./../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js");

function hasRel(rel, link) {
  try {
    link = document.createElement('link');
    return link.relList.supports(rel);
  } catch (_unused) {}
}

var relPrefetch = hasRel('preload') && !hasRel('prefetch') ? // https://caniuse.com/#feat=link-rel-preload
// macOS and iOS (Safari does not support prefetch)
'preload' : // https://caniuse.com/#feat=link-rel-prefetch
// IE 11, Edge 12+, nearly all evergreen
'prefetch';
var hasNoModule = ('noModule' in document.createElement('script'));
/** @param {string} route */

function normalizeRoute(route) {
  if (route[0] !== '/') {
    throw new Error("Route name should start with a \"/\", got \"" + route + "\"");
  }

  route = route.replace(/\/index$/, '/');
  if (route === '/') return route;
  return route.replace(/\/$/, '');
}

function appendLink(href, rel, as) {
  return new Promise(function (res, rej, link) {
    link = document.createElement('link');
    link.crossOrigin = undefined;
    link.href = href;
    link.rel = rel;
    if (as) link.as = as;
    link.onload = res;
    link.onerror = rej;
    document.head.appendChild(link);
  });
}

var PageLoader = /*#__PURE__*/function () {
  function PageLoader(buildId, assetPrefix) {
    _classCallCheck(this, PageLoader);

    this.buildId = buildId;
    this.assetPrefix = assetPrefix;
    this.pageCache = {};
    this.pageRegisterEvents = (0, _mitt["default"])();
    this.loadingRoutes = {};

    if (false) {}
    /** @type {Promise<Set<string>>} */


    this.promisedSsgManifest = new Promise(function (resolve) {
      if (window.__SSG_MANIFEST) {
        resolve(window.__SSG_MANIFEST);
      } else {
        window.__SSG_MANIFEST_CB = function () {
          resolve(window.__SSG_MANIFEST);
        };
      }
    });
  } // Returns a promise for the dependencies for a particular route


  _createClass(PageLoader, [{
    key: "getDependencies",
    value: function getDependencies(route) {
      var _this = this;

      return this.promisedBuildManifest.then(function (man) {
        return man[route] && man[route].map(function (url) {
          return _this.assetPrefix + "/_next/" + encodeURI(url);
        }) || [];
      });
    }
    /**
    * @param {string} href the route href (file-system path)
    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes
    */

  }, {
    key: "getDataHref",
    value: function getDataHref(href, asPath) {
      var _this2 = this;

      var getHrefForSlug =
      /** @type string */
      function getHrefForSlug(path) {
        path = (0, _router.delBasePath)(path);
        return _this2.assetPrefix + "/_next/data/" + _this2.buildId + (path === '/' ? '/index' : path) + ".json";
      };

      var _ref2 = (0, _url.parse)(href, true),
          hrefPathname = _ref2.pathname,
          query = _ref2.query;

      var _ref3 = (0, _url.parse)(asPath),
          asPathname = _ref3.pathname;

      var route = normalizeRoute(hrefPathname);
      var isDynamic = (0, _isDynamic.isDynamicRoute)(route),
          interpolatedRoute;

      if (isDynamic) {
        var dynamicRegex = (0, _routeRegex.getRouteRegex)(route);
        var dynamicGroups = dynamicRegex.groups;
        var dynamicMatches = // Try to match the dynamic route against the asPath
        (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) || // Fall back to reading the values from the href
        // TODO: should this take priority; also need to change in the router.
        query;
        interpolatedRoute = route;

        if (!Object.keys(dynamicGroups).every(function (param) {
          var value = dynamicMatches[param];
          var repeat = dynamicGroups[param].repeat; // support single-level catch-all
          // TODO: more robust handling for user-error (passing `/`)

          if (repeat && !Array.isArray(value)) value = [value];
          return param in dynamicMatches && ( // Interpolate group into data URL if present
          interpolatedRoute = interpolatedRoute.replace("[" + (repeat ? '...' : '') + param + "]", repeat ? value.map(encodeURIComponent).join('/') : encodeURIComponent(value)));
        })) {
          interpolatedRoute = ''; // did not satisfy all requirements
          // n.b. We ignore this error because we handle warning for this case in
          // development in the `<Link>` component directly.
        }
      }

      return isDynamic ? interpolatedRoute && getHrefForSlug(interpolatedRoute) : getHrefForSlug(route);
    }
    /**
    * @param {string} href the route href (file-system path)
    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes
    */

  }, {
    key: "prefetchData",
    value: function prefetchData(href, asPath) {
      var _this3 = this;

      var _ref4 = (0, _url.parse)(href, true),
          hrefPathname = _ref4.pathname;

      var route = normalizeRoute(hrefPathname);
      return this.promisedSsgManifest.then(function (s, _dataHref) {
        return (// Check if the route requires a data file
          s.has(route) && ( // Try to generate data href, noop when falsy
          _dataHref = _this3.getDataHref(href, asPath)) && // noop when data has already been prefetched (dedupe)
          !document.querySelector("link[rel=\"" + relPrefetch + "\"][href^=\"" + _dataHref + "\"]") && // Inject the `<link rel=prefetch>` tag for above computed `href`.
          appendLink(_dataHref, relPrefetch, 'fetch')
        );
      });
    }
  }, {
    key: "loadPage",
    value: function loadPage(route) {
      return this.loadPageScript(route);
    }
  }, {
    key: "loadPageScript",
    value: function loadPageScript(route) {
      var _this4 = this;

      route = normalizeRoute(route);
      return new Promise(function (resolve, reject) {
        var fire = function fire(_ref) {
          var error = _ref.error,
              page = _ref.page,
              mod = _ref.mod;

          _this4.pageRegisterEvents.off(route, fire);

          delete _this4.loadingRoutes[route];

          if (error) {
            reject(error);
          } else {
            resolve({
              page: page,
              mod: mod
            });
          }
        }; // If there's a cached version of the page, let's use it.


        var cachedPage = _this4.pageCache[route];

        if (cachedPage) {
          var error = cachedPage.error,
              page = cachedPage.page,
              mod = cachedPage.mod;
          error ? reject(error) : resolve({
            page: page,
            mod: mod
          });
          return;
        } // Register a listener to get the page


        _this4.pageRegisterEvents.on(route, fire); // If the page is loading via SSR, we need to wait for it
        // rather downloading it again.


        if (document.querySelector("script[data-next-page=\"" + route + "\"]")) {
          return;
        }

        if (!_this4.loadingRoutes[route]) {
          _this4.loadingRoutes[route] = true;

          if (false) {} else {
            _this4.loadRoute(route);
          }
        }
      });
    }
  }, {
    key: "loadRoute",
    value: function loadRoute(route) {
      route = normalizeRoute(route);
      var scriptRoute = route === '/' ? '/index.js' : route + ".js";
      var url = this.assetPrefix + "/_next/static/" + encodeURIComponent(this.buildId) + "/pages" + encodeURI(scriptRoute);
      this.loadScript(url, route, true);
    }
  }, {
    key: "loadScript",
    value: function loadScript(url, route, isPage) {
      var _this5 = this;

      var script = document.createElement('script');

      if (false) {}

      script.crossOrigin = undefined;
      script.src = url;

      script.onerror = function () {
        var error = new Error("Error loading script " + url);
        error.code = 'PAGE_LOAD_ERROR';

        _this5.pageRegisterEvents.emit(route, {
          error: error
        });
      };

      document.body.appendChild(script);
    } // This method if called by the route code.

  }, {
    key: "registerPage",
    value: function registerPage(route, regFn) {
      var _this6 = this;

      var register = function register() {
        try {
          var mod = regFn();
          var pageData = {
            page: mod["default"] || mod,
            mod: mod
          };
          _this6.pageCache[route] = pageData;

          _this6.pageRegisterEvents.emit(route, pageData);
        } catch (error) {
          _this6.pageCache[route] = {
            error: error
          };

          _this6.pageRegisterEvents.emit(route, {
            error: error
          });
        }
      };

      if (true) {
        // Wait for webpack to become idle if it's not.
        // More info: https://github.com/zeit/next.js/pull/1511
        if ( true && module.hot.status() !== 'idle') {
          console.log("Waiting for webpack to become \"idle\" to initialize the page: \"" + route + "\"");

          var check = function check(status) {
            if (status === 'idle') {
              module.hot.removeStatusHandler(check);
              register();
            }
          };

          module.hot.status(check);
          return;
        }
      }

      register();
    }
    /**
    * @param {string} route
    * @param {boolean} [isDependency]
    */

  }, {
    key: "prefetch",
    value: function prefetch(route, isDependency) {
      var _this7 = this;

      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118
      // License: Apache 2.0
      var cn;

      if (cn = navigator.connection) {
        // Don't prefetch if using 2G or if Save-Data is enabled.
        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();
      }
      /** @type {string} */


      var url;

      if (isDependency) {
        url = route;
      } else {
        route = normalizeRoute(route);
        var scriptRoute = (route === '/' ? '/index' : route) + ".js";

        if (false) {}

        url = this.assetPrefix + "/_next/static/" + encodeURIComponent(this.buildId) + "/pages" + encodeURI(scriptRoute);
      }

      return Promise.all(document.querySelector("link[rel=\"" + relPrefetch + "\"][href^=\"" + url + "\"], script[data-next-page=\"" + route + "\"]") ? [] : [appendLink(url, relPrefetch, url.match(/\.css$/) ? 'style' : 'script'),  false && false]).then( // do not return any data
      function () {}, // swallow prefetch errors
      function () {});
    }
  }]);

  return PageLoader;
}();

exports["default"] = PageLoader;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/performance-relayer.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/client/performance-relayer.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = void 0;

var _webVitals = __webpack_require__(/*! web-vitals */ "./node_modules/web-vitals/dist/web-vitals.es5.min.js");

var _default = function _default(onPerfEntry) {
  (0, _webVitals.getCLS)(onPerfEntry);
  (0, _webVitals.getFID)(onPerfEntry);
  (0, _webVitals.getFCP)(onPerfEntry);
  (0, _webVitals.getLCP)(onPerfEntry);
  (0, _webVitals.getTTFB)(onPerfEntry);
};

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _construct = __webpack_require__(/*! @babel/runtime/helpers/construct */ "./node_modules/@babel/runtime/helpers/construct.js");

var _s = $RefreshSig$();

function _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2["default"];
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter["default"];
/* global window */

var singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],
  ready: function ready(cb) {
    if (this.router) return cb();

    if (true) {
      this.readyCallbacks.push(cb);
    }
  }
}; // Create public properties and methods of the router in the singletonRouter

var urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath'];
var routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
var coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get: function get() {
    return _router2["default"].events;
  }
});
urlPropertyFields.forEach(function (field) {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get: function get() {
      var router = getRouter();
      return router[field];
    }
  });
});
coreMethodFields.forEach(function (field) {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = function () {
    var router = getRouter();
    return router[field].apply(router, arguments);
  };
});
routerEvents.forEach(function (event) {
  singletonRouter.ready(function () {
    _router2["default"].events.on(event, function () {
      var eventField = "on" + event.charAt(0).toUpperCase() + event.substring(1);
      var _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField].apply(_singletonRouter, arguments);
        } catch (err) {
          // tslint:disable-next-line:no-console
          console.error("Error when running the Router event: " + eventField); // tslint:disable-next-line:no-console

          console.error(err.message + "\n" + err.stack);
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    var message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports["default"] = _default;

function useRouter() {
  _s();

  return _react["default"].useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


_s(useRouter, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

var createRouter = function createRouter() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  singletonRouter.router = _construct(_router2["default"], args);
  singletonRouter.readyCallbacks.forEach(function (cb) {
    return cb();
  });
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  var _router = router;
  var instance = {};

  var _iterator = _createForOfIteratorHelper(urlPropertyFields),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var property = _step.value;

      if (typeof _router[property] === 'object') {
        instance[property] = Object.assign({}, _router[property]); // makes sure query is not stateful

        continue;
      }

      instance[property] = _router[property];
    } // Events is a static property on the router, the router doesn't have to be initialized to use it

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  instance.events = _router2["default"].events;
  coreMethodFields.forEach(function (field) {
    instance[field] = function () {
      return _router[field].apply(_router, arguments);
    };
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react["default"].createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    var name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = "withRouter(" + name + ")";
  }

  return WithRouterWrapper;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/compiled/strip-ansi/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/strip-ansi/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__dirname, module) {module.exports = function (e, r) {
  "use strict";

  var t = {};

  function __webpack_require__(r) {
    if (t[r]) {
      return t[r].exports;
    }

    var n = t[r] = {
      i: r,
      l: false,
      exports: {}
    };
    e[r].call(n.exports, n, n.exports, __webpack_require__);
    n.l = true;
    return n.exports;
  }

  __webpack_require__.ab = __dirname + "/";

  function startup() {
    return __webpack_require__(855);
  }

  return startup();
}({
  849: function _(e) {
    "use strict";

    e.exports = function () {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$onlyFirst = _ref.onlyFirst,
          e = _ref$onlyFirst === void 0 ? false : _ref$onlyFirst;

      var r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(r, e ? undefined : "g");
    };
  },
  855: function _(e, r, t) {
    "use strict";

    var n = t(849);

    e.exports = function (e) {
      return typeof e === "string" ? e.replace(n(), "") : e;
    };
  }
});

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, "/", __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head-manager-context.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head-manager-context.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

exports.HeadManagerContext = React.createContext(null);

if (true) {
  exports.HeadManagerContext.displayName = 'HeadManagerContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
/*
MIT License

Copyright (c) Jason Miller (https://jasonformat.com/)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

Object.defineProperty(exports, "__esModule", {
  value: true
});

function mitt() {
  var all = Object.create(null);
  return {
    on: function on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },
    off: function off(type, handler) {
      if (all[type]) {
        // tslint:disable-next-line:no-bitwise
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },
    emit: function emit(type) {
      for (var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        evts[_key - 1] = arguments[_key];
      }

      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(function (handler) {
        handler.apply(void 0, evts);
      });
    }
  };
}

exports["default"] = mitt;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router-context.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router-context.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

exports.RouterContext = React.createContext(null);

if (true) {
  exports.RouterContext.displayName = 'RouterContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var url_1 = __webpack_require__(/*! url */ "./node_modules/native-url/dist/index.js");

var mitt_1 = __importDefault(__webpack_require__(/*! ../mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var is_dynamic_1 = __webpack_require__(/*! ./utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var route_matcher_1 = __webpack_require__(/*! ./utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var route_regex_1 = __webpack_require__(/*! ./utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

var basePath =  false || '';

function addBasePath(path) {
  return path.indexOf(basePath) !== 0 ? basePath + path : path;
}

exports.addBasePath = addBasePath;

function delBasePath(path) {
  return path.indexOf(basePath) === 0 ? path.substr(basePath.length) || '/' : path;
}

exports.delBasePath = delBasePath;

function toRoute(path) {
  return path.replace(/\/$/, '') || '/';
}

var prepareRoute = function prepareRoute(path) {
  return toRoute(!path || path === '/' ? '/index' : path);
};

function fetchNextData(pathname, query, isServerRender, cb) {
  var attempts = isServerRender ? 3 : 1;

  function getResponse() {
    return fetch(utils_1.formatWithValidation({
      pathname: addBasePath( // @ts-ignore __NEXT_DATA__
      "/_next/data/".concat(__NEXT_DATA__.buildId).concat(delBasePath(pathname), ".json")),
      query: query
    }), {
      // Cookies are required to be present for Next.js' SSG "Preview Mode".
      // Cookies may also be required for `getServerSideProps`.
      //
      // > `fetch` wont send cookies, unless you set the credentials init
      // > option.
      // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
      //
      // > For maximum browser compatibility when it comes to sending &
      // > receiving cookies, always supply the `credentials: 'same-origin'`
      // > option instead of relying on the default.
      // https://github.com/github/fetch#caveats
      credentials: 'same-origin'
    }).then(function (res) {
      if (!res.ok) {
        if (--attempts > 0 && res.status >= 500) {
          return getResponse();
        }

        throw new Error("Failed to load static props");
      }

      return res.json();
    });
  }

  return getResponse().then(function (data) {
    return cb ? cb(data) : data;
  })["catch"](function (err) {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      ;
      err.code = 'PAGE_LOAD_ERROR';
    }

    throw err;
  });
}

var Router = /*#__PURE__*/function () {
  function Router(pathname, query, as, _ref) {
    var _this = this;

    var initialProps = _ref.initialProps,
        pageLoader = _ref.pageLoader,
        App = _ref.App,
        wrapApp = _ref.wrapApp,
        Component = _ref.Component,
        err = _ref.err,
        subscription = _ref.subscription,
        isFallback = _ref.isFallback;

    _classCallCheck(this, Router);

    // Static Data Cache
    this.sdc = {};

    this.onPopState = function (e) {
      if (!e.state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        var _pathname = _this.pathname,
            _query = _this.query;

        _this.changeState('replaceState', utils_1.formatWithValidation({
          pathname: _pathname,
          query: _query
        }), utils_1.getURL());

        return;
      } // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site


      if (e.state && _this.isSsr && e.state.as === _this.asPath && url_1.parse(e.state.url).pathname === _this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (_this._bps && !_this._bps(e.state)) {
        return;
      }

      var _e$state = e.state,
          url = _e$state.url,
          as = _e$state.as,
          options = _e$state.options;

      if (true) {
        if (typeof url === 'undefined' || typeof as === 'undefined') {
          console.warn('`popstate` event triggered but `event.state` did not have `url` or `as` https://err.sh/zeit/next.js/popstate-state-empty');
        }
      }

      _this.replace(url, as, options);
    };

    this._getStaticData = function (asPath) {
      var pathname = prepareRoute(url_1.parse(asPath).pathname);
      return  false ? undefined : fetchNextData(pathname, null, _this.isSsr, function (data) {
        return _this.sdc[pathname] = data;
      });
    };

    this._getServerData = function (asPath) {
      var _url_1$parse = url_1.parse(asPath, true),
          pathname = _url_1$parse.pathname,
          query = _url_1$parse.query;

      pathname = prepareRoute(pathname);
      return fetchNextData(pathname, query, _this.isSsr);
    }; // represents the current component key


    this.route = toRoute(pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (pathname !== '/_error') {
      this.components[this.route] = {
        Component: Component,
        props: initialProps,
        err: err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = pathname;
    this.query = query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    this.asPath = // @ts-ignore this is temporarily global (attached to window)
    is_dynamic_1.isDynamicRoute(pathname) && __NEXT_DATA__.autoExport ? pathname : as;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (as.substr(0, 2) !== '//') {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState('replaceState', utils_1.formatWithValidation({
          pathname: pathname,
          query: query
        }), as);
      }

      window.addEventListener('popstate', this.onPopState);
    }
  } // @deprecated backwards compatibility even though it's a private method.


  _createClass(Router, [{
    key: "update",
    value: function update(route, mod) {
      var Component = mod["default"] || mod;
      var data = this.components[route];

      if (!data) {
        throw new Error("Cannot update unavailable route: ".concat(route));
      }

      var newData = Object.assign(Object.assign({}, data), {
        Component: Component,
        __N_SSG: mod.__N_SSG,
        __N_SSP: mod.__N_SSP
      });
      this.components[route] = newData; // pages/_app.js updated

      if (route === '/_app') {
        this.notify(this.components[this.route]);
        return;
      }

      if (route === this.route) {
        this.notify(newData);
      }
    }
  }, {
    key: "reload",
    value: function reload() {
      window.location.reload();
    }
    /**
     * Go back in history
     */

  }, {
    key: "back",
    value: function back() {
      window.history.back();
    }
    /**
     * Performs a `pushState` with arguments
     * @param url of the route
     * @param as masks `url` for the browser
     * @param options object you can define `shallow` and other options
     */

  }, {
    key: "push",
    value: function push(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.change('pushState', url, as, options);
    }
    /**
     * Performs a `replaceState` with arguments
     * @param url of the route
     * @param as masks `url` for the browser
     * @param options object you can define `shallow` and other options
     */

  }, {
    key: "replace",
    value: function replace(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.change('replaceState', url, as, options);
    }
  }, {
    key: "change",
    value: function change(method, _url, _as, options) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (!options._h) {
          _this2.isSsr = false;
        } // marking route changes as a navigation start entry


        if (utils_1.ST) {
          performance.mark('routeChange');
        } // If url and as provided as an object representation,
        // we'll format them into the string version here.


        var url = typeof _url === 'object' ? utils_1.formatWithValidation(_url) : _url;
        var as = typeof _as === 'object' ? utils_1.formatWithValidation(_as) : _as;
        url = addBasePath(url);
        as = addBasePath(as); // Add the ending slash to the paths. So, we can serve the
        // "<page>/index.html" directly for the SSR page.

        if (false) { var rewriteUrlForNextExport; }

        _this2.abortComponentLoad(as); // If the url change is only related to a hash change
        // We should not proceed. We should only change the state.
        // WARNING: `_h` is an internal option for handing Next.js client-side
        // hydration. Your app should _never_ use this property. It may change at
        // any time without notice.


        if (!options._h && _this2.onlyAHashChange(as)) {
          _this2.asPath = as;
          Router.events.emit('hashChangeStart', as);

          _this2.changeState(method, url, as, options);

          _this2.scrollToHash(as);

          Router.events.emit('hashChangeComplete', as);
          return resolve(true);
        }

        var _url_1$parse2 = url_1.parse(url, true),
            pathname = _url_1$parse2.pathname,
            query = _url_1$parse2.query,
            protocol = _url_1$parse2.protocol;

        if (!pathname || protocol) {
          if (true) {
            throw new Error("Invalid href passed to router: ".concat(url, " https://err.sh/zeit/next.js/invalid-href-passed"));
          }

          return resolve(false);
        } // If asked to change the current URL we should reload the current page
        // (not location.reload() but reload getInitialProps and other Next.js stuffs)
        // We also need to set the method = replaceState always
        // as this should not go into the history (That's how browsers work)
        // We should compare the new asPath to the current asPath, not the url


        if (!_this2.urlIsNew(as)) {
          method = 'replaceState';
        }

        var route = toRoute(pathname);
        var _options$shallow = options.shallow,
            shallow = _options$shallow === void 0 ? false : _options$shallow;

        if (is_dynamic_1.isDynamicRoute(route)) {
          var _url_1$parse3 = url_1.parse(as),
              asPathname = _url_1$parse3.pathname;

          var routeRegex = route_regex_1.getRouteRegex(route);
          var routeMatch = route_matcher_1.getRouteMatcher(routeRegex)(asPathname);

          if (!routeMatch) {
            var missingParams = Object.keys(routeRegex.groups).filter(function (param) {
              return !query[param];
            });

            if (missingParams.length > 0) {
              if (true) {
                console.warn("Mismatching `as` and `href` failed to manually provide " + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
              }

              return reject(new Error("The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ") + "Read more: https://err.sh/zeit/next.js/incompatible-href-as"));
            }
          } else {
            // Merge params into `query`, overwriting any specified in search
            Object.assign(query, routeMatch);
          }
        }

        Router.events.emit('routeChangeStart', as); // If shallow is true and the route exists in the router cache we reuse the previous result

        _this2.getRouteInfo(route, pathname, query, as, shallow).then(function (routeInfo) {
          var error = routeInfo.error;

          if (error && error.cancelled) {
            return resolve(false);
          }

          Router.events.emit('beforeHistoryChange', as);

          _this2.changeState(method, url, as, options);

          if (true) {
            var appComp = _this2.components['/_app'].Component;
            window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
          }

          _this2.set(route, pathname, query, as, routeInfo);

          if (error) {
            Router.events.emit('routeChangeError', error, as);
            throw error;
          }

          Router.events.emit('routeChangeComplete', as);
          return resolve(true);
        }, reject);
      });
    }
  }, {
    key: "changeState",
    value: function changeState(method, url, as) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (true) {
        if (typeof window.history === 'undefined') {
          console.error("Warning: window.history is not available.");
          return;
        }

        if (typeof window.history[method] === 'undefined') {
          console.error("Warning: window.history.".concat(method, " is not available"));
          return;
        }
      }

      if (method !== 'pushState' || utils_1.getURL() !== as) {
        window.history[method]({
          url: url,
          as: as,
          options: options
        }, // Most browsers currently ignores this parameter, although they may use it in the future.
        // Passing the empty string here should be safe against future changes to the method.
        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
        '', as);
      }
    }
  }, {
    key: "getRouteInfo",
    value: function getRouteInfo(route, pathname, query, as) {
      var _this3 = this;

      var shallow = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var cachedRouteInfo = this.components[route]; // If there is a shallow route transition possible
      // If the route is already rendered on the screen.

      if (shallow && cachedRouteInfo && this.route === route) {
        return Promise.resolve(cachedRouteInfo);
      }

      var handleError = function handleError(err, loadErrorFail) {
        return new Promise(function (resolve) {
          if (err.code === 'PAGE_LOAD_ERROR' || loadErrorFail) {
            // If we can't load the page it could be one of following reasons
            //  1. Page doesn't exists
            //  2. Page does exist in a different zone
            //  3. Internal error while loading the page
            // So, doing a hard reload is the proper way to deal with this.
            window.location.href = as; // Changing the URL doesn't block executing the current code path.
            // So, we need to mark it as a cancelled error and stop the routing logic.

            err.cancelled = true; // @ts-ignore TODO: fix the control flow here

            return resolve({
              error: err
            });
          }

          if (err.cancelled) {
            // @ts-ignore TODO: fix the control flow here
            return resolve({
              error: err
            });
          }

          resolve(_this3.fetchComponent('/_error').then(function (res) {
            var Component = res.page;
            var routeInfo = {
              Component: Component,
              err: err
            };
            return new Promise(function (resolve) {
              _this3.getInitialProps(Component, {
                err: err,
                pathname: pathname,
                query: query
              }).then(function (props) {
                routeInfo.props = props;
                routeInfo.error = err;
                resolve(routeInfo);
              }, function (gipErr) {
                console.error('Error in error page `getInitialProps`: ', gipErr);
                routeInfo.error = err;
                routeInfo.props = {};
                resolve(routeInfo);
              });
            });
          })["catch"](function (err) {
            return handleError(err, true);
          }));
        });
      };

      return new Promise(function (resolve, reject) {
        if (cachedRouteInfo) {
          return resolve(cachedRouteInfo);
        }

        _this3.fetchComponent(route).then(function (res) {
          return resolve({
            Component: res.page,
            __N_SSG: res.mod.__N_SSG,
            __N_SSP: res.mod.__N_SSP
          });
        }, reject);
      }).then(function (routeInfo) {
        var Component = routeInfo.Component,
            __N_SSG = routeInfo.__N_SSG,
            __N_SSP = routeInfo.__N_SSP;

        if (true) {
          var _require = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"),
              isValidElementType = _require.isValidElementType;

          if (!isValidElementType(Component)) {
            throw new Error("The default export is not a React Component in page: \"".concat(pathname, "\""));
          }
        }

        return _this3._getData(function () {
          return __N_SSG ? _this3._getStaticData(as) : __N_SSP ? _this3._getServerData(as) : _this3.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
          {
            pathname: pathname,
            query: query,
            asPath: as
          });
        }).then(function (props) {
          routeInfo.props = props;
          _this3.components[route] = routeInfo;
          return routeInfo;
        });
      })["catch"](handleError);
    }
  }, {
    key: "set",
    value: function set(route, pathname, query, as, data) {
      this.isFallback = false;
      this.route = route;
      this.pathname = pathname;
      this.query = query;
      this.asPath = as;
      this.notify(data);
    }
    /**
     * Callback to execute before replacing router state
     * @param cb callback to be executed
     */

  }, {
    key: "beforePopState",
    value: function beforePopState(cb) {
      this._bps = cb;
    }
  }, {
    key: "onlyAHashChange",
    value: function onlyAHashChange(as) {
      if (!this.asPath) return false;

      var _this$asPath$split = this.asPath.split('#'),
          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),
          oldUrlNoHash = _this$asPath$split2[0],
          oldHash = _this$asPath$split2[1];

      var _as$split = as.split('#'),
          _as$split2 = _slicedToArray(_as$split, 2),
          newUrlNoHash = _as$split2[0],
          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same


      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
        return true;
      } // If the urls are change, there's more than a hash change


      if (oldUrlNoHash !== newUrlNoHash) {
        return false;
      } // If the hash has changed, then it's a hash only change.
      // This check is necessary to handle both the enter and
      // leave hash === '' cases. The identity case falls through
      // and is treated as a next reload.


      return oldHash !== newHash;
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash(as) {
      var _as$split3 = as.split('#'),
          _as$split4 = _slicedToArray(_as$split3, 2),
          hash = _as$split4[1]; // Scroll to top if the hash is just `#` with no value


      if (hash === '') {
        window.scrollTo(0, 0);
        return;
      } // First we check if the element by id is found


      var idEl = document.getElementById(hash);

      if (idEl) {
        idEl.scrollIntoView();
        return;
      } // If there's no element with the id, we check the `name` property
      // To mirror browsers


      var nameEl = document.getElementsByName(hash)[0];

      if (nameEl) {
        nameEl.scrollIntoView();
      }
    }
  }, {
    key: "urlIsNew",
    value: function urlIsNew(asPath) {
      return this.asPath !== asPath;
    }
    /**
     * Prefetch page code, you may wait for the data during page rendering.
     * This feature only works in production!
     * @param url the href of prefetched page
     * @param asPath the as path of the prefetched page
     */

  }, {
    key: "prefetch",
    value: function prefetch(url) {
      var _this4 = this;

      var asPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return new Promise(function (resolve, reject) {
        var _url_1$parse4 = url_1.parse(url),
            pathname = _url_1$parse4.pathname,
            protocol = _url_1$parse4.protocol;

        if (!pathname || protocol) {
          if (true) {
            throw new Error("Invalid href passed to router: ".concat(url, " https://err.sh/zeit/next.js/invalid-href-passed"));
          }

          return;
        } // Prefetch is not supported in development mode because it would trigger on-demand-entries


        if (true) {
          return;
        }

        var route = delBasePath(toRoute(pathname));
        Promise.all([_this4.pageLoader.prefetchData(url, delBasePath(asPath)), _this4.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]).then(function () {
          return resolve();
        }, reject);
      });
    }
  }, {
    key: "fetchComponent",
    value: function () {
      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(route) {
        var cancelled, cancel, componentResult, error;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cancelled = false;

                cancel = this.clc = function () {
                  cancelled = true;
                };

                route = delBasePath(route);
                _context.next = 5;
                return this.pageLoader.loadPage(route);

              case 5:
                componentResult = _context.sent;

                if (!cancelled) {
                  _context.next = 10;
                  break;
                }

                error = new Error("Abort fetching component for route: \"".concat(route, "\""));
                error.cancelled = true;
                throw error;

              case 10:
                if (cancel === this.clc) {
                  this.clc = null;
                }

                return _context.abrupt("return", componentResult);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function fetchComponent(_x) {
        return _fetchComponent.apply(this, arguments);
      }

      return fetchComponent;
    }()
  }, {
    key: "_getData",
    value: function _getData(fn) {
      var _this5 = this;

      var cancelled = false;

      var cancel = function cancel() {
        cancelled = true;
      };

      this.clc = cancel;
      return fn().then(function (data) {
        if (cancel === _this5.clc) {
          _this5.clc = null;
        }

        if (cancelled) {
          var err = new Error('Loading initial props cancelled');
          err.cancelled = true;
          throw err;
        }

        return data;
      });
    }
  }, {
    key: "getInitialProps",
    value: function getInitialProps(Component, ctx) {
      var App = this.components['/_app'].Component;

      var AppTree = this._wrapApp(App);

      ctx.AppTree = AppTree;
      return utils_1.loadGetInitialProps(App, {
        AppTree: AppTree,
        Component: Component,
        router: this,
        ctx: ctx
      });
    }
  }, {
    key: "abortComponentLoad",
    value: function abortComponentLoad(as) {
      if (this.clc) {
        var e = new Error('Route Cancelled');
        e.cancelled = true;
        Router.events.emit('routeChangeError', e, as);
        this.clc();
        this.clc = null;
      }
    }
  }, {
    key: "notify",
    value: function notify(data) {
      this.sub(data, this.components['/_app'].Component);
    }
  }], [{
    key: "_rewriteUrlForNextExport",
    value: function _rewriteUrlForNextExport(url) {
      if (false) { var rewriteUrlForNextExport; } else {
        return url;
      }
    }
  }]);

  return Router;
}();

exports["default"] = Router;
Router.events = mitt_1["default"]();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
}); // Identify /[param]/ in route string

var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

exports.isDynamicRoute = isDynamicRoute;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

function getRouteMatcher(routeRegex) {
  var re = routeRegex.re,
      groups = routeRegex.groups;
  return function (pathname) {
    var routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    var decode = function decode(param) {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        var err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    var params = {};
    Object.keys(groups).forEach(function (slugName) {
      var g = groups[slugName];
      var m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(function (entry) {
          return decode(entry);
        }) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

exports.getRouteMatcher = getRouteMatcher;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
}); // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function getRouteRegex(normalizedRoute) {
  // Escape all characters that could be considered RegEx
  var escapedRoute = escapeRegex(normalizedRoute.replace(/\/$/, '') || '/');
  var groups = {};
  var groupIndex = 1;
  var parameterizedRoute = escapedRoute.replace(/\/\\\[([^/]+?)\\\](?=\/|$)/g, function (_, $1) {
    var isCatchAll = /^(\\\.){3}/.test($1);
    groups[$1 // Un-escape key
    .replace(/\\([|\\{}()[\]^$+*?.-])/g, '$1').replace(/^\.{3}/, '') // eslint-disable-next-line no-sequences
    ] = {
      pos: groupIndex++,
      repeat: isCatchAll
    };
    return isCatchAll ? '/(.+?)' : '/([^/]+?)';
  });
  var namedParameterizedRoute; // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) {}

  return Object.assign({
    re: new RegExp('^' + parameterizedRoute + '(?:/)?$', 'i'),
    groups: groups
  }, namedParameterizedRoute ? {
    namedRegex: "^".concat(namedParameterizedRoute, "(?:/)?$")
  } : {});
}

exports.getRouteRegex = getRouteRegex;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/runtime-config.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/runtime-config.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
var runtimeConfig;

exports["default"] = function () {
  return runtimeConfig;
};

function setConfig(configValue) {
  runtimeConfig = configValue;
}

exports.setConfig = setConfig;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});

var url_1 = __webpack_require__(/*! url */ "./node_modules/native-url/dist/index.js");
/**
 * Utils
 */


function execOnce(fn) {
  var used = false;
  var result;
  return function () {
    if (!used) {
      used = true;
      result = fn.apply(void 0, arguments);
    }

    return result;
  };
}

exports.execOnce = execOnce;

function getLocationOrigin() {
  var _window$location = window.location,
      protocol = _window$location.protocol,
      hostname = _window$location.hostname,
      port = _window$location.port;
  return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}

exports.getLocationOrigin = getLocationOrigin;

function getURL() {
  var href = window.location.href;
  var origin = getLocationOrigin();
  return href.substring(origin.length);
}

exports.getURL = getURL;

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

exports.getDisplayName = getDisplayName;

function isResSent(res) {
  return res.finished || res.headersSent;
}

exports.isResSent = isResSent;

function loadGetInitialProps(_x, _x2) {
  return _loadGetInitialProps.apply(this, arguments);
}

function _loadGetInitialProps() {
  _loadGetInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(App, ctx) {
    var _a, message, res, props, _message;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (false) {}

            if (!((_a = App.prototype) === null || _a === void 0 ? void 0 : _a.getInitialProps)) {
              _context.next = 4;
              break;
            }

            message = "\"".concat(getDisplayName(App), ".getInitialProps()\" is defined as an instance method - visit https://err.sh/zeit/next.js/get-initial-props-as-an-instance-method for more information.");
            throw new Error(message);

          case 4:
            // when called from _app `ctx` is nested in `ctx`
            res = ctx.res || ctx.ctx && ctx.ctx.res;

            if (App.getInitialProps) {
              _context.next = 12;
              break;
            }

            if (!(ctx.ctx && ctx.Component)) {
              _context.next = 11;
              break;
            }

            _context.next = 9;
            return loadGetInitialProps(ctx.Component, ctx.ctx);

          case 9:
            _context.t0 = _context.sent;
            return _context.abrupt("return", {
              pageProps: _context.t0
            });

          case 11:
            return _context.abrupt("return", {});

          case 12:
            _context.next = 14;
            return App.getInitialProps(ctx);

          case 14:
            props = _context.sent;

            if (!(res && isResSent(res))) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", props);

          case 17:
            if (props) {
              _context.next = 20;
              break;
            }

            _message = "\"".concat(getDisplayName(App), ".getInitialProps()\" should resolve to an object. But found \"").concat(props, "\" instead.");
            throw new Error(_message);

          case 20:
            if (true) {
              if (Object.keys(props).length === 0 && !ctx.ctx) {
                console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://err.sh/zeit/next.js/empty-object-getInitialProps"));
              }
            }

            return _context.abrupt("return", props);

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadGetInitialProps.apply(this, arguments);
}

exports.loadGetInitialProps = loadGetInitialProps;
exports.urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];

function formatWithValidation(url, options) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(function (key) {
        if (exports.urlObjectKeys.indexOf(key) === -1) {
          console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
        }
      });
    }
  }

  return url_1.format(url, options);
}

exports.formatWithValidation = formatWithValidation;
exports.SP = typeof performance !== 'undefined';
exports.ST = exports.SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/platform/platform.js":
/*!*******************************************!*\
  !*** ./node_modules/platform/platform.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Platform.js <https://mths.be/platform>
 * Copyright 2014-2016 Benjamin Tan <https://demoneaux.github.io/>
 * Copyright 2011-2013 John-David Dalton <http://allyoucanleet.com/>
 * Available under MIT license <https://mths.be/mit>
 */
;(function() {
  'use strict';

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used as a reference to the global object. */
  var root = (objectTypes[typeof window] && window) || this;

  /** Backup possible global object. */
  var oldRoot = root;

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  /**
   * Used as the maximum length of an array-like object.
   * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
   * for more details.
   */
  var maxSafeInteger = Math.pow(2, 53) - 1;

  /** Regular expression to detect Opera. */
  var reOpera = /\bOpera/;

  /** Possible global object. */
  var thisBinding = this;

  /** Used for native method references. */
  var objectProto = Object.prototype;

  /** Used to check for own properties of an object. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to resolve the internal `[[Class]]` of values. */
  var toString = objectProto.toString;

  /*--------------------------------------------------------------------------*/

  /**
   * Capitalizes a string value.
   *
   * @private
   * @param {string} string The string to capitalize.
   * @returns {string} The capitalized string.
   */
  function capitalize(string) {
    string = String(string);
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  /**
   * A utility function to clean up the OS name.
   *
   * @private
   * @param {string} os The OS name to clean up.
   * @param {string} [pattern] A `RegExp` pattern matching the OS name.
   * @param {string} [label] A label for the OS.
   */
  function cleanupOS(os, pattern, label) {
    // Platform tokens are defined at:
    // http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    // http://web.archive.org/web/20081122053950/http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    var data = {
      '10.0': '10',
      '6.4':  '10 Technical Preview',
      '6.3':  '8.1',
      '6.2':  '8',
      '6.1':  'Server 2008 R2 / 7',
      '6.0':  'Server 2008 / Vista',
      '5.2':  'Server 2003 / XP 64-bit',
      '5.1':  'XP',
      '5.01': '2000 SP1',
      '5.0':  '2000',
      '4.0':  'NT',
      '4.90': 'ME'
    };
    // Detect Windows version from platform tokens.
    if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) &&
        (data = data[/[\d.]+$/.exec(os)])) {
      os = 'Windows ' + data;
    }
    // Correct character case and cleanup string.
    os = String(os);

    if (pattern && label) {
      os = os.replace(RegExp(pattern, 'i'), label);
    }

    os = format(
      os.replace(/ ce$/i, ' CE')
        .replace(/\bhpw/i, 'web')
        .replace(/\bMacintosh\b/, 'Mac OS')
        .replace(/_PowerPC\b/i, ' OS')
        .replace(/\b(OS X) [^ \d]+/i, '$1')
        .replace(/\bMac (OS X)\b/, '$1')
        .replace(/\/(\d)/, ' $1')
        .replace(/_/g, '.')
        .replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '')
        .replace(/\bx86\.64\b/gi, 'x86_64')
        .replace(/\b(Windows Phone) OS\b/, '$1')
        .replace(/\b(Chrome OS \w+) [\d.]+\b/, '$1')
        .split(' on ')[0]
    );

    return os;
  }

  /**
   * An iteration utility for arrays and objects.
   *
   * @private
   * @param {Array|Object} object The object to iterate over.
   * @param {Function} callback The function called per iteration.
   */
  function each(object, callback) {
    var index = -1,
        length = object ? object.length : 0;

    if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {
      while (++index < length) {
        callback(object[index], index, object);
      }
    } else {
      forOwn(object, callback);
    }
  }

  /**
   * Trim and conditionally capitalize string values.
   *
   * @private
   * @param {string} string The string to format.
   * @returns {string} The formatted string.
   */
  function format(string) {
    string = trim(string);
    return /^(?:webOS|i(?:OS|P))/.test(string)
      ? string
      : capitalize(string);
  }

  /**
   * Iterates over an object's own properties, executing the `callback` for each.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} callback The function executed per own property.
   */
  function forOwn(object, callback) {
    for (var key in object) {
      if (hasOwnProperty.call(object, key)) {
        callback(object[key], key, object);
      }
    }
  }

  /**
   * Gets the internal `[[Class]]` of a value.
   *
   * @private
   * @param {*} value The value.
   * @returns {string} The `[[Class]]`.
   */
  function getClassOf(value) {
    return value == null
      ? capitalize(value)
      : toString.call(value).slice(8, -1);
  }

  /**
   * Host objects can return type values that are different from their actual
   * data type. The objects we are concerned with usually return non-primitive
   * types of "object", "function", or "unknown".
   *
   * @private
   * @param {*} object The owner of the property.
   * @param {string} property The property to check.
   * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.
   */
  function isHostType(object, property) {
    var type = object != null ? typeof object[property] : 'number';
    return !/^(?:boolean|number|string|undefined)$/.test(type) &&
      (type == 'object' ? !!object[property] : true);
  }

  /**
   * Prepares a string for use in a `RegExp` by making hyphens and spaces optional.
   *
   * @private
   * @param {string} string The string to qualify.
   * @returns {string} The qualified string.
   */
  function qualify(string) {
    return String(string).replace(/([ -])(?!$)/g, '$1?');
  }

  /**
   * A bare-bones `Array#reduce` like utility function.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function called per iteration.
   * @returns {*} The accumulated result.
   */
  function reduce(array, callback) {
    var accumulator = null;
    each(array, function(value, index) {
      accumulator = callback(accumulator, value, index, array);
    });
    return accumulator;
  }

  /**
   * Removes leading and trailing whitespace from a string.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} The trimmed string.
   */
  function trim(string) {
    return String(string).replace(/^ +| +$/g, '');
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a new platform object.
   *
   * @memberOf platform
   * @param {Object|string} [ua=navigator.userAgent] The user agent string or
   *  context object.
   * @returns {Object} A platform object.
   */
  function parse(ua) {

    /** The environment context object. */
    var context = root;

    /** Used to flag when a custom context is provided. */
    var isCustomContext = ua && typeof ua == 'object' && getClassOf(ua) != 'String';

    // Juggle arguments.
    if (isCustomContext) {
      context = ua;
      ua = null;
    }

    /** Browser navigator object. */
    var nav = context.navigator || {};

    /** Browser user agent string. */
    var userAgent = nav.userAgent || '';

    ua || (ua = userAgent);

    /** Used to flag when `thisBinding` is the [ModuleScope]. */
    var isModuleScope = isCustomContext || thisBinding == oldRoot;

    /** Used to detect if browser is like Chrome. */
    var likeChrome = isCustomContext
      ? !!nav.likeChrome
      : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());

    /** Internal `[[Class]]` value shortcuts. */
    var objectClass = 'Object',
        airRuntimeClass = isCustomContext ? objectClass : 'ScriptBridgingProxyObject',
        enviroClass = isCustomContext ? objectClass : 'Environment',
        javaClass = (isCustomContext && context.java) ? 'JavaPackage' : getClassOf(context.java),
        phantomClass = isCustomContext ? objectClass : 'RuntimeObject';

    /** Detect Java environments. */
    var java = /\bJava/.test(javaClass) && context.java;

    /** Detect Rhino. */
    var rhino = java && getClassOf(context.environment) == enviroClass;

    /** A character to represent alpha. */
    var alpha = java ? 'a' : '\u03b1';

    /** A character to represent beta. */
    var beta = java ? 'b' : '\u03b2';

    /** Browser document object. */
    var doc = context.document || {};

    /**
     * Detect Opera browser (Presto-based).
     * http://www.howtocreate.co.uk/operaStuff/operaObject.html
     * http://dev.opera.com/articles/view/opera-mini-web-content-authoring-guidelines/#operamini
     */
    var opera = context.operamini || context.opera;

    /** Opera `[[Class]]`. */
    var operaClass = reOpera.test(operaClass = (isCustomContext && opera) ? opera['[[Class]]'] : getClassOf(opera))
      ? operaClass
      : (opera = null);

    /*------------------------------------------------------------------------*/

    /** Temporary variable used over the script's lifetime. */
    var data;

    /** The CPU architecture. */
    var arch = ua;

    /** Platform description array. */
    var description = [];

    /** Platform alpha/beta indicator. */
    var prerelease = null;

    /** A flag to indicate that environment features should be used to resolve the platform. */
    var useFeatures = ua == userAgent;

    /** The browser/environment version. */
    var version = useFeatures && opera && typeof opera.version == 'function' && opera.version();

    /** A flag to indicate if the OS ends with "/ Version" */
    var isSpecialCasedOS;

    /* Detectable layout engines (order is important). */
    var layout = getLayout([
      { 'label': 'EdgeHTML', 'pattern': 'Edge' },
      'Trident',
      { 'label': 'WebKit', 'pattern': 'AppleWebKit' },
      'iCab',
      'Presto',
      'NetFront',
      'Tasman',
      'KHTML',
      'Gecko'
    ]);

    /* Detectable browser names (order is important). */
    var name = getName([
      'Adobe AIR',
      'Arora',
      'Avant Browser',
      'Breach',
      'Camino',
      'Epiphany',
      'Fennec',
      'Flock',
      'Galeon',
      'GreenBrowser',
      'iCab',
      'Iceweasel',
      'K-Meleon',
      'Konqueror',
      'Lunascape',
      'Maxthon',
      { 'label': 'Microsoft Edge', 'pattern': 'Edge' },
      'Midori',
      'Nook Browser',
      'PaleMoon',
      'PhantomJS',
      'Raven',
      'Rekonq',
      'RockMelt',
      'SeaMonkey',
      { 'label': 'Silk', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Sleipnir',
      'SlimBrowser',
      { 'label': 'SRWare Iron', 'pattern': 'Iron' },
      'Sunrise',
      'Swiftfox',
      'WebPositive',
      'Opera Mini',
      { 'label': 'Opera Mini', 'pattern': 'OPiOS' },
      'Opera',
      { 'label': 'Opera', 'pattern': 'OPR' },
      'Chrome',
      { 'label': 'Chrome Mobile', 'pattern': '(?:CriOS|CrMo)' },
      { 'label': 'Firefox', 'pattern': '(?:Firefox|Minefield)' },
      { 'label': 'Firefox for iOS', 'pattern': 'FxiOS' },
      { 'label': 'IE', 'pattern': 'IEMobile' },
      { 'label': 'IE', 'pattern': 'MSIE' },
      'Safari'
    ]);

    /* Detectable products (order is important). */
    var product = getProduct([
      { 'label': 'BlackBerry', 'pattern': 'BB10' },
      'BlackBerry',
      { 'label': 'Galaxy S', 'pattern': 'GT-I9000' },
      { 'label': 'Galaxy S2', 'pattern': 'GT-I9100' },
      { 'label': 'Galaxy S3', 'pattern': 'GT-I9300' },
      { 'label': 'Galaxy S4', 'pattern': 'GT-I9500' },
      'Google TV',
      'Lumia',
      'iPad',
      'iPod',
      'iPhone',
      'Kindle',
      { 'label': 'Kindle Fire', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Nexus',
      'Nook',
      'PlayBook',
      'PlayStation 3',
      'PlayStation 4',
      'PlayStation Vita',
      'TouchPad',
      'Transformer',
      { 'label': 'Wii U', 'pattern': 'WiiU' },
      'Wii',
      'Xbox One',
      { 'label': 'Xbox 360', 'pattern': 'Xbox' },
      'Xoom'
    ]);

    /* Detectable manufacturers. */
    var manufacturer = getManufacturer({
      'Apple': { 'iPad': 1, 'iPhone': 1, 'iPod': 1 },
      'Archos': {},
      'Amazon': { 'Kindle': 1, 'Kindle Fire': 1 },
      'Asus': { 'Transformer': 1 },
      'Barnes & Noble': { 'Nook': 1 },
      'BlackBerry': { 'PlayBook': 1 },
      'Google': { 'Google TV': 1, 'Nexus': 1 },
      'HP': { 'TouchPad': 1 },
      'HTC': {},
      'LG': {},
      'Microsoft': { 'Xbox': 1, 'Xbox One': 1 },
      'Motorola': { 'Xoom': 1 },
      'Nintendo': { 'Wii U': 1,  'Wii': 1 },
      'Nokia': { 'Lumia': 1 },
      'Samsung': { 'Galaxy S': 1, 'Galaxy S2': 1, 'Galaxy S3': 1, 'Galaxy S4': 1 },
      'Sony': { 'PlayStation 4': 1, 'PlayStation 3': 1, 'PlayStation Vita': 1 }
    });

    /* Detectable operating systems (order is important). */
    var os = getOS([
      'Windows Phone',
      'Android',
      'CentOS',
      { 'label': 'Chrome OS', 'pattern': 'CrOS' },
      'Debian',
      'Fedora',
      'FreeBSD',
      'Gentoo',
      'Haiku',
      'Kubuntu',
      'Linux Mint',
      'OpenBSD',
      'Red Hat',
      'SuSE',
      'Ubuntu',
      'Xubuntu',
      'Cygwin',
      'Symbian OS',
      'hpwOS',
      'webOS ',
      'webOS',
      'Tablet OS',
      'Linux',
      'Mac OS X',
      'Macintosh',
      'Mac',
      'Windows 98;',
      'Windows '
    ]);

    /*------------------------------------------------------------------------*/

    /**
     * Picks the layout engine from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected layout engine.
     */
    function getLayout(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the manufacturer from an array of guesses.
     *
     * @private
     * @param {Array} guesses An object of guesses.
     * @returns {null|string} The detected manufacturer.
     */
    function getManufacturer(guesses) {
      return reduce(guesses, function(result, value, key) {
        // Lookup the manufacturer by product or scan the UA for the manufacturer.
        return result || (
          value[product] ||
          value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] ||
          RegExp('\\b' + qualify(key) + '(?:\\b|\\w*\\d)', 'i').exec(ua)
        ) && key;
      });
    }

    /**
     * Picks the browser name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected browser name.
     */
    function getName(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the OS name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected OS name.
     */
    function getOS(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua)
            )) {
          result = cleanupOS(result, pattern, guess.label || guess);
        }
        return result;
      });
    }

    /**
     * Picks the product name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected product name.
     */
    function getProduct(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + ' *\\d+[.\\w_]*', 'i').exec(ua) ||
              RegExp('\\b' + pattern + '(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)', 'i').exec(ua)
            )) {
          // Split by forward slash and append product version if needed.
          if ((result = String((guess.label && !RegExp(pattern, 'i').test(guess.label)) ? guess.label : result).split('/'))[1] && !/[\d.]+/.test(result[0])) {
            result[0] += ' ' + result[1];
          }
          // Correct character case and cleanup string.
          guess = guess.label || guess;
          result = format(result[0]
            .replace(RegExp(pattern, 'i'), guess)
            .replace(RegExp('; *(?:' + guess + '[_-])?', 'i'), ' ')
            .replace(RegExp('(' + guess + ')[-_.]?(\\w)', 'i'), '$1 $2'));
        }
        return result;
      });
    }

    /**
     * Resolves the version using an array of UA patterns.
     *
     * @private
     * @param {Array} patterns An array of UA patterns.
     * @returns {null|string} The detected version.
     */
    function getVersion(patterns) {
      return reduce(patterns, function(result, pattern) {
        return result || (RegExp(pattern +
          '(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)', 'i').exec(ua) || 0)[1] || null;
      });
    }

    /**
     * Returns `platform.description` when the platform object is coerced to a string.
     *
     * @name toString
     * @memberOf platform
     * @returns {string} Returns `platform.description` if available, else an empty string.
     */
    function toStringPlatform() {
      return this.description || '';
    }

    /*------------------------------------------------------------------------*/

    // Convert layout to an array so we can add extra details.
    layout && (layout = [layout]);

    // Detect product names that contain their manufacturer's name.
    if (manufacturer && !product) {
      product = getProduct([manufacturer]);
    }
    // Clean up Google TV.
    if ((data = /\bGoogle TV\b/.exec(product))) {
      product = data[0];
    }
    // Detect simulators.
    if (/\bSimulator\b/i.test(ua)) {
      product = (product ? product + ' ' : '') + 'Simulator';
    }
    // Detect Opera Mini 8+ running in Turbo/Uncompressed mode on iOS.
    if (name == 'Opera Mini' && /\bOPiOS\b/.test(ua)) {
      description.push('running in Turbo/Uncompressed mode');
    }
    // Detect IE Mobile 11.
    if (name == 'IE' && /\blike iPhone OS\b/.test(ua)) {
      data = parse(ua.replace(/like iPhone OS/, ''));
      manufacturer = data.manufacturer;
      product = data.product;
    }
    // Detect iOS.
    else if (/^iP/.test(product)) {
      name || (name = 'Safari');
      os = 'iOS' + ((data = / OS ([\d_]+)/i.exec(ua))
        ? ' ' + data[1].replace(/_/g, '.')
        : '');
    }
    // Detect Kubuntu.
    else if (name == 'Konqueror' && !/buntu/i.test(os)) {
      os = 'Kubuntu';
    }
    // Detect Android browsers.
    else if ((manufacturer && manufacturer != 'Google' &&
        ((/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua)) || /\bVita\b/.test(product))) ||
        (/\bAndroid\b/.test(os) && /^Chrome/.test(name) && /\bVersion\//i.test(ua))) {
      name = 'Android Browser';
      os = /\bAndroid\b/.test(os) ? os : 'Android';
    }
    // Detect Silk desktop/accelerated modes.
    else if (name == 'Silk') {
      if (!/\bMobi/i.test(ua)) {
        os = 'Android';
        description.unshift('desktop mode');
      }
      if (/Accelerated *= *true/i.test(ua)) {
        description.unshift('accelerated');
      }
    }
    // Detect PaleMoon identifying as Firefox.
    else if (name == 'PaleMoon' && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
      description.push('identifying as Firefox ' + data[1]);
    }
    // Detect Firefox OS and products running Firefox.
    else if (name == 'Firefox' && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
      os || (os = 'Firefox OS');
      product || (product = data[1]);
    }
    // Detect false positives for Firefox/Safari.
    else if (!name || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
      // Escape the `/` for Firefox 1.
      if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + '/') + 8))) {
        // Clear name of false positives.
        name = null;
      }
      // Reassign a generic name.
      if ((data = product || manufacturer || os) &&
          (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
        name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + ' Browser';
      }
    }
    // Detect non-Opera (Presto-based) versions (order is important).
    if (!version) {
      version = getVersion([
        '(?:Cloud9|CriOS|CrMo|Edge|FxiOS|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|Silk(?!/[\\d.]+$))',
        'Version',
        qualify(name),
        '(?:Firefox|Minefield|NetFront)'
      ]);
    }
    // Detect stubborn layout engines.
    if ((data =
          layout == 'iCab' && parseFloat(version) > 3 && 'WebKit' ||
          /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? 'Blink' : 'Presto') ||
          /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && 'WebKit' ||
          !layout && /\bMSIE\b/i.test(ua) && (os == 'Mac OS' ? 'Tasman' : 'Trident') ||
          layout == 'WebKit' && /\bPlayStation\b(?! Vita\b)/i.test(name) && 'NetFront'
        )) {
      layout = [data];
    }
    // Detect Windows Phone 7 desktop mode.
    if (name == 'IE' && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
      name += ' Mobile';
      os = 'Windows Phone ' + (/\+$/.test(data) ? data : data + '.x');
      description.unshift('desktop mode');
    }
    // Detect Windows Phone 8.x desktop mode.
    else if (/\bWPDesktop\b/i.test(ua)) {
      name = 'IE Mobile';
      os = 'Windows Phone 8.x';
      description.unshift('desktop mode');
      version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
    }
    // Detect IE 11.
    else if (name != 'IE' && layout == 'Trident' && (data = /\brv:([\d.]+)/.exec(ua))) {
      if (name) {
        description.push('identifying as ' + name + (version ? ' ' + version : ''));
      }
      name = 'IE';
      version = data[1];
    }
    // Leverage environment features.
    if (useFeatures) {
      // Detect server-side environments.
      // Rhino has a global function while others have a global object.
      if (isHostType(context, 'global')) {
        if (java) {
          data = java.lang.System;
          arch = data.getProperty('os.arch');
          os = os || data.getProperty('os.name') + ' ' + data.getProperty('os.version');
        }
        if (isModuleScope && isHostType(context, 'system') && (data = [context.system])[0]) {
          os || (os = data[0].os || null);
          try {
            data[1] = context.require('ringo/engine').version;
            version = data[1].join('.');
            name = 'RingoJS';
          } catch(e) {
            if (data[0].global.system == context.system) {
              name = 'Narwhal';
            }
          }
        }
        else if (
          typeof context.process == 'object' && !context.process.browser &&
          (data = context.process)
        ) {
          name = 'Node.js';
          arch = data.arch;
          os = data.platform;
          version = /[\d.]+/.exec(data.version)[0];
        }
        else if (rhino) {
          name = 'Rhino';
        }
      }
      // Detect Adobe AIR.
      else if (getClassOf((data = context.runtime)) == airRuntimeClass) {
        name = 'Adobe AIR';
        os = data.flash.system.Capabilities.os;
      }
      // Detect PhantomJS.
      else if (getClassOf((data = context.phantom)) == phantomClass) {
        name = 'PhantomJS';
        version = (data = data.version || null) && (data.major + '.' + data.minor + '.' + data.patch);
      }
      // Detect IE compatibility modes.
      else if (typeof doc.documentMode == 'number' && (data = /\bTrident\/(\d+)/i.exec(ua))) {
        // We're in compatibility mode when the Trident version + 4 doesn't
        // equal the document mode.
        version = [version, doc.documentMode];
        if ((data = +data[1] + 4) != version[1]) {
          description.push('IE ' + version[1] + ' mode');
          layout && (layout[1] = '');
          version[1] = data;
        }
        version = name == 'IE' ? String(version[1].toFixed(1)) : version[0];
      }
      os = os && format(os);
    }
    // Detect prerelease phases.
    if (version && (data =
          /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) ||
          /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ';' + (useFeatures && nav.appMinorVersion)) ||
          /\bMinefield\b/i.test(ua) && 'a'
        )) {
      prerelease = /b/i.test(data) ? 'beta' : 'alpha';
      version = version.replace(RegExp(data + '\\+?$'), '') +
        (prerelease == 'beta' ? beta : alpha) + (/\d+\+?/.exec(data) || '');
    }
    // Detect Firefox Mobile.
    if (name == 'Fennec' || name == 'Firefox' && /\b(?:Android|Firefox OS)\b/.test(os)) {
      name = 'Firefox Mobile';
    }
    // Obscure Maxthon's unreliable version.
    else if (name == 'Maxthon' && version) {
      version = version.replace(/\.[\d.]+/, '.x');
    }
    // Detect Xbox 360 and Xbox One.
    else if (/\bXbox\b/i.test(product)) {
      os = null;
      if (product == 'Xbox 360' && /\bIEMobile\b/.test(ua)) {
        description.unshift('mobile mode');
      }
    }
    // Add mobile postfix.
    else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) &&
        (os == 'Windows CE' || /Mobi/i.test(ua))) {
      name += ' Mobile';
    }
    // Detect IE platform preview.
    else if (name == 'IE' && useFeatures && context.external === null) {
      description.unshift('platform preview');
    }
    // Detect BlackBerry OS version.
    // http://docs.blackberry.com/en/developers/deliverables/18169/HTTP_headers_sent_by_BB_Browser_1234911_11.jsp
    else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data =
          (RegExp(product.replace(/ +/g, ' *') + '/([.\\d]+)', 'i').exec(ua) || 0)[1] ||
          version
        )) {
      data = [data, /BB10/.test(ua)];
      os = (data[1] ? (product = null, manufacturer = 'BlackBerry') : 'Device Software') + ' ' + data[0];
      version = null;
    }
    // Detect Opera identifying/masking itself as another browser.
    // http://www.opera.com/support/kb/view/843/
    else if (this != forOwn && product != 'Wii' && (
          (useFeatures && opera) ||
          (/Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua)) ||
          (name == 'Firefox' && /\bOS X (?:\d+\.){2,}/.test(os)) ||
          (name == 'IE' && (
            (os && !/^Win/.test(os) && version > 5.5) ||
            /\bWindows XP\b/.test(os) && version > 8 ||
            version == 8 && !/\bTrident\b/.test(ua)
          ))
        ) && !reOpera.test((data = parse.call(forOwn, ua.replace(reOpera, '') + ';'))) && data.name) {
      // When "identifying", the UA contains both Opera and the other browser's name.
      data = 'ing as ' + data.name + ((data = data.version) ? ' ' + data : '');
      if (reOpera.test(name)) {
        if (/\bIE\b/.test(data) && os == 'Mac OS') {
          os = null;
        }
        data = 'identify' + data;
      }
      // When "masking", the UA contains only the other browser's name.
      else {
        data = 'mask' + data;
        if (operaClass) {
          name = format(operaClass.replace(/([a-z])([A-Z])/g, '$1 $2'));
        } else {
          name = 'Opera';
        }
        if (/\bIE\b/.test(data)) {
          os = null;
        }
        if (!useFeatures) {
          version = null;
        }
      }
      layout = ['Presto'];
      description.push(data);
    }
    // Detect WebKit Nightly and approximate Chrome/Safari versions.
    if ((data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
      // Correct build number for numeric comparison.
      // (e.g. "532.5" becomes "532.05")
      data = [parseFloat(data.replace(/\.(\d)$/, '.0$1')), data];
      // Nightly builds are postfixed with a "+".
      if (name == 'Safari' && data[1].slice(-1) == '+') {
        name = 'WebKit Nightly';
        prerelease = 'alpha';
        version = data[1].slice(0, -1);
      }
      // Clear incorrect browser versions.
      else if (version == data[1] ||
          version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
        version = null;
      }
      // Use the full Chrome version when available.
      data[1] = (/\bChrome\/([\d.]+)/i.exec(ua) || 0)[1];
      // Detect Blink layout engine.
      if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == 'WebKit') {
        layout = ['Blink'];
      }
      // Detect JavaScriptCore.
      // http://stackoverflow.com/questions/6768474/how-can-i-detect-which-javascript-engine-v8-or-jsc-is-used-at-runtime-in-androi
      if (!useFeatures || (!likeChrome && !data[1])) {
        layout && (layout[1] = 'like Safari');
        data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? '4+' : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : '8');
      } else {
        layout && (layout[1] = 'like Chrome');
        data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.10 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.30 ? 11 : data < 535.01 ? 12 : data < 535.02 ? '13+' : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.10 ? 19 : data < 537.01 ? 20 : data < 537.11 ? '21+' : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != 'Blink' ? '27' : '28');
      }
      // Add the postfix of ".x" or "+" for approximate versions.
      layout && (layout[1] += ' ' + (data += typeof data == 'number' ? '.x' : /[.+]/.test(data) ? '' : '+'));
      // Obscure version for some Safari 1-2 releases.
      if (name == 'Safari' && (!version || parseInt(version) > 45)) {
        version = data;
      }
    }
    // Detect Opera desktop modes.
    if (name == 'Opera' &&  (data = /\bzbov|zvav$/.exec(os))) {
      name += ' ';
      description.unshift('desktop mode');
      if (data == 'zvav') {
        name += 'Mini';
        version = null;
      } else {
        name += 'Mobile';
      }
      os = os.replace(RegExp(' *' + data + '$'), '');
    }
    // Detect Chrome desktop mode.
    else if (name == 'Safari' && /\bChrome\b/.exec(layout && layout[1])) {
      description.unshift('desktop mode');
      name = 'Chrome Mobile';
      version = null;

      if (/\bOS X\b/.test(os)) {
        manufacturer = 'Apple';
        os = 'iOS 4.3+';
      } else {
        os = null;
      }
    }
    // Strip incorrect OS versions.
    if (version && version.indexOf((data = /[\d.]+$/.exec(os))) == 0 &&
        ua.indexOf('/' + data + '-') > -1) {
      os = trim(os.replace(data, ''));
    }
    // Add layout engine.
    if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (
        /Browser|Lunascape|Maxthon/.test(name) ||
        name != 'Safari' && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) ||
        /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Sleipnir|Web)/.test(name) && layout[1])) {
      // Don't add layout details to description if they are falsey.
      (data = layout[layout.length - 1]) && description.push(data);
    }
    // Combine contextual information.
    if (description.length) {
      description = ['(' + description.join('; ') + ')'];
    }
    // Append manufacturer to description.
    if (manufacturer && product && product.indexOf(manufacturer) < 0) {
      description.push('on ' + manufacturer);
    }
    // Append product to description.
    if (product) {
      description.push((/^on /.test(description[description.length - 1]) ? '' : 'on ') + product);
    }
    // Parse the OS into an object.
    if (os) {
      data = / ([\d.+]+)$/.exec(os);
      isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == '/';
      os = {
        'architecture': 32,
        'family': (data && !isSpecialCasedOS) ? os.replace(data[0], '') : os,
        'version': data ? data[1] : null,
        'toString': function() {
          var version = this.version;
          return this.family + ((version && !isSpecialCasedOS) ? ' ' + version : '') + (this.architecture == 64 ? ' 64-bit' : '');
        }
      };
    }
    // Add browser/OS architecture.
    if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
      if (os) {
        os.architecture = 64;
        os.family = os.family.replace(RegExp(' *' + data), '');
      }
      if (
          name && (/\bWOW64\b/i.test(ua) ||
          (useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua)))
      ) {
        description.unshift('32-bit');
      }
    }
    // Chrome 39 and above on OS X is always 64-bit.
    else if (
        os && /^OS X/.test(os.family) &&
        name == 'Chrome' && parseFloat(version) >= 39
    ) {
      os.architecture = 64;
    }

    ua || (ua = null);

    /*------------------------------------------------------------------------*/

    /**
     * The platform object.
     *
     * @name platform
     * @type Object
     */
    var platform = {};

    /**
     * The platform description.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.description = ua;

    /**
     * The name of the browser's layout engine.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.layout = layout && layout[0];

    /**
     * The name of the product's manufacturer.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.manufacturer = manufacturer;

    /**
     * The name of the browser/environment.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.name = name;

    /**
     * The alpha/beta release indicator.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.prerelease = prerelease;

    /**
     * The name of the product hosting the browser.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.product = product;

    /**
     * The browser's user agent string.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.ua = ua;

    /**
     * The browser/environment version.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.version = name && version;

    /**
     * The name of the operating system.
     *
     * @memberOf platform
     * @type Object
     */
    platform.os = os || {

      /**
       * The CPU architecture the OS is built for.
       *
       * @memberOf platform.os
       * @type number|null
       */
      'architecture': null,

      /**
       * The family of the OS.
       *
       * Common values include:
       * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
       * "Windows XP", "OS X", "Ubuntu", "Debian", "Fedora", "Red Hat", "SuSE",
       * "Android", "iOS" and "Windows Phone"
       *
       * @memberOf platform.os
       * @type string|null
       */
      'family': null,

      /**
       * The version of the OS.
       *
       * @memberOf platform.os
       * @type string|null
       */
      'version': null,

      /**
       * Returns the OS string.
       *
       * @memberOf platform.os
       * @returns {string} The OS string.
       */
      'toString': function() { return 'null'; }
    };

    platform.parse = parse;
    platform.toString = toStringPlatform;

    if (platform.version) {
      description.unshift(version);
    }
    if (platform.name) {
      description.unshift(name);
    }
    if (os && name && !(os == String(os).split(' ')[0] && (os == name.split(' ')[0] || product))) {
      description.push(product ? '(' + os + ')' : 'on ' + os);
    }
    if (description.length) {
      platform.description = description.join(' ');
    }
    return platform;
  }

  /*--------------------------------------------------------------------------*/

  // Export platform.
  var platform = parse();

  // Some AMD build optimizers, like r.js, check for condition patterns like the following:
  if (true) {
    // Expose platform on the global object to prevent errors when platform is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    root.platform = platform;

    // Define as an anonymous module so platform can be aliased through path mapping.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return platform;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else {}
}.call(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring-es3/encode.js");


/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!***********************************************************************************************!*\
  !*** delegated ./node_modules/react-dom/index.js from dll-reference dll_b9380c54b6aeb86e51e7 ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(/*! dll-reference dll_b9380c54b6aeb86e51e7 */ "dll-reference dll_b9380c54b6aeb86e51e7"))("./node_modules/react-dom/index.js");

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*******************************************************************************************!*\
  !*** delegated ./node_modules/react/index.js from dll-reference dll_b9380c54b6aeb86e51e7 ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(/*! dll-reference dll_b9380c54b6aeb86e51e7 */ "dll-reference dll_b9380c54b6aeb86e51e7"))("./node_modules/react/index.js");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js ***!
  \***********************************************************************/
/*! exports provided: parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
var UNKNOWN_FUNCTION = '<unknown>';
/**
 * This parses the different stack traces and puts them into one format
 * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)
 */

function parse(stackString) {
  var lines = stackString.split('\n');
  return lines.reduce(function (stack, line) {
    var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);

    if (parseResult) {
      stack.push(parseResult);
    }

    return stack;
  }, []);
}
var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;

function parseChrome(line) {
  var parts = chromeRe.exec(line);

  if (!parts) {
    return null;
  }

  var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line

  var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line

  var submatch = chromeEvalRe.exec(parts[2]);

  if (isEval && submatch != null) {
    // throw out eval line/column and use top-most line/column number
    parts[2] = submatch[1]; // url

    parts[3] = submatch[2]; // line

    parts[4] = submatch[3]; // column
  }

  return {
    file: !isNative ? parts[2] : null,
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: isNative ? [parts[2]] : [],
    lineNumber: parts[3] ? +parts[3] : null,
    column: parts[4] ? +parts[4] : null
  };
}

var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;

function parseWinjs(line) {
  var parts = winjsRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}

var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;

function parseGecko(line) {
  var parts = geckoRe.exec(line);

  if (!parts) {
    return null;
  }

  var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
  var submatch = geckoEvalRe.exec(parts[3]);

  if (isEval && submatch != null) {
    // throw out eval line/column and use top-most line number
    parts[3] = submatch[1];
    parts[4] = submatch[2];
    parts[5] = null; // no column when eval
  }

  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: parts[2] ? parts[2].split(',') : [],
    lineNumber: parts[4] ? +parts[4] : null,
    column: parts[5] ? +parts[5] : null
  };
}

var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;

function parseJSC(line) {
  var parts = javaScriptCoreRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[4],
    column: parts[5] ? +parts[5] : null
  };
}

var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;

function parseNode(line) {
  var parts = nodeRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}




/***/ }),

/***/ "./node_modules/web-vitals/dist/web-vitals.es5.min.js":
/*!************************************************************!*\
  !*** ./node_modules/web-vitals/dist/web-vitals.es5.min.js ***!
  \************************************************************/
/*! exports provided: getCLS, getFCP, getFID, getLCP, getTTFB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCLS", function() { return p; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFCP", function() { return m; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFID", function() { return v; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLCP", function() { return g; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTTFB", function() { return h; });
var t,n,e=function(){return"".concat(Date.now(),"-").concat(Math.floor(8999999999999*Math.random())+1e12)},i=function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return{name:t,value:n,delta:0,entries:[],id:e(),isFinal:!1}},a=function(t,n){try{if(PerformanceObserver.supportedEntryTypes.includes(t)){var e=new PerformanceObserver((function(t){return t.getEntries().map(n)}));return e.observe({type:t,buffered:!0}),e}}catch(t){}},r=!1,o=!1,s=function(t){r=!t.persisted},u=function(){addEventListener("pagehide",s),addEventListener("unload",(function(){}))},c=function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];o||(u(),o=!0),addEventListener("visibilitychange",(function(n){var e=n.timeStamp;"hidden"===document.visibilityState&&t({timeStamp:e,isUnloading:r})}),{capture:!0,once:n})},l=function(t,n,e,i){var a;return function(){e&&n.isFinal&&e.disconnect(),n.value>=0&&(i||n.isFinal||"hidden"===document.visibilityState)&&(n.delta=n.value-(a||0),(n.delta||n.isFinal||void 0===a)&&(t(n),a=n.value))}},p=function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=i("CLS",0),r=function(t){t.hadRecentInput||(e.value+=t.value,e.entries.push(t),s())},o=a("layout-shift",r),s=l(t,e,o,n);c((function(t){var n=t.isUnloading;o&&o.takeRecords().map(r),n&&(e.isFinal=!0),s()}))},d=function(){return void 0===t&&(t="hidden"===document.visibilityState?0:1/0,c((function(n){var e=n.timeStamp;return t=e}),!0)),{get timeStamp(){return t}}},m=function(t){var n=i("FCP"),e=d(),r=a("paint",(function(t){"first-contentful-paint"===t.name&&t.startTime<e.timeStamp&&(n.value=t.startTime,n.isFinal=!0,n.entries.push(t),o())})),o=l(t,n,r)},v=function(t){var n=i("FID"),e=d(),r=function(t){t.startTime<e.timeStamp&&(n.value=t.processingStart-t.startTime,n.entries.push(t),n.isFinal=!0,s())},o=a("first-input",r),s=l(t,n,o);c((function(){o&&(o.takeRecords().map(r),o.disconnect())}),!0),o||window.perfMetrics&&window.perfMetrics.onFirstInputDelay&&window.perfMetrics.onFirstInputDelay((function(t,i){i.timeStamp<e.timeStamp&&(n.value=t,n.isFinal=!0,n.entries=[{entryType:"first-input",name:i.type,target:i.target,cancelable:i.cancelable,startTime:i.timeStamp,processingStart:i.timeStamp+t}],s())}))},f=function(){return n||(n=new Promise((function(t){return["scroll","keydown","pointerdown"].map((function(n){addEventListener(n,t,{once:!0,passive:!0,capture:!0})}))}))),n},g=function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=i("LCP"),r=d(),o=function(t){var n=t.startTime;n<r.timeStamp?(e.value=n,e.entries.push(t)):e.isFinal=!0,u()},s=a("largest-contentful-paint",o),u=l(t,e,s,n),p=function(){e.isFinal||(s&&s.takeRecords().map(o),e.isFinal=!0,u())};f().then(p),c(p,!0)},h=function(t){var n,e=i("TTFB");n=function(){try{var n=performance.getEntriesByType("navigation")[0]||function(){var t=performance.timing,n={entryType:"navigation",startTime:0};for(var e in t)"navigationStart"!==e&&"toJSON"!==e&&(n[e]=Math.max(t[e]-t.navigationStart,0));return n}();e.value=e.delta=n.responseStart,e.entries=[n],e.isFinal=!0,t(e)}catch(t){}},"complete"===document.readyState?setTimeout(n,0):addEventListener("pageshow",n)};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/workbox-window/build/workbox-window.prod.es5.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/workbox-window/build/workbox-window.prod.es5.mjs ***!
  \***********************************************************************/
/*! exports provided: Workbox, messageSW */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Workbox", function() { return a; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "messageSW", function() { return n; });
try{self["workbox:window:5.1.3"]&&_()}catch(n){}function n(n,t){return new Promise((function(r){var i=new MessageChannel;i.port1.onmessage=function(n){r(n.data)},n.postMessage(t,[i.port2])}))}function t(n,t){for(var r=0;r<t.length;r++){var i=t[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,i.key,i)}}try{self["workbox:core:5.1.3"]&&_()}catch(n){}var r=function(){var n=this;this.promise=new Promise((function(t,r){n.resolve=t,n.reject=r}))};function i(n,t){var r=location.href;return new URL(n,r).href===new URL(t,r).href}var e=function(n,t){this.type=n,Object.assign(this,t)};function o(n,t,r){return r?t?t(n):n:(n&&n.then||(n=Promise.resolve(n)),t?n.then(t):n)}function u(){}var a=function(u){var a,f;function s(n,t){var a,c;return void 0===t&&(t={}),(a=u.call(this)||this).t={},a.i=0,a.o=new r,a.u=new r,a.s=new r,a.v=0,a.h=new Set,a.l=function(){var n=a.g,t=n.installing;a.i>0||!i(t.scriptURL,a.m)||performance.now()>a.v+6e4?(a.P=t,n.removeEventListener("updatefound",a.l)):(a.p=t,a.h.add(t),a.o.resolve(t)),++a.i,t.addEventListener("statechange",a.k)},a.k=function(n){var t=a.g,r=n.target,i=r.state,o=r===a.P,u=o?"external":"",c={sw:r,originalEvent:n};!o&&a.j&&(c.isUpdate=!0),a.dispatchEvent(new e(u+i,c)),"installed"===i?a.O=self.setTimeout((function(){"installed"===i&&t.waiting===r&&a.dispatchEvent(new e(u+"waiting",c))}),200):"activating"===i&&(clearTimeout(a.O),o||a.u.resolve(r))},a.R=function(n){var t=a.p;t===navigator.serviceWorker.controller&&(a.dispatchEvent(new e("controlling",{sw:t,originalEvent:n,isUpdate:a.j})),a.s.resolve(t))},a.S=(c=function(n){var t=n.data,r=n.source;return o(a.getSW(),(function(){a.h.has(r)&&a.dispatchEvent(new e("message",{data:t,sw:r,originalEvent:n}))}))},function(){for(var n=[],t=0;t<arguments.length;t++)n[t]=arguments[t];try{return Promise.resolve(c.apply(this,n))}catch(n){return Promise.reject(n)}}),a.m=n,a.t=t,navigator.serviceWorker.addEventListener("message",a.S),a}f=u,(a=s).prototype=Object.create(f.prototype),a.prototype.constructor=a,a.__proto__=f;var v,h,w,l=s.prototype;return l.register=function(n){var t=(void 0===n?{}:n).immediate,r=void 0!==t&&t;try{var u=this;return function(n,t){var r=n();if(r&&r.then)return r.then(t);return t(r)}((function(){if(!r&&"complete"!==document.readyState)return c(new Promise((function(n){return window.addEventListener("load",n)})))}),(function(){return u.j=Boolean(navigator.serviceWorker.controller),u.U=u.B(),o(u.L(),(function(n){u.g=n,u.U&&(u.p=u.U,u.u.resolve(u.U),u.s.resolve(u.U),u.U.addEventListener("statechange",u.k,{once:!0}));var t=u.g.waiting;return t&&i(t.scriptURL,u.m)&&(u.p=t,Promise.resolve().then((function(){u.dispatchEvent(new e("waiting",{sw:t,wasWaitingBeforeRegister:!0}))})).then((function(){}))),u.p&&(u.o.resolve(u.p),u.h.add(u.p)),u.g.addEventListener("updatefound",u.l),navigator.serviceWorker.addEventListener("controllerchange",u.R,{once:!0}),u.g}))}))}catch(n){return Promise.reject(n)}},l.update=function(){try{return this.g?c(this.g.update()):void 0}catch(n){return Promise.reject(n)}},l.getSW=function(){try{return void 0!==this.p?this.p:this.o.promise}catch(n){return Promise.reject(n)}},l.messageSW=function(t){try{return o(this.getSW(),(function(r){return n(r,t)}))}catch(n){return Promise.reject(n)}},l.B=function(){var n=navigator.serviceWorker.controller;return n&&i(n.scriptURL,this.m)?n:void 0},l.L=function(){try{var n=this;return function(n,t){try{var r=n()}catch(n){return t(n)}if(r&&r.then)return r.then(void 0,t);return r}((function(){return o(navigator.serviceWorker.register(n.m,n.t),(function(t){return n.v=performance.now(),t}))}),(function(n){throw n}))}catch(n){return Promise.reject(n)}},v=s,(h=[{key:"active",get:function(){return this.u.promise}},{key:"controlling",get:function(){return this.s.promise}}])&&t(v.prototype,h),w&&t(v,w),s}(function(){function n(){this.M=new Map}var t=n.prototype;return t.addEventListener=function(n,t){this._(n).add(t)},t.removeEventListener=function(n,t){this._(n).delete(t)},t.dispatchEvent=function(n){n.target=this;var t=this._(n.type),r=Array.isArray(t),i=0;for(t=r?t:t[Symbol.iterator]();;){var e;if(r){if(i>=t.length)break;e=t[i++]}else{if((i=t.next()).done)break;e=i.value}e(n)}},t._=function(n){return this.M.has(n)||this.M.set(n,new Set),this.M.get(n)},n}());function c(n,t){if(!t)return n&&n.then?n.then(u):Promise.resolve()}
//# sourceMappingURL=workbox-window.prod.es5.mjs.map


/***/ }),

/***/ 0:
/*!*********************************************************************************************!*\
  !*** multi ./node_modules/next-pwa/register.js ./node_modules/next/dist/client/next-dev.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! C:\Users\user\projects\vibe\node_modules\next-pwa\register.js */"./node_modules/next-pwa/register.js");
module.exports = __webpack_require__(/*! .\node_modules\next\dist\client\next-dev.js */"./node_modules/next/dist/client/next-dev.js");


/***/ }),

/***/ "dll-reference dll_b9380c54b6aeb86e51e7":
/*!*******************************************!*\
  !*** external "dll_b9380c54b6aeb86e51e7" ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = dll_b9380c54b6aeb86e51e7;

/***/ })

},[[0,"static/runtime/webpack.js"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aEhvbGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9FcnJvckJvdW5kYXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvUmVhY3REZXZPdmVybGF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvYnVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9Db2RlRnJhbWUvQ29kZUZyYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9Db2RlRnJhbWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL0NvZGVGcmFtZS9zdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL0RpYWxvZy9EaWFsb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL0RpYWxvZy9EaWFsb2dCb2R5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9EaWFsb2cvRGlhbG9nQ29udGVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL0RpYWxvZ0hlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9EaWFsb2cvc3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9MZWZ0UmlnaHREaWFsb2dIZWFkZXIvTGVmdFJpZ2h0RGlhbG9nSGVhZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9MZWZ0UmlnaHREaWFsb2dIZWFkZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL0xlZnRSaWdodERpYWxvZ0hlYWRlci9zdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL092ZXJsYXkvT3ZlcmxheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvT3ZlcmxheS9ib2R5LWxvY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvT3ZlcmxheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvT3ZlcmxheS9zdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL1NoYWRvd1BvcnRhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvVGVybWluYWwvVGVybWluYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL1Rlcm1pbmFsL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9UZXJtaW5hbC9zdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL1RvYXN0L1RvYXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9Ub2FzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvVG9hc3Qvc3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29udGFpbmVyL0J1aWxkRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb250YWluZXIvRXJyb3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29udGFpbmVyL1J1bnRpbWVFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2hlbHBlcnMvbm9kZVN0YWNrRnJhbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvaGVscGVycy9ub29wLXRlbXBsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvaGVscGVycy9wYXJzZVN0YWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvaGVscGVycy9zdGFjay1mcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2hvb2tzL3VzZS1vbi1jbGljay1vdXRzaWRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvc3R5bGVzL0Jhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9zdHlsZXMvQ29tcG9uZW50U3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvc3R5bGVzL0Nzc1Jlc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbm9kZV9tb2R1bGVzL3N0cmlwLWFuc2kvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvZWxlbWVudC9kaXNhYmxlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9lbGVtZW50L2ZvY3VzLnN2Zy1mb3JlaWduLW9iamVjdC1oYWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2dldC9wYXJlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2dldC9zaGFkb3ctaG9zdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy9hY3RpdmUtZWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy9kaXNhYmxlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy9mb2N1cy1yZWxldmFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy9mb2N1c2FibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvaXMvaXMudXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy9uYXRpdmUtZGlzYWJsZWQtc3VwcG9ydGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2lzL29ubHktdGFiYmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvaXMvdGFiYmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvaXMvdmFsaWQtYXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy92YWxpZC10YWJpbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy92aXNpYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL21haW50YWluL2Rpc2FibGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL21haW50YWluL3RhYi1mb2N1cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9tYXAva2V5Y29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9vYnNlcnZlL3NoYWRvdy1tdXRhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvcXVlcnkvZm9jdXNhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3F1ZXJ5L2ZvY3VzYWJsZS5xdWljay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9xdWVyeS9mb2N1c2FibGUuc3RyaWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3F1ZXJ5L3NoYWRvdy1ob3N0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9xdWVyeS90YWJiYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9xdWVyeS90YWJzZXF1ZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9xdWVyeS90YWJzZXF1ZW5jZS5zb3J0LWFyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvcXVlcnkvdGFic2VxdWVuY2Uuc29ydC1zaGFkb3dlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9xdWVyeS90YWJzZXF1ZW5jZS5zb3J0LXRhYmluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3NlbGVjdG9yL2ZvY3VzYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9jc3Mtc2hhZG93LXBpZXJjaW5nLWRlZXAtY29tYmluYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9kZXRlY3QtZm9jdXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtYXJlYS1pbWctdGFiaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtYXJlYS10YWJpbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1hcmVhLXdpdGhvdXQtaHJlZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1hdWRpby13aXRob3V0LWNvbnRyb2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLWJyb2tlbi1pbWFnZS1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtY2hpbGRyZW4tb2YtZm9jdXNhYmxlLWZsZXhib3guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtZmllbGRzZXQtZGlzYWJsZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtZmllbGRzZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtZmxleGJveC1jb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtZm9ybS1kaXNhYmxlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1pbWctaXNtYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtaW1nLXVzZW1hcC10YWJpbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1pbi1oaWRkZW4taWZyYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLWluLXplcm8tZGltZW5zaW9uLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1pbnZhbGlkLXRhYmluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLWxhYmVsLXRhYmluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLW9iamVjdC1zdmctaGlkZGVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLW9iamVjdC1zdmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtb2JqZWN0LXN3Zi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1yZWRpcmVjdC1pbWctdXNlbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXJlZGlyZWN0LWxlZ2VuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1zY3JvbGwtYm9keS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1zY3JvbGwtY29udGFpbmVyLXdpdGhvdXQtb3ZlcmZsb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtc2Nyb2xsLWNvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1zdW1tYXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXN2Zy1mb2N1c2FibGUtYXR0cmlidXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXN2Zy1mb3JlaWdub2JqZWN0LXRhYmluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXN2Zy1pbi1pZnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtc3ZnLW5lZ2F0aXZlLXRhYmluZGV4LWF0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1zdmctdGFiaW5kZXgtYXR0cmlidXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXN2Zy11c2UtdGFiaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtc3ZnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXRhYmluZGV4LXRyYWlsaW5nLWNoYXJhY3RlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtdmlkZW8td2l0aG91dC1jb250cm9scy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9oZWxwZXIvc3ZnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL21lZGlhL2dpZi5pbnZhbGlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL21lZGlhL2dpZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9tZWRpYS9tcDMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvbWVkaWEvbXA0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL21lZGlhL3N2Zy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9zdXBwb3J0cy1jYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9zdXBwb3J0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy90YWJzZXF1ZW5jZS1hcmVhLWF0LWltZy1wb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL2FycmF5LWZpbmQtaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9jb21wYXJlLXBvc2l0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvY29udGV4dC10by1lbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvZWxlbWVudC1tYXRjaGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvZ2V0LWNvbnRlbnQtZG9jdW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9nZXQtZG9jdW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9nZXQtZnJhbWUtZWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL2dldC13aW5kb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9pbWFnZS1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9sb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9tZXJnZS1kb20tb3JkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9ub2RlLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvcGxhdGZvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9zZWxlY3QtaW4tc2hhZG93cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL3NvcnQtZG9tLW9yZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvdGFiaW5kZXgtdmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC90b2dnbGUtYXR0cmlidXRlLXZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvdG9nZ2xlLWF0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy92ZXJzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3doZW4va2V5LmJpbmRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvd2hlbi9rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fuc2VyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLmVzY2FwZS9jc3MuZXNjYXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uYXRpdmUtdXJsL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQtcHdhL3JlZ2lzdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL2ZpbmFsbHktcG9seWZpbGwubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3VuZmV0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L2Rldi1idWlsZC13YXRjaGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2Rldi9lcnJvci1vdmVybGF5L2V2ZW50c291cmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2Rldi9lcnJvci1vdmVybGF5L2Zvcm1hdC13ZWJwYWNrLW1lc3NhZ2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2Rldi9lcnJvci1vdmVybGF5L2hvdC1kZXYtY2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2Rldi9ldmVudC1zb3VyY2UtcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L2ZvdWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L29uLWRlbWFuZC1lbnRyaWVzLWNsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvb24tZGVtYW5kLWVudHJpZXMtdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L3ByZXJlbmRlci1pbmRpY2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L3dlYnBhY2staG90LW1pZGRsZXdhcmUtY2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2hlYWQtbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9uZXh0LWRldi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9wYWdlLWxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9wZXJmb3JtYW5jZS1yZWxheWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC93aXRoLXJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3N0cmlwLWFuc2kvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9saWIvaGVhZC1tYW5hZ2VyLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9saWIvbWl0dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9yb3V0ZXItY29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yb3V0ZS1yZWdleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9ydW50aW1lLWNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGxhdGZvcm0vcGxhdGZvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBkbGxfYjkzODBjNTRiNmFlYjg2ZTUxZTciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgZGxsX2I5MzgwYzU0YjZhZWI4NmU1MWU3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0YWNrdHJhY2UtcGFyc2VyL2Rpc3Qvc3RhY2stdHJhY2UtcGFyc2VyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2ViLXZpdGFscy9kaXN0L3dlYi12aXRhbHMuZXM1Lm1pbi5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dvcmtib3gtd2luZG93L2J1aWxkL3dvcmtib3gtd2luZG93LnByb2QuZXM1Lm1qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJkbGxfYjkzODBjNTRiNmFlYjg2ZTUxZTdcIiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwib25seUZpcnN0IiwicGF0dGVybiIsImpvaW4iLCJSZWdFeHAiLCJ1bmRlZmluZWQiLCJhbnNpUmVnZXgiLCJyZXF1aXJlIiwic3RyaW5nIiwicmVwbGFjZSIsIl9fZXNNb2R1bGUiLCJpbml0aWFsaXplQnVpbGRXYXRjaGVyIiwiX2V2ZW50c291cmNlIiwic2hhZG93SG9zdCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlkIiwic3R5bGUiLCJwb3NpdGlvbiIsImJvdHRvbSIsInJpZ2h0Iiwid2lkdGgiLCJoZWlnaHQiLCJ6SW5kZXgiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJzaGFkb3dSb290IiwicHJlZml4IiwiYXR0YWNoU2hhZG93IiwibW9kZSIsImNvbnRhaW5lciIsImNyZWF0ZUNvbnRhaW5lciIsImNzcyIsImNyZWF0ZUNzcyIsImlzVmlzaWJsZSIsImlzQnVpbGRpbmciLCJ0aW1lb3V0SWQiLCJldnRTb3VyY2UiLCJnZXRFdmVudFNvdXJjZVdyYXBwZXIiLCJwYXRoIiwiYWRkTWVzc2FnZUxpc3RlbmVyIiwiZXZlbnQiLCJkYXRhIiwiaGFuZGxlTWVzc2FnZSIsIl91bnVzZWQiLCJvYmoiLCJKU09OIiwicGFyc2UiLCJhY3Rpb24iLCJjbGVhclRpbWVvdXQiLCJ1cGRhdGVDb250YWluZXIiLCJzZXRUaW1lb3V0IiwiY2xhc3NMaXN0IiwiYWRkIiwicmVtb3ZlIiwiaW5uZXJIVE1MIiwidGV4dENvbnRlbnQiLCJldmVudENhbGxiYWNrcyIsIkV2ZW50U291cmNlV3JhcHBlciIsIm9wdGlvbnMiLCJzb3VyY2UiLCJsYXN0QWN0aXZpdHkiLCJEYXRlIiwibGlzdGVuZXJzIiwidGltZW91dCIsImluaXQiLCJ0aW1lciIsInNldEludGVydmFsIiwiaGFuZGxlRGlzY29ubmVjdCIsIndpbmRvdyIsIkV2ZW50U291cmNlIiwib25vcGVuIiwiaGFuZGxlT25saW5lIiwib25lcnJvciIsIm9ubWVzc2FnZSIsImxvZyIsImNvbnNvbGUiLCJpIiwibGVuZ3RoIiwiaW5kZXhPZiIsImZvckVhY2giLCJjYiIsImNsZWFySW50ZXJ2YWwiLCJjbG9zZSIsImZuIiwicHVzaCIsIm9uZGVtYW5kIiwiZnJpZW5kbHlTeW50YXhFcnJvckxhYmVsIiwiaXNMaWtlbHlBU3ludGF4RXJyb3IiLCJtZXNzYWdlIiwiZm9ybWF0TWVzc2FnZSIsImxpbmVzIiwic3BsaXQiLCJmaWx0ZXIiLCJsaW5lIiwidGVzdCIsIm1hcCIsInBhcnNpbmdFcnJvciIsImV4ZWMiLCJlcnJvckxpbmUiLCJlcnJvckNvbHVtbiIsImVycm9yTWVzc2FnZSIsInRyaW0iLCJzcGxpY2UiLCJtYXRjaCIsImluZGV4IiwiYXJyIiwiZm9ybWF0V2VicGFja01lc3NhZ2VzIiwianNvbiIsImZvcm1hdHRlZEVycm9ycyIsImVycm9ycyIsImZvcm1hdHRlZFdhcm5pbmdzIiwid2FybmluZ3MiLCJyZXN1bHQiLCJzb21lIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiY29ubmVjdCIsIkRldk92ZXJsYXkiLCJfc3RyaXBBbnNpIiwiX2Zvcm1hdFdlYnBhY2tNZXNzYWdlcyIsImhhZFJ1bnRpbWVFcnJvciIsImN1c3RvbUhtckV2ZW50SGFuZGxlciIsInJlZ2lzdGVyIiwicHJvY2Vzc01lc3NhZ2UiLCJleCIsIndhcm4iLCJzdWJzY3JpYmVUb0htckV2ZW50IiwiaGFuZGxlciIsIm9uVW5yZWNvdmVyYWJsZUVycm9yIiwiaXNGaXJzdENvbXBpbGF0aW9uIiwibW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCIsImhhc0NvbXBpbGVFcnJvcnMiLCJjbGVhck91dGRhdGVkRXJyb3JzIiwiY2xlYXIiLCJoYW5kbGVTdWNjZXNzIiwiaXNIb3RVcGRhdGUiLCJ0cnlBcHBseVVwZGF0ZXMiLCJvblN1Y2Nlc3NmdWxIb3RVcGRhdGUiLCJoYXNVcGRhdGVzIiwib25GYXN0UmVmcmVzaCIsImhhbmRsZVdhcm5pbmdzIiwicHJpbnRXYXJuaW5ncyIsImZvcm1hdHRlZCIsImhhbmRsZUVycm9ycyIsIm9uQnVpbGRFcnJvciIsImVycm9yIiwicHJvY2VzcyIsInNlbGYiLCJfX05FWFRfSE1SX0NCIiwib25CdWlsZE9rIiwib25SZWZyZXNoIiwiaGFuZGxlQXZhaWxhYmxlSGFzaCIsImhhc2giLCJlIiwiaGFzRXJyb3JzIiwiQm9vbGVhbiIsImhhc1dhcm5pbmdzIiwiaXNVcGRhdGVBdmFpbGFibGUiLCJfX3dlYnBhY2tfaGFzaF9fIiwiY2FuQXBwbHlVcGRhdGVzIiwiaG90Iiwic3RhdHVzIiwiYWZ0ZXJBcHBseVVwZGF0ZXMiLCJyZW1vdmVTdGF0dXNIYW5kbGVyIiwiYWRkU3RhdHVzSGFuZGxlciIsIm9uSG90VXBkYXRlU3VjY2VzcyIsImhhbmRsZUFwcGx5VXBkYXRlcyIsImVyciIsInVwZGF0ZWRNb2R1bGVzIiwibG9jYXRpb24iLCJyZWxvYWQiLCJjaGVjayIsInRoZW4iLCJfdW5mZXRjaCIsIlJlc3BvbnNlIiwiVGV4dERlY29kZXIiLCJUZXh0RW5jb2RlciIsIkFib3J0Q29udHJvbGxlciIsInNpZ25hbCIsImFib3J0IiwiVGV4dERlY29kZXJQb2x5ZmlsbCIsImJpdHNOZWVkZWQiLCJjb2RlUG9pbnQiLCJwcm90b3R5cGUiLCJkZWNvZGUiLCJvY3RldHMiLCJ2YWxpZCIsInNoaWZ0Iiwib2N0ZXRzQ291bnQiLCJFcnJvciIsIlJFUExBQ0VSIiwib2N0ZXQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzdXBwb3J0c1N0cmVhbU9wdGlvbiIsImVuY29kZSIsInN0cmVhbSIsImsiLCJYSFJXcmFwcGVyIiwieGhyIiwid2l0aENyZWRlbnRpYWxzIiwicmVzcG9uc2VUeXBlIiwicmVhZHlTdGF0ZSIsInN0YXR1c1RleHQiLCJyZXNwb25zZVRleHQiLCJvbnByb2dyZXNzIiwib25yZWFkeXN0YXRlY2hhbmdlIiwiX2NvbnRlbnRUeXBlIiwiX3hociIsIl9zZW5kVGltZW91dCIsIl9hYm9ydCIsIm9wZW4iLCJtZXRob2QiLCJ1cmwiLCJ0aGF0Iiwic3RhdGUiLCJzaWxlbnQiLCJvbmxvYWQiLCJvbmFib3J0Iiwib25TdGFydCIsImNvbnRlbnRUeXBlIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJvblByb2dyZXNzIiwib25GaW5pc2giLCJvblJlYWR5U3RhdGVDaGFuZ2UiLCJvblRpbWVvdXQiLCJYTUxIdHRwUmVxdWVzdCIsIm5hbWUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwidmFsdWUiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJzZW5kIiwiZXJyb3IxIiwidG9Mb3dlckNhc2UiLCJjIiwiY2hhckNvZGVBdCIsIkhlYWRlcnNQb2x5ZmlsbCIsImFsbCIsIk9iamVjdCIsImNyZWF0ZSIsImFycmF5IiwicGFydHMiLCJfbWFwIiwiZ2V0IiwiWEhSVHJhbnNwb3J0Iiwib25TdGFydENhbGxiYWNrIiwib25Qcm9ncmVzc0NhbGxiYWNrIiwib25GaW5pc2hDYWxsYmFjayIsImhlYWRlcnMiLCJvZmZzZXQiLCJjaHVuayIsInNsaWNlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiSGVhZGVyc1dyYXBwZXIiLCJfaGVhZGVycyIsIkZldGNoVHJhbnNwb3J0IiwiY29udHJvbGxlciIsInRleHREZWNvZGVyIiwiY3JlZGVudGlhbHMiLCJjYWNoZSIsInJlc3BvbnNlIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiY2FuY2VsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWFkTmV4dENodW5rIiwicmVhZCIsImRvbmUiLCJFdmVudFRhcmdldCIsIl9saXN0ZW5lcnMiLCJ0aHJvd0Vycm9yIiwiZGlzcGF0Y2hFdmVudCIsInRhcmdldCIsInR5cGVMaXN0ZW5lcnMiLCJ0eXBlIiwibGlzdGVuZXIiLCJoYW5kbGVFdmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJmb3VuZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJmaWx0ZXJlZCIsIkV2ZW50IiwiTWVzc2FnZUV2ZW50IiwibGFzdEV2ZW50SWQiLCJDb25uZWN0aW9uRXZlbnQiLCJXQUlUSU5HIiwiQ09OTkVDVElORyIsIk9QRU4iLCJDTE9TRUQiLCJBRlRFUl9DUiIsIkZJRUxEX1NUQVJUIiwiRklFTEQiLCJWQUxVRV9TVEFSVCIsIlZBTFVFIiwiY29udGVudFR5cGVSZWdFeHAiLCJNSU5JTVVNX0RVUkFUSU9OIiwiTUFYSU1VTV9EVVJBVElPTiIsInBhcnNlRHVyYXRpb24iLCJkZWYiLCJuIiwicGFyc2VJbnQiLCJjbGFtcER1cmF0aW9uIiwiTWF0aCIsIm1pbiIsIm1heCIsImZpcmUiLCJmIiwiRXZlbnRTb3VyY2VQb2x5ZmlsbCIsIl9jbG9zZSIsInN0YXJ0IiwiaXNGZXRjaFN1cHBvcnRlZCIsImVzIiwiaW5pdGlhbFJldHJ5IiwiaGVhcnRiZWF0VGltZW91dCIsInJldHJ5Iiwid2FzQWN0aXZpdHkiLCJzdHJpbmdpZnkiLCJDdXJyZW50VHJhbnNwb3J0IiwiVHJhbnNwb3J0IiwidHJhbnNwb3J0IiwiY2FuY2VsRnVuY3Rpb24iLCJjdXJyZW50U3RhdGUiLCJkYXRhQnVmZmVyIiwibGFzdEV2ZW50SWRCdWZmZXIiLCJldmVudFR5cGVCdWZmZXIiLCJ0ZXh0QnVmZmVyIiwiZmllbGRTdGFydCIsInZhbHVlU3RhcnQiLCJ0ZXh0Q2h1bmsiLCJmaWVsZCIsInJlcXVlc3RVUkwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXF1ZXN0SGVhZGVycyIsIl9kZWZhdWx0IiwiZGlzcGxheUNvbnRlbnQiLCJjYWxsYmFjayIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIngiLCJxdWVyeVNlbGVjdG9yQWxsIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiX3JvdXRlciIsIl9vbkRlbWFuZEVudHJpZXNVdGlscyIsIl9yZWYiLCJhc3NldFByZWZpeCIsInJlYWR5IiwiZXZlbnRzIiwib24iLCJzZXR1cFBpbmciLCJiaW5kIiwicGF0aG5hbWUiLCJjdXJyZW50UGFnZSIsInZpc2liaWxpdHlTdGF0ZSIsImNsb3NlUGluZyIsInBhdGhuYW1lRm4iLCJwYXlsb2FkIiwiaW52YWxpZCIsImhyZWYiLCJwYWdlUmVzIiwidHJhbnNpdGlvbiIsImV4cGFuZEVsIiwicXVlcnlTZWxlY3RvciIsImNsb3NlRWwiLCJkaXNtaXNzS2V5IiwiZGlzbWlzc1VudGlsIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImRpc21pc3NlZCIsImdldFRpbWUiLCJfX05FWFRfREFUQV9fIiwibmV4dEV4cG9ydCIsImV4cGFuZGVkQ2xhc3MiLCJ0b2dnbGVUaW1lb3V0IiwidG9nZ2xlRXhwYW5kIiwiZXhwYW5kIiwiZGlzcGxheSIsIm9uZUhvdXJBd2F5Iiwic2V0SXRlbSIsIm5leHQiLCJpc1ByZXJlbmRlcmVkIiwiX2hvdERldkNsaWVudCIsImRldkNsaWVudCIsInBhZ2UiLCJyb3V0ZXIiLCJfcGFnZSIsImNvbXBvbmVudHMiLCJpbml0SGVhZE1hbmFnZXIiLCJET01BdHRyaWJ1dGVOYW1lcyIsImFjY2VwdENoYXJzZXQiLCJjbGFzc05hbWUiLCJodG1sRm9yIiwiaHR0cEVxdWl2IiwicmVhY3RFbGVtZW50VG9ET00iLCJwcm9wcyIsImVsIiwicCIsImF0dHIiLCJzZXRBdHRyaWJ1dGUiLCJjaGlsZHJlbiIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwidXBkYXRlRWxlbWVudHMiLCJoZWFkRWwiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImhlYWRDb3VudEVsIiwiaGVhZENvdW50IiwiTnVtYmVyIiwiY29udGVudCIsIm9sZFRhZ3MiLCJqIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsInRhZ05hbWUiLCJuZXdUYWdzIiwibmV3VGFnIiwibGVuIiwib2xkVGFnIiwiaXNFcXVhbE5vZGUiLCJ0IiwiaW5zZXJ0QmVmb3JlIiwidG9TdHJpbmciLCJ1cGRhdGVQcm9taXNlIiwiaGVhZCIsInByb21pc2UiLCJ0YWdzIiwiaCIsInRpdGxlQ29tcG9uZW50IiwidGl0bGUiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZDMiLCJyZW5kZXIiLCJyZW5kZXJFcnJvciIsImVtaXR0ZXIiLCJ2ZXJzaW9uIiwiX2V4dGVuZHMyIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQyIiwiX3F1ZXJ5c3RyaW5nIiwiX3JlYWN0IiwiX3JlYWN0RG9tIiwiX2hlYWRNYW5hZ2VyQ29udGV4dCIsIl9taXR0IiwiX3JvdXRlckNvbnRleHQiLCJfaXNEeW5hbWljIiwiZW52Q29uZmlnIiwiX3V0aWxzIiwiX2hlYWRNYW5hZ2VyIiwiX3BhZ2VMb2FkZXIiLCJfcGVyZm9ybWFuY2VSZWxheWVyIiwiZ2V0RWxlbWVudEJ5SWQiLCJxdWVyeSIsImJ1aWxkSWQiLCJydW50aW1lQ29uZmlnIiwiZHluYW1pY0lkcyIsImlzRmFsbGJhY2siLCJfX3dlYnBhY2tfcHVibGljX3BhdGhfXyIsInNldENvbmZpZyIsInNlcnZlclJ1bnRpbWVDb25maWciLCJwdWJsaWNSdW50aW1lQ29uZmlnIiwiYXNQYXRoIiwiZ2V0VVJMIiwicGFnZUxvYWRlciIsInIiLCJyZWdpc3RlclBhZ2UiLCJfX05FWFRfUCIsInVwZGF0ZUhlYWQiLCJhcHBFbGVtZW50IiwibGFzdEFwcFByb3BzIiwid2VicGFja0hNUiIsIkVycm9yQ29tcG9uZW50IiwiQ29tcG9uZW50IiwiQXBwIiwib25QZXJmRW50cnkiLCJDb250YWluZXIiLCJpbmZvIiwic2Nyb2xsVG9IYXNoIiwiaXNTc3IiLCJpc0R5bmFtaWNSb3V0ZSIsInNlYXJjaCIsIl9fTl9TU0ciLCJzdWJzdHIiLCJfaCIsInNoYWxsb3ciLCJfX05FWFRfSFlEUkFURUQiLCJfX05FWFRfSFlEUkFURURfQ0IiLCJzdWJzdHJpbmciLCJzY3JvbGxJbnRvVmlldyIsIlJlYWN0RGV2T3ZlcmxheSIsIl90ZW1wIiwicGFzc2VkV2VicGFja0hNUiIsImxvYWRQYWdlU2NyaXB0IiwiYXBwIiwibW9kIiwicmVwb3J0V2ViVml0YWxzIiwiX3JlZjIiLCJzdGFydFRpbWUiLCJkdXJhdGlvbiIsImVudHJ5VHlwZSIsImVudHJpZXMiLCJ1bmlxdWVJRCIsIm5vdyIsImZsb29yIiwicmFuZG9tIiwicGVyZlN0YXJ0RW50cnkiLCJsYWJlbCIsImluaXRpYWxFcnIiLCJsb2FkUGFnZSIsImlzVmFsaWRFbGVtZW50VHlwZSIsImdldE5vZGVFcnJvciIsInN0YWNrIiwibm9kZSIsIl9fTkVYVF9QUkVMT0FEUkVBRFkiLCJjcmVhdGVSb3V0ZXIiLCJpbml0aWFsUHJvcHMiLCJ3cmFwQXBwIiwic3Vic2NyaXB0aW9uIiwiX3JlZjMiLCJyZW5kZXJDdHgiLCJkb1JlbmRlciIsIl9yZWY0IiwiQXBwVHJlZSIsImFwcEN0eCIsImN0eCIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJpbml0UHJvcHMiLCJpc0luaXRpYWxSZW5kZXIiLCJoeWRyYXRlIiwicmVhY3RSb290IiwicmVuZGVyUmVhY3RFbGVtZW50IiwicmVhY3RFbCIsImRvbUVsIiwiU1QiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJtYXJrSHlkcmF0ZUNvbXBsZXRlIiwibWFya1JlbmRlckNvbXBsZXRlIiwibWVhc3VyZSIsImdldEVudHJpZXNCeU5hbWUiLCJjbGVhck1hcmtzIiwibmF2U3RhcnRFbnRyaWVzIiwiY2xlYXJNZWFzdXJlcyIsIkFwcENvbnRhaW5lciIsIl9yZWY1IiwiUm91dGVyQ29udGV4dCIsIlByb3ZpZGVyIiwibWFrZVB1YmxpY1JvdXRlckluc3RhbmNlIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiYXBwUHJvcHMiLCJfcmVmNiIsIl9xdWVyeSIsIl9hc1BhdGgiLCJlbWl0IiwiZWxlbSIsIl9ldmVudFNvdXJjZVBvbHlmaWxsIiwiX29uRGVtYW5kRW50cmllc0NsaWVudCIsIl93ZWJwYWNrSG90TWlkZGxld2FyZUNsaWVudCIsIl9kZXZCdWlsZFdhdGNoZXIiLCJfcHJlcmVuZGVySW5kaWNhdG9yIiwiX2ZvdWMiLCJ2ZXJzaW9ucyIsImxhc3RTY3JvbGwiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwieSIsInNjcm9sbCIsIl91cmwiLCJfcm91dGVNYXRjaGVyIiwiX3JvdXRlUmVnZXgiLCJoYXNSZWwiLCJyZWwiLCJsaW5rIiwicmVsTGlzdCIsInN1cHBvcnRzIiwicmVsUHJlZmV0Y2giLCJoYXNOb01vZHVsZSIsIm5vcm1hbGl6ZVJvdXRlIiwicm91dGUiLCJhcHBlbmRMaW5rIiwiYXMiLCJyZXMiLCJyZWoiLCJjcm9zc09yaWdpbiIsIlBhZ2VMb2FkZXIiLCJwYWdlQ2FjaGUiLCJwYWdlUmVnaXN0ZXJFdmVudHMiLCJsb2FkaW5nUm91dGVzIiwicHJvbWlzZWRTc2dNYW5pZmVzdCIsIl9fU1NHX01BTklGRVNUIiwiX19TU0dfTUFOSUZFU1RfQ0IiLCJwcm9taXNlZEJ1aWxkTWFuaWZlc3QiLCJtYW4iLCJlbmNvZGVVUkkiLCJnZXRIcmVmRm9yU2x1ZyIsImRlbEJhc2VQYXRoIiwiaHJlZlBhdGhuYW1lIiwiYXNQYXRobmFtZSIsImlzRHluYW1pYyIsImludGVycG9sYXRlZFJvdXRlIiwiZHluYW1pY1JlZ2V4IiwiZ2V0Um91dGVSZWdleCIsImR5bmFtaWNHcm91cHMiLCJncm91cHMiLCJkeW5hbWljTWF0Y2hlcyIsImdldFJvdXRlTWF0Y2hlciIsImtleXMiLCJldmVyeSIsInBhcmFtIiwicmVwZWF0IiwiQXJyYXkiLCJpc0FycmF5IiwicyIsIl9kYXRhSHJlZiIsImhhcyIsImdldERhdGFIcmVmIiwib2ZmIiwiY2FjaGVkUGFnZSIsImxvYWRSb3V0ZSIsInNjcmlwdFJvdXRlIiwibG9hZFNjcmlwdCIsImlzUGFnZSIsInNjcmlwdCIsInNyYyIsImNvZGUiLCJyZWdGbiIsInBhZ2VEYXRhIiwiaXNEZXBlbmRlbmN5IiwiY24iLCJuYXZpZ2F0b3IiLCJjb25uZWN0aW9uIiwic2F2ZURhdGEiLCJlZmZlY3RpdmVUeXBlIiwiX3dlYlZpdGFscyIsImdldENMUyIsImdldEZJRCIsImdldEZDUCIsImdldExDUCIsImdldFRURkIiLCJ1c2VSb3V0ZXIiLCJ3aXRoUm91dGVyIiwiX3JvdXRlcjIiLCJSb3V0ZXIiLCJOZXh0Um91dGVyIiwiX3dpdGhSb3V0ZXIiLCJzaW5nbGV0b25Sb3V0ZXIiLCJyZWFkeUNhbGxiYWNrcyIsInVybFByb3BlcnR5RmllbGRzIiwicm91dGVyRXZlbnRzIiwiY29yZU1ldGhvZEZpZWxkcyIsImRlZmluZVByb3BlcnR5IiwiZ2V0Um91dGVyIiwiYXJndW1lbnRzIiwiZXZlbnRGaWVsZCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiX3NpbmdsZXRvblJvdXRlciIsInVzZUNvbnRleHQiLCJfbGVuIiwiYXJncyIsIl9rZXkiLCJpbnN0YW5jZSIsInByb3BlcnR5IiwiYXNzaWduIiwiQ29tcG9zZWRDb21wb25lbnQiLCJXaXRoUm91dGVyV3JhcHBlciIsImdldEluaXRpYWxQcm9wcyIsIm9yaWdHZXRJbml0aWFsUHJvcHMiLCJkaXNwbGF5TmFtZSIsIl9fd2VicGFja19yZXF1aXJlX18iLCJsIiwiYWIiLCJfX2Rpcm5hbWUiLCJzdGFydHVwIiwiX19pbXBvcnRTdGFyIiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwibWl0dCIsImV2dHMiLCJfX2ltcG9ydERlZmF1bHQiLCJ1cmxfMSIsIm1pdHRfMSIsInV0aWxzXzEiLCJpc19keW5hbWljXzEiLCJyb3V0ZV9tYXRjaGVyXzEiLCJyb3V0ZV9yZWdleF8xIiwiYmFzZVBhdGgiLCJhZGRCYXNlUGF0aCIsInRvUm91dGUiLCJwcmVwYXJlUm91dGUiLCJmZXRjaE5leHREYXRhIiwiaXNTZXJ2ZXJSZW5kZXIiLCJhdHRlbXB0cyIsImdldFJlc3BvbnNlIiwiZmV0Y2giLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsIm9rIiwic2RjIiwib25Qb3BTdGF0ZSIsImNoYW5nZVN0YXRlIiwiX2JwcyIsIl9nZXRTdGF0aWNEYXRhIiwiX2dldFNlcnZlckRhdGEiLCJfX05fU1NQIiwiYXV0b0V4cG9ydCIsInN1YiIsImNsYyIsIl93cmFwQXBwIiwibmV3RGF0YSIsIm5vdGlmeSIsImhpc3RvcnkiLCJiYWNrIiwiY2hhbmdlIiwiX2FzIiwiYWJvcnRDb21wb25lbnRMb2FkIiwib25seUFIYXNoQ2hhbmdlIiwicHJvdG9jb2wiLCJ1cmxJc05ldyIsInJvdXRlUmVnZXgiLCJyb3V0ZU1hdGNoIiwibWlzc2luZ1BhcmFtcyIsImdldFJvdXRlSW5mbyIsInJvdXRlSW5mbyIsImNhbmNlbGxlZCIsImFwcENvbXAiLCJzZXQiLCJjYWNoZWRSb3V0ZUluZm8iLCJoYW5kbGVFcnJvciIsImxvYWRFcnJvckZhaWwiLCJmZXRjaENvbXBvbmVudCIsImdpcEVyciIsIl9nZXREYXRhIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsIm5ld1VybE5vSGFzaCIsIm5ld0hhc2giLCJzY3JvbGxUbyIsImlkRWwiLCJuYW1lRWwiLCJnZXRFbGVtZW50c0J5TmFtZSIsInByZWZldGNoRGF0YSIsInByaW9yaXR5IiwiY29tcG9uZW50UmVzdWx0IiwiVEVTVF9ST1VURSIsInJlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiXyIsInBhcmFtcyIsInNsdWdOYW1lIiwiZyIsIm0iLCJwb3MiLCJlbnRyeSIsImVzY2FwZVJlZ2V4Iiwic3RyIiwibm9ybWFsaXplZFJvdXRlIiwiZXNjYXBlZFJvdXRlIiwiZ3JvdXBJbmRleCIsInBhcmFtZXRlcml6ZWRSb3V0ZSIsIiQxIiwiaXNDYXRjaEFsbCIsIm5hbWVkUGFyYW1ldGVyaXplZFJvdXRlIiwibmFtZWRSZWdleCIsImNvbmZpZ1ZhbHVlIiwiZXhlY09uY2UiLCJ1c2VkIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJob3N0bmFtZSIsInBvcnQiLCJvcmlnaW4iLCJnZXREaXNwbGF5TmFtZSIsImlzUmVzU2VudCIsImZpbmlzaGVkIiwiaGVhZGVyc1NlbnQiLCJfYSIsInBhZ2VQcm9wcyIsInVybE9iamVjdEtleXMiLCJrZXkiLCJmb3JtYXQiLCJTUCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7Ozs7O0FD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Q0E7O0FBRUE7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG1CQUFtQjtBQUNuRTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEVBQTBFLGdCQUFnQjtBQUMxRix1REFBdUQsZ0JBQWdCOztBQUV2RTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0Esb0M7Ozs7Ozs7Ozs7OztBQ2pVYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsZUFBZTtBQUNsRTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsbUJBQU8sQ0FBQyxxRkFBNEI7O0FBRTVEOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyx1REFBVzs7QUFFbEM7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLDZEQUFnQjs7QUFFdkM7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQW1COztBQUUzQyxpQkFBaUIsbUJBQU8sQ0FBQyx5RUFBc0I7O0FBRS9DOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQzs7Ozs7Ozs7Ozs7O0FDdkZhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixtQkFBTyxDQUFDLHFGQUE0Qjs7QUFFNUQ7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMseUVBQXNCOztBQUUvQzs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQzs7Ozs7Ozs7Ozs7O0FDdEVhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVELHNCQUFzQixtQkFBTyxDQUFDLGlGQUEwQjs7QUFFeEQ7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLDZEQUFnQjs7QUFFdkM7O0FBRUEsd0JBQXdCLG1CQUFPLENBQUMscUZBQTRCOztBQUU1RDs7QUFFQSx1QkFBdUIsbUJBQU8sQ0FBQyxtRkFBMkI7O0FBRTFEOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxtQkFBbUI7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsbUM7Ozs7Ozs7Ozs7OztBQ2hLYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFO0FBQ2pqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTs7QUFFQSxrQ0FBa0MsbUNBQW1DO0FBQ3JFLFVBQVU7QUFDVjs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyxxRUFBb0I7O0FBRTdDOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFvQjs7QUFFN0M7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsdUVBQXFCOztBQUU3Qzs7QUFFQSx1QkFBdUIsbUJBQU8sQ0FBQyx1RkFBNkI7O0FBRTVEOztBQUVBLHVCQUF1QixtQkFBTyxDQUFDLGlGQUEwQjs7QUFFekQsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxRkFBcUY7QUFDckY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDBEQUEwRDtBQUNuRyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxzQ0FBc0M7QUFDL0c7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsa0JBQWtCO0FBQzNGO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLG9DOzs7Ozs7Ozs7Ozs7QUMvTGE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxtRkFBbUY7QUFDbkY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEscUJBQXFCLG1CQUFPLENBQUMseUVBQXNCOztBQUVuRDs7QUFFQSxtQkFBbUIsbUJBQU8sQ0FBQyx5RUFBc0I7O0FBRWpEOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyx1REFBYTs7QUFFaEM7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0EscUM7Ozs7Ozs7Ozs7OztBQ2pGYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQzs7Ozs7Ozs7Ozs7O0FDakZhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVELG9HQUFvRyxtQkFBbUIsRUFBRSxtQkFBbUIsOEhBQThIOztBQUUxUSxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFOztBQUVqakI7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFvQjs7QUFFN0M7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsMkVBQXVCOztBQUVsRDs7QUFFQSx3QkFBd0IsbUJBQU8sQ0FBQyxxRkFBNEI7O0FBRTVEOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLDRDOzs7Ozs7Ozs7Ozs7QUM1SWE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLG1CQUFPLENBQUMscUZBQTRCOztBQUU1RDs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBb0I7O0FBRTdDOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLDBFQUFtQjs7QUFFN0M7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7O0FBRUE7QUFDQSxxQzs7Ozs7Ozs7Ozs7O0FDdkRhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsMkVBQXVCOztBQUVoRDs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQywrREFBaUI7O0FBRTNDOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkM7Ozs7Ozs7Ozs7OztBQzVDYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLCtEQUFpQjs7QUFFMUM7O0FBRUEscUJBQXFCLG1CQUFPLENBQUMseUVBQXNCOztBQUVuRDs7QUFFQSxtQkFBbUIsbUJBQU8sQ0FBQyx5RUFBc0I7O0FBRWpEOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDOzs7Ozs7Ozs7Ozs7QUMxR2E7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSx3QkFBd0IsbUJBQU8sQ0FBQyxxRkFBNEI7O0FBRTVEOztBQUVBLG1CQUFtQixtQkFBTyxDQUFDLHlFQUFzQjs7QUFFakQ7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Qzs7Ozs7Ozs7Ozs7O0FDeEVhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsOERBQWE7O0FBRXRDOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFnQjs7QUFFeEM7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBLG9DOzs7Ozs7Ozs7Ozs7QUN0Q2E7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsNERBQVk7O0FBRXBDOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFvQjs7QUFFN0M7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQWtCOztBQUUxQzs7QUFFQSxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBeUI7O0FBRXBEOztBQUVBLG9CQUFvQixtQkFBTyxDQUFDLDhGQUE2Qjs7QUFFekQ7O0FBRUEsb0JBQW9CLG1CQUFPLENBQUMsOEZBQTZCOztBQUV6RDs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyx5RUFBc0I7O0FBRS9DOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUM7Ozs7Ozs7Ozs7OztBQ25HYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFO0FBQ2pqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsNERBQVk7O0FBRXBDOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLCtFQUF5Qjs7QUFFdEQ7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMseUVBQXNCOztBQUVqRDs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBbUI7O0FBRTNDLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQsZUFBZTtBQUNwRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0EsaUQ7Ozs7Ozs7Ozs7OztBQzlHYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFOztBQUVqakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFPLENBQUMscUVBQW9COztBQUU5Qzs7QUFFQSxxQkFBcUIsbUJBQU8sQ0FBQywrRUFBeUI7O0FBRXREOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLDZFQUF3Qjs7QUFFckQ7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1CQUFtQjtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxxRDs7Ozs7Ozs7Ozs7O0FDdk1hOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0NBQWdDLEVBQUU7QUFDckU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLDZFQUF3Qjs7QUFFckQ7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0EscUQ7Ozs7Ozs7Ozs7OztBQ3JFYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixtQkFBTyxDQUFDLG1GQUEyQjs7QUFFMUQ7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMseUVBQXNCOztBQUUvQzs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxxQzs7Ozs7Ozs7Ozs7O0FDbkVhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrRDs7Ozs7Ozs7Ozs7O0FDOUJhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQWtCOztBQUUxQzs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdCQUFnQixPQUFPLFdBQVcsV0FBVyxZQUFZLGlCQUFpQjtBQUM1SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLE9BQU87QUFDWixLQUFLLFNBQVM7QUFDZDtBQUNBLEtBQUssU0FBUztBQUNkO0FBQ0E7QUFDQSxLQUFLLFNBQVM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDOzs7Ozs7Ozs7Ozs7QUM3R2E7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQsV0FBVyxtQkFBTyxDQUFDLGlFQUFhOztBQUVoQzs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EOzs7Ozs7Ozs7Ozs7QUN0QmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQsV0FBVyxtQkFBTyxDQUFDLGlFQUFhOztBQUVoQzs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBa0I7O0FBRTFDOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQzs7Ozs7Ozs7Ozs7O0FDckNhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVELFdBQVcsbUJBQU8sQ0FBQyxpRUFBYTs7QUFFaEM7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQWtCOztBQUUxQzs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRDs7Ozs7Ozs7Ozs7O0FDbkNhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVELFVBQVUsbUJBQU8sQ0FBQyxpRUFBYTs7QUFFL0I7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RDs7Ozs7Ozs7Ozs7O0FDekJhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVELFdBQVcsbUJBQU8sQ0FBQyxpRkFBcUI7O0FBRXhDOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRDs7Ozs7Ozs7Ozs7O0FDdkJhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsc0JBQXNCLGVBQWU7QUFDOUYscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0Q7Ozs7Ozs7Ozs7OztBQ2pCYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRDs7Ozs7Ozs7Ozs7O0FDbEJhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQzs7Ozs7Ozs7Ozs7O0FDWmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsc0JBQXNCLGVBQWU7QUFDOUYscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLG1EOzs7Ozs7Ozs7Ozs7QUNmYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0M7Ozs7Ozs7Ozs7OztBQ2pCYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxXQUFXLG1CQUFPLENBQUMsaUVBQWE7O0FBRWhDOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQzs7Ozs7Ozs7Ozs7O0FDeEJhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVELFdBQVcsbUJBQU8sQ0FBQyxpRUFBYTs7QUFFaEM7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEOzs7Ozs7Ozs7Ozs7QUN2QmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRDs7Ozs7Ozs7Ozs7O0FDakNhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBa0I7O0FBRTFDOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3Rjs7QUFFQTtBQUNBLDBEOzs7Ozs7Ozs7Ozs7QUNuQmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0Q7Ozs7Ozs7Ozs7OztBQ2ZhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRDs7Ozs7Ozs7Ozs7O0FDcEJhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVELFdBQVcsbUJBQU8sQ0FBQyxpRUFBYTs7QUFFaEM7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRDs7Ozs7Ozs7Ozs7O0FDekJhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVELFdBQVcsbUJBQU8sQ0FBQyxpRUFBYTs7QUFFaEM7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQWtCOztBQUUxQzs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Qzs7Ozs7Ozs7Ozs7O0FDdENhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBa0I7O0FBRTFDOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBOztBQUVBO0FBQ0EsNEM7Ozs7Ozs7Ozs7OztBQ3BCYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxXQUFXLG1CQUFPLENBQUMsaUVBQWE7O0FBRWhDOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEOzs7Ozs7Ozs7Ozs7QUMxQmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEOzs7Ozs7Ozs7Ozs7QUM1QmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYyxnQkFBZ0I7QUFDOUUsa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Qzs7Ozs7Ozs7Ozs7O0FDaEJhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQsa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsbUU7Ozs7Ozs7Ozs7OztBQ2ZhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWMsZ0JBQWdCO0FBQzlFLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGtEOzs7Ozs7Ozs7Ozs7QUNmYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Qzs7Ozs7Ozs7Ozs7O0FDYmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQsV0FBVyxtQkFBTyxDQUFDLG1FQUFjOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHlEOzs7Ozs7Ozs7Ozs7QUNqQmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQsV0FBVyxtQkFBTyxDQUFDLG1FQUFjOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLDREOzs7Ozs7Ozs7Ozs7QUNuQmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLGlFQUFrQjs7QUFFMUM7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0M7Ozs7Ozs7Ozs7OztBQ3hCYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxXQUFXLG1CQUFPLENBQUMsbUVBQWM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUU7Ozs7Ozs7Ozs7OztBQ2pCYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxXQUFXLG1CQUFPLENBQUMsbUVBQWM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esd0Q7Ozs7Ozs7Ozs7OztBQ2pCYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxXQUFXLG1CQUFPLENBQUMsbUVBQWM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtEOzs7Ozs7Ozs7Ozs7QUNsQmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQsV0FBVyxtQkFBTyxDQUFDLG1FQUFjOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHFDOzs7Ozs7Ozs7Ozs7QUNqQmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEQ7Ozs7Ozs7Ozs7OztBQ2ZhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUM7Ozs7Ozs7Ozs7OztBQ2pCYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxVQUFVLG1CQUFPLENBQUMsaUVBQWE7O0FBRS9COztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEOzs7Ozs7Ozs7Ozs7QUN4QmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLG9IQUE2Qzs7QUFFbEU7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCOzs7Ozs7Ozs7Ozs7QUNuQ2E7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRCxrQ0FBa0M7QUFDbEM7QUFDQSx1Qzs7Ozs7Ozs7Ozs7O0FDUGE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRCxrQ0FBa0M7QUFDbEM7QUFDQSwrQjs7Ozs7Ozs7Ozs7O0FDUGE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQsV0FBVyxtQkFBTyxDQUFDLDJEQUFPOztBQUUxQjs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0EsK0I7Ozs7Ozs7Ozs7OztBQ2hCYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxXQUFXLG1CQUFPLENBQUMsMkRBQU87O0FBRTFCOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSwrQjs7Ozs7Ozs7Ozs7O0FDaEJhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0NBQXNDO0FBQ3RDO0FBQ0EsK0I7Ozs7Ozs7Ozs7OztBQ1BhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVELGVBQWUsbUJBQU8sQ0FBQyxxREFBWTs7QUFFbkM7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEM7Ozs7Ozs7Ozs7OztBQ2hGYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsdUVBQWdCOztBQUUzQzs7QUFFQSxxQkFBcUIsbUJBQU8sQ0FBQywyRUFBa0I7O0FBRS9DOztBQUVBLHVDQUF1QyxtQkFBTyxDQUFDLHFIQUF1Qzs7QUFFdEY7O0FBRUEsNEJBQTRCLG1CQUFPLENBQUMsNkZBQTJCOztBQUUvRDs7QUFFQSx5QkFBeUIsbUJBQU8sQ0FBQyxxRkFBdUI7O0FBRXhEOztBQUVBLDRCQUE0QixtQkFBTyxDQUFDLDZGQUEyQjs7QUFFL0Q7O0FBRUEsaUNBQWlDLG1CQUFPLENBQUMsdUdBQWdDOztBQUV6RTs7QUFFQSwyQkFBMkIsbUJBQU8sQ0FBQywyRkFBMEI7O0FBRTdEOztBQUVBLHVDQUF1QyxtQkFBTyxDQUFDLHFIQUF1Qzs7QUFFdEY7O0FBRUEsNkJBQTZCLG1CQUFPLENBQUMsNkZBQTJCOztBQUVoRTs7QUFFQSxxQkFBcUIsbUJBQU8sQ0FBQywyRUFBa0I7O0FBRS9DOztBQUVBLDZCQUE2QixtQkFBTyxDQUFDLDZGQUEyQjs7QUFFaEU7O0FBRUEseUJBQXlCLG1CQUFPLENBQUMscUZBQXVCOztBQUV4RDs7QUFFQSxxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBbUI7O0FBRWhEOztBQUVBLDhCQUE4QixtQkFBTyxDQUFDLGlHQUE2Qjs7QUFFbkU7O0FBRUEsMkJBQTJCLG1CQUFPLENBQUMsMkZBQTBCOztBQUU3RDs7QUFFQSxrQ0FBa0MsbUJBQU8sQ0FBQywyR0FBa0M7O0FBRTVFOztBQUVBLDRCQUE0QixtQkFBTyxDQUFDLDJGQUEwQjs7QUFFOUQ7O0FBRUEsMEJBQTBCLG1CQUFPLENBQUMsdUZBQXdCOztBQUUxRDs7QUFFQSw0QkFBNEIsbUJBQU8sQ0FBQyw2RkFBMkI7O0FBRS9EOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLCtFQUFvQjs7QUFFbEQ7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsK0VBQW9COztBQUVsRDs7QUFFQSw4QkFBOEIsbUJBQU8sQ0FBQyxpR0FBNkI7O0FBRW5FOztBQUVBLDJCQUEyQixtQkFBTyxDQUFDLHlGQUF5Qjs7QUFFNUQ7O0FBRUEsdUJBQXVCLG1CQUFPLENBQUMsaUZBQXFCOztBQUVwRDs7QUFFQSwyQ0FBMkMsbUJBQU8sQ0FBQyw2SEFBMkM7O0FBRTlGOztBQUVBLDRCQUE0QixtQkFBTyxDQUFDLDJGQUEwQjs7QUFFOUQ7O0FBRUEsb0JBQW9CLG1CQUFPLENBQUMseUVBQWlCOztBQUU3Qzs7QUFFQSxrQ0FBa0MsbUJBQU8sQ0FBQyx5R0FBaUM7O0FBRTNFOztBQUVBLGlDQUFpQyxtQkFBTyxDQUFDLHVHQUFnQzs7QUFFekU7O0FBRUEseUNBQXlDLG1CQUFPLENBQUMseUhBQXlDOztBQUUxRjs7QUFFQSwyQkFBMkIsbUJBQU8sQ0FBQywyRkFBMEI7O0FBRTdEOztBQUVBLHFDQUFxQyxtQkFBTyxDQUFDLCtHQUFvQzs7QUFFakY7O0FBRUEsd0JBQXdCLG1CQUFPLENBQUMscUZBQXVCOztBQUV2RDs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBYTs7QUFFckM7O0FBRUEsdUNBQXVDLG1CQUFPLENBQUMsbUhBQXNDOztBQUVyRjs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyxxRUFBZTs7QUFFekM7O0FBRUEsaUNBQWlDLG1CQUFPLENBQUMsdUdBQWdDOztBQUV6RTs7QUFFQSxvQ0FBb0MsbUJBQU8sQ0FBQywrR0FBb0M7O0FBRWhGOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9DOzs7Ozs7Ozs7Ozs7QUN6T2E7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLGlFQUFrQjs7QUFFMUM7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7O0FBRUE7QUFDQSw0RDs7Ozs7Ozs7Ozs7O0FDcEJhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEM7Ozs7Ozs7Ozs7OztBQzdCYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlCQUFpQjtBQUMxRDtBQUNBOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEM7Ozs7Ozs7Ozs7OztBQ25DYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMscUVBQW9COztBQUU3Qzs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQSw4Qzs7Ozs7Ozs7Ozs7O0FDekNhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQzs7Ozs7Ozs7Ozs7O0FDaENhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEOzs7Ozs7Ozs7Ozs7QUN0QmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Qzs7Ozs7Ozs7Ozs7O0FDbkJhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsMEJBQTBCLG1CQUFPLENBQUMsbUZBQXdCOztBQUUxRDs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQywrREFBYzs7QUFFdkM7O0FBRUEsdUJBQXVCLG1CQUFPLENBQUMsNkVBQXFCOztBQUVwRDs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkM7Ozs7Ozs7Ozs7OztBQ2pFYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQU8sQ0FBQyxtRUFBZ0I7O0FBRTNDOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBLHNDOzs7Ozs7Ozs7Ozs7QUNsQmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLDJEQUFZOztBQUUvQjs7QUFFQSxtQkFBbUIsbUJBQU8sQ0FBQyx5RUFBc0I7O0FBRWpEOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7Ozs7Ozs7OztBQ3REYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQzs7Ozs7Ozs7Ozs7O0FDakJhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsaUZBQTBCOztBQUV4RDs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQywrREFBYzs7QUFFdkM7O0FBRUEsb0JBQW9CLG1CQUFPLENBQUMsdUVBQWtCOztBQUU5Qzs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSwyQzs7Ozs7Ozs7Ozs7O0FDeEhhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0M7Ozs7Ozs7Ozs7OztBQ2xDYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxpQkFBaUIsbUJBQU8sQ0FBQyxxREFBVTs7QUFFbkM7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0M7Ozs7Ozs7Ozs7OztBQzVEYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsbUJBQU8sQ0FBQywrSEFBaUQ7O0FBRWhHOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Qzs7Ozs7Ozs7Ozs7O0FDaENhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQzs7Ozs7Ozs7Ozs7O0FDakJhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLHlFQUFzQjs7QUFFbkQ7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0EsMEM7Ozs7Ozs7Ozs7OztBQzVCYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEOzs7Ozs7Ozs7Ozs7QUNuQ2E7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Qzs7Ozs7Ozs7Ozs7O0FDbkNhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUM7Ozs7Ozs7Ozs7OztBQ1ZhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyw2REFBZ0I7O0FBRXZDOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLHVDOzs7Ozs7Ozs7Ozs7QUN4SGE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUVBQXlFLDJDQUEyQztBQUNwSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxpRUFBZTs7QUFFbEM7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMscUVBQW9COztBQUU3Qzs7QUFFQSx1QkFBdUIsbUJBQU8sQ0FBQyxpRkFBMEI7O0FBRXpELHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3Rjs7QUFFQTtBQUNBO0FBQ0EsK0I7Ozs7Ozs7Ozs7OztBQ2hHYTs7QUFFYjs7QUFFQSxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFOztBQUVqakIsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkoscUJBQXFCLDBDQUEwQyxHQUFHLDBDQUEwQyxHQUFHLDRDQUE0QyxHQUFHLCtDQUErQyxHQUFHLDJDQUEyQyxHQUFHLGdEQUFnRCxHQUFHLDZDQUE2QyxHQUFHLDhDQUE4QyxLQUFLLG9EQUFvRCxHQUFHLG1EQUFtRCxHQUFHLG1EQUFtRCxHQUFHLHVEQUF1RCxHQUFHLG9EQUFvRCxHQUFHLHdEQUF3RCxHQUFHLHFEQUFxRCxHQUFHLHVEQUF1RDs7QUFFbDFCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIscUJBQXFCLE9BQU87QUFDNUI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixxQkFBcUIsT0FBTztBQUM1Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIscUJBQXFCLE9BQU87QUFDNUI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQixPQUFPO0FBQzVCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsT0FBTztBQUNsQywrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEMsZ0NBQWdDLFFBQVE7QUFDeEMsb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixxQkFBcUIsT0FBTztBQUM1Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQixzQkFBc0I7QUFDdEYsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQixPQUFPO0FBQzVCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixxQkFBcUIsT0FBTztBQUM1Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIscUJBQXFCLE9BQU87QUFDNUI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQixPQUFPO0FBQzVCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7O0FBRUE7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLGNBQWM7QUFDbEM7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSx1Qjs7Ozs7Ozs7Ozs7QUNobkJBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsS0FBSyxJQUEwQjtBQUMvQjtBQUNBO0FBQ0EsRUFBRSxNQUFNLEVBTU47QUFDRixDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ3pHRCxXQUFXLG1CQUFPLENBQUMsNERBQWEsNkVBQTZFLGNBQWMsNkJBQTZCLHNCQUFzQiw0RkFBNEYsNktBQTZLLDZCQUE2QixpTEFBaUwseUdBQXlHLFFBQVEsc0RBQXNELHVHQUF1RyxnQkFBZ0IsZ0NBQWdDLDRCQUE0QixnQkFBZ0IsOEtBQThLLGlCQUFpQixnR0FBZ0csd0ZBQXdGLGtPQUFrTyxjQUFjLG1EQUFtRCwwRUFBMEUsSUFBSSw2REFBNkQsSUFBSSxhQUFhLGNBQWMsSUFBSSxvQkFBb0IsU0FBUyxVQUFVLGtCQUFrQix3RkFBd0YsNEJBQTRCLG1HQUFtRyw0REFBNEQsd0tBQXdLLDJDQUEyQyx1REFBdUQsc0JBQXNCLElBQUksYUFBYSxTQUFTLHlFQUF5RSxJQUFJLGVBQWUsU0FBUyxnQ0FBZ0MscU5BQXFOLG1CQUFtQiw0bEJBQTRsQixvREFBb0QsMENBQTBDLGlDQUFpQyxJQUFJLHVGQUF1RixpQkFBaUI7QUFDam5IOzs7Ozs7Ozs7Ozs7O0FDREE7QUFBQTtBQUF3Qzs7QUFFeEM7QUFDQSx1QkFBdUIsc0RBQU8sQ0FBQyxRQUFVLEdBQUcsUUFBUSxHQUFhLEVBQUU7QUFDbkUsS0FBSyxJQUF1QjtBQUM1Qjs7Ozs7Ozs7Ozs7O0FDTEEsc0NBQXNDLDhDQUE4QyxnQ0FBZ0MsNkJBQTZCLHNDQUFzQyxTQUFTLEVBQUUsYUFBYSxzQ0FBc0MsUUFBUSxFQUFFLEc7Ozs7Ozs7Ozs7O0FDQS9QLDZCQUE2QixjQUFjLDJCQUEyQix1Q0FBdUMsY0FBYyxPQUFPLGlHQUFpRyx1Q0FBdUMsaUJBQWlCLG1EQUFtRCxpQkFBaUIsK0NBQStDLGtCQUFrQixnQkFBZ0IsU0FBUyxvQkFBb0IsU0FBUyxpQkFBaUIsMEJBQTBCLGlCQUFpQiwrQkFBK0IsOERBQThELGlGQUFpRiwrREFBK0QsU0FBUyxxR0FBcUcscUJBQXFCO0FBQ2w0Qjs7Ozs7Ozs7Ozs7OztBQ0RBLDhDQUFhOztBQUFBUixPQUFPLENBQUNVLFVBQVIsR0FBbUIsSUFBbkI7QUFBd0JWLE9BQU8sV0FBUCxHQUFnQlcsc0JBQWhCOztBQUF1QyxJQUFJQyxZQUFZLEdBQUNMLG1CQUFPLENBQUMscUdBQUQsQ0FBeEI7O0FBQXdELFNBQVNJLHNCQUFULEdBQWlDO0FBQUMsTUFBSUUsVUFBVSxHQUFDQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBZjtBQUE2Q0YsWUFBVSxDQUFDRyxFQUFYLEdBQWMsc0JBQWQsQ0FBOUMsQ0FBbUY7O0FBQ3hQSCxZQUFVLENBQUNJLEtBQVgsQ0FBaUJDLFFBQWpCLEdBQTBCLE9BQTFCO0FBQWtDTCxZQUFVLENBQUNJLEtBQVgsQ0FBaUJFLE1BQWpCLEdBQXdCLE1BQXhCO0FBQStCTixZQUFVLENBQUNJLEtBQVgsQ0FBaUJHLEtBQWpCLEdBQXVCLE1BQXZCO0FBQThCUCxZQUFVLENBQUNJLEtBQVgsQ0FBaUJJLEtBQWpCLEdBQXVCLENBQXZCO0FBQXlCUixZQUFVLENBQUNJLEtBQVgsQ0FBaUJLLE1BQWpCLEdBQXdCLENBQXhCO0FBQTBCVCxZQUFVLENBQUNJLEtBQVgsQ0FBaUJNLE1BQWpCLEdBQXdCLEtBQXhCO0FBQThCVCxVQUFRLENBQUNVLElBQVQsQ0FBY0MsV0FBZCxDQUEwQlosVUFBMUI7QUFBc0MsTUFBSWEsVUFBSjtBQUFlLE1BQUlDLE1BQU0sR0FBQyxFQUFYOztBQUFjLE1BQUdkLFVBQVUsQ0FBQ2UsWUFBZCxFQUEyQjtBQUFDRixjQUFVLEdBQUNiLFVBQVUsQ0FBQ2UsWUFBWCxDQUF3QjtBQUFDQyxVQUFJLEVBQUM7QUFBTixLQUF4QixDQUFYO0FBQW1ELEdBQS9FLE1BQW1GO0FBQUM7QUFDdlU7QUFDQTtBQUNBSCxjQUFVLEdBQUNiLFVBQVg7QUFBc0JjLFVBQU0sR0FBQyx1QkFBUDtBQUFnQyxHQUorRyxDQUkvRzs7O0FBQ3RELE1BQUlHLFNBQVMsR0FBQ0MsZUFBZSxDQUFDSixNQUFELENBQTdCO0FBQXNDRCxZQUFVLENBQUNELFdBQVgsQ0FBdUJLLFNBQXZCLEVBTCtILENBSzdGOztBQUN4RSxNQUFJRSxHQUFHLEdBQUNDLFNBQVMsQ0FBQ04sTUFBRCxDQUFqQjtBQUEwQkQsWUFBVSxDQUFDRCxXQUFYLENBQXVCTyxHQUF2QixFQU4ySSxDQU0vRzs7QUFDdEQsTUFBSUUsU0FBUyxHQUFDLEtBQWQ7QUFBb0IsTUFBSUMsVUFBVSxHQUFDLEtBQWY7QUFBcUIsTUFBSUMsU0FBUyxHQUFDLElBQWQsQ0FQNEgsQ0FPekc7O0FBQzVELE1BQUlDLFNBQVMsR0FBQyxDQUFDLEdBQUV6QixZQUFZLENBQUMwQixxQkFBaEIsRUFBdUM7QUFBQ0MsUUFBSSxFQUFDO0FBQU4sR0FBdkMsQ0FBZDtBQUFrRkYsV0FBUyxDQUFDRyxrQkFBVixDQUE2QixVQUFBQyxLQUFLLEVBQUU7QUFBQztBQUN2SCxRQUFHQSxLQUFLLENBQUNDLElBQU4sS0FBYSxjQUFoQixFQUErQjtBQUFDO0FBQVE7O0FBQUEsUUFBRztBQUFDQyxtQkFBYSxDQUFDRixLQUFELENBQWI7QUFBc0IsS0FBMUIsQ0FBMEIsT0FBTUcsT0FBTixFQUFjLENBQUU7QUFBQyxHQUREOztBQUNHLFdBQVNELGFBQVQsQ0FBdUJGLEtBQXZCLEVBQTZCO0FBQUMsUUFBSUksR0FBRyxHQUFDQyxJQUFJLENBQUNDLEtBQUwsQ0FBV04sS0FBSyxDQUFDQyxJQUFqQixDQUFSLENBQUQsQ0FBZ0M7O0FBQ2xKLFlBQU9HLEdBQUcsQ0FBQ0csTUFBWDtBQUFtQixXQUFJLFVBQUo7QUFBZVosaUJBQVMsSUFBRWEsWUFBWSxDQUFDYixTQUFELENBQXZCO0FBQW1DRixpQkFBUyxHQUFDLElBQVY7QUFBZUMsa0JBQVUsR0FBQyxJQUFYO0FBQWdCZSx1QkFBZTtBQUFHOztBQUFNLFdBQUksT0FBSjtBQUFZLFdBQUksTUFBSjtBQUFXZixrQkFBVSxHQUFDLEtBQVgsQ0FBWCxDQUE0Qjs7QUFDcEtDLGlCQUFTLEdBQUNlLFVBQVUsQ0FBQyxZQUFJO0FBQUNqQixtQkFBUyxHQUFDLEtBQVY7QUFBZ0JnQix5QkFBZTtBQUFJLFNBQXpDLEVBQTBDLEdBQTFDLENBQXBCO0FBQW1FQSx1QkFBZTtBQUFHO0FBRHJGO0FBQzZGOztBQUFBLFdBQVNBLGVBQVQsR0FBMEI7QUFBQyxRQUFHZixVQUFILEVBQWM7QUFBQ0wsZUFBUyxDQUFDc0IsU0FBVixDQUFvQkMsR0FBcEIsQ0FBd0IxQixNQUFNLEdBQUMsVUFBL0I7QUFBNEMsS0FBM0QsTUFBK0Q7QUFBQ0csZUFBUyxDQUFDc0IsU0FBVixDQUFvQkUsTUFBcEIsQ0FBMkIzQixNQUFNLEdBQUMsVUFBbEM7QUFBK0M7O0FBQUEsUUFBR08sU0FBSCxFQUFhO0FBQUNKLGVBQVMsQ0FBQ3NCLFNBQVYsQ0FBb0JDLEdBQXBCLENBQXdCMUIsTUFBTSxHQUFDLFNBQS9CO0FBQTJDLEtBQXpELE1BQTZEO0FBQUNHLGVBQVMsQ0FBQ3NCLFNBQVYsQ0FBb0JFLE1BQXBCLENBQTJCM0IsTUFBTSxHQUFDLFNBQWxDO0FBQThDO0FBQUM7QUFBQzs7QUFBQSxTQUFTSSxlQUFULENBQXlCSixNQUF6QixFQUFnQztBQUFDLE1BQUlHLFNBQVMsR0FBQ2hCLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixLQUF2QixDQUFkO0FBQTRDZSxXQUFTLENBQUNkLEVBQVYsR0FBYVcsTUFBTSxHQUFDLFdBQXBCO0FBQWdDRyxXQUFTLENBQUN5QixTQUFWLEdBQW9CLHFCQUFtQjVCLE1BQW5CLEdBQTBCLDZPQUExQixHQUF3UUEsTUFBeFEsR0FBK1Esd05BQS9RLEdBQXdlQSxNQUF4ZSxHQUErZSwyQ0FBL2UsR0FBMmhCQSxNQUEzaEIsR0FBa2lCLHFMQUF0akI7QUFBNHVCLFNBQU9HLFNBQVA7QUFBa0I7O0FBQUEsU0FBU0csU0FBVCxDQUFtQk4sTUFBbkIsRUFBMEI7QUFBQyxNQUFJSyxHQUFHLEdBQUNsQixRQUFRLENBQUNDLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBUjtBQUF3Q2lCLEtBQUcsQ0FBQ3dCLFdBQUosR0FBZ0IsWUFBVTdCLE1BQVYsR0FBaUIsNmlCQUFqQixHQUErakJBLE1BQS9qQixHQUFza0IsMkNBQXRrQixHQUFrbkJBLE1BQWxuQixHQUF5bkIsWUFBem5CLEdBQXNvQkEsTUFBdG9CLEdBQTZvQixpREFBN29CLEdBQStyQkEsTUFBL3JCLEdBQXNzQixZQUF0c0IsR0FBbXRCQSxNQUFudEIsR0FBMHRCLG9FQUExdEIsR0FBK3hCQSxNQUEveEIsR0FBc3lCLHlFQUF0eUIsR0FBZzNCQSxNQUFoM0IsR0FBdTNCLCtFQUF2M0IsR0FBdThCQSxNQUF2OEIsR0FBODhCLGlDQUE5OEIsR0FBZy9CQSxNQUFoL0IsR0FBdS9CLG9FQUF2L0IsR0FBNGpDQSxNQUE1akMsR0FBbWtDLHlLQUFua0MsR0FBNnVDQSxNQUE3dUMsR0FBb3ZDLHVKQUFwd0M7QUFBNDVDLFNBQU9LLEdBQVA7QUFBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWDNxRiw4Q0FBYTs7QUFBQWhDLE9BQU8sQ0FBQ1UsVUFBUixHQUFtQixJQUFuQjtBQUF3QlYsT0FBTyxDQUFDc0MscUJBQVIsR0FBOEJBLHFCQUE5QjtBQUFvRCxJQUFJbUIsY0FBYyxHQUFDLEVBQW5COztBQUFzQixTQUFTQyxrQkFBVCxDQUE0QkMsT0FBNUIsRUFBb0M7QUFBQyxNQUFJQyxNQUFKO0FBQVcsTUFBSUMsWUFBWSxHQUFDLElBQUlDLElBQUosRUFBakI7QUFBNEIsTUFBSUMsU0FBUyxHQUFDLEVBQWQ7O0FBQWlCLE1BQUcsQ0FBQ0osT0FBTyxDQUFDSyxPQUFaLEVBQW9CO0FBQUNMLFdBQU8sQ0FBQ0ssT0FBUixHQUFnQixLQUFHLElBQW5CO0FBQXlCOztBQUFBQyxNQUFJO0FBQUcsTUFBSUMsS0FBSyxHQUFDQyxXQUFXLENBQUMsWUFBVTtBQUFDLFFBQUcsSUFBSUwsSUFBSixLQUFXRCxZQUFYLEdBQXdCRixPQUFPLENBQUNLLE9BQW5DLEVBQTJDO0FBQUNJLHNCQUFnQjtBQUFJO0FBQUMsR0FBN0UsRUFBOEVULE9BQU8sQ0FBQ0ssT0FBUixHQUFnQixDQUE5RixDQUFyQjs7QUFBc0gsV0FBU0MsSUFBVCxHQUFlO0FBQUNMLFVBQU0sR0FBQyxJQUFJUyxNQUFNLENBQUNDLFdBQVgsQ0FBdUJYLE9BQU8sQ0FBQ3BCLElBQS9CLENBQVA7QUFBNENxQixVQUFNLENBQUNXLE1BQVAsR0FBY0MsWUFBZDtBQUEyQlosVUFBTSxDQUFDYSxPQUFQLEdBQWVMLGdCQUFmO0FBQWdDUixVQUFNLENBQUNjLFNBQVAsR0FBaUIvQixhQUFqQjtBQUFnQzs7QUFBQSxXQUFTNkIsWUFBVCxHQUF1QjtBQUFDLFFBQUdiLE9BQU8sQ0FBQ2dCLEdBQVgsRUFBZUMsT0FBTyxDQUFDRCxHQUFSLENBQVksaUJBQVo7QUFBK0JkLGdCQUFZLEdBQUMsSUFBSUMsSUFBSixFQUFiO0FBQXlCOztBQUFBLFdBQVNuQixhQUFULENBQXVCRixLQUF2QixFQUE2QjtBQUFDb0IsZ0JBQVksR0FBQyxJQUFJQyxJQUFKLEVBQWI7O0FBQXdCLFNBQUksSUFBSWUsQ0FBQyxHQUFDLENBQVYsRUFBWUEsQ0FBQyxHQUFDZCxTQUFTLENBQUNlLE1BQXhCLEVBQStCRCxDQUFDLEVBQWhDLEVBQW1DO0FBQUNkLGVBQVMsQ0FBQ2MsQ0FBRCxDQUFULENBQWFwQyxLQUFiO0FBQXFCOztBQUFBLFFBQUdBLEtBQUssQ0FBQ0MsSUFBTixDQUFXcUMsT0FBWCxDQUFtQixRQUFuQixNQUErQixDQUFDLENBQW5DLEVBQXFDO0FBQUN0QixvQkFBYyxDQUFDdUIsT0FBZixDQUF1QixVQUFBQyxFQUFFO0FBQUEsZUFBRUEsRUFBRSxDQUFDeEMsS0FBRCxDQUFKO0FBQUEsT0FBekI7QUFBdUM7QUFBQzs7QUFBQSxXQUFTMkIsZ0JBQVQsR0FBMkI7QUFBQ2MsaUJBQWEsQ0FBQ2hCLEtBQUQsQ0FBYjtBQUFxQk4sVUFBTSxDQUFDdUIsS0FBUDtBQUFlaEMsY0FBVSxDQUFDYyxJQUFELEVBQU1OLE9BQU8sQ0FBQ0ssT0FBZCxDQUFWO0FBQWtDOztBQUFBLFNBQU07QUFBQ21CLFNBQUssRUFBQyxpQkFBSTtBQUFDRCxtQkFBYSxDQUFDaEIsS0FBRCxDQUFiO0FBQXFCTixZQUFNLENBQUN1QixLQUFQO0FBQWdCLEtBQWpEO0FBQWtEM0Msc0JBQWtCLEVBQUMsU0FBU0Esa0JBQVQsQ0FBNEI0QyxFQUE1QixFQUErQjtBQUFDckIsZUFBUyxDQUFDc0IsSUFBVixDQUFlRCxFQUFmO0FBQW9CO0FBQXpILEdBQU47QUFBa0k7O0tBQXQ1QjFCLGtCOztBQUFzNUIsU0FBU3BCLHFCQUFULENBQStCcUIsT0FBL0IsRUFBdUM7QUFBQyxNQUFHLENBQUNBLE9BQU8sQ0FBQzJCLFFBQVosRUFBcUI7QUFBQyxXQUFNO0FBQUM5Qyx3QkFBa0IsRUFBQyw0QkFBQXlDLEVBQUUsRUFBRTtBQUFDeEIsc0JBQWMsQ0FBQzRCLElBQWYsQ0FBb0JKLEVBQXBCO0FBQXlCO0FBQWxELEtBQU47QUFBMkQ7O0FBQUEsU0FBT3ZCLGtCQUFrQixDQUFDQyxPQUFELENBQXpCO0FBQW9DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQTNxQyw4Q0FBYTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JWO0FBQ0g7Ozs7QUFDQSxJQUFJNEIsd0JBQXdCLEdBQUMsZUFBN0I7O0FBQTZDLFNBQVNDLG9CQUFULENBQThCQyxPQUE5QixFQUFzQztBQUFDLFNBQU9BLE9BQU8sQ0FBQ1YsT0FBUixDQUFnQlEsd0JBQWhCLE1BQTRDLENBQUMsQ0FBcEQ7QUFBdUQsQyxDQUFBOzs7QUFDM0ksU0FBU0csYUFBVCxDQUF1QkQsT0FBdkIsRUFBK0I7QUFBQyxNQUFJRSxLQUFLLEdBQUNGLE9BQU8sQ0FBQ0csS0FBUixDQUFjLElBQWQsQ0FBVixDQUFELENBQStCO0FBQzlEOztBQUNBRCxPQUFLLEdBQUNBLEtBQUssQ0FBQ0UsTUFBTixDQUFhLFVBQUFDLElBQUk7QUFBQSxXQUFFLENBQUMsdUJBQXVCQyxJQUF2QixDQUE0QkQsSUFBNUIsQ0FBSDtBQUFBLEdBQWpCLENBQU4sQ0FGK0IsQ0FFOEI7QUFDN0Q7O0FBQ0FILE9BQUssR0FBQ0EsS0FBSyxDQUFDSyxHQUFOLENBQVUsVUFBQUYsSUFBSSxFQUFFO0FBQUMsUUFBSUcsWUFBWSxHQUFDLGdEQUFnREMsSUFBaEQsQ0FBcURKLElBQXJELENBQWpCOztBQUE0RSxRQUFHLENBQUNHLFlBQUosRUFBaUI7QUFBQyxhQUFPSCxJQUFQO0FBQWE7O0FBQTVHLHVDQUFxSkcsWUFBcko7QUFBQSxRQUFpSEUsU0FBakg7QUFBQSxRQUEySEMsV0FBM0g7QUFBQSxRQUF1SUMsWUFBdkk7O0FBQWtLLFdBQU9kLHdCQUF3QixHQUFDLEdBQXpCLEdBQTZCYyxZQUE3QixHQUEwQyxJQUExQyxHQUErQ0YsU0FBL0MsR0FBeUQsR0FBekQsR0FBNkRDLFdBQTdELEdBQXlFLEdBQWhGO0FBQXFGLEdBQXZRLENBQU47QUFBK1FYLFNBQU8sR0FBQ0UsS0FBSyxDQUFDeEYsSUFBTixDQUFXLElBQVgsQ0FBUixDQUpoUCxDQUl5UTs7QUFDeFNzRixTQUFPLEdBQUNBLE9BQU8sQ0FBQ2hGLE9BQVIsQ0FBZ0IsMENBQWhCLEVBQTJEOEUsd0JBQXdCLEdBQUMsZUFBcEYsQ0FBUixDQUwrQixDQUs4RTs7QUFDN0dFLFNBQU8sR0FBQ0EsT0FBTyxDQUFDaEYsT0FBUixDQUFnQixpREFBaEIsRUFBa0UseURBQWxFLENBQVI7QUFBcUlnRixTQUFPLEdBQUNBLE9BQU8sQ0FBQ2hGLE9BQVIsQ0FBZ0IsMkVBQWhCLEVBQTRGLG9GQUE1RixDQUFSO0FBQTBMZ0YsU0FBTyxHQUFDQSxPQUFPLENBQUNoRixPQUFSLENBQWdCLHlFQUFoQixFQUEwRiw0RUFBMUYsQ0FBUjtBQUFnTGtGLE9BQUssR0FBQ0YsT0FBTyxDQUFDRyxLQUFSLENBQWMsSUFBZCxDQUFOLENBTmhkLENBTTBlOztBQUN6Z0IsTUFBR0QsS0FBSyxDQUFDYixNQUFOLEdBQWEsQ0FBYixJQUFnQmEsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTVyxJQUFULE9BQWtCLEVBQXJDLEVBQXdDO0FBQUNYLFNBQUssQ0FBQ1ksTUFBTixDQUFhLENBQWIsRUFBZSxDQUFmO0FBQW1CLEdBUDdCLENBTzZCOzs7QUFDNURaLE9BQUssQ0FBQyxDQUFELENBQUwsR0FBU0EsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTbEYsT0FBVCxDQUFpQixvQkFBakIsRUFBc0MsSUFBdEMsQ0FBVCxDQVIrQixDQVFzQjs7QUFDckQsTUFBR2tGLEtBQUssQ0FBQyxDQUFELENBQUwsSUFBVUEsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTWixPQUFULENBQWlCLG9CQUFqQixNQUF5QyxDQUF0RCxFQUF3RDtBQUFDWSxTQUFLLEdBQUMsQ0FBQ0EsS0FBSyxDQUFDLENBQUQsQ0FBTixFQUFVQSxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNsRixPQUFULENBQWlCLFNBQWpCLEVBQTJCLEVBQTNCLEVBQStCQSxPQUEvQixDQUF1QyxxQ0FBdkMsRUFBNkUsbUJBQTdFLENBQVYsQ0FBTjtBQUFvSCxHQVQ5SSxDQVM4STs7O0FBQzdLLE1BQUdrRixLQUFLLENBQUMsQ0FBRCxDQUFMLElBQVVBLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU2EsS0FBVCxDQUFlLCtCQUFmLENBQWIsRUFBNkQ7QUFBQztBQUM5RGIsU0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFTQSxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNsRixPQUFULENBQWlCLHlCQUFqQixFQUEyQyxJQUEzQyxDQUFUO0FBQTBEa0YsU0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFTLDRFQUFUO0FBQXNGQSxTQUFLLENBQUMsQ0FBRCxDQUFMLElBQVUsOERBQVY7QUFBeUVBLFNBQUssQ0FBQyxDQUFELENBQUwsSUFBVSxtREFBVjtBQUErRDs7QUFBQUYsU0FBTyxHQUFDRSxLQUFLLENBQUN4RixJQUFOLENBQVcsSUFBWCxDQUFSLENBWHpQLENBV2tSO0FBQ2pUO0FBQ0E7QUFDQTs7QUFDQXNGLFNBQU8sR0FBQ0EsT0FBTyxDQUFDaEYsT0FBUixDQUFnQixnREFBaEIsRUFBaUUsRUFBakUsQ0FBUixDQWYrQixDQWU4Qzs7QUFDN0VnRixTQUFPLEdBQUNBLE9BQU8sQ0FBQ2hGLE9BQVIsQ0FBZ0IsNkJBQWhCLEVBQThDLEVBQTlDLENBQVIsQ0FoQitCLENBZ0IyQjs7QUFDMURrRixPQUFLLEdBQUNGLE9BQU8sQ0FBQ0csS0FBUixDQUFjLElBQWQsQ0FBTixDQWpCK0IsQ0FpQkw7O0FBQzFCRCxPQUFLLEdBQUNBLEtBQUssQ0FBQ0UsTUFBTixDQUFhLFVBQUNDLElBQUQsRUFBTVcsS0FBTixFQUFZQyxHQUFaO0FBQUEsV0FBa0JELEtBQUssS0FBRyxDQUFSLElBQVdYLElBQUksQ0FBQ1EsSUFBTCxPQUFjLEVBQXpCLElBQTZCUixJQUFJLENBQUNRLElBQUwsT0FBY0ksR0FBRyxDQUFDRCxLQUFLLEdBQUMsQ0FBUCxDQUFILENBQWFILElBQWIsRUFBN0Q7QUFBQSxHQUFiLENBQU4sQ0FsQitCLENBa0JzRTs7QUFDckdiLFNBQU8sR0FBQ0UsS0FBSyxDQUFDeEYsSUFBTixDQUFXLElBQVgsQ0FBUjtBQUF5QixTQUFPc0YsT0FBTyxDQUFDYSxJQUFSLEVBQVA7QUFBdUI7O0FBQUEsU0FBU0sscUJBQVQsQ0FBK0JDLElBQS9CLEVBQW9DO0FBQUMsTUFBSUMsZUFBZSxHQUFDRCxJQUFJLENBQUNFLE1BQUwsQ0FBWWQsR0FBWixDQUFnQixVQUFTUCxPQUFULEVBQWlCO0FBQUMsV0FBT0MsYUFBYSxDQUFDRCxPQUFELEVBQVMsSUFBVCxDQUFwQjtBQUFvQyxHQUF0RSxDQUFwQjtBQUE0RixNQUFJc0IsaUJBQWlCLEdBQUNILElBQUksQ0FBQ0ksUUFBTCxDQUFjaEIsR0FBZCxDQUFrQixVQUFTUCxPQUFULEVBQWlCO0FBQUMsV0FBT0MsYUFBYSxDQUFDRCxPQUFELEVBQVMsS0FBVCxDQUFwQjtBQUFxQyxHQUF6RSxDQUF0QjtBQUFpRyxNQUFJd0IsTUFBTSxHQUFDO0FBQUNILFVBQU0sRUFBQ0QsZUFBUjtBQUF3QkcsWUFBUSxFQUFDRDtBQUFqQyxHQUFYOztBQUErRCxNQUFHRSxNQUFNLENBQUNILE1BQVAsQ0FBY0ksSUFBZCxDQUFtQjFCLG9CQUFuQixDQUFILEVBQTRDO0FBQUM7QUFDOVh5QixVQUFNLENBQUNILE1BQVAsR0FBY0csTUFBTSxDQUFDSCxNQUFQLENBQWNqQixNQUFkLENBQXFCTCxvQkFBckIsQ0FBZDtBQUEwRDs7QUFBQSxTQUFPeUIsTUFBUDtBQUFlOztBQUFBbEgsTUFBTSxDQUFDQyxPQUFQLEdBQWUyRyxxQkFBZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0N6RSw4Q0FBYTs7QUFBQSxJQUFJUSxzQkFBc0IsR0FBQzVHLG1CQUFPLENBQUMsb0hBQUQsQ0FBbEM7O0FBQW1GLElBQUk2Ryx1QkFBdUIsR0FBQzdHLG1CQUFPLENBQUMsc0hBQUQsQ0FBbkM7O0FBQXFGUCxPQUFPLENBQUNVLFVBQVIsR0FBbUIsSUFBbkI7QUFBd0JWLE9BQU8sV0FBUCxHQUFnQnFILE9BQWhCOztBQUF3QixJQUFJQyxVQUFVLEdBQUNGLHVCQUF1QixDQUFDN0csbUJBQU8sQ0FBQyxnR0FBRCxDQUFSLENBQXRDOztBQUFzRixJQUFJZ0gsVUFBVSxHQUFDSixzQkFBc0IsQ0FBQzVHLG1CQUFPLENBQUMsNEZBQUQsQ0FBUixDQUFyQzs7QUFBZ0YsSUFBSUssWUFBWSxHQUFDTCxtQkFBTyxDQUFDLHVGQUFELENBQXhCOztBQUEwQyxJQUFJaUgsc0JBQXNCLEdBQUNMLHNCQUFzQixDQUFDNUcsbUJBQU8sQ0FBQywrR0FBRCxDQUFSLENBQWpEO0FBQXdGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCemdCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxJQUFJa0gsZUFBZSxHQUFDLEtBQXBCO0FBQTBCLElBQUlDLHFCQUFKOztBQUEwQixTQUFTTCxPQUFULENBQWlCMUQsT0FBakIsRUFBeUI7QUFBQzJELFlBQVUsQ0FBQ0ssUUFBWDtBQUFzQixHQUFDLEdBQUUvRyxZQUFZLENBQUMwQixxQkFBaEIsRUFBdUNxQixPQUF2QyxFQUFnRG5CLGtCQUFoRCxDQUFtRSxVQUFBQyxLQUFLLEVBQUU7QUFBQztBQUMvSyxRQUFHQSxLQUFLLENBQUNDLElBQU4sS0FBYSxjQUFoQixFQUErQjtBQUFDO0FBQVE7O0FBQUEsUUFBRztBQUFDa0Ysb0JBQWMsQ0FBQ25GLEtBQUQsQ0FBZDtBQUF1QixLQUEzQixDQUEyQixPQUFNb0YsRUFBTixFQUFTO0FBQUNqRCxhQUFPLENBQUNrRCxJQUFSLENBQWEsMEJBQXdCckYsS0FBSyxDQUFDQyxJQUE5QixHQUFtQyxJQUFuQyxHQUF3Q21GLEVBQXJEO0FBQTBEO0FBQUMsR0FEcEM7QUFDc0MsU0FBTTtBQUFDRSx1QkFBRCwrQkFBcUJDLE9BQXJCLEVBQTZCO0FBQUNOLDJCQUFxQixHQUFDTSxPQUF0QjtBQUErQixLQUE3RDtBQUE4REMsd0JBQTlELGtDQUFvRjtBQUFDUixxQkFBZSxHQUFDLElBQWhCO0FBQXNCO0FBQTNHLEdBQU47QUFBb0gsQyxDQUFBOzs7QUFDOVAsSUFBSVMsa0JBQWtCLEdBQUMsSUFBdkI7QUFBNEIsSUFBSUMseUJBQXlCLEdBQUMsSUFBOUI7QUFBbUMsSUFBSUMsZ0JBQWdCLEdBQUMsS0FBckI7O0FBQTJCLFNBQVNDLG1CQUFULEdBQThCO0FBQUM7QUFDekgsTUFBRyxPQUFPekQsT0FBUCxLQUFpQixXQUFqQixJQUE4QixPQUFPQSxPQUFPLENBQUMwRCxLQUFmLEtBQXVCLFVBQXhELEVBQW1FO0FBQUMsUUFBR0YsZ0JBQUgsRUFBb0I7QUFBQ3hELGFBQU8sQ0FBQzBELEtBQVI7QUFBaUI7QUFBQztBQUFDLEMsQ0FBQTs7O0FBQzVHLFNBQVNDLGFBQVQsR0FBd0I7QUFBQ0YscUJBQW1CO0FBQUcsTUFBSUcsV0FBVyxHQUFDLENBQUNOLGtCQUFqQjtBQUFvQ0Esb0JBQWtCLEdBQUMsS0FBbkI7QUFBeUJFLGtCQUFnQixHQUFDLEtBQWpCLENBQXBGLENBQTJHOztBQUNuSSxNQUFHSSxXQUFILEVBQWU7QUFBQ0MsbUJBQWUsQ0FBQyxTQUFTQyxxQkFBVCxDQUErQkMsVUFBL0IsRUFBMEM7QUFBQztBQUMzRTtBQUNBQyxtQkFBYSxDQUFDRCxVQUFELENBQWI7QUFBMkIsS0FGSSxDQUFmO0FBRWM7QUFBQyxDLENBQUE7OztBQUMvQixTQUFTRSxjQUFULENBQXdCN0IsUUFBeEIsRUFBaUM7QUFBQ3FCLHFCQUFtQjtBQUFHLE1BQUlHLFdBQVcsR0FBQyxDQUFDTixrQkFBakI7QUFBb0NBLG9CQUFrQixHQUFDLEtBQW5CO0FBQXlCRSxrQkFBZ0IsR0FBQyxLQUFqQjs7QUFBdUIsV0FBU1UsYUFBVCxHQUF3QjtBQUFDO0FBQ3JLLFFBQUlDLFNBQVMsR0FBQyxDQUFDLEdBQUV2QixzQkFBc0IsV0FBekIsRUFBbUM7QUFBQ1IsY0FBUSxFQUFDQSxRQUFWO0FBQW1CRixZQUFNLEVBQUM7QUFBMUIsS0FBbkMsQ0FBZDs7QUFBZ0YsUUFBRyxPQUFPbEMsT0FBUCxLQUFpQixXQUFqQixJQUE4QixPQUFPQSxPQUFPLENBQUNrRCxJQUFmLEtBQXNCLFVBQXZELEVBQWtFO0FBQUMsV0FBSSxJQUFJakQsQ0FBQyxHQUFDLENBQVYsRUFBWUEsQ0FBQyxHQUFDa0UsU0FBUyxDQUFDL0IsUUFBVixDQUFtQmxDLE1BQWpDLEVBQXdDRCxDQUFDLEVBQXpDLEVBQTRDO0FBQUMsWUFBR0EsQ0FBQyxLQUFHLENBQVAsRUFBUztBQUFDRCxpQkFBTyxDQUFDa0QsSUFBUixDQUFhLCtDQUE2Qyw4Q0FBMUQ7QUFBMEc7QUFBTzs7QUFBQWxELGVBQU8sQ0FBQ2tELElBQVIsQ0FBYSxDQUFDLEdBQUVQLFVBQVUsV0FBYixFQUF1QndCLFNBQVMsQ0FBQy9CLFFBQVYsQ0FBbUJuQyxDQUFuQixDQUF2QixDQUFiO0FBQTZEO0FBQUM7QUFBQzs7QUFBQWlFLGVBQWEsR0FEdFcsQ0FDeVc7O0FBQzFZLE1BQUdOLFdBQUgsRUFBZTtBQUFDQyxtQkFBZSxDQUFDLFNBQVNDLHFCQUFULENBQStCQyxVQUEvQixFQUEwQztBQUFDO0FBQzNFO0FBQ0FDLG1CQUFhLENBQUNELFVBQUQsQ0FBYjtBQUEyQixLQUZJLENBQWY7QUFFYztBQUFDLEMsQ0FBQTs7O0FBQy9CLFNBQVNLLFlBQVQsQ0FBc0JsQyxNQUF0QixFQUE2QjtBQUFDdUIscUJBQW1CO0FBQUdILG9CQUFrQixHQUFDLEtBQW5CO0FBQXlCRSxrQkFBZ0IsR0FBQyxJQUFqQixDQUFoRCxDQUFzRTs7QUFDbkcsTUFBSVcsU0FBUyxHQUFDLENBQUMsR0FBRXZCLHNCQUFzQixXQUF6QixFQUFtQztBQUFDVixVQUFNLEVBQUNBLE1BQVI7QUFBZUUsWUFBUSxFQUFDO0FBQXhCLEdBQW5DLENBQWQsQ0FENkIsQ0FDaUQ7O0FBQzlFTSxZQUFVLENBQUMyQixZQUFYLENBQXdCRixTQUFTLENBQUNqQyxNQUFWLENBQWlCLENBQWpCLENBQXhCLEVBRjZCLENBRWdCOztBQUM3QyxNQUFHLE9BQU9sQyxPQUFQLEtBQWlCLFdBQWpCLElBQThCLE9BQU9BLE9BQU8sQ0FBQ3NFLEtBQWYsS0FBdUIsVUFBeEQsRUFBbUU7QUFBQyxTQUFJLElBQUlyRSxDQUFDLEdBQUMsQ0FBVixFQUFZQSxDQUFDLEdBQUNrRSxTQUFTLENBQUNqQyxNQUFWLENBQWlCaEMsTUFBL0IsRUFBc0NELENBQUMsRUFBdkMsRUFBMEM7QUFBQ0QsYUFBTyxDQUFDc0UsS0FBUixDQUFjLENBQUMsR0FBRTNCLFVBQVUsV0FBYixFQUF1QndCLFNBQVMsQ0FBQ2pDLE1BQVYsQ0FBaUJqQyxDQUFqQixDQUF2QixDQUFkO0FBQTREO0FBQUMsR0FIL0ksQ0FHK0k7QUFDNUs7OztBQUNBLE1BQUdzRSxTQUFILEVBQWdDO0FBQUMsUUFBR0MsSUFBSSxDQUFDQyxhQUFSLEVBQXNCO0FBQUNELFVBQUksQ0FBQ0MsYUFBTCxDQUFtQk4sU0FBUyxDQUFDakMsTUFBVixDQUFpQixDQUFqQixDQUFuQjs7QUFBd0NzQyxVQUFJLENBQUNDLGFBQUwsR0FBbUIsSUFBbkI7QUFBeUI7QUFBQztBQUFDOztBQUFBLFNBQVNULGFBQVQsQ0FBdUJELFVBQXZCLEVBQWtDO0FBQUNyQixZQUFVLENBQUNnQyxTQUFYOztBQUF1QixNQUFHWCxVQUFILEVBQWM7QUFBQ3JCLGNBQVUsQ0FBQ2lDLFNBQVg7QUFBd0I7O0FBQUEzRSxTQUFPLENBQUNELEdBQVIsQ0FBWSxxQkFBWjtBQUFvQyxDLENBQUE7OztBQUNoUSxTQUFTNkUsbUJBQVQsQ0FBNkJDLElBQTdCLEVBQWtDO0FBQUM7QUFDbkN0QiwyQkFBeUIsR0FBQ3NCLElBQTFCO0FBQWdDLEMsQ0FBQTs7O0FBQ2hDLFNBQVM3QixjQUFULENBQXdCOEIsQ0FBeEIsRUFBMEI7QUFBQyxNQUFJN0csR0FBRyxHQUFDQyxJQUFJLENBQUNDLEtBQUwsQ0FBVzJHLENBQUMsQ0FBQ2hILElBQWIsQ0FBUjs7QUFBMkIsVUFBT0csR0FBRyxDQUFDRyxNQUFYO0FBQW1CLFNBQUksVUFBSjtBQUFlO0FBQUM0QixlQUFPLENBQUNELEdBQVIsQ0FBWSwyQkFBWjtBQUF5QztBQUFPOztBQUFBLFNBQUksT0FBSjtBQUFZLFNBQUksTUFBSjtBQUFXO0FBQUMsWUFBRzlCLEdBQUcsQ0FBQzRHLElBQVAsRUFBWTtBQUFDRCw2QkFBbUIsQ0FBQzNHLEdBQUcsQ0FBQzRHLElBQUwsQ0FBbkI7QUFBK0I7O0FBQTdDLFlBQWlEM0MsTUFBakQsR0FBa0VqRSxHQUFsRSxDQUFpRGlFLE1BQWpEO0FBQUEsWUFBd0RFLFFBQXhELEdBQWtFbkUsR0FBbEUsQ0FBd0RtRSxRQUF4RDtBQUFzRSxZQUFJMkMsU0FBUyxHQUFDQyxPQUFPLENBQUM5QyxNQUFNLElBQUVBLE1BQU0sQ0FBQ2hDLE1BQWhCLENBQXJCOztBQUE2QyxZQUFHNkUsU0FBSCxFQUFhO0FBQUMsaUJBQU9YLFlBQVksQ0FBQ2xDLE1BQUQsQ0FBbkI7QUFBNkI7O0FBQUEsWUFBSStDLFdBQVcsR0FBQ0QsT0FBTyxDQUFDNUMsUUFBUSxJQUFFQSxRQUFRLENBQUNsQyxNQUFwQixDQUF2Qjs7QUFBbUQsWUFBRytFLFdBQUgsRUFBZTtBQUFDLGlCQUFPaEIsY0FBYyxDQUFDN0IsUUFBRCxDQUFyQjtBQUFpQzs7QUFBQSxlQUFPdUIsYUFBYSxFQUFwQjtBQUF3Qjs7QUFBQTtBQUFRO0FBQUMsWUFBR2IscUJBQUgsRUFBeUI7QUFBQ0EsK0JBQXFCLENBQUM3RSxHQUFELENBQXJCO0FBQTJCO0FBQU87O0FBQUE7QUFBTztBQUFoZDtBQUFrZCxDLENBQUE7OztBQUN4Z0IsU0FBU2lILGlCQUFULEdBQTRCO0FBQUM7QUFBK0I7QUFDNUQ7QUFDQSxTQUFPM0IseUJBQXlCLEtBQUc0Qix1QkFBbkM7QUFBcUQsQyxDQUFBOzs7QUFDckQsU0FBU0MsZUFBVCxHQUEwQjtBQUFDLFNBQU9qSyxNQUFNLENBQUNrSyxHQUFQLENBQVdDLE1BQVgsT0FBc0IsTUFBN0I7QUFBcUM7O0FBQUEsU0FBU0MsaUJBQVQsQ0FBMkIvRSxFQUEzQixFQUE4QjtBQUFDLE1BQUc0RSxlQUFlLEVBQWxCLEVBQXFCO0FBQUM1RSxNQUFFO0FBQUksR0FBNUIsTUFBZ0M7QUFBQSxRQUFVNEMsT0FBVixHQUFDLFNBQVNBLE9BQVQsQ0FBaUJrQyxNQUFqQixFQUF3QjtBQUFDLFVBQUdBLE1BQU0sS0FBRyxNQUFaLEVBQW1CO0FBQUNuSyxjQUFNLENBQUNrSyxHQUFQLENBQVdHLG1CQUFYLENBQStCcEMsT0FBL0I7QUFBd0M1QyxVQUFFO0FBQUk7QUFBQyxLQUE3Rjs7QUFBNkZyRixVQUFNLENBQUNrSyxHQUFQLENBQVdJLGdCQUFYLENBQTRCckMsT0FBNUI7QUFBc0M7QUFBQyxDLENBQUE7OztBQUNuUSxTQUFTUyxlQUFULENBQXlCNkIsa0JBQXpCLEVBQTRDO0FBQUMsTUFBRyxLQUFILEVBQWUsRUFFcEQ7O0FBQUEsTUFBRyxDQUFDUixpQkFBaUIsRUFBbEIsSUFBc0IsQ0FBQ0UsZUFBZSxFQUF6QyxFQUE0QztBQUFDO0FBQVE7O0FBQUEsV0FBU08sa0JBQVQsQ0FBNEJDLEdBQTVCLEVBQWdDQyxjQUFoQyxFQUErQztBQUFDLFFBQUdELEdBQUcsSUFBRS9DLGVBQUwsSUFBc0IsQ0FBQ2dELGNBQTFCLEVBQXlDO0FBQUMsVUFBR0QsR0FBSCxFQUFPO0FBQUM1RixlQUFPLENBQUNrRCxJQUFSLENBQWEsOENBQTRDLHNIQUE1QyxHQUFtSyw2SEFBbkssR0FBaVMsNEdBQWpTLEdBQThZLHlIQUE5WSxHQUF3Z0IsMkVBQXJoQjtBQUFtbUIsT0FBM21CLE1BQWduQixJQUFHTCxlQUFILEVBQW1CO0FBQUM3QyxlQUFPLENBQUNrRCxJQUFSLENBQWEsMkZBQWI7QUFBMkc7O0FBQUF6RCxZQUFNLENBQUNxRyxRQUFQLENBQWdCQyxNQUFoQjtBQUF5QjtBQUFROztBQUFBLFFBQUloQyxVQUFVLEdBQUNpQixPQUFPLENBQUNhLGNBQWMsQ0FBQzNGLE1BQWhCLENBQXRCOztBQUE4QyxRQUFHLE9BQU93RixrQkFBUCxLQUE0QixVQUEvQixFQUEwQztBQUFDO0FBQ2hnQ0Esd0JBQWtCLENBQUMzQixVQUFELENBQWxCO0FBQWdDOztBQUFBLFFBQUdtQixpQkFBaUIsRUFBcEIsRUFBdUI7QUFBQztBQUN4RHJCLHFCQUFlLENBQUNFLFVBQVUsR0FBQ3RJLFNBQUQsR0FBV2lLLGtCQUF0QixDQUFmO0FBQTBELEtBRDFCLE1BQzhCO0FBQUMsVUFBR25CLFNBQUgsRUFBZ0M7QUFBQ2dCLHlCQUFpQixDQUFDLFlBQUk7QUFBQyxjQUFHZixJQUFJLENBQUNDLGFBQVIsRUFBc0I7QUFBQ0QsZ0JBQUksQ0FBQ0MsYUFBTDs7QUFBcUJELGdCQUFJLENBQUNDLGFBQUwsR0FBbUIsSUFBbkI7QUFBeUI7QUFBQyxTQUE1RSxDQUFqQjtBQUFnRztBQUFDO0FBQUMsR0FKdEosQ0FJc0o7OztBQUNsTXRKLFFBQU0sQ0FBQ2tLLEdBQVAsQ0FBV1csS0FBWDtBQUFpQjtBQUFlLE1BQWhDLEVBQXNDQyxJQUF0QyxDQUEyQyxVQUFBSixjQUFjLEVBQUU7QUFBQ0Ysc0JBQWtCLENBQUMsSUFBRCxFQUFNRSxjQUFOLENBQWxCO0FBQXlDLEdBQXJHLEVBQXNHLFVBQUFELEdBQUcsRUFBRTtBQUFDRCxzQkFBa0IsQ0FBQ0MsR0FBRCxFQUFLLElBQUwsQ0FBbEI7QUFBOEIsR0FBMUk7QUFBNkk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9EN0ksOENBQWE7O0FBQUEsSUFBSXJELHNCQUFzQixHQUFDNUcsbUJBQU8sQ0FBQyxvSEFBRCxDQUFsQzs7QUFBbUZQLE9BQU8sQ0FBQ1UsVUFBUixHQUFtQixJQUFuQjtBQUF3QlYsT0FBTyxXQUFQLEdBQWdCLEtBQUssQ0FBckI7O0FBQXVCLElBQUk4SyxRQUFRLEdBQUMzRCxzQkFBc0IsQ0FBQzVHLG1CQUFPLENBQUMsOEZBQUQsQ0FBUixDQUFuQztBQUFrRjtBQUFxQjtBQUN0UDtBQUNBOzs7QUFDQSxJQUFJTyxRQUFRLEdBQUN1RCxNQUFNLENBQUN2RCxRQUFwQjtBQUE2QixJQUFJaUssUUFBUSxHQUFDMUcsTUFBTSxDQUFDMEcsUUFBcEI7QUFBNkIsSUFBSUMsV0FBVyxHQUFDM0csTUFBTSxDQUFDMkcsV0FBdkI7QUFBbUMsSUFBSUMsV0FBVyxHQUFDNUcsTUFBTSxDQUFDNEcsV0FBdkI7QUFBbUMsSUFBSUMsZUFBZSxHQUFDN0csTUFBTSxDQUFDNkcsZUFBM0I7O0FBQTJDLElBQUdBLGVBQWUsSUFBRTdLLFNBQXBCLEVBQThCO0FBQUM2SyxpQkFBZSxHQUFDLFNBQVNBLGVBQVQsR0FBMEI7QUFBQyxTQUFLQyxNQUFMLEdBQVksSUFBWjs7QUFBaUIsU0FBS0MsS0FBTCxHQUFXLFlBQVUsQ0FBRSxDQUF2QjtBQUF5QixHQUFyRjtBQUF1Rjs7QUFBQSxTQUFTQyxtQkFBVCxHQUE4QjtBQUFDLE9BQUtDLFVBQUwsR0FBZ0IsQ0FBaEI7QUFBa0IsT0FBS0MsU0FBTCxHQUFlLENBQWY7QUFBa0I7O0tBQTFERixtQjs7QUFBMERBLG1CQUFtQixDQUFDRyxTQUFwQixDQUE4QkMsTUFBOUIsR0FBcUMsVUFBU0MsTUFBVCxFQUFnQjtBQUFDLFdBQVNDLEtBQVQsQ0FBZUosU0FBZixFQUF5QkssS0FBekIsRUFBK0JDLFdBQS9CLEVBQTJDO0FBQUMsUUFBR0EsV0FBVyxLQUFHLENBQWpCLEVBQW1CO0FBQUMsYUFBT04sU0FBUyxJQUFFLFVBQVFLLEtBQW5CLElBQTBCTCxTQUFTLElBQUVLLEtBQVgsSUFBa0IsTUFBbkQ7QUFBMkQ7O0FBQUEsUUFBR0MsV0FBVyxLQUFHLENBQWpCLEVBQW1CO0FBQUMsYUFBT04sU0FBUyxJQUFFLFVBQVFLLEtBQW5CLElBQTBCTCxTQUFTLElBQUVLLEtBQVgsSUFBa0IsTUFBNUMsSUFBb0RMLFNBQVMsSUFBRSxVQUFRSyxLQUFuQixJQUEwQkwsU0FBUyxJQUFFSyxLQUFYLElBQWtCLE1BQXZHO0FBQStHOztBQUFBLFFBQUdDLFdBQVcsS0FBRyxDQUFqQixFQUFtQjtBQUFDLGFBQU9OLFNBQVMsSUFBRSxZQUFVSyxLQUFyQixJQUE0QkwsU0FBUyxJQUFFSyxLQUFYLElBQWtCLFFBQXJEO0FBQStEOztBQUFBLFVBQU0sSUFBSUUsS0FBSixFQUFOO0FBQW1COztBQUFBLFdBQVNELFdBQVQsQ0FBcUJQLFVBQXJCLEVBQWdDQyxTQUFoQyxFQUEwQztBQUFDLFFBQUdELFVBQVUsS0FBRyxJQUFFLENBQWxCLEVBQW9CO0FBQUMsYUFBT0MsU0FBUyxJQUFFLENBQVgsR0FBYSxFQUFiLEdBQWdCLENBQWhCLEdBQWtCQSxTQUFTLEdBQUMsRUFBVixHQUFhLENBQWIsR0FBZSxDQUF4QztBQUEyQzs7QUFBQSxRQUFHRCxVQUFVLEtBQUcsSUFBRSxDQUFsQixFQUFvQjtBQUFDLGFBQU9DLFNBQVMsR0FBQyxFQUFWLEdBQWEsQ0FBYixHQUFlLENBQXRCO0FBQXlCOztBQUFBLFFBQUdELFVBQVUsS0FBRyxJQUFFLENBQWxCLEVBQW9CO0FBQUMsYUFBTyxDQUFQO0FBQVU7O0FBQUEsVUFBTSxJQUFJUSxLQUFKLEVBQU47QUFBbUI7O0FBQUEsTUFBSUMsUUFBUSxHQUFDLE1BQWI7QUFBb0IsTUFBSXZMLE1BQU0sR0FBQyxFQUFYO0FBQWMsTUFBSThLLFVBQVUsR0FBQyxLQUFLQSxVQUFwQjtBQUErQixNQUFJQyxTQUFTLEdBQUMsS0FBS0EsU0FBbkI7O0FBQTZCLE9BQUksSUFBSTFHLENBQUMsR0FBQyxDQUFWLEVBQVlBLENBQUMsR0FBQzZHLE1BQU0sQ0FBQzVHLE1BQXJCLEVBQTRCRCxDQUFDLElBQUUsQ0FBL0IsRUFBaUM7QUFBQyxRQUFJbUgsS0FBSyxHQUFDTixNQUFNLENBQUM3RyxDQUFELENBQWhCOztBQUFvQixRQUFHeUcsVUFBVSxLQUFHLENBQWhCLEVBQWtCO0FBQUMsVUFBR1UsS0FBSyxHQUFDLEdBQU4sSUFBV0EsS0FBSyxHQUFDLEdBQWpCLElBQXNCLENBQUNMLEtBQUssQ0FBQ0osU0FBUyxJQUFFLENBQVgsR0FBYVMsS0FBSyxHQUFDLEVBQXBCLEVBQXVCVixVQUFVLEdBQUMsQ0FBbEMsRUFBb0NPLFdBQVcsQ0FBQ1AsVUFBRCxFQUFZQyxTQUFaLENBQS9DLENBQS9CLEVBQXNHO0FBQUNELGtCQUFVLEdBQUMsQ0FBWDtBQUFhQyxpQkFBUyxHQUFDUSxRQUFWO0FBQW1CdkwsY0FBTSxJQUFFeUwsTUFBTSxDQUFDQyxZQUFQLENBQW9CWCxTQUFwQixDQUFSO0FBQXdDO0FBQUM7O0FBQUEsUUFBR0QsVUFBVSxLQUFHLENBQWhCLEVBQWtCO0FBQUMsVUFBR1UsS0FBSyxJQUFFLENBQVAsSUFBVUEsS0FBSyxJQUFFLEdBQXBCLEVBQXdCO0FBQUNWLGtCQUFVLEdBQUMsQ0FBWDtBQUFhQyxpQkFBUyxHQUFDUyxLQUFWO0FBQWlCLE9BQXZELE1BQTRELElBQUdBLEtBQUssSUFBRSxHQUFQLElBQVlBLEtBQUssSUFBRSxHQUF0QixFQUEwQjtBQUFDVixrQkFBVSxHQUFDLElBQUUsQ0FBYjtBQUFlQyxpQkFBUyxHQUFDUyxLQUFLLEdBQUMsRUFBaEI7QUFBb0IsT0FBOUQsTUFBbUUsSUFBR0EsS0FBSyxJQUFFLEdBQVAsSUFBWUEsS0FBSyxJQUFFLEdBQXRCLEVBQTBCO0FBQUNWLGtCQUFVLEdBQUMsSUFBRSxDQUFiO0FBQWVDLGlCQUFTLEdBQUNTLEtBQUssR0FBQyxFQUFoQjtBQUFvQixPQUE5RCxNQUFtRSxJQUFHQSxLQUFLLElBQUUsR0FBUCxJQUFZQSxLQUFLLElBQUUsR0FBdEIsRUFBMEI7QUFBQ1Ysa0JBQVUsR0FBQyxJQUFFLENBQWI7QUFBZUMsaUJBQVMsR0FBQ1MsS0FBSyxHQUFDLENBQWhCO0FBQW1CLE9BQTdELE1BQWlFO0FBQUNWLGtCQUFVLEdBQUMsQ0FBWDtBQUFhQyxpQkFBUyxHQUFDUSxRQUFWO0FBQW9COztBQUFBLFVBQUdULFVBQVUsS0FBRyxDQUFiLElBQWdCLENBQUNLLEtBQUssQ0FBQ0osU0FBRCxFQUFXRCxVQUFYLEVBQXNCTyxXQUFXLENBQUNQLFVBQUQsRUFBWUMsU0FBWixDQUFqQyxDQUF6QixFQUFrRjtBQUFDRCxrQkFBVSxHQUFDLENBQVg7QUFBYUMsaUJBQVMsR0FBQ1EsUUFBVjtBQUFvQjtBQUFDLEtBQTdhLE1BQWliO0FBQUNULGdCQUFVLElBQUUsQ0FBWjtBQUFjQyxlQUFTLEdBQUNBLFNBQVMsSUFBRSxDQUFYLEdBQWFTLEtBQUssR0FBQyxFQUE3QjtBQUFpQzs7QUFBQSxRQUFHVixVQUFVLEtBQUcsQ0FBaEIsRUFBa0I7QUFBQyxVQUFHQyxTQUFTLElBQUUsTUFBZCxFQUFxQjtBQUFDL0ssY0FBTSxJQUFFeUwsTUFBTSxDQUFDQyxZQUFQLENBQW9CWCxTQUFwQixDQUFSO0FBQXdDLE9BQTlELE1BQWtFO0FBQUMvSyxjQUFNLElBQUV5TCxNQUFNLENBQUNDLFlBQVAsQ0FBb0IsVUFBUVgsU0FBUyxHQUFDLE1BQVYsR0FBaUIsQ0FBakIsSUFBb0IsRUFBNUIsQ0FBcEIsQ0FBUjtBQUE2RC9LLGNBQU0sSUFBRXlMLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQixVQUFRWCxTQUFTLEdBQUMsTUFBVixHQUFpQixDQUFqQixHQUFtQixLQUEzQixDQUFwQixDQUFSO0FBQWdFO0FBQUM7QUFBQzs7QUFBQSxPQUFLRCxVQUFMLEdBQWdCQSxVQUFoQjtBQUEyQixPQUFLQyxTQUFMLEdBQWVBLFNBQWY7QUFBeUIsU0FBTy9LLE1BQVA7QUFBZSxDQUFyckQsQyxDQUFzckQ7OztBQUMxaEUsSUFBSTJMLG9CQUFvQixHQUFDLFNBQVNBLG9CQUFULEdBQStCO0FBQUMsTUFBRztBQUFDLFdBQU8sSUFBSW5CLFdBQUosR0FBa0JTLE1BQWxCLENBQXlCLElBQUlSLFdBQUosR0FBa0JtQixNQUFsQixDQUF5QixNQUF6QixDQUF6QixFQUEwRDtBQUFDQyxZQUFNLEVBQUM7QUFBUixLQUExRCxNQUEyRSxNQUFsRjtBQUEwRixHQUE5RixDQUE4RixPQUFNbkQsS0FBTixFQUFZO0FBQUN0RSxXQUFPLENBQUNELEdBQVIsQ0FBWXVFLEtBQVo7QUFBb0I7O0FBQUEsU0FBTyxLQUFQO0FBQWMsQ0FBdE0sQyxDQUF1TTs7O0FBQ3ZNLElBQUc4QixXQUFXLElBQUUzSyxTQUFiLElBQXdCNEssV0FBVyxJQUFFNUssU0FBckMsSUFBZ0QsQ0FBQzhMLG9CQUFvQixFQUF4RSxFQUEyRTtBQUFDbkIsYUFBVyxHQUFDSyxtQkFBWjtBQUFpQzs7QUFBQSxJQUFJaUIsQ0FBQyxHQUFDLFNBQVNBLENBQVQsR0FBWSxDQUFFLENBQXBCOztBQUFxQixTQUFTQyxVQUFULENBQW9CQyxHQUFwQixFQUF3QjtBQUFDLE9BQUtDLGVBQUwsR0FBcUIsS0FBckI7QUFBMkIsT0FBS0MsWUFBTCxHQUFrQixFQUFsQjtBQUFxQixPQUFLQyxVQUFMLEdBQWdCLENBQWhCO0FBQWtCLE9BQUt6QyxNQUFMLEdBQVksQ0FBWjtBQUFjLE9BQUswQyxVQUFMLEdBQWdCLEVBQWhCO0FBQW1CLE9BQUtDLFlBQUwsR0FBa0IsRUFBbEI7QUFBcUIsT0FBS0MsVUFBTCxHQUFnQlIsQ0FBaEI7QUFBa0IsT0FBS1Msa0JBQUwsR0FBd0JULENBQXhCO0FBQTBCLE9BQUtVLFlBQUwsR0FBa0IsRUFBbEI7QUFBcUIsT0FBS0MsSUFBTCxHQUFVVCxHQUFWO0FBQWMsT0FBS1UsWUFBTCxHQUFrQixDQUFsQjtBQUFvQixPQUFLQyxNQUFMLEdBQVliLENBQVo7QUFBZTs7TUFBMVBDLFU7O0FBQTBQQSxVQUFVLENBQUNmLFNBQVgsQ0FBcUI0QixJQUFyQixHQUEwQixVQUFTQyxNQUFULEVBQWdCQyxHQUFoQixFQUFvQjtBQUFDLE9BQUtILE1BQUwsQ0FBWSxJQUFaOztBQUFrQixNQUFJSSxJQUFJLEdBQUMsSUFBVDtBQUFjLE1BQUlmLEdBQUcsR0FBQyxLQUFLUyxJQUFiO0FBQWtCLE1BQUlPLEtBQUssR0FBQyxDQUFWO0FBQVksTUFBSXhKLE9BQU8sR0FBQyxDQUFaOztBQUFjLE9BQUttSixNQUFMLEdBQVksVUFBU00sTUFBVCxFQUFnQjtBQUFDLFFBQUdGLElBQUksQ0FBQ0wsWUFBTCxLQUFvQixDQUF2QixFQUF5QjtBQUFDakssa0JBQVksQ0FBQ3NLLElBQUksQ0FBQ0wsWUFBTixDQUFaO0FBQWdDSyxVQUFJLENBQUNMLFlBQUwsR0FBa0IsQ0FBbEI7QUFBcUI7O0FBQUEsUUFBR00sS0FBSyxLQUFHLENBQVIsSUFBV0EsS0FBSyxLQUFHLENBQW5CLElBQXNCQSxLQUFLLEtBQUcsQ0FBakMsRUFBbUM7QUFBQ0EsV0FBSyxHQUFDLENBQU47QUFBUWhCLFNBQUcsQ0FBQ2tCLE1BQUosR0FBV3BCLENBQVg7QUFBYUUsU0FBRyxDQUFDL0gsT0FBSixHQUFZNkgsQ0FBWjtBQUFjRSxTQUFHLENBQUNtQixPQUFKLEdBQVlyQixDQUFaO0FBQWNFLFNBQUcsQ0FBQ00sVUFBSixHQUFlUixDQUFmO0FBQWlCRSxTQUFHLENBQUNPLGtCQUFKLEdBQXVCVCxDQUF2QixDQUFuRSxDQUE0RjtBQUMzdUI7O0FBQ0FFLFNBQUcsQ0FBQ3BCLEtBQUo7O0FBQVksVUFBR3BILE9BQU8sS0FBRyxDQUFiLEVBQWU7QUFBQ2Ysb0JBQVksQ0FBQ2UsT0FBRCxDQUFaO0FBQXNCQSxlQUFPLEdBQUMsQ0FBUjtBQUFXOztBQUFBLFVBQUcsQ0FBQ3lKLE1BQUosRUFBVztBQUFDRixZQUFJLENBQUNaLFVBQUwsR0FBZ0IsQ0FBaEI7QUFBa0JZLFlBQUksQ0FBQ1Isa0JBQUw7QUFBMkI7QUFBQzs7QUFBQVMsU0FBSyxHQUFDLENBQU47QUFBUyxHQUZnWTs7QUFFL1gsTUFBSUksT0FBTyxHQUFDLFNBQVNBLE9BQVQsR0FBa0I7QUFBQyxRQUFHSixLQUFLLEtBQUcsQ0FBWCxFQUFhO0FBQUM7QUFDOUssVUFBSXRELE1BQU0sR0FBQyxDQUFYO0FBQWEsVUFBSTBDLFVBQVUsR0FBQyxFQUFmO0FBQWtCLFVBQUlpQixXQUFXLEdBQUN4TixTQUFoQjs7QUFBMEIsVUFBRyxFQUFFLGlCQUFnQm1NLEdBQWxCLENBQUgsRUFBMEI7QUFBQyxZQUFHO0FBQUN0QyxnQkFBTSxHQUFDc0MsR0FBRyxDQUFDdEMsTUFBWDtBQUFrQjBDLG9CQUFVLEdBQUNKLEdBQUcsQ0FBQ0ksVUFBZjtBQUEwQmlCLHFCQUFXLEdBQUNyQixHQUFHLENBQUNzQixpQkFBSixDQUFzQixjQUF0QixDQUFaO0FBQW1ELFNBQW5HLENBQW1HLE9BQU01RSxLQUFOLEVBQVk7QUFBQztBQUNwTTtBQUNBO0FBQ0FnQixnQkFBTSxHQUFDLENBQVA7QUFBUzBDLG9CQUFVLEdBQUMsRUFBWDtBQUFjaUIscUJBQVcsR0FBQ3hOLFNBQVosQ0FINEssQ0FHdEo7QUFDN0M7QUFDQTtBQUNDO0FBQUMsT0FOdUQsTUFNbkQ7QUFBQzZKLGNBQU0sR0FBQyxHQUFQO0FBQVcwQyxrQkFBVSxHQUFDLElBQVg7QUFBZ0JpQixtQkFBVyxHQUFDckIsR0FBRyxDQUFDcUIsV0FBaEI7QUFBNkI7O0FBQUEsVUFBRzNELE1BQU0sS0FBRyxDQUFaLEVBQWM7QUFBQ3NELGFBQUssR0FBQyxDQUFOO0FBQVFELFlBQUksQ0FBQ1osVUFBTCxHQUFnQixDQUFoQjtBQUFrQlksWUFBSSxDQUFDckQsTUFBTCxHQUFZQSxNQUFaO0FBQW1CcUQsWUFBSSxDQUFDWCxVQUFMLEdBQWdCQSxVQUFoQjtBQUEyQlcsWUFBSSxDQUFDUCxZQUFMLEdBQWtCYSxXQUFsQjtBQUE4Qk4sWUFBSSxDQUFDUixrQkFBTDtBQUEyQjtBQUFDO0FBQUMsR0FQaEY7O0FBT2lGLE1BQUlnQixVQUFVLEdBQUMsU0FBU0EsVUFBVCxHQUFxQjtBQUFDSCxXQUFPOztBQUFHLFFBQUdKLEtBQUssS0FBRyxDQUFSLElBQVdBLEtBQUssS0FBRyxDQUF0QixFQUF3QjtBQUFDQSxXQUFLLEdBQUMsQ0FBTjtBQUFRLFVBQUlYLFlBQVksR0FBQyxFQUFqQjs7QUFBb0IsVUFBRztBQUFDQSxvQkFBWSxHQUFDTCxHQUFHLENBQUNLLFlBQWpCO0FBQStCLE9BQW5DLENBQW1DLE9BQU0zRCxLQUFOLEVBQVksQ0FBQztBQUNyVzs7QUFBQXFFLFVBQUksQ0FBQ1osVUFBTCxHQUFnQixDQUFoQjtBQUFrQlksVUFBSSxDQUFDVixZQUFMLEdBQWtCQSxZQUFsQjtBQUErQlUsVUFBSSxDQUFDVCxVQUFMO0FBQW1CO0FBQUMsR0FENEk7O0FBQzNJLE1BQUlrQixRQUFRLEdBQUMsU0FBU0EsUUFBVCxHQUFtQjtBQUFDO0FBQ3hHO0FBQ0FELGNBQVU7O0FBQUcsUUFBR1AsS0FBSyxLQUFHLENBQVIsSUFBV0EsS0FBSyxLQUFHLENBQW5CLElBQXNCQSxLQUFLLEtBQUcsQ0FBakMsRUFBbUM7QUFBQ0EsV0FBSyxHQUFDLENBQU47O0FBQVEsVUFBR3hKLE9BQU8sS0FBRyxDQUFiLEVBQWU7QUFBQ2Ysb0JBQVksQ0FBQ2UsT0FBRCxDQUFaO0FBQXNCQSxlQUFPLEdBQUMsQ0FBUjtBQUFXOztBQUFBdUosVUFBSSxDQUFDWixVQUFMLEdBQWdCLENBQWhCO0FBQWtCWSxVQUFJLENBQUNSLGtCQUFMO0FBQTJCO0FBQUMsR0FGakY7O0FBRWtGLE1BQUlrQixrQkFBa0IsR0FBQyxTQUFTQSxrQkFBVCxHQUE2QjtBQUFDLFFBQUd6QixHQUFHLElBQUVuTSxTQUFSLEVBQWtCO0FBQUM7QUFDak8sVUFBR21NLEdBQUcsQ0FBQ0csVUFBSixLQUFpQixDQUFwQixFQUFzQjtBQUFDcUIsZ0JBQVE7QUFBSSxPQUFuQyxNQUF3QyxJQUFHeEIsR0FBRyxDQUFDRyxVQUFKLEtBQWlCLENBQXBCLEVBQXNCO0FBQUNvQixrQkFBVTtBQUFJLE9BQXJDLE1BQTBDLElBQUd2QixHQUFHLENBQUNHLFVBQUosS0FBaUIsQ0FBcEIsRUFBc0I7QUFBQ2lCLGVBQU87QUFBSTtBQUFDO0FBQUMsR0FEbUM7O0FBQ2xDLE1BQUlNLFNBQVMsR0FBQyxTQUFTQSxTQUFULEdBQW9CO0FBQUNsSyxXQUFPLEdBQUNiLFVBQVUsQ0FBQyxZQUFVO0FBQUMrSyxlQUFTO0FBQUksS0FBekIsRUFBMEIsR0FBMUIsQ0FBbEI7O0FBQWlELFFBQUcxQixHQUFHLENBQUNHLFVBQUosS0FBaUIsQ0FBcEIsRUFBc0I7QUFBQ29CLGdCQUFVO0FBQUk7QUFBQyxHQUExSCxDQWI0VCxDQWFqTTs7O0FBQ2xQdkIsS0FBRyxDQUFDa0IsTUFBSixHQUFXTSxRQUFYO0FBQW9CeEIsS0FBRyxDQUFDL0gsT0FBSixHQUFZdUosUUFBWixDQWQrWixDQWMxWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFDQXhCLEtBQUcsQ0FBQ21CLE9BQUosR0FBWUssUUFBWixDQW5CbWIsQ0FtQjlaOztBQUNyQixNQUFHLEVBQUUsa0JBQWlCRyxjQUFjLENBQUMzQyxTQUFsQyxLQUE4QyxFQUFFLGFBQVkyQyxjQUFjLENBQUMzQyxTQUE3QixDQUFqRCxFQUF5RjtBQUFDZ0IsT0FBRyxDQUFDTSxVQUFKLEdBQWVpQixVQUFmO0FBQTJCLEdBcEI4VCxDQW9COVQ7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0F2QixLQUFHLENBQUNPLGtCQUFKLEdBQXVCa0Isa0JBQXZCOztBQUEwQyxNQUFHLGlCQUFnQnpCLEdBQW5CLEVBQXVCO0FBQUNjLE9BQUcsSUFBRSxDQUFDQSxHQUFHLENBQUN2SSxPQUFKLENBQVksR0FBWixNQUFtQixDQUFDLENBQXBCLEdBQXNCLEdBQXRCLEdBQTBCLEdBQTNCLElBQWdDLGNBQXJDO0FBQXFEOztBQUFBeUgsS0FBRyxDQUFDWSxJQUFKLENBQVNDLE1BQVQsRUFBZ0JDLEdBQWhCLEVBQW9CLElBQXBCOztBQUEwQixNQUFHLGdCQUFlZCxHQUFsQixFQUFzQjtBQUFDO0FBQ3hLO0FBQ0F4SSxXQUFPLEdBQUNiLFVBQVUsQ0FBQyxZQUFVO0FBQUMrSyxlQUFTO0FBQUksS0FBekIsRUFBMEIsQ0FBMUIsQ0FBbEI7QUFBZ0Q7QUFBQyxDQTVCb1Y7O0FBNEJuVjNCLFVBQVUsQ0FBQ2YsU0FBWCxDQUFxQkosS0FBckIsR0FBMkIsWUFBVTtBQUFDLE9BQUsrQixNQUFMLENBQVksS0FBWjtBQUFvQixDQUExRDs7QUFBMkRaLFVBQVUsQ0FBQ2YsU0FBWCxDQUFxQnNDLGlCQUFyQixHQUF1QyxVQUFTTSxJQUFULEVBQWM7QUFBQyxTQUFPLEtBQUtwQixZQUFaO0FBQTBCLENBQWhGOztBQUFpRlQsVUFBVSxDQUFDZixTQUFYLENBQXFCNkMsZ0JBQXJCLEdBQXNDLFVBQVNELElBQVQsRUFBY0UsS0FBZCxFQUFvQjtBQUFDLE1BQUk5QixHQUFHLEdBQUMsS0FBS1MsSUFBYjs7QUFBa0IsTUFBRyxzQkFBcUJULEdBQXhCLEVBQTRCO0FBQUNBLE9BQUcsQ0FBQzZCLGdCQUFKLENBQXFCRCxJQUFyQixFQUEwQkUsS0FBMUI7QUFBa0M7QUFBQyxDQUE3STs7QUFBOEkvQixVQUFVLENBQUNmLFNBQVgsQ0FBcUIrQyxxQkFBckIsR0FBMkMsWUFBVTtBQUFDLFNBQU8sS0FBS3RCLElBQUwsQ0FBVXNCLHFCQUFWLElBQWlDbE8sU0FBakMsR0FBMkMsS0FBSzRNLElBQUwsQ0FBVXNCLHFCQUFWLEVBQTNDLEdBQTZFLEVBQXBGO0FBQXdGLENBQTlJOztBQUErSWhDLFVBQVUsQ0FBQ2YsU0FBWCxDQUFxQmdELElBQXJCLEdBQTBCLFlBQVU7QUFBQztBQUNoZ0IsTUFBRyxFQUFFLGVBQWNMLGNBQWMsQ0FBQzNDLFNBQS9CLEtBQTJDMUssUUFBUSxJQUFFVCxTQUFyRCxJQUFnRVMsUUFBUSxDQUFDNkwsVUFBVCxJQUFxQnRNLFNBQXJGLElBQWdHUyxRQUFRLENBQUM2TCxVQUFULEtBQXNCLFVBQXpILEVBQW9JO0FBQUMsUUFBSVksSUFBSSxHQUFDLElBQVQ7QUFBY0EsUUFBSSxDQUFDTCxZQUFMLEdBQWtCL0osVUFBVSxDQUFDLFlBQVU7QUFBQ29LLFVBQUksQ0FBQ0wsWUFBTCxHQUFrQixDQUFsQjtBQUFvQkssVUFBSSxDQUFDaUIsSUFBTDtBQUFhLEtBQTdDLEVBQThDLENBQTlDLENBQTVCO0FBQTZFO0FBQVE7O0FBQUEsTUFBSWhDLEdBQUcsR0FBQyxLQUFLUyxJQUFiLENBRHVSLENBQ3JROztBQUMxUFQsS0FBRyxDQUFDQyxlQUFKLEdBQW9CLEtBQUtBLGVBQXpCO0FBQXlDRCxLQUFHLENBQUNFLFlBQUosR0FBaUIsS0FBS0EsWUFBdEI7O0FBQW1DLE1BQUc7QUFBQztBQUNoRkYsT0FBRyxDQUFDZ0MsSUFBSixDQUFTbk8sU0FBVDtBQUFxQixHQUR1RCxDQUN2RCxPQUFNb08sTUFBTixFQUFhO0FBQUM7QUFDbkMsVUFBTUEsTUFBTjtBQUFjO0FBQUMsQ0FKNGM7O0FBSTNjLFNBQVNDLFdBQVQsQ0FBcUJOLElBQXJCLEVBQTBCO0FBQUMsU0FBT0EsSUFBSSxDQUFDM04sT0FBTCxDQUFhLFFBQWIsRUFBc0IsVUFBU2tPLENBQVQsRUFBVztBQUFDLFdBQU8xQyxNQUFNLENBQUNDLFlBQVAsQ0FBb0J5QyxDQUFDLENBQUNDLFVBQUYsQ0FBYSxDQUFiLElBQWdCLElBQXBDLENBQVA7QUFBa0QsR0FBcEYsQ0FBUDtBQUE4Rjs7QUFBQSxTQUFTQyxlQUFULENBQXlCQyxHQUF6QixFQUE2QjtBQUFDO0FBQ3ZLLE1BQUk5SSxHQUFHLEdBQUMrSSxNQUFNLENBQUNDLE1BQVAsQ0FBYyxJQUFkLENBQVI7QUFBNEIsTUFBSUMsS0FBSyxHQUFDSCxHQUFHLENBQUNsSixLQUFKLENBQVUsTUFBVixDQUFWOztBQUE0QixPQUFJLElBQUlmLENBQUMsR0FBQyxDQUFWLEVBQVlBLENBQUMsR0FBQ29LLEtBQUssQ0FBQ25LLE1BQXBCLEVBQTJCRCxDQUFDLElBQUUsQ0FBOUIsRUFBZ0M7QUFBQyxRQUFJaUIsSUFBSSxHQUFDbUosS0FBSyxDQUFDcEssQ0FBRCxDQUFkO0FBQWtCLFFBQUlxSyxLQUFLLEdBQUNwSixJQUFJLENBQUNGLEtBQUwsQ0FBVyxJQUFYLENBQVY7QUFBMkIsUUFBSXdJLElBQUksR0FBQ2MsS0FBSyxDQUFDdEQsS0FBTixFQUFUO0FBQXVCLFFBQUkwQyxLQUFLLEdBQUNZLEtBQUssQ0FBQy9PLElBQU4sQ0FBVyxJQUFYLENBQVY7QUFBMkI2RixPQUFHLENBQUMwSSxXQUFXLENBQUNOLElBQUQsQ0FBWixDQUFILEdBQXVCRSxLQUF2QjtBQUE4Qjs7QUFBQSxPQUFLYSxJQUFMLEdBQVVuSixHQUFWO0FBQWU7O01BRG5GNkksZTs7QUFDbUZBLGVBQWUsQ0FBQ3JELFNBQWhCLENBQTBCNEQsR0FBMUIsR0FBOEIsVUFBU2hCLElBQVQsRUFBYztBQUFDLFNBQU8sS0FBS2UsSUFBTCxDQUFVVCxXQUFXLENBQUNOLElBQUQsQ0FBckIsQ0FBUDtBQUFxQyxDQUFsRjs7QUFBbUYsU0FBU2lCLFlBQVQsR0FBdUIsQ0FBRTs7TUFBaEJBLFk7O0FBQWdCQSxZQUFZLENBQUM3RCxTQUFiLENBQXVCNEIsSUFBdkIsR0FBNEIsVUFBU1osR0FBVCxFQUFhOEMsZUFBYixFQUE2QkMsa0JBQTdCLEVBQWdEQyxnQkFBaEQsRUFBaUVsQyxHQUFqRSxFQUFxRWIsZUFBckUsRUFBcUZnRCxPQUFyRixFQUE2RjtBQUFDakQsS0FBRyxDQUFDWSxJQUFKLENBQVMsS0FBVCxFQUFlRSxHQUFmO0FBQW9CLE1BQUlvQyxNQUFNLEdBQUMsQ0FBWDs7QUFBYWxELEtBQUcsQ0FBQ00sVUFBSixHQUFlLFlBQVU7QUFBQyxRQUFJRCxZQUFZLEdBQUNMLEdBQUcsQ0FBQ0ssWUFBckI7QUFBa0MsUUFBSThDLEtBQUssR0FBQzlDLFlBQVksQ0FBQytDLEtBQWIsQ0FBbUJGLE1BQW5CLENBQVY7QUFBcUNBLFVBQU0sSUFBRUMsS0FBSyxDQUFDN0ssTUFBZDtBQUFxQnlLLHNCQUFrQixDQUFDSSxLQUFELENBQWxCO0FBQTJCLEdBQWpKOztBQUFrSm5ELEtBQUcsQ0FBQ08sa0JBQUosR0FBdUIsWUFBVTtBQUFDLFFBQUdQLEdBQUcsQ0FBQ0csVUFBSixLQUFpQixDQUFwQixFQUFzQjtBQUFDLFVBQUl6QyxNQUFNLEdBQUNzQyxHQUFHLENBQUN0QyxNQUFmO0FBQXNCLFVBQUkwQyxVQUFVLEdBQUNKLEdBQUcsQ0FBQ0ksVUFBbkI7QUFBOEIsVUFBSWlCLFdBQVcsR0FBQ3JCLEdBQUcsQ0FBQ3NCLGlCQUFKLENBQXNCLGNBQXRCLENBQWhCO0FBQXNELFVBQUkyQixPQUFPLEdBQUNqRCxHQUFHLENBQUMrQixxQkFBSixFQUFaO0FBQXdDZSxxQkFBZSxDQUFDcEYsTUFBRCxFQUFRMEMsVUFBUixFQUFtQmlCLFdBQW5CLEVBQStCLElBQUlnQixlQUFKLENBQW9CWSxPQUFwQixDQUEvQixFQUE0RCxZQUFVO0FBQUNqRCxXQUFHLENBQUNwQixLQUFKO0FBQWEsT0FBcEYsQ0FBZjtBQUFzRyxLQUEvUSxNQUFvUixJQUFHb0IsR0FBRyxDQUFDRyxVQUFKLEtBQWlCLENBQXBCLEVBQXNCO0FBQUM2QyxzQkFBZ0I7QUFBSTtBQUFDLEdBQWxXOztBQUFtV2hELEtBQUcsQ0FBQ0MsZUFBSixHQUFvQkEsZUFBcEI7QUFBb0NELEtBQUcsQ0FBQ0UsWUFBSixHQUFpQixNQUFqQjs7QUFBd0IsT0FBSSxJQUFJMEIsSUFBUixJQUFnQnFCLE9BQWhCLEVBQXdCO0FBQUMsUUFBR1YsTUFBTSxDQUFDdkQsU0FBUCxDQUFpQnFFLGNBQWpCLENBQWdDQyxJQUFoQyxDQUFxQ0wsT0FBckMsRUFBNkNyQixJQUE3QyxDQUFILEVBQXNEO0FBQUM1QixTQUFHLENBQUM2QixnQkFBSixDQUFxQkQsSUFBckIsRUFBMEJxQixPQUFPLENBQUNyQixJQUFELENBQWpDO0FBQTBDO0FBQUM7O0FBQUE1QixLQUFHLENBQUNnQyxJQUFKO0FBQVksQ0FBbjFCOztBQUFvMUIsU0FBU3VCLGNBQVQsQ0FBd0JOLE9BQXhCLEVBQWdDO0FBQUMsT0FBS08sUUFBTCxHQUFjUCxPQUFkO0FBQXVCOztNQUEvQ00sYzs7QUFBK0NBLGNBQWMsQ0FBQ3ZFLFNBQWYsQ0FBeUI0RCxHQUF6QixHQUE2QixVQUFTaEIsSUFBVCxFQUFjO0FBQUMsU0FBTyxLQUFLNEIsUUFBTCxDQUFjWixHQUFkLENBQWtCaEIsSUFBbEIsQ0FBUDtBQUFnQyxDQUE1RTs7QUFBNkUsU0FBUzZCLGNBQVQsR0FBeUIsQ0FBRTs7TUFBbEJBLGM7O0FBQWtCQSxjQUFjLENBQUN6RSxTQUFmLENBQXlCNEIsSUFBekIsR0FBOEIsVUFBU1osR0FBVCxFQUFhOEMsZUFBYixFQUE2QkMsa0JBQTdCLEVBQWdEQyxnQkFBaEQsRUFBaUVsQyxHQUFqRSxFQUFxRWIsZUFBckUsRUFBcUZnRCxPQUFyRixFQUE2RjtBQUFDLE1BQUlTLFVBQVUsR0FBQyxJQUFJaEYsZUFBSixFQUFmO0FBQXFDLE1BQUlDLE1BQU0sR0FBQytFLFVBQVUsQ0FBQy9FLE1BQXRCLENBQXRDLENBQW1FOztBQUNuZ0QsTUFBSWdGLFdBQVcsR0FBQyxJQUFJbkYsV0FBSixFQUFoQjtBQUFrQyxHQUFDLEdBQUVGLFFBQVEsV0FBWCxFQUFxQndDLEdBQXJCLEVBQXlCO0FBQUNtQyxXQUFPLEVBQUNBLE9BQVQ7QUFBaUJXLGVBQVcsRUFBQzNELGVBQWUsR0FBQyxTQUFELEdBQVcsYUFBdkQ7QUFBcUV0QixVQUFNLEVBQUNBLE1BQTVFO0FBQW1Ga0YsU0FBSyxFQUFDO0FBQXpGLEdBQXpCLEVBQStIeEYsSUFBL0gsQ0FBb0ksVUFBU3lGLFFBQVQsRUFBa0I7QUFBQyxRQUFJQyxNQUFNLEdBQUNELFFBQVEsQ0FBQzlPLElBQVQsQ0FBY2dQLFNBQWQsRUFBWDtBQUFxQ2xCLG1CQUFlLENBQUNnQixRQUFRLENBQUNwRyxNQUFWLEVBQWlCb0csUUFBUSxDQUFDMUQsVUFBMUIsRUFBcUMwRCxRQUFRLENBQUNiLE9BQVQsQ0FBaUJMLEdBQWpCLENBQXFCLGNBQXJCLENBQXJDLEVBQTBFLElBQUlXLGNBQUosQ0FBbUJPLFFBQVEsQ0FBQ2IsT0FBNUIsQ0FBMUUsRUFBK0csWUFBVTtBQUFDUyxnQkFBVSxDQUFDOUUsS0FBWDtBQUFtQm1GLFlBQU0sQ0FBQ0UsTUFBUDtBQUFpQixLQUE5SixDQUFmO0FBQStLLFdBQU8sSUFBSUMsT0FBSixDQUFZLFVBQVNDLE9BQVQsRUFBaUJDLE1BQWpCLEVBQXdCO0FBQUMsVUFBSUMsYUFBYSxHQUFDLFNBQVNBLGFBQVQsR0FBd0I7QUFBQ04sY0FBTSxDQUFDTyxJQUFQLEdBQWNqRyxJQUFkLENBQW1CLFVBQVM1RCxNQUFULEVBQWdCO0FBQUMsY0FBR0EsTUFBTSxDQUFDOEosSUFBVixFQUFlO0FBQUM7QUFDeGhCSixtQkFBTyxDQUFDdFEsU0FBRCxDQUFQO0FBQW9CLFdBRG9mLE1BQ2hmO0FBQUMsZ0JBQUlzUCxLQUFLLEdBQUNRLFdBQVcsQ0FBQzFFLE1BQVosQ0FBbUJ4RSxNQUFNLENBQUNxSCxLQUExQixFQUFnQztBQUFDakMsb0JBQU0sRUFBQztBQUFSLGFBQWhDLENBQVY7QUFBeURrRCw4QkFBa0IsQ0FBQ0ksS0FBRCxDQUFsQjtBQUEwQmtCLHlCQUFhO0FBQUk7QUFBQyxTQURzVyxFQUNwVyxPQURvVyxFQUMzVixVQUFTM0gsS0FBVCxFQUFlO0FBQUMwSCxnQkFBTSxDQUFDMUgsS0FBRCxDQUFOO0FBQWUsU0FENFQ7QUFDelQsT0FEOFE7O0FBQzdRMkgsbUJBQWE7QUFBSSxLQUR1TixDQUFQO0FBQzdNLEdBRDlKLEVBQ2dLaEcsSUFEaEssQ0FDcUssVUFBUzVELE1BQVQsRUFBZ0I7QUFBQ3VJLG9CQUFnQjtBQUFHLFdBQU92SSxNQUFQO0FBQWUsR0FEeE4sRUFDeU4sVUFBU2lDLEtBQVQsRUFBZTtBQUFDc0csb0JBQWdCO0FBQUcsV0FBT2tCLE9BQU8sQ0FBQ0UsTUFBUixDQUFlMUgsS0FBZixDQUFQO0FBQThCLEdBRDFSO0FBQzZSLENBRnNnQzs7QUFFcmdDLFNBQVM4SCxXQUFULEdBQXNCO0FBQUMsT0FBS0MsVUFBTCxHQUFnQmxDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLElBQWQsQ0FBaEI7QUFBcUM7O01BQW5EZ0MsVzs7QUFBbUQsU0FBU0UsVUFBVCxDQUFvQnhILENBQXBCLEVBQXNCO0FBQUN2RyxZQUFVLENBQUMsWUFBVTtBQUFDLFVBQU11RyxDQUFOO0FBQVMsR0FBckIsRUFBc0IsQ0FBdEIsQ0FBVjtBQUFvQzs7QUFBQXNILFdBQVcsQ0FBQ3hGLFNBQVosQ0FBc0IyRixhQUF0QixHQUFvQyxVQUFTMU8sS0FBVCxFQUFlO0FBQUNBLE9BQUssQ0FBQzJPLE1BQU4sR0FBYSxJQUFiO0FBQWtCLE1BQUlDLGFBQWEsR0FBQyxLQUFLSixVQUFMLENBQWdCeE8sS0FBSyxDQUFDNk8sSUFBdEIsQ0FBbEI7O0FBQThDLE1BQUdELGFBQWEsSUFBRWhSLFNBQWxCLEVBQTRCO0FBQUMsUUFBSXlFLE1BQU0sR0FBQ3VNLGFBQWEsQ0FBQ3ZNLE1BQXpCOztBQUFnQyxTQUFJLElBQUlELENBQUMsR0FBQyxDQUFWLEVBQVlBLENBQUMsR0FBQ0MsTUFBZCxFQUFxQkQsQ0FBQyxJQUFFLENBQXhCLEVBQTBCO0FBQUMsVUFBSTBNLFFBQVEsR0FBQ0YsYUFBYSxDQUFDeE0sQ0FBRCxDQUExQjs7QUFBOEIsVUFBRztBQUFDLFlBQUcsT0FBTzBNLFFBQVEsQ0FBQ0MsV0FBaEIsS0FBOEIsVUFBakMsRUFBNEM7QUFBQ0Qsa0JBQVEsQ0FBQ0MsV0FBVCxDQUFxQi9PLEtBQXJCO0FBQTZCLFNBQTFFLE1BQThFO0FBQUM4TyxrQkFBUSxDQUFDekIsSUFBVCxDQUFjLElBQWQsRUFBbUJyTixLQUFuQjtBQUEyQjtBQUFDLE9BQS9HLENBQStHLE9BQU1pSCxDQUFOLEVBQVE7QUFBQ3dILGtCQUFVLENBQUN4SCxDQUFELENBQVY7QUFBZTtBQUFDO0FBQUM7QUFBQyxDQUFwWDs7QUFBcVhzSCxXQUFXLENBQUN4RixTQUFaLENBQXNCaUcsZ0JBQXRCLEdBQXVDLFVBQVNILElBQVQsRUFBY0MsUUFBZCxFQUF1QjtBQUFDRCxNQUFJLEdBQUNyRixNQUFNLENBQUNxRixJQUFELENBQVg7QUFBa0IsTUFBSXZOLFNBQVMsR0FBQyxLQUFLa04sVUFBbkI7QUFBOEIsTUFBSUksYUFBYSxHQUFDdE4sU0FBUyxDQUFDdU4sSUFBRCxDQUEzQjs7QUFBa0MsTUFBR0QsYUFBYSxJQUFFaFIsU0FBbEIsRUFBNEI7QUFBQ2dSLGlCQUFhLEdBQUMsRUFBZDtBQUFpQnROLGFBQVMsQ0FBQ3VOLElBQUQsQ0FBVCxHQUFnQkQsYUFBaEI7QUFBK0I7O0FBQUEsTUFBSUssS0FBSyxHQUFDLEtBQVY7O0FBQWdCLE9BQUksSUFBSTdNLENBQUMsR0FBQyxDQUFWLEVBQVlBLENBQUMsR0FBQ3dNLGFBQWEsQ0FBQ3ZNLE1BQTVCLEVBQW1DRCxDQUFDLElBQUUsQ0FBdEMsRUFBd0M7QUFBQyxRQUFHd00sYUFBYSxDQUFDeE0sQ0FBRCxDQUFiLEtBQW1CME0sUUFBdEIsRUFBK0I7QUFBQ0csV0FBSyxHQUFDLElBQU47QUFBWTtBQUFDOztBQUFBLE1BQUcsQ0FBQ0EsS0FBSixFQUFVO0FBQUNMLGlCQUFhLENBQUNoTSxJQUFkLENBQW1Ca00sUUFBbkI7QUFBOEI7QUFBQyxDQUE5Vzs7QUFBK1dQLFdBQVcsQ0FBQ3hGLFNBQVosQ0FBc0JtRyxtQkFBdEIsR0FBMEMsVUFBU0wsSUFBVCxFQUFjQyxRQUFkLEVBQXVCO0FBQUNELE1BQUksR0FBQ3JGLE1BQU0sQ0FBQ3FGLElBQUQsQ0FBWDtBQUFrQixNQUFJdk4sU0FBUyxHQUFDLEtBQUtrTixVQUFuQjtBQUE4QixNQUFJSSxhQUFhLEdBQUN0TixTQUFTLENBQUN1TixJQUFELENBQTNCOztBQUFrQyxNQUFHRCxhQUFhLElBQUVoUixTQUFsQixFQUE0QjtBQUFDLFFBQUl1UixRQUFRLEdBQUMsRUFBYjs7QUFBZ0IsU0FBSSxJQUFJL00sQ0FBQyxHQUFDLENBQVYsRUFBWUEsQ0FBQyxHQUFDd00sYUFBYSxDQUFDdk0sTUFBNUIsRUFBbUNELENBQUMsSUFBRSxDQUF0QyxFQUF3QztBQUFDLFVBQUd3TSxhQUFhLENBQUN4TSxDQUFELENBQWIsS0FBbUIwTSxRQUF0QixFQUErQjtBQUFDSyxnQkFBUSxDQUFDdk0sSUFBVCxDQUFjZ00sYUFBYSxDQUFDeE0sQ0FBRCxDQUEzQjtBQUFpQztBQUFDOztBQUFBLFFBQUcrTSxRQUFRLENBQUM5TSxNQUFULEtBQWtCLENBQXJCLEVBQXVCO0FBQUMsYUFBT2YsU0FBUyxDQUFDdU4sSUFBRCxDQUFoQjtBQUF3QixLQUFoRCxNQUFvRDtBQUFDdk4sZUFBUyxDQUFDdU4sSUFBRCxDQUFULEdBQWdCTSxRQUFoQjtBQUEwQjtBQUFDO0FBQUMsQ0FBN1g7O0FBQThYLFNBQVNDLEtBQVQsQ0FBZVAsSUFBZixFQUFvQjtBQUFDLE9BQUtBLElBQUwsR0FBVUEsSUFBVjtBQUFlLE9BQUtGLE1BQUwsR0FBWS9RLFNBQVo7QUFBdUI7O01BQWxEd1IsSzs7QUFBa0QsU0FBU0MsWUFBVCxDQUFzQlIsSUFBdEIsRUFBMkIzTixPQUEzQixFQUFtQztBQUFDa08sT0FBSyxDQUFDL0IsSUFBTixDQUFXLElBQVgsRUFBZ0J3QixJQUFoQjtBQUFzQixPQUFLNU8sSUFBTCxHQUFVaUIsT0FBTyxDQUFDakIsSUFBbEI7QUFBdUIsT0FBS3FQLFdBQUwsR0FBaUJwTyxPQUFPLENBQUNvTyxXQUF6QjtBQUFzQzs7TUFBOUdELFk7QUFBOEdBLFlBQVksQ0FBQ3RHLFNBQWIsR0FBdUJ1RCxNQUFNLENBQUNDLE1BQVAsQ0FBYzZDLEtBQUssQ0FBQ3JHLFNBQXBCLENBQXZCOztBQUFzRCxTQUFTd0csZUFBVCxDQUF5QlYsSUFBekIsRUFBOEIzTixPQUE5QixFQUFzQztBQUFDa08sT0FBSyxDQUFDL0IsSUFBTixDQUFXLElBQVgsRUFBZ0J3QixJQUFoQjtBQUFzQixPQUFLcEgsTUFBTCxHQUFZdkcsT0FBTyxDQUFDdUcsTUFBcEI7QUFBMkIsT0FBSzBDLFVBQUwsR0FBZ0JqSixPQUFPLENBQUNpSixVQUF4QjtBQUFtQyxPQUFLNkMsT0FBTCxHQUFhOUwsT0FBTyxDQUFDOEwsT0FBckI7QUFBOEI7O09BQWhKdUMsZTtBQUFnSkEsZUFBZSxDQUFDeEcsU0FBaEIsR0FBMEJ1RCxNQUFNLENBQUNDLE1BQVAsQ0FBYzZDLEtBQUssQ0FBQ3JHLFNBQXBCLENBQTFCO0FBQXlELElBQUl5RyxPQUFPLEdBQUMsQ0FBQyxDQUFiO0FBQWUsSUFBSUMsVUFBVSxHQUFDLENBQWY7QUFBaUIsSUFBSUMsSUFBSSxHQUFDLENBQVQ7QUFBVyxJQUFJQyxNQUFNLEdBQUMsQ0FBWDtBQUFhLElBQUlDLFFBQVEsR0FBQyxDQUFDLENBQWQ7QUFBZ0IsSUFBSUMsV0FBVyxHQUFDLENBQWhCO0FBQWtCLElBQUlDLEtBQUssR0FBQyxDQUFWO0FBQVksSUFBSUMsV0FBVyxHQUFDLENBQWhCO0FBQWtCLElBQUlDLEtBQUssR0FBQyxDQUFWO0FBQVksSUFBSUMsaUJBQWlCLEdBQUMsK0NBQXRCO0FBQXNFLElBQUlDLGdCQUFnQixHQUFDLElBQXJCO0FBQTBCLElBQUlDLGdCQUFnQixHQUFDLFFBQXJCOztBQUE4QixJQUFJQyxhQUFhLEdBQUMsU0FBU0EsYUFBVCxDQUF1QnZFLEtBQXZCLEVBQTZCd0UsR0FBN0IsRUFBaUM7QUFBQyxNQUFJQyxDQUFDLEdBQUNDLFFBQVEsQ0FBQzFFLEtBQUQsRUFBTyxFQUFQLENBQWQ7O0FBQXlCLE1BQUd5RSxDQUFDLEtBQUdBLENBQVAsRUFBUztBQUFDQSxLQUFDLEdBQUNELEdBQUY7QUFBTzs7QUFBQSxTQUFPRyxhQUFhLENBQUNGLENBQUQsQ0FBcEI7QUFBeUIsQ0FBdkg7O0FBQXdILElBQUlFLGFBQWEsR0FBQyxTQUFTQSxhQUFULENBQXVCRixDQUF2QixFQUF5QjtBQUFDLFNBQU9HLElBQUksQ0FBQ0MsR0FBTCxDQUFTRCxJQUFJLENBQUNFLEdBQUwsQ0FBU0wsQ0FBVCxFQUFXSixnQkFBWCxDQUFULEVBQXNDQyxnQkFBdEMsQ0FBUDtBQUFnRSxDQUE1Rzs7QUFBNkcsSUFBSVMsSUFBSSxHQUFDLFNBQVNBLElBQVQsQ0FBYzlGLElBQWQsRUFBbUIrRixDQUFuQixFQUFxQjdRLEtBQXJCLEVBQTJCO0FBQUMsTUFBRztBQUFDLFFBQUcsT0FBTzZRLENBQVAsS0FBVyxVQUFkLEVBQXlCO0FBQUNBLE9BQUMsQ0FBQ3hELElBQUYsQ0FBT3ZDLElBQVAsRUFBWTlLLEtBQVo7QUFBb0I7QUFBQyxHQUFuRCxDQUFtRCxPQUFNaUgsQ0FBTixFQUFRO0FBQUN3SCxjQUFVLENBQUN4SCxDQUFELENBQVY7QUFBZTtBQUFDLENBQWpIOztBQUFrSCxTQUFTNkosbUJBQVQsQ0FBNkJqRyxHQUE3QixFQUFpQzNKLE9BQWpDLEVBQXlDO0FBQUNxTixhQUFXLENBQUNsQixJQUFaLENBQWlCLElBQWpCO0FBQXVCLE9BQUt2TCxNQUFMLEdBQVlsRSxTQUFaO0FBQXNCLE9BQUtxRSxTQUFMLEdBQWVyRSxTQUFmO0FBQXlCLE9BQUtvRSxPQUFMLEdBQWFwRSxTQUFiO0FBQXVCLE9BQUtpTixHQUFMLEdBQVNqTixTQUFUO0FBQW1CLE9BQUtzTSxVQUFMLEdBQWdCdE0sU0FBaEI7QUFBMEIsT0FBS29NLGVBQUwsR0FBcUJwTSxTQUFyQjtBQUErQixPQUFLbVQsTUFBTCxHQUFZblQsU0FBWjtBQUFzQm9ULE9BQUssQ0FBQyxJQUFELEVBQU1uRyxHQUFOLEVBQVUzSixPQUFWLENBQUw7QUFBeUI7O09BQXpQNFAsbUI7QUFBeVAsSUFBSUcsZ0JBQWdCLEdBQUM1SSxRQUFRLFdBQVIsSUFBa0J6SyxTQUFsQixJQUE2QjBLLFFBQVEsSUFBRTFLLFNBQXZDLElBQWtELFVBQVMwSyxRQUFRLENBQUNTLFNBQXpGOztBQUFtRyxTQUFTaUksS0FBVCxDQUFlRSxFQUFmLEVBQWtCckcsR0FBbEIsRUFBc0IzSixPQUF0QixFQUE4QjtBQUFDMkosS0FBRyxHQUFDckIsTUFBTSxDQUFDcUIsR0FBRCxDQUFWO0FBQWdCLE1BQUliLGVBQWUsR0FBQzlJLE9BQU8sSUFBRXRELFNBQVQsSUFBb0J1SixPQUFPLENBQUNqRyxPQUFPLENBQUM4SSxlQUFULENBQS9DO0FBQXlFLE1BQUltSCxZQUFZLEdBQUNYLGFBQWEsQ0FBQyxJQUFELENBQTlCO0FBQXFDLE1BQUlZLGdCQUFnQixHQUFDbFEsT0FBTyxJQUFFdEQsU0FBVCxJQUFvQnNELE9BQU8sQ0FBQ2tRLGdCQUFSLElBQTBCeFQsU0FBOUMsR0FBd0R3UyxhQUFhLENBQUNsUCxPQUFPLENBQUNrUSxnQkFBVCxFQUEwQixLQUExQixDQUFyRSxHQUFzR1osYUFBYSxDQUFDLEtBQUQsQ0FBeEk7QUFBZ0osTUFBSWxCLFdBQVcsR0FBQyxFQUFoQjtBQUFtQixNQUFJK0IsS0FBSyxHQUFDRixZQUFWO0FBQXVCLE1BQUlHLFdBQVcsR0FBQyxLQUFoQjtBQUFzQixNQUFJdEUsT0FBTyxHQUFDOUwsT0FBTyxJQUFFdEQsU0FBVCxJQUFvQnNELE9BQU8sQ0FBQzhMLE9BQVIsSUFBaUJwUCxTQUFyQyxHQUErQ3lDLElBQUksQ0FBQ0MsS0FBTCxDQUFXRCxJQUFJLENBQUNrUixTQUFMLENBQWVyUSxPQUFPLENBQUM4TCxPQUF2QixDQUFYLENBQS9DLEdBQTJGcFAsU0FBdkc7QUFBaUgsTUFBSTRULGdCQUFnQixHQUFDdFEsT0FBTyxJQUFFdEQsU0FBVCxJQUFvQnNELE9BQU8sQ0FBQ3VRLFNBQVIsSUFBbUI3VCxTQUF2QyxHQUFpRHNELE9BQU8sQ0FBQ3VRLFNBQXpELEdBQW1FL0YsY0FBeEY7QUFBdUcsTUFBSTNCLEdBQUcsR0FBQ2tILGdCQUFnQixJQUFFLEVBQUUvUCxPQUFPLElBQUV0RCxTQUFULElBQW9Cc0QsT0FBTyxDQUFDdVEsU0FBUixJQUFtQjdULFNBQXpDLENBQWxCLEdBQXNFQSxTQUF0RSxHQUFnRixJQUFJa00sVUFBSixDQUFlLElBQUkwSCxnQkFBSixFQUFmLENBQXhGO0FBQStILE1BQUlFLFNBQVMsR0FBQzNILEdBQUcsSUFBRW5NLFNBQUwsR0FBZSxJQUFJNFAsY0FBSixFQUFmLEdBQW9DLElBQUlaLFlBQUosRUFBbEQ7QUFBcUUsTUFBSStFLGNBQWMsR0FBQy9ULFNBQW5CO0FBQTZCLE1BQUkyRCxPQUFPLEdBQUMsQ0FBWjtBQUFjLE1BQUlxUSxZQUFZLEdBQUNwQyxPQUFqQjtBQUF5QixNQUFJcUMsVUFBVSxHQUFDLEVBQWY7QUFBa0IsTUFBSUMsaUJBQWlCLEdBQUMsRUFBdEI7QUFBeUIsTUFBSUMsZUFBZSxHQUFDLEVBQXBCO0FBQXVCLE1BQUlDLFVBQVUsR0FBQyxFQUFmO0FBQWtCLE1BQUlqSCxLQUFLLEdBQUM4RSxXQUFWO0FBQXNCLE1BQUlvQyxVQUFVLEdBQUMsQ0FBZjtBQUFpQixNQUFJQyxVQUFVLEdBQUMsQ0FBZjs7QUFBaUIsTUFBSS9HLE9BQU8sR0FBQyxTQUFTQSxPQUFULENBQWlCMUQsTUFBakIsRUFBd0IwQyxVQUF4QixFQUFtQ2lCLFdBQW5DLEVBQStDNEIsT0FBL0MsRUFBdURnQixNQUF2RCxFQUE4RDtBQUFDLFFBQUc0RCxZQUFZLEtBQUduQyxVQUFsQixFQUE2QjtBQUFDa0Msb0JBQWMsR0FBQzNELE1BQWY7O0FBQXNCLFVBQUd2RyxNQUFNLEtBQUcsR0FBVCxJQUFjMkQsV0FBVyxJQUFFeE4sU0FBM0IsSUFBc0NxUyxpQkFBaUIsQ0FBQzNNLElBQWxCLENBQXVCOEgsV0FBdkIsQ0FBekMsRUFBNkU7QUFBQ3dHLG9CQUFZLEdBQUNsQyxJQUFiO0FBQWtCNEIsbUJBQVcsR0FBQyxJQUFaO0FBQWlCRCxhQUFLLEdBQUNGLFlBQU47QUFBbUJELFVBQUUsQ0FBQ2hILFVBQUgsR0FBY3dGLElBQWQ7QUFBbUIsWUFBSTFQLEtBQUssR0FBQyxJQUFJdVAsZUFBSixDQUFvQixNQUFwQixFQUEyQjtBQUFDOUgsZ0JBQU0sRUFBQ0EsTUFBUjtBQUFlMEMsb0JBQVUsRUFBQ0EsVUFBMUI7QUFBcUM2QyxpQkFBTyxFQUFDQTtBQUE3QyxTQUEzQixDQUFWO0FBQTRGa0UsVUFBRSxDQUFDeEMsYUFBSCxDQUFpQjFPLEtBQWpCO0FBQXdCNFEsWUFBSSxDQUFDTSxFQUFELEVBQUlBLEVBQUUsQ0FBQ3BQLE1BQVAsRUFBYzlCLEtBQWQsQ0FBSjtBQUEwQixPQUFyUyxNQUF5UztBQUFDLFlBQUlnRCxPQUFPLEdBQUMsRUFBWjs7QUFBZSxZQUFHeUUsTUFBTSxLQUFHLEdBQVosRUFBZ0I7QUFBQyxjQUFHMEMsVUFBSCxFQUFjO0FBQUNBLHNCQUFVLEdBQUNBLFVBQVUsQ0FBQ25NLE9BQVgsQ0FBbUIsTUFBbkIsRUFBMEIsR0FBMUIsQ0FBWDtBQUEyQzs7QUFBQWdGLGlCQUFPLEdBQUMseUNBQXVDeUUsTUFBdkMsR0FBOEMsR0FBOUMsR0FBa0QwQyxVQUFsRCxHQUE2RCw0Q0FBckU7QUFBbUgsU0FBOUwsTUFBa007QUFBQ25ILGlCQUFPLEdBQUMsZ0ZBQThFb0ksV0FBVyxJQUFFeE4sU0FBYixHQUF1QixHQUF2QixHQUEyQndOLFdBQVcsQ0FBQ3BOLE9BQVosQ0FBb0IsTUFBcEIsRUFBMkIsR0FBM0IsQ0FBekcsSUFBMEksNEJBQWxKO0FBQWdMOztBQUFBeVEsa0JBQVUsQ0FBQyxJQUFJcEYsS0FBSixDQUFVckcsT0FBVixDQUFELENBQVY7QUFBK0JOLGFBQUs7QUFBRyxZQUFJMUMsS0FBSyxHQUFDLElBQUl1UCxlQUFKLENBQW9CLE9BQXBCLEVBQTRCO0FBQUM5SCxnQkFBTSxFQUFDQSxNQUFSO0FBQWUwQyxvQkFBVSxFQUFDQSxVQUExQjtBQUFxQzZDLGlCQUFPLEVBQUNBO0FBQTdDLFNBQTVCLENBQVY7QUFBNkZrRSxVQUFFLENBQUN4QyxhQUFILENBQWlCMU8sS0FBakI7QUFBd0I0USxZQUFJLENBQUNNLEVBQUQsRUFBSUEsRUFBRSxDQUFDbFAsT0FBUCxFQUFlaEMsS0FBZixDQUFKO0FBQTJCO0FBQUM7QUFBQyxHQUFwK0I7O0FBQXErQixNQUFJc0wsVUFBVSxHQUFDLFNBQVNBLFVBQVQsQ0FBb0I2RyxTQUFwQixFQUE4QjtBQUFDLFFBQUdQLFlBQVksS0FBR2xDLElBQWxCLEVBQXVCO0FBQUMsVUFBSVksQ0FBQyxHQUFDLENBQUMsQ0FBUDs7QUFBUyxXQUFJLElBQUlsTyxDQUFDLEdBQUMsQ0FBVixFQUFZQSxDQUFDLEdBQUMrUCxTQUFTLENBQUM5UCxNQUF4QixFQUErQkQsQ0FBQyxJQUFFLENBQWxDLEVBQW9DO0FBQUMsWUFBSThKLENBQUMsR0FBQ2lHLFNBQVMsQ0FBQ2hHLFVBQVYsQ0FBcUIvSixDQUFyQixDQUFOOztBQUE4QixZQUFHOEosQ0FBQyxLQUFHLEtBQUtDLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBSixJQUF3QkQsQ0FBQyxLQUFHLEtBQUtDLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBL0IsRUFBa0Q7QUFBQ21FLFdBQUMsR0FBQ2xPLENBQUY7QUFBSztBQUFDOztBQUFBLFVBQUk4SyxLQUFLLEdBQUMsQ0FBQ29ELENBQUMsS0FBRyxDQUFDLENBQUwsR0FBTzBCLFVBQVAsR0FBa0IsRUFBbkIsSUFBdUJHLFNBQVMsQ0FBQ2hGLEtBQVYsQ0FBZ0IsQ0FBaEIsRUFBa0JtRCxDQUFDLEdBQUMsQ0FBcEIsQ0FBakM7QUFBd0QwQixnQkFBVSxHQUFDLENBQUMxQixDQUFDLEtBQUcsQ0FBQyxDQUFMLEdBQU8wQixVQUFQLEdBQWtCLEVBQW5CLElBQXVCRyxTQUFTLENBQUNoRixLQUFWLENBQWdCbUQsQ0FBQyxHQUFDLENBQWxCLENBQWxDOztBQUF1RCxVQUFHcEQsS0FBSyxLQUFHLEVBQVgsRUFBYztBQUFDb0UsbUJBQVcsR0FBQyxJQUFaO0FBQWtCOztBQUFBLFdBQUksSUFBSTdTLFFBQVEsR0FBQyxDQUFqQixFQUFtQkEsUUFBUSxHQUFDeU8sS0FBSyxDQUFDN0ssTUFBbEMsRUFBeUM1RCxRQUFRLElBQUUsQ0FBbkQsRUFBcUQ7QUFBQyxZQUFJeU4sQ0FBQyxHQUFDZ0IsS0FBSyxDQUFDZixVQUFOLENBQWlCMU4sUUFBakIsQ0FBTjs7QUFBaUMsWUFBR3NNLEtBQUssS0FBRzZFLFFBQVIsSUFBa0IxRCxDQUFDLEtBQUcsS0FBS0MsVUFBTCxDQUFnQixDQUFoQixDQUF6QixFQUE0QztBQUFDcEIsZUFBSyxHQUFDOEUsV0FBTjtBQUFtQixTQUFoRSxNQUFvRTtBQUFDLGNBQUc5RSxLQUFLLEtBQUc2RSxRQUFYLEVBQW9CO0FBQUM3RSxpQkFBSyxHQUFDOEUsV0FBTjtBQUFtQjs7QUFBQSxjQUFHM0QsQ0FBQyxLQUFHLEtBQUtDLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBSixJQUF3QkQsQ0FBQyxLQUFHLEtBQUtDLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBL0IsRUFBa0Q7QUFBQyxnQkFBR3BCLEtBQUssS0FBRzhFLFdBQVgsRUFBdUI7QUFBQyxrQkFBRzlFLEtBQUssS0FBRytFLEtBQVgsRUFBaUI7QUFBQ29DLDBCQUFVLEdBQUN6VCxRQUFRLEdBQUMsQ0FBcEI7QUFBdUI7O0FBQUEsa0JBQUkyVCxLQUFLLEdBQUNsRixLQUFLLENBQUNDLEtBQU4sQ0FBWThFLFVBQVosRUFBdUJDLFVBQVUsR0FBQyxDQUFsQyxDQUFWO0FBQStDLGtCQUFJckcsS0FBSyxHQUFDcUIsS0FBSyxDQUFDQyxLQUFOLENBQVkrRSxVQUFVLElBQUVBLFVBQVUsR0FBQ3pULFFBQVgsSUFBcUJ5TyxLQUFLLENBQUNmLFVBQU4sQ0FBaUIrRixVQUFqQixNQUErQixJQUFJL0YsVUFBSixDQUFlLENBQWYsQ0FBcEQsR0FBc0UsQ0FBdEUsR0FBd0UsQ0FBMUUsQ0FBdEIsRUFBbUcxTixRQUFuRyxDQUFWOztBQUF1SCxrQkFBRzJULEtBQUssS0FBRyxNQUFYLEVBQWtCO0FBQUNQLDBCQUFVLElBQUUsSUFBWjtBQUFpQkEsMEJBQVUsSUFBRWhHLEtBQVo7QUFBbUIsZUFBdkQsTUFBNEQsSUFBR3VHLEtBQUssS0FBRyxJQUFYLEVBQWdCO0FBQUNOLGlDQUFpQixHQUFDakcsS0FBbEI7QUFBeUIsZUFBMUMsTUFBK0MsSUFBR3VHLEtBQUssS0FBRyxPQUFYLEVBQW1CO0FBQUNMLCtCQUFlLEdBQUNsRyxLQUFoQjtBQUF1QixlQUEzQyxNQUFnRCxJQUFHdUcsS0FBSyxLQUFHLE9BQVgsRUFBbUI7QUFBQ2pCLDRCQUFZLEdBQUNmLGFBQWEsQ0FBQ3ZFLEtBQUQsRUFBT3NGLFlBQVAsQ0FBMUI7QUFBK0NFLHFCQUFLLEdBQUNGLFlBQU47QUFBb0IsZUFBdkYsTUFBNEYsSUFBR2lCLEtBQUssS0FBRyxrQkFBWCxFQUE4QjtBQUFDaEIsZ0NBQWdCLEdBQUNoQixhQUFhLENBQUN2RSxLQUFELEVBQU91RixnQkFBUCxDQUE5Qjs7QUFBdUQsb0JBQUc3UCxPQUFPLEtBQUcsQ0FBYixFQUFlO0FBQUNmLDhCQUFZLENBQUNlLE9BQUQsQ0FBWjtBQUFzQkEseUJBQU8sR0FBQ2IsVUFBVSxDQUFDLFlBQVU7QUFBQytLLDZCQUFTO0FBQUksbUJBQXpCLEVBQTBCMkYsZ0JBQTFCLENBQWxCO0FBQStEO0FBQUM7QUFBQzs7QUFBQSxnQkFBR3JHLEtBQUssS0FBRzhFLFdBQVgsRUFBdUI7QUFBQyxrQkFBR2dDLFVBQVUsS0FBRyxFQUFoQixFQUFtQjtBQUFDdkMsMkJBQVcsR0FBQ3dDLGlCQUFaOztBQUE4QixvQkFBR0MsZUFBZSxLQUFHLEVBQXJCLEVBQXdCO0FBQUNBLGlDQUFlLEdBQUMsU0FBaEI7QUFBMkI7O0FBQUEsb0JBQUkvUixLQUFLLEdBQUMsSUFBSXFQLFlBQUosQ0FBaUIwQyxlQUFqQixFQUFpQztBQUFDOVIsc0JBQUksRUFBQzRSLFVBQVUsQ0FBQzFFLEtBQVgsQ0FBaUIsQ0FBakIsQ0FBTjtBQUEwQm1DLDZCQUFXLEVBQUN3QztBQUF0QyxpQkFBakMsQ0FBVjtBQUFxR1osa0JBQUUsQ0FBQ3hDLGFBQUgsQ0FBaUIxTyxLQUFqQjs7QUFBd0Isb0JBQUcrUixlQUFlLEtBQUcsU0FBckIsRUFBK0I7QUFBQ25CLHNCQUFJLENBQUNNLEVBQUQsRUFBSUEsRUFBRSxDQUFDalAsU0FBUCxFQUFpQmpDLEtBQWpCLENBQUo7QUFBNkI7O0FBQUEsb0JBQUc0UixZQUFZLEtBQUdqQyxNQUFsQixFQUF5QjtBQUFDO0FBQVE7QUFBQzs7QUFBQWtDLHdCQUFVLEdBQUMsRUFBWDtBQUFjRSw2QkFBZSxHQUFDLEVBQWhCO0FBQW9COztBQUFBaEgsaUJBQUssR0FBQ21CLENBQUMsS0FBRyxLQUFLQyxVQUFMLENBQWdCLENBQWhCLENBQUosR0FBdUJ5RCxRQUF2QixHQUFnQ0MsV0FBdEM7QUFBbUQsV0FBOW5DLE1BQWtvQztBQUFDLGdCQUFHOUUsS0FBSyxLQUFHOEUsV0FBWCxFQUF1QjtBQUFDb0Msd0JBQVUsR0FBQ3hULFFBQVg7QUFBb0JzTSxtQkFBSyxHQUFDK0UsS0FBTjtBQUFhOztBQUFBLGdCQUFHL0UsS0FBSyxLQUFHK0UsS0FBWCxFQUFpQjtBQUFDLGtCQUFHNUQsQ0FBQyxLQUFHLElBQUlDLFVBQUosQ0FBZSxDQUFmLENBQVAsRUFBeUI7QUFBQytGLDBCQUFVLEdBQUN6VCxRQUFRLEdBQUMsQ0FBcEI7QUFBc0JzTSxxQkFBSyxHQUFDZ0YsV0FBTjtBQUFtQjtBQUFDLGFBQXRGLE1BQTJGLElBQUdoRixLQUFLLEtBQUdnRixXQUFYLEVBQXVCO0FBQUNoRixtQkFBSyxHQUFDaUYsS0FBTjtBQUFhO0FBQUM7QUFBQztBQUFDO0FBQUM7QUFBQyxHQUFoMkQ7O0FBQWkyRCxNQUFJekUsUUFBUSxHQUFDLFNBQVNBLFFBQVQsR0FBbUI7QUFBQyxRQUFHcUcsWUFBWSxLQUFHbEMsSUFBZixJQUFxQmtDLFlBQVksS0FBR25DLFVBQXZDLEVBQWtEO0FBQUNtQyxrQkFBWSxHQUFDcEMsT0FBYjs7QUFBcUIsVUFBR2pPLE9BQU8sS0FBRyxDQUFiLEVBQWU7QUFBQ2Ysb0JBQVksQ0FBQ2UsT0FBRCxDQUFaO0FBQXNCQSxlQUFPLEdBQUMsQ0FBUjtBQUFXOztBQUFBQSxhQUFPLEdBQUNiLFVBQVUsQ0FBQyxZQUFVO0FBQUMrSyxpQkFBUztBQUFJLE9BQXpCLEVBQTBCNEYsS0FBMUIsQ0FBbEI7QUFBbURBLFdBQUssR0FBQ2IsYUFBYSxDQUFDQyxJQUFJLENBQUNDLEdBQUwsQ0FBU1MsWUFBWSxHQUFDLEVBQXRCLEVBQXlCRSxLQUFLLEdBQUMsQ0FBL0IsQ0FBRCxDQUFuQjtBQUF1REgsUUFBRSxDQUFDaEgsVUFBSCxHQUFjdUYsVUFBZDtBQUF5QixVQUFJelAsS0FBSyxHQUFDLElBQUlvUCxLQUFKLENBQVUsT0FBVixDQUFWO0FBQTZCOEIsUUFBRSxDQUFDeEMsYUFBSCxDQUFpQjFPLEtBQWpCO0FBQXdCNFEsVUFBSSxDQUFDTSxFQUFELEVBQUlBLEVBQUUsQ0FBQ2xQLE9BQVAsRUFBZWhDLEtBQWYsQ0FBSjtBQUEyQjtBQUFDLEdBQTlXOztBQUErVyxNQUFJMEMsS0FBSyxHQUFDLFNBQVNBLEtBQVQsR0FBZ0I7QUFBQ2tQLGdCQUFZLEdBQUNqQyxNQUFiOztBQUFvQixRQUFHZ0MsY0FBYyxJQUFFL1QsU0FBbkIsRUFBNkI7QUFBQytULG9CQUFjO0FBQUdBLG9CQUFjLEdBQUMvVCxTQUFmO0FBQTBCOztBQUFBLFFBQUcyRCxPQUFPLEtBQUcsQ0FBYixFQUFlO0FBQUNmLGtCQUFZLENBQUNlLE9BQUQsQ0FBWjtBQUFzQkEsYUFBTyxHQUFDLENBQVI7QUFBVzs7QUFBQTJQLE1BQUUsQ0FBQ2hILFVBQUgsR0FBY3lGLE1BQWQ7QUFBc0IsR0FBL0w7O0FBQWdNLE1BQUlsRSxTQUFTLEdBQUMsU0FBU0EsU0FBVCxHQUFvQjtBQUFDbEssV0FBTyxHQUFDLENBQVI7O0FBQVUsUUFBR3FRLFlBQVksS0FBR3BDLE9BQWxCLEVBQTBCO0FBQUMsVUFBRyxDQUFDOEIsV0FBRCxJQUFjSyxjQUFjLElBQUUvVCxTQUFqQyxFQUEyQztBQUFDNlEsa0JBQVUsQ0FBQyxJQUFJcEYsS0FBSixDQUFVLHdCQUFzQitILGdCQUF0QixHQUF1Qyw4QkFBakQsQ0FBRCxDQUFWO0FBQTZGTyxzQkFBYztBQUFHQSxzQkFBYyxHQUFDL1QsU0FBZjtBQUEwQixPQUFwTCxNQUF3TDtBQUFDMFQsbUJBQVcsR0FBQyxLQUFaO0FBQWtCL1AsZUFBTyxHQUFDYixVQUFVLENBQUMsWUFBVTtBQUFDK0ssbUJBQVM7QUFBSSxTQUF6QixFQUEwQjJGLGdCQUExQixDQUFsQjtBQUErRDs7QUFBQTtBQUFROztBQUFBRSxlQUFXLEdBQUMsS0FBWjtBQUFrQi9QLFdBQU8sR0FBQ2IsVUFBVSxDQUFDLFlBQVU7QUFBQytLLGVBQVM7QUFBSSxLQUF6QixFQUEwQjJGLGdCQUExQixDQUFsQjtBQUE4RFEsZ0JBQVksR0FBQ25DLFVBQWI7QUFBd0JvQyxjQUFVLEdBQUMsRUFBWDtBQUFjRSxtQkFBZSxHQUFDLEVBQWhCO0FBQW1CRCxxQkFBaUIsR0FBQ3hDLFdBQWxCO0FBQThCMEMsY0FBVSxHQUFDLEVBQVg7QUFBY0MsY0FBVSxHQUFDLENBQVg7QUFBYUMsY0FBVSxHQUFDLENBQVg7QUFBYW5ILFNBQUssR0FBQzhFLFdBQU4sQ0FBdmdCLENBQXloQjtBQUMxeFA7O0FBQ0EsUUFBSXdDLFVBQVUsR0FBQ3hILEdBQWY7O0FBQW1CLFFBQUdBLEdBQUcsQ0FBQ3NDLEtBQUosQ0FBVSxDQUFWLEVBQVksQ0FBWixNQUFpQixPQUFqQixJQUEwQnRDLEdBQUcsQ0FBQ3NDLEtBQUosQ0FBVSxDQUFWLEVBQVksQ0FBWixNQUFpQixPQUE5QyxFQUFzRDtBQUFDLFVBQUdtQyxXQUFXLEtBQUcsRUFBakIsRUFBb0I7QUFBQytDLGtCQUFVLElBQUUsQ0FBQ3hILEdBQUcsQ0FBQ3ZJLE9BQUosQ0FBWSxHQUFaLE1BQW1CLENBQUMsQ0FBcEIsR0FBc0IsR0FBdEIsR0FBMEIsR0FBM0IsSUFBZ0MsY0FBaEMsR0FBK0NnUSxrQkFBa0IsQ0FBQ2hELFdBQUQsQ0FBN0U7QUFBNEY7QUFBQzs7QUFBQSxRQUFJaUQsY0FBYyxHQUFDLEVBQW5CO0FBQXNCQSxrQkFBYyxDQUFDLFFBQUQsQ0FBZCxHQUF5QixtQkFBekI7O0FBQTZDLFFBQUd2RixPQUFPLElBQUVwUCxTQUFaLEVBQXNCO0FBQUMsV0FBSSxJQUFJK04sSUFBUixJQUFnQnFCLE9BQWhCLEVBQXdCO0FBQUMsWUFBR1YsTUFBTSxDQUFDdkQsU0FBUCxDQUFpQnFFLGNBQWpCLENBQWdDQyxJQUFoQyxDQUFxQ0wsT0FBckMsRUFBNkNyQixJQUE3QyxDQUFILEVBQXNEO0FBQUM0Ryx3QkFBYyxDQUFDNUcsSUFBRCxDQUFkLEdBQXFCcUIsT0FBTyxDQUFDckIsSUFBRCxDQUE1QjtBQUFvQztBQUFDO0FBQUM7O0FBQUEsUUFBRztBQUFDK0YsZUFBUyxDQUFDL0csSUFBVixDQUFlWixHQUFmLEVBQW1Cb0IsT0FBbkIsRUFBMkJHLFVBQTNCLEVBQXNDQyxRQUF0QyxFQUErQzhHLFVBQS9DLEVBQTBEckksZUFBMUQsRUFBMEV1SSxjQUExRTtBQUEyRixLQUEvRixDQUErRixPQUFNOUwsS0FBTixFQUFZO0FBQUMvRCxXQUFLO0FBQUcsWUFBTStELEtBQU47QUFBYTtBQUFDLEdBRml0Tjs7QUFFaHROeUssSUFBRSxDQUFDckcsR0FBSCxHQUFPQSxHQUFQO0FBQVdxRyxJQUFFLENBQUNoSCxVQUFILEdBQWN1RixVQUFkO0FBQXlCeUIsSUFBRSxDQUFDbEgsZUFBSCxHQUFtQkEsZUFBbkI7QUFBbUNrSCxJQUFFLENBQUNILE1BQUgsR0FBVXJPLEtBQVY7QUFBZ0IrSSxXQUFTO0FBQUk7O0FBQUFxRixtQkFBbUIsQ0FBQy9ILFNBQXBCLEdBQThCdUQsTUFBTSxDQUFDQyxNQUFQLENBQWNnQyxXQUFXLENBQUN4RixTQUExQixDQUE5QjtBQUFtRStILG1CQUFtQixDQUFDL0gsU0FBcEIsQ0FBOEIwRyxVQUE5QixHQUF5Q0EsVUFBekM7QUFBb0RxQixtQkFBbUIsQ0FBQy9ILFNBQXBCLENBQThCMkcsSUFBOUIsR0FBbUNBLElBQW5DO0FBQXdDb0IsbUJBQW1CLENBQUMvSCxTQUFwQixDQUE4QjRHLE1BQTlCLEdBQXFDQSxNQUFyQzs7QUFBNENtQixtQkFBbUIsQ0FBQy9ILFNBQXBCLENBQThCckcsS0FBOUIsR0FBb0MsWUFBVTtBQUFDLE9BQUtxTyxNQUFMO0FBQWUsQ0FBOUQ7O0FBQStERCxtQkFBbUIsQ0FBQ3JCLFVBQXBCLEdBQStCQSxVQUEvQjtBQUEwQ3FCLG1CQUFtQixDQUFDcEIsSUFBcEIsR0FBeUJBLElBQXpCO0FBQThCb0IsbUJBQW1CLENBQUNuQixNQUFwQixHQUEyQkEsTUFBM0I7QUFBa0NtQixtQkFBbUIsQ0FBQy9ILFNBQXBCLENBQThCaUIsZUFBOUIsR0FBOENwTSxTQUE5QztBQUF3RCxJQUFJNFUsUUFBUSxHQUFDMUIsbUJBQWI7QUFBaUN2VCxPQUFPLFdBQVAsR0FBZ0JpVixRQUFoQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQ2hrQyw4Q0FBYTs7QUFBQWpWLE9BQU8sQ0FBQ1UsVUFBUixHQUFtQixJQUFuQjtBQUF3QlYsT0FBTyxDQUFDa1YsY0FBUixHQUF1QkEsY0FBdkI7O0FBQXNDLFNBQVNBLGNBQVQsQ0FBd0JDLFFBQXhCLEVBQWlDO0FBQUM7QUFDN0c7QUFDQTtBQUNBO0FBQUMsR0FBQzlRLE1BQU0sQ0FBQytRLHFCQUFQLElBQThCalMsVUFBL0IsRUFBMkMsWUFBVTtBQUFDLFNBQUksSUFBSWtTLENBQUMsR0FBQ3ZVLFFBQVEsQ0FBQ3dVLGdCQUFULENBQTBCLHVCQUExQixDQUFOLEVBQXlEelEsQ0FBQyxHQUFDd1EsQ0FBQyxDQUFDdlEsTUFBakUsRUFBd0VELENBQUMsRUFBekUsR0FBNkU7QUFBQ3dRLE9BQUMsQ0FBQ3hRLENBQUQsQ0FBRCxDQUFLMFEsVUFBTCxDQUFnQkMsV0FBaEIsQ0FBNEJILENBQUMsQ0FBQ3hRLENBQUQsQ0FBN0I7QUFBbUM7O0FBQUEsUUFBR3NRLFFBQUgsRUFBWTtBQUFDQSxjQUFRO0FBQUk7QUFBQyxHQUFqTTtBQUFvTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSHJNLDhDQUFhOzs7Ozs7QUFBQSxJQUFJaE8sc0JBQXNCLEdBQUM1RyxtQkFBTyxDQUFDLG9IQUFELENBQWxDOztBQUFtRlAsT0FBTyxDQUFDVSxVQUFSLEdBQW1CLElBQW5CO0FBQXdCVixPQUFPLFdBQVAsR0FBZ0IsS0FBSyxDQUFyQjs7QUFBdUIsSUFBSXlWLE9BQU8sR0FBQ3RPLHNCQUFzQixDQUFDNUcsbUJBQU8sQ0FBQyw4REFBRCxDQUFSLENBQWxDOztBQUEyRCxJQUFJbVYscUJBQXFCLEdBQUNuVixtQkFBTyxDQUFDLGlHQUFELENBQWpDOztBQUErRCxJQUFJMFUsUUFBUTtBQUFBLHVFQUFDLGlCQUFNVSxJQUFOO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFrQkMsdUJBQWxCLEdBQStCRCxJQUEvQixDQUFrQkMsV0FBbEI7O0FBQW9DSCxtQkFBTyxXQUFQLENBQWdCSSxLQUFoQixDQUFzQixZQUFJO0FBQUNKLHFCQUFPLFdBQVAsQ0FBZ0JLLE1BQWhCLENBQXVCQyxFQUF2QixDQUEwQixxQkFBMUIsRUFBZ0RMLHFCQUFxQixDQUFDTSxTQUF0QixDQUFnQ0MsSUFBaEMsQ0FBcUMsS0FBSyxDQUExQyxFQUE0Q0wsV0FBNUMsRUFBd0Q7QUFBQSx1QkFBSUgsT0FBTyxXQUFQLENBQWdCUyxRQUFwQjtBQUFBLGVBQXhELENBQWhEO0FBQXdJLGFBQW5LOztBQUFxSyxhQUFDLEdBQUVSLHFCQUFxQixDQUFDTSxTQUF6QixFQUFvQ0osV0FBcEMsRUFBZ0Q7QUFBQSxxQkFBSUgsT0FBTyxXQUFQLENBQWdCUyxRQUFwQjtBQUFBLGFBQWhELEVBQTZFUixxQkFBcUIsQ0FBQ1MsV0FBbkcsRUFBek0sQ0FBeVQ7O0FBQy9rQixnQkFBRyxDQUFDaE4sU0FBSixFQUFpQztBQUFDckksc0JBQVEsQ0FBQzJRLGdCQUFULENBQTBCLGtCQUExQixFQUE2QyxVQUFBaFAsS0FBSyxFQUFFO0FBQUMsb0JBQUkrSyxLQUFLLEdBQUMxTSxRQUFRLENBQUNzVixlQUFuQjs7QUFBbUMsb0JBQUc1SSxLQUFLLEtBQUcsU0FBWCxFQUFxQjtBQUFDLG1CQUFDLEdBQUVrSSxxQkFBcUIsQ0FBQ00sU0FBekIsRUFBb0NKLFdBQXBDLEVBQWdEO0FBQUEsMkJBQUlILE9BQU8sV0FBUCxDQUFnQlMsUUFBcEI7QUFBQSxtQkFBaEQsRUFBNkUsSUFBN0U7QUFBb0YsaUJBQTFHLE1BQThHO0FBQUMsbUJBQUMsR0FBRVIscUJBQXFCLENBQUNXLFNBQXpCO0FBQXVDO0FBQUMsZUFBL087QUFBaVBoUyxvQkFBTSxDQUFDb04sZ0JBQVAsQ0FBd0IsY0FBeEIsRUFBdUMsWUFBSTtBQUFDLGlCQUFDLEdBQUVpRSxxQkFBcUIsQ0FBQ1csU0FBekI7QUFBdUMsZUFBbkY7QUFBc0Y7O0FBRG5GO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQUQ7O0FBQUEsa0JBQVJwQixRQUFRO0FBQUE7QUFBQTtBQUFBLEdBQVo7O0FBQ2tHalYsT0FBTyxXQUFQLEdBQWdCaVYsUUFBaEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0QzVyw4Q0FBYTs7QUFBQSxJQUFJOU4sc0JBQXNCLEdBQUM1RyxtQkFBTyxDQUFDLG9IQUFELENBQWxDOztBQUFtRlAsT0FBTyxDQUFDVSxVQUFSLEdBQW1CLElBQW5CO0FBQXdCVixPQUFPLENBQUNxVyxTQUFSLEdBQWtCQSxTQUFsQjtBQUE0QnJXLE9BQU8sQ0FBQ2dXLFNBQVIsR0FBa0JBLFNBQWxCO0FBQTRCaFcsT0FBTyxDQUFDbVcsV0FBUixHQUFvQixLQUFLLENBQXpCOztBQUEyQixJQUFJckwsUUFBUSxHQUFDM0Qsc0JBQXNCLENBQUM1RyxtQkFBTyxDQUFDLDhGQUFELENBQVIsQ0FBbkM7O0FBQWtGLElBQUlLLFlBQVksR0FBQ0wsbUJBQU8sQ0FBQyxxR0FBRCxDQUF4QjtBQUF3RDs7O0FBQXFCLElBQUk4QixTQUFKO0FBQWMsSUFBSThULFdBQUo7QUFBZ0JuVyxPQUFPLENBQUNtVyxXQUFSLEdBQW9CQSxXQUFwQjs7QUFBZ0MsU0FBU0UsU0FBVCxHQUFvQjtBQUFDLE1BQUdoVSxTQUFILEVBQWFBLFNBQVMsQ0FBQzhDLEtBQVY7QUFBa0I5QyxXQUFTLEdBQUMsSUFBVjtBQUFnQjs7QUFBQSxTQUFTMlQsU0FBVCxDQUFtQkosV0FBbkIsRUFBK0JVLFVBQS9CLEVBQTBDeEMsS0FBMUMsRUFBZ0Q7QUFBQyxNQUFJb0MsUUFBUSxHQUFDSSxVQUFVLEVBQXZCLENBQUQsQ0FBMkI7O0FBQ3ZqQixNQUFHSixRQUFRLEtBQUdDLFdBQVgsSUFBd0IsQ0FBQ3JDLEtBQTVCLEVBQWtDO0FBQU85VCxTQUFPLENBQUNtVyxXQUFSLEdBQW9CQSxXQUFXLEdBQUNELFFBQWhDLENBRG1mLENBQzFjOztBQUNsRkcsV0FBUztBQUFHLE1BQUkvSSxHQUFHLEdBQUNzSSxXQUFXLEdBQUMsMEJBQVosR0FBdUNPLFdBQS9DO0FBQTJEOVQsV0FBUyxHQUFDLENBQUMsR0FBRXpCLFlBQVksQ0FBQzBCLHFCQUFoQixFQUF1QztBQUFDQyxRQUFJLEVBQUMrSyxHQUFOO0FBQVV0SixXQUFPLEVBQUMsSUFBbEI7QUFBdUJzQixZQUFRLEVBQUM7QUFBaEMsR0FBdkMsQ0FBVjtBQUFxRmpELFdBQVMsQ0FBQ0csa0JBQVYsQ0FBNkIsVUFBQUMsS0FBSyxFQUFFO0FBQUMsUUFBR0EsS0FBSyxDQUFDQyxJQUFOLENBQVdxQyxPQUFYLENBQW1CLEdBQW5CLE1BQTBCLENBQUMsQ0FBOUIsRUFBZ0M7O0FBQU8sUUFBRztBQUFDLFVBQUl3UixPQUFPLEdBQUN6VCxJQUFJLENBQUNDLEtBQUwsQ0FBV04sS0FBSyxDQUFDQyxJQUFqQixDQUFaOztBQUFtQyxVQUFHNlQsT0FBTyxDQUFDQyxPQUFYLEVBQW1CO0FBQUM7QUFDblM7QUFDQSxTQUFDLEdBQUUxTCxRQUFRLFdBQVgsRUFBcUJKLFFBQVEsQ0FBQytMLElBQTlCLEVBQW1DO0FBQUNyRyxxQkFBVyxFQUFDO0FBQWIsU0FBbkMsRUFBZ0V2RixJQUFoRSxDQUFxRSxVQUFBNkwsT0FBTyxFQUFFO0FBQUMsY0FBR0EsT0FBTyxDQUFDeE0sTUFBUixLQUFpQixHQUFwQixFQUF3QjtBQUFDUSxvQkFBUSxDQUFDQyxNQUFUO0FBQW1CO0FBQUMsU0FBNUg7QUFBK0g7QUFBQyxLQUZ3RyxDQUV4RyxPQUFNSCxHQUFOLEVBQVU7QUFBQzVGLGFBQU8sQ0FBQ3NFLEtBQVIsQ0FBYyw0Q0FBZCxFQUEyRHNCLEdBQTNEO0FBQWlFO0FBQUMsR0FGakQ7QUFFb0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0poTiw4Q0FBYTs7QUFBQSxJQUFJckQsc0JBQXNCLEdBQUM1RyxtQkFBTyxDQUFDLG9IQUFELENBQWxDOztBQUFtRlAsT0FBTyxDQUFDVSxVQUFSLEdBQW1CLElBQW5CO0FBQXdCVixPQUFPLFdBQVAsR0FBZ0JXLHNCQUFoQjs7QUFBdUMsSUFBSThVLE9BQU8sR0FBQ3RPLHNCQUFzQixDQUFDNUcsbUJBQU8sQ0FBQyw0REFBRCxDQUFSLENBQWxDOztBQUF5RCxTQUFTSSxzQkFBVCxHQUFpQztBQUFDLE1BQUlFLFVBQVUsR0FBQ0MsUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBQWY7QUFBNkNGLFlBQVUsQ0FBQ0csRUFBWCxHQUFjLDRCQUFkLENBQTlDLENBQXlGOztBQUNsVkgsWUFBVSxDQUFDSSxLQUFYLENBQWlCQyxRQUFqQixHQUEwQixPQUExQjtBQUFrQ0wsWUFBVSxDQUFDSSxLQUFYLENBQWlCRSxNQUFqQixHQUF3QixNQUF4QjtBQUErQk4sWUFBVSxDQUFDSSxLQUFYLENBQWlCRyxLQUFqQixHQUF1QixNQUF2QjtBQUE4QlAsWUFBVSxDQUFDSSxLQUFYLENBQWlCSSxLQUFqQixHQUF1QixDQUF2QjtBQUF5QlIsWUFBVSxDQUFDSSxLQUFYLENBQWlCSyxNQUFqQixHQUF3QixDQUF4QjtBQUEwQlQsWUFBVSxDQUFDSSxLQUFYLENBQWlCTSxNQUFqQixHQUF3QixLQUF4QjtBQUE4QlYsWUFBVSxDQUFDSSxLQUFYLENBQWlCMFYsVUFBakIsR0FBNEIsZ0JBQTVCO0FBQTZDN1YsVUFBUSxDQUFDVSxJQUFULENBQWNDLFdBQWQsQ0FBMEJaLFVBQTFCO0FBQXNDLE1BQUlhLFVBQUo7QUFBZSxNQUFJQyxNQUFNLEdBQUMsRUFBWDs7QUFBYyxNQUFHZCxVQUFVLENBQUNlLFlBQWQsRUFBMkI7QUFBQ0YsY0FBVSxHQUFDYixVQUFVLENBQUNlLFlBQVgsQ0FBd0I7QUFBQ0MsVUFBSSxFQUFDO0FBQU4sS0FBeEIsQ0FBWDtBQUFtRCxHQUEvRSxNQUFtRjtBQUFDO0FBQ3BYO0FBQ0E7QUFDQUgsY0FBVSxHQUFDYixVQUFYO0FBQXNCYyxVQUFNLEdBQUMsNkJBQVA7QUFBc0MsR0FKNkwsQ0FJN0w7OztBQUM1RCxNQUFJRyxTQUFTLEdBQUNDLGVBQWUsQ0FBQ0osTUFBRCxDQUE3QjtBQUFzQ0QsWUFBVSxDQUFDRCxXQUFYLENBQXVCSyxTQUF2QixFQUxtTixDQUtqTDs7QUFDeEUsTUFBSUUsR0FBRyxHQUFDQyxTQUFTLENBQUNOLE1BQUQsQ0FBakI7QUFBMEJELFlBQVUsQ0FBQ0QsV0FBWCxDQUF1Qk8sR0FBdkI7QUFBNEIsTUFBSTRVLFFBQVEsR0FBQzlVLFNBQVMsQ0FBQytVLGFBQVYsQ0FBd0IsR0FBeEIsQ0FBYjtBQUEwQyxNQUFJQyxPQUFPLEdBQUNoVixTQUFTLENBQUMrVSxhQUFWLENBQXdCLE1BQUlsVixNQUFKLEdBQVcsT0FBbkMsQ0FBWixDQU55SixDQU1qRzs7QUFDeEosTUFBSW9WLFVBQVUsR0FBQyxvQ0FBZjtBQUFvRCxNQUFJQyxZQUFZLEdBQUNoRSxRQUFRLENBQUMzTyxNQUFNLENBQUM0UyxZQUFQLENBQW9CQyxPQUFwQixDQUE0QkgsVUFBNUIsQ0FBRCxFQUF5QyxFQUF6QyxDQUF6QjtBQUFzRSxNQUFJSSxTQUFTLEdBQUNILFlBQVksR0FBQyxJQUFJbFQsSUFBSixHQUFXc1QsT0FBWCxFQUEzQjtBQUFnRCxNQUFJbFYsU0FBUyxHQUFDLENBQUNpVixTQUFELElBQVk5UyxNQUFNLENBQUNnVCxhQUFQLENBQXFCQyxVQUEvQzs7QUFBMEQsV0FBU3BVLGVBQVQsR0FBMEI7QUFBQyxRQUFHaEIsU0FBSCxFQUFhO0FBQUNKLGVBQVMsQ0FBQ3NCLFNBQVYsQ0FBb0JDLEdBQXBCLENBQXdCMUIsTUFBTSxHQUFDLFNBQS9CO0FBQTJDLEtBQXpELE1BQTZEO0FBQUNHLGVBQVMsQ0FBQ3NCLFNBQVYsQ0FBb0JFLE1BQXBCLENBQTJCM0IsTUFBTSxHQUFDLFNBQWxDO0FBQThDO0FBQUM7O0FBQUEsTUFBSTRWLGFBQWEsR0FBQzVWLE1BQU0sR0FBQyxVQUF6QjtBQUFvQyxNQUFJNlYsYUFBSjs7QUFBa0IsTUFBSUMsWUFBWSxHQUFDLFNBQVNBLFlBQVQsQ0FBc0JDLE1BQXRCLEVBQTZCO0FBQUMsUUFBR0EsTUFBTSxLQUFHLEtBQUssQ0FBakIsRUFBbUI7QUFBQ0EsWUFBTSxHQUFDLElBQVA7QUFBYTs7QUFBQXpVLGdCQUFZLENBQUN1VSxhQUFELENBQVo7QUFBNEJBLGlCQUFhLEdBQUNyVSxVQUFVLENBQUMsWUFBSTtBQUFDLFVBQUd1VSxNQUFILEVBQVU7QUFBQ2QsZ0JBQVEsQ0FBQ3hULFNBQVQsQ0FBbUJDLEdBQW5CLENBQXVCa1UsYUFBdkI7QUFBc0NULGVBQU8sQ0FBQzdWLEtBQVIsQ0FBYzBXLE9BQWQsR0FBc0IsTUFBdEI7QUFBOEIsT0FBL0UsTUFBbUY7QUFBQ2YsZ0JBQVEsQ0FBQ3hULFNBQVQsQ0FBbUJFLE1BQW5CLENBQTBCaVUsYUFBMUI7QUFBeUNULGVBQU8sQ0FBQzdWLEtBQVIsQ0FBYzBXLE9BQWQsR0FBc0IsTUFBdEI7QUFBOEI7QUFBQyxLQUFsSyxFQUFtSyxFQUFuSyxDQUF4QjtBQUFnTSxHQUE1Uzs7QUFBNlNiLFNBQU8sQ0FBQ3JGLGdCQUFSLENBQXlCLE9BQXpCLEVBQWlDLFlBQUk7QUFBQyxRQUFJbUcsV0FBVyxHQUFDLElBQUk5VCxJQUFKLEdBQVdzVCxPQUFYLEtBQXFCLElBQUUsRUFBRixHQUFLLEVBQUwsR0FBUSxJQUE3QztBQUFrRC9TLFVBQU0sQ0FBQzRTLFlBQVAsQ0FBb0JZLE9BQXBCLENBQTRCZCxVQUE1QixFQUF1Q2EsV0FBVyxHQUFDLEVBQW5EO0FBQXVEMVYsYUFBUyxHQUFDLEtBQVY7QUFBZ0JnQixtQkFBZTtBQUFJLEdBQWxMO0FBQW9MNFQsU0FBTyxDQUFDckYsZ0JBQVIsQ0FBeUIsWUFBekIsRUFBc0M7QUFBQSxXQUFJZ0csWUFBWSxFQUFoQjtBQUFBLEdBQXRDO0FBQTBEWCxTQUFPLENBQUNyRixnQkFBUixDQUF5QixZQUF6QixFQUFzQztBQUFBLFdBQUlnRyxZQUFZLENBQUMsS0FBRCxDQUFoQjtBQUFBLEdBQXRDO0FBQStEYixVQUFRLENBQUNuRixnQkFBVCxDQUEwQixZQUExQixFQUF1QztBQUFBLFdBQUlnRyxZQUFZLEVBQWhCO0FBQUEsR0FBdkM7QUFBMkRiLFVBQVEsQ0FBQ25GLGdCQUFULENBQTBCLFlBQTFCLEVBQXVDO0FBQUEsV0FBSWdHLFlBQVksQ0FBQyxLQUFELENBQWhCO0FBQUEsR0FBdkM7O0FBQWdFaEMsU0FBTyxXQUFQLENBQWdCSyxNQUFoQixDQUF1QkMsRUFBdkIsQ0FBMEIscUJBQTFCLEVBQWdELFlBQUk7QUFBQzdULGFBQVMsR0FBQ21DLE1BQU0sQ0FBQ3lULElBQVAsQ0FBWUMsYUFBdEI7QUFBb0M3VSxtQkFBZTtBQUFJLEdBQTVHOztBQUE4R0EsaUJBQWU7QUFBSTs7QUFBQSxTQUFTbkIsZUFBVCxDQUF5QkosTUFBekIsRUFBZ0M7QUFBQyxNQUFJRyxTQUFTLEdBQUNoQixRQUFRLENBQUNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBZDtBQUE0Q2UsV0FBUyxDQUFDZCxFQUFWLEdBQWFXLE1BQU0sR0FBQyxXQUFwQjtBQUFnQ0csV0FBUyxDQUFDeUIsU0FBVixHQUFvQix3QkFBc0I1QixNQUF0QixHQUE2QixnT0FBN0IsR0FBOFBBLE1BQTlQLEdBQXFRLHVhQUF6UjtBQUFpc0IsU0FBT0csU0FBUDtBQUFrQjs7QUFBQSxTQUFTRyxTQUFULENBQW1CTixNQUFuQixFQUEwQjtBQUFDLE1BQUlLLEdBQUcsR0FBQ2xCLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixPQUF2QixDQUFSO0FBQXdDaUIsS0FBRyxDQUFDd0IsV0FBSixHQUFnQixZQUFVN0IsTUFBVixHQUFpQix1SEFBakIsR0FBeUlBLE1BQXpJLEdBQWdKLDBZQUFoSixHQUEyaEJBLE1BQTNoQixHQUFraUIsbXlCQUFsaUIsR0FBczBDQSxNQUF0MEMsR0FBNjBDLDJDQUE3MEMsR0FBeTNDQSxNQUF6M0MsR0FBZzRDLDhLQUFoNEMsR0FBK2lEQSxNQUEvaUQsR0FBc2pELHFGQUF0akQsR0FBNG9EQSxNQUE1b0QsR0FBbXBELGNBQW5wRCxHQUFrcURBLE1BQWxxRCxHQUF5cUQsaURBQXpxRCxHQUEydERBLE1BQTN0RCxHQUFrdUQsWUFBbHVELEdBQSt1REEsTUFBL3VELEdBQXN2RCxtR0FBdHZELEdBQTAxREEsTUFBMTFELEdBQWkyRCx5SkFBajNEO0FBQTJnRSxTQUFPSyxHQUFQO0FBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1BscEksOENBQWE7Ozs7QUFBQSxJQUFJbUYsc0JBQXNCLEdBQUM1RyxtQkFBTyxDQUFDLG9IQUFELENBQWxDOztBQUFtRlAsT0FBTyxDQUFDVSxVQUFSLEdBQW1CLElBQW5CO0FBQXdCVixPQUFPLFdBQVAsR0FBZ0IsS0FBSyxDQUFyQjs7QUFBdUIsSUFBSWdZLGFBQWEsR0FBQzdRLHNCQUFzQixDQUFDNUcsbUJBQU8sQ0FBQywyR0FBRCxDQUFSLENBQXhDOztBQUFvRixJQUFJMFUsUUFBUSxHQUFDLFNBQVRBLFFBQVMsQ0FBQ1UsSUFBRCxFQUFRO0FBQUEsTUFBS0MsV0FBTCxHQUFrQkQsSUFBbEIsQ0FBS0MsV0FBTDtBQUF1QixNQUFJalMsT0FBTyxHQUFDO0FBQUNwQixRQUFJLEVBQUNxVCxXQUFXLEdBQUM7QUFBbEIsR0FBWjtBQUFvRCxNQUFJcUMsU0FBUyxHQUFDLENBQUMsR0FBRUQsYUFBYSxXQUFoQixFQUEwQnJVLE9BQTFCLENBQWQ7QUFBaURzVSxXQUFTLENBQUNsUSxtQkFBVixDQUE4QixVQUFBbEYsR0FBRyxFQUFFO0FBQUMsUUFBR0EsR0FBRyxDQUFDRyxNQUFKLEtBQWEsWUFBaEIsRUFBNkI7QUFBQyxhQUFPcUIsTUFBTSxDQUFDcUcsUUFBUCxDQUFnQkMsTUFBaEIsRUFBUDtBQUFpQzs7QUFBQSxRQUFHOUgsR0FBRyxDQUFDRyxNQUFKLEtBQWEsYUFBaEIsRUFBOEI7QUFBQSxxQ0FBV0gsR0FBRyxDQUFDSCxJQUFmO0FBQUEsVUFBS3dWLElBQUw7O0FBQW9CLFVBQUdBLElBQUksS0FBRzdULE1BQU0sQ0FBQ3lULElBQVAsQ0FBWUssTUFBWixDQUFtQmpDLFFBQTdCLEVBQXNDO0FBQUMsZUFBTzdSLE1BQU0sQ0FBQ3FHLFFBQVAsQ0FBZ0JDLE1BQWhCLEVBQVA7QUFBaUM7O0FBQUE7QUFBUTs7QUFBQSxRQUFHOUgsR0FBRyxDQUFDRyxNQUFKLEtBQWEsV0FBaEIsRUFBNEI7QUFBQSxzQ0FBWUgsR0FBRyxDQUFDSCxJQUFoQjtBQUFBLFVBQUswVixLQUFMOztBQUFxQixVQUFHQSxLQUFLLEtBQUcvVCxNQUFNLENBQUN5VCxJQUFQLENBQVlLLE1BQVosQ0FBbUJqQyxRQUEzQixJQUFxQyxPQUFPN1IsTUFBTSxDQUFDeVQsSUFBUCxDQUFZSyxNQUFaLENBQW1CRSxVQUFuQixDQUE4QkQsS0FBOUIsQ0FBUCxLQUE4QyxXQUF0RixFQUFrRztBQUFDLGVBQU8vVCxNQUFNLENBQUNxRyxRQUFQLENBQWdCQyxNQUFoQixFQUFQO0FBQWlDOztBQUFBO0FBQVE7O0FBQUEsVUFBTSxJQUFJbUIsS0FBSixDQUFVLHVCQUFxQmpKLEdBQUcsQ0FBQ0csTUFBbkMsQ0FBTjtBQUFrRCxHQUFwZDtBQUFzZCxTQUFPaVYsU0FBUDtBQUFrQixDQUF6bkI7O0FBQTBuQmpZLE9BQU8sV0FBUCxHQUFnQmlWLFFBQWhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBNzFCLDhDQUFhOztBQUFBalYsT0FBTyxDQUFDVSxVQUFSLEdBQW1CLElBQW5CO0FBQXdCVixPQUFPLFdBQVAsR0FBZ0JzWSxlQUFoQjtBQUFnQyxJQUFJQyxpQkFBaUIsR0FBQztBQUFDQyxlQUFhLEVBQUMsZ0JBQWY7QUFBZ0NDLFdBQVMsRUFBQyxPQUExQztBQUFrREMsU0FBTyxFQUFDLEtBQTFEO0FBQWdFQyxXQUFTLEVBQUM7QUFBMUUsQ0FBdEI7O0FBQThHLFNBQVNDLGlCQUFULENBQTJCakQsSUFBM0IsRUFBZ0M7QUFBQSxNQUFLckUsSUFBTCxHQUFpQnFFLElBQWpCLENBQUtyRSxJQUFMO0FBQUEsTUFBVXVILEtBQVYsR0FBaUJsRCxJQUFqQixDQUFVa0QsS0FBVjtBQUFzQixNQUFJQyxFQUFFLEdBQUNoWSxRQUFRLENBQUNDLGFBQVQsQ0FBdUJ1USxJQUF2QixDQUFQOztBQUFvQyxPQUFJLElBQUl5SCxDQUFSLElBQWFGLEtBQWIsRUFBbUI7QUFBQyxRQUFHLENBQUNBLEtBQUssQ0FBQ2hKLGNBQU4sQ0FBcUJrSixDQUFyQixDQUFKLEVBQTRCO0FBQVMsUUFBR0EsQ0FBQyxLQUFHLFVBQUosSUFBZ0JBLENBQUMsS0FBRyx5QkFBdkIsRUFBaUQsU0FBdkYsQ0FBZ0c7O0FBQ2hZLFFBQUdGLEtBQUssQ0FBQ0UsQ0FBRCxDQUFMLEtBQVcxWSxTQUFkLEVBQXdCO0FBQVMsUUFBSTJZLElBQUksR0FBQ1QsaUJBQWlCLENBQUNRLENBQUQsQ0FBakIsSUFBc0JBLENBQUMsQ0FBQ3JLLFdBQUYsRUFBL0I7QUFBK0NvSyxNQUFFLENBQUNHLFlBQUgsQ0FBZ0JELElBQWhCLEVBQXFCSCxLQUFLLENBQUNFLENBQUQsQ0FBMUI7QUFBZ0M7O0FBRG1HLE1BQy9GRyxRQUQrRixHQUM3REwsS0FENkQsQ0FDL0ZLLFFBRCtGO0FBQUEsTUFDdEZDLHVCQURzRixHQUM3RE4sS0FENkQsQ0FDdEZNLHVCQURzRjs7QUFDdkQsTUFBR0EsdUJBQUgsRUFBMkI7QUFBQ0wsTUFBRSxDQUFDdlYsU0FBSCxHQUFhNFYsdUJBQXVCLENBQUNDLE1BQXhCLElBQWdDLEVBQTdDO0FBQWlELEdBQTdFLE1BQWtGLElBQUdGLFFBQUgsRUFBWTtBQUFDSixNQUFFLENBQUN0VixXQUFILEdBQWUsT0FBTzBWLFFBQVAsS0FBa0IsUUFBbEIsR0FBMkJBLFFBQTNCLEdBQW9DQSxRQUFRLENBQUMvWSxJQUFULENBQWMsRUFBZCxDQUFuRDtBQUFzRTs7QUFBQSxTQUFPMlksRUFBUDtBQUFXOztBQUFBLFNBQVNPLGNBQVQsQ0FBd0IvSCxJQUF4QixFQUE2QitHLFVBQTdCLEVBQXdDO0FBQUMsTUFBSWlCLE1BQU0sR0FBQ3hZLFFBQVEsQ0FBQ3lZLG9CQUFULENBQThCLE1BQTlCLEVBQXNDLENBQXRDLENBQVg7QUFBb0QsTUFBSUMsV0FBVyxHQUFDRixNQUFNLENBQUN6QyxhQUFQLENBQXFCLDRCQUFyQixDQUFoQjs7QUFBbUUsWUFBdUM7QUFBQyxRQUFHLENBQUMyQyxXQUFKLEVBQWdCO0FBQUM1VSxhQUFPLENBQUNzRSxLQUFSLENBQWMscUZBQWQ7QUFBcUc7QUFBUTtBQUFDOztBQUFBLE1BQUl1USxTQUFTLEdBQUNDLE1BQU0sQ0FBQ0YsV0FBVyxDQUFDRyxPQUFiLENBQXBCO0FBQTBDLE1BQUlDLE9BQU8sR0FBQyxFQUFaOztBQUFlLE9BQUksSUFBSS9VLENBQUMsR0FBQyxDQUFOLEVBQVFnVixDQUFDLEdBQUNMLFdBQVcsQ0FBQ00sc0JBQTFCLEVBQWlEalYsQ0FBQyxHQUFDNFUsU0FBbkQsRUFBNkQ1VSxDQUFDLElBQUdnVixDQUFDLEdBQUNBLENBQUMsQ0FBQ0Msc0JBQXJFLEVBQTRGO0FBQUMsUUFBR0QsQ0FBQyxDQUFDRSxPQUFGLENBQVVyTCxXQUFWLE9BQTBCNEMsSUFBN0IsRUFBa0M7QUFBQ3NJLGFBQU8sQ0FBQ3ZVLElBQVIsQ0FBYXdVLENBQWI7QUFBaUI7QUFBQzs7QUFBQSxNQUFJRyxPQUFPLEdBQUMzQixVQUFVLENBQUNyUyxHQUFYLENBQWU0UyxpQkFBZixFQUFrQy9TLE1BQWxDLENBQXlDLFVBQUFvVSxNQUFNLEVBQUU7QUFBQyxTQUFJLElBQUkzTixDQUFDLEdBQUMsQ0FBTixFQUFRNE4sR0FBRyxHQUFDTixPQUFPLENBQUM5VSxNQUF4QixFQUErQndILENBQUMsR0FBQzROLEdBQWpDLEVBQXFDNU4sQ0FBQyxFQUF0QyxFQUF5QztBQUFDLFVBQUk2TixNQUFNLEdBQUNQLE9BQU8sQ0FBQ3ROLENBQUQsQ0FBbEI7O0FBQXNCLFVBQUc2TixNQUFNLENBQUNDLFdBQVAsQ0FBbUJILE1BQW5CLENBQUgsRUFBOEI7QUFBQ0wsZUFBTyxDQUFDclQsTUFBUixDQUFlK0YsQ0FBZixFQUFpQixDQUFqQjtBQUFvQixlQUFPLEtBQVA7QUFBYztBQUFDOztBQUFBLFdBQU8sSUFBUDtBQUFhLEdBQWpNLENBQVo7QUFBK01zTixTQUFPLENBQUM1VSxPQUFSLENBQWdCLFVBQUFxVixDQUFDO0FBQUEsV0FBRUEsQ0FBQyxDQUFDOUUsVUFBRixDQUFhQyxXQUFiLENBQXlCNkUsQ0FBekIsQ0FBRjtBQUFBLEdBQWpCO0FBQWdETCxTQUFPLENBQUNoVixPQUFSLENBQWdCLFVBQUFxVixDQUFDO0FBQUEsV0FBRWYsTUFBTSxDQUFDZ0IsWUFBUCxDQUFvQkQsQ0FBcEIsRUFBc0JiLFdBQXRCLENBQUY7QUFBQSxHQUFqQjtBQUF1REEsYUFBVyxDQUFDRyxPQUFaLEdBQW9CLENBQUNGLFNBQVMsR0FBQ0csT0FBTyxDQUFDOVUsTUFBbEIsR0FBeUJrVixPQUFPLENBQUNsVixNQUFsQyxFQUEwQ3lWLFFBQTFDLEVBQXBCO0FBQTBFOztBQUFBLFNBQVNqQyxlQUFULEdBQTBCO0FBQUMsTUFBSWtDLGFBQWEsR0FBQyxJQUFsQjtBQUF1QixTQUFPLFVBQUFDLElBQUksRUFBRTtBQUFDLFFBQUlDLE9BQU8sR0FBQ0YsYUFBYSxHQUFDOUosT0FBTyxDQUFDQyxPQUFSLEdBQWtCOUYsSUFBbEIsQ0FBdUIsWUFBSTtBQUFDLFVBQUc2UCxPQUFPLEtBQUdGLGFBQWIsRUFBMkI7QUFBT0EsbUJBQWEsR0FBQyxJQUFkO0FBQW1CLFVBQUlHLElBQUksR0FBQyxFQUFUO0FBQVlGLFVBQUksQ0FBQ3pWLE9BQUwsQ0FBYSxVQUFBNFYsQ0FBQyxFQUFFO0FBQUMsWUFBSXZDLFVBQVUsR0FBQ3NDLElBQUksQ0FBQ0MsQ0FBQyxDQUFDdEosSUFBSCxDQUFKLElBQWMsRUFBN0I7QUFBZ0MrRyxrQkFBVSxDQUFDaFQsSUFBWCxDQUFnQnVWLENBQWhCO0FBQW1CRCxZQUFJLENBQUNDLENBQUMsQ0FBQ3RKLElBQUgsQ0FBSixHQUFhK0csVUFBYjtBQUF5QixPQUE3RjtBQUErRixVQUFJd0MsY0FBYyxHQUFDRixJQUFJLENBQUNHLEtBQUwsR0FBV0gsSUFBSSxDQUFDRyxLQUFMLENBQVcsQ0FBWCxDQUFYLEdBQXlCLElBQTVDO0FBQWlELFVBQUlBLEtBQUssR0FBQyxFQUFWOztBQUFhLFVBQUdELGNBQUgsRUFBa0I7QUFBQSxZQUFLM0IsUUFBTCxHQUFlMkIsY0FBYyxDQUFDaEMsS0FBOUIsQ0FBS0ssUUFBTDtBQUFvQzRCLGFBQUssR0FBQyxPQUFPNUIsUUFBUCxLQUFrQixRQUFsQixHQUEyQkEsUUFBM0IsR0FBb0NBLFFBQVEsQ0FBQy9ZLElBQVQsQ0FBYyxFQUFkLENBQTFDO0FBQTZEOztBQUFBLFVBQUcyYSxLQUFLLEtBQUdoYSxRQUFRLENBQUNnYSxLQUFwQixFQUEwQmhhLFFBQVEsQ0FBQ2dhLEtBQVQsR0FBZUEsS0FBZjtBQUFxQixPQUFDLE1BQUQsRUFBUSxNQUFSLEVBQWUsTUFBZixFQUFzQixPQUF0QixFQUE4QixRQUE5QixFQUF3QzlWLE9BQXhDLENBQWdELFVBQUFzTSxJQUFJLEVBQUU7QUFBQytILHNCQUFjLENBQUMvSCxJQUFELEVBQU1xSixJQUFJLENBQUNySixJQUFELENBQUosSUFBWSxFQUFsQixDQUFkO0FBQXFDLE9BQTVGO0FBQStGLEtBQTNmLENBQTFCO0FBQXdoQixHQUF0aUI7QUFBd2lCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNEeHpELDhDQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSXlKLHdCQUF3QixHQUFDeGEsbUJBQU8sQ0FBQyxzSEFBRCxDQUFwQzs7QUFBc0YsSUFBSTRHLHNCQUFzQixHQUFDNUcsbUJBQU8sQ0FBQyxvSEFBRCxDQUFsQzs7QUFBbUZQLE9BQU8sQ0FBQ1UsVUFBUixHQUFtQixJQUFuQjtBQUF3QlYsT0FBTyxDQUFDZ2IsTUFBUixHQUFlQSxNQUFmO0FBQXNCaGIsT0FBTyxDQUFDaWIsV0FBUixHQUFvQkEsV0FBcEI7QUFBZ0NqYixPQUFPLFdBQVAsR0FBZ0JBLE9BQU8sQ0FBQ2tiLE9BQVIsR0FBZ0JsYixPQUFPLENBQUNtWSxNQUFSLEdBQWVuWSxPQUFPLENBQUNtYixPQUFSLEdBQWdCLEtBQUssQ0FBcEU7O0FBQXNFLElBQUlDLFNBQVMsR0FBQ2pVLHNCQUFzQixDQUFDNUcsbUJBQU8sQ0FBQyx3RkFBRCxDQUFSLENBQXBDOztBQUFnRixJQUFJOGEsd0JBQXdCLEdBQUNsVSxzQkFBc0IsQ0FBQzVHLG1CQUFPLENBQUMsc0hBQUQsQ0FBUixDQUFuRDs7QUFBOEcsSUFBSWtWLE9BQU8sR0FBQ2xWLG1CQUFPLENBQUMsOERBQUQsQ0FBbkI7O0FBQW1DLElBQUkrYSxZQUFZLEdBQUMvYSxtQkFBTyxDQUFDLDREQUFELENBQXhCOztBQUF3QyxJQUFJZ2IsTUFBTSxHQUFDcFUsc0JBQXNCLENBQUM1RyxtQkFBTyxDQUFDLDRDQUFELENBQVIsQ0FBakM7O0FBQW9ELElBQUlpYixTQUFTLEdBQUNyVSxzQkFBc0IsQ0FBQzVHLG1CQUFPLENBQUMsb0RBQUQsQ0FBUixDQUFwQzs7QUFBMkQsSUFBSWtiLG1CQUFtQixHQUFDbGIsbUJBQU8sQ0FBQyxpSEFBRCxDQUEvQjs7QUFBMkUsSUFBSW1iLEtBQUssR0FBQ3ZVLHNCQUFzQixDQUFDNUcsbUJBQU8sQ0FBQyxpRkFBRCxDQUFSLENBQWhDOztBQUFxRSxJQUFJb2IsY0FBYyxHQUFDcGIsbUJBQU8sQ0FBQyxxR0FBRCxDQUExQjs7QUFBZ0UsSUFBSXFiLFVBQVUsR0FBQ3JiLG1CQUFPLENBQUMsdUhBQUQsQ0FBdEI7O0FBQXFFLElBQUlzYixTQUFTLEdBQUNkLHdCQUF3QixDQUFDeGEsbUJBQU8sQ0FBQyxxR0FBRCxDQUFSLENBQXRDOztBQUFxRixJQUFJdWIsTUFBTSxHQUFDdmIsbUJBQU8sQ0FBQyxtRkFBRCxDQUFsQjs7QUFBK0MsSUFBSXdiLFlBQVksR0FBQzVVLHNCQUFzQixDQUFDNUcsbUJBQU8sQ0FBQyx1RUFBRCxDQUFSLENBQXZDOztBQUFtRSxJQUFJeWIsV0FBVyxHQUFDN1Usc0JBQXNCLENBQUM1RyxtQkFBTyxDQUFDLHFFQUFELENBQVIsQ0FBdEM7O0FBQWlFLElBQUkwYixtQkFBbUIsR0FBQzlVLHNCQUFzQixDQUFDNUcsbUJBQU8sQ0FBQyxxRkFBRCxDQUFSLENBQTlDO0FBQWlGO0FBQXNCOzs7QUFDdDBDLElBQUcsRUFBRSxhQUFZbVEsT0FBTyxDQUFDbEYsU0FBdEIsQ0FBSCxFQUFvQztBQUFDO0FBQ3JDa0YsU0FBTyxDQUFDbEYsU0FBUixjQUEwQmpMLG1CQUFPLENBQUMsd0hBQUQsQ0FBakM7QUFBcUY7O0FBQUEsSUFBSW1DLElBQUksR0FBQ0ksSUFBSSxDQUFDQyxLQUFMLENBQVdqQyxRQUFRLENBQUNvYixjQUFULENBQXdCLGVBQXhCLEVBQXlDMVksV0FBcEQsQ0FBVDtBQUEwRWEsTUFBTSxDQUFDZ1QsYUFBUCxHQUFxQjNVLElBQXJCO0FBQTBCLElBQUl5WSxPQUFPLEdBQUMsT0FBWjtBQUFvQm5iLE9BQU8sQ0FBQ21iLE9BQVIsR0FBZ0JBLE9BQWhCO0lBQTRCdEMsSyxHQUE4RW5XLEksQ0FBOUVtVyxLO0lBQU1yTyxHLEdBQXdFOUgsSSxDQUF4RThILEc7SUFBSTBOLEksR0FBb0V4VixJLENBQXBFd1YsSTtJQUFLaUUsSyxHQUErRHpaLEksQ0FBL0R5WixLO0lBQU1DLE8sR0FBeUQxWixJLENBQXpEMFosTztJQUFReEcsVyxHQUFpRGxULEksQ0FBakRrVCxXO0lBQVl5RyxhLEdBQXFDM1osSSxDQUFyQzJaLGE7SUFBY0MsVSxHQUF1QjVaLEksQ0FBdkI0WixVO0lBQVdDLFUsR0FBWTdaLEksQ0FBWjZaLFU7QUFBaUIsSUFBSTVhLE1BQU0sR0FBQ2lVLFdBQVcsSUFBRSxFQUF4QixDLENBQTJCO0FBQ3ZWOztBQUNBNEcscUJBQXVCLEdBQUM3YSxNQUFNLEdBQUMsU0FBL0IsQyxDQUF5QztBQUN6Qzs7QUFDQWthLFNBQVMsQ0FBQ1ksU0FBVixDQUFvQjtBQUFDQyxxQkFBbUIsRUFBQyxFQUFyQjtBQUF3QkMscUJBQW1CLEVBQUNOLGFBQWEsSUFBRTtBQUEzRCxDQUFwQjtBQUFvRixJQUFJTyxNQUFNLEdBQUMsQ0FBQyxHQUFFZCxNQUFNLENBQUNlLE1BQVYsR0FBWDtBQUErQixJQUFJQyxVQUFVLEdBQUMsSUFBSWQsV0FBVyxXQUFmLENBQXdCSSxPQUF4QixFQUFnQ3phLE1BQWhDLENBQWY7O0FBQXVELElBQUlnRyxRQUFRLEdBQUMsU0FBVEEsUUFBUyxDQUFDZ08sSUFBRCxFQUFRO0FBQUEsNkJBQVVBLElBQVY7QUFBQSxNQUFLb0gsQ0FBTDtBQUFBLE1BQU96SixDQUFQOztBQUFlLFNBQU93SixVQUFVLENBQUNFLFlBQVgsQ0FBd0JELENBQXhCLEVBQTBCekosQ0FBMUIsQ0FBUDtBQUFxQyxDQUF6RTs7QUFBMEUsSUFBR2pQLE1BQU0sQ0FBQzRZLFFBQVYsRUFBbUI7QUFBQzVZLFFBQU0sQ0FBQzRZLFFBQVAsQ0FBZ0JqWCxHQUFoQixDQUFvQjJCLFFBQXBCO0FBQStCOztBQUFBdEQsTUFBTSxDQUFDNFksUUFBUCxHQUFnQixFQUFoQjtBQUFtQjVZLE1BQU0sQ0FBQzRZLFFBQVAsQ0FBZ0I1WCxJQUFoQixHQUFxQnNDLFFBQXJCO0FBQThCLElBQUl1VixVQUFVLEdBQUMsQ0FBQyxHQUFFbkIsWUFBWSxXQUFmLEdBQWY7QUFBMEMsSUFBSW9CLFVBQVUsR0FBQ3JjLFFBQVEsQ0FBQ29iLGNBQVQsQ0FBd0IsUUFBeEIsQ0FBZjtBQUFpRCxJQUFJa0IsWUFBSjtBQUFpQixJQUFJQyxVQUFKO0FBQWUsSUFBSWxGLE1BQUo7QUFBV25ZLE9BQU8sQ0FBQ21ZLE1BQVIsR0FBZUEsTUFBZjtBQUFzQixJQUFJbUYsY0FBSjtBQUFtQixJQUFJQyxTQUFKO0FBQWMsSUFBSUMsR0FBSixFQUFRQyxXQUFSOztJQUEwQkMsUzs7Ozs7Ozs7Ozs7OztzQ0FBNkRsVCxHLEVBQUltVCxJLEVBQUs7QUFBQyxXQUFLOUUsS0FBTCxDQUFXelQsRUFBWCxDQUFjb0YsR0FBZCxFQUFrQm1ULElBQWxCO0FBQXlCOzs7d0NBQW1CO0FBQUMsV0FBS0MsWUFBTDs7QUFBb0IsVUFBR3pVLEtBQUgsRUFBOEIsRUFBbkQsQ0FDN2E7QUFDclA7QUFDQTtBQUNBOzs7QUFDQSxVQUFHZ1AsTUFBTSxDQUFDMEYsS0FBUCxLQUFldEIsVUFBVSxJQUFFN1osSUFBSSxDQUFDNFUsVUFBTCxLQUFrQixDQUFDLEdBQUVzRSxVQUFVLENBQUNrQyxjQUFkLEVBQThCM0YsTUFBTSxDQUFDakMsUUFBckMsS0FBZ0R4TCxRQUFRLENBQUNxVCxNQUEzRSxDQUFaLElBQWdHbEYsS0FBSyxJQUFFQSxLQUFLLENBQUNtRixPQUFiLElBQXNCdFQsUUFBUSxDQUFDcVQsTUFBOUksQ0FBSCxFQUF5SjtBQUFDO0FBQzFKNUYsY0FBTSxDQUFDMVgsT0FBUCxDQUFlMFgsTUFBTSxDQUFDakMsUUFBUCxHQUFnQixHQUFoQixHQUFvQixDQUFDLEdBQUVvRixZQUFZLENBQUN0SCxTQUFoQixFQUEyQixDQUFDLEdBQUVvSCxTQUFTLFdBQVosRUFBc0IsQ0FBQyxHQUFFQSxTQUFTLFdBQVosRUFBc0IsRUFBdEIsRUFBeUJqRCxNQUFNLENBQUNnRSxLQUFoQyxDQUF0QixFQUE2RCxDQUFDLEdBQUViLFlBQVksQ0FBQ3ZZLEtBQWhCLEVBQXVCMkgsUUFBUSxDQUFDcVQsTUFBVCxDQUFnQkUsTUFBaEIsQ0FBdUIsQ0FBdkIsQ0FBdkIsQ0FBN0QsQ0FBM0IsQ0FBbkMsRUFBK0tyQixNQUEvSyxFQUFzTDtBQUFDO0FBQ3ZMO0FBQ0E7QUFDQXNCLFlBQUUsRUFBQyxDQUhtTDtBQUdqTDtBQUNMO0FBQ0E7QUFDQTtBQUNBQyxpQkFBTyxFQUFDLENBQUM1QjtBQVA2SyxTQUF0TDtBQU91Qjs7QUFBQSxVQUFHcFQsU0FBSCxFQUFnQztBQUFDOUUsY0FBTSxDQUFDK1osZUFBUCxHQUF1QixJQUF2Qjs7QUFBNEIsWUFBRy9aLE1BQU0sQ0FBQ2dhLGtCQUFWLEVBQTZCO0FBQUNoYSxnQkFBTSxDQUFDZ2Esa0JBQVA7QUFBNkI7QUFBQztBQUFDOzs7eUNBQW9CO0FBQUMsV0FBS1QsWUFBTDtBQUFxQjs7O21DQUFjO0FBQUEsc0JBQVdsVCxRQUFYO0FBQUEsVUFBS2pCLElBQUwsYUFBS0EsSUFBTDtBQUFvQkEsVUFBSSxHQUFDQSxJQUFJLElBQUVBLElBQUksQ0FBQzZVLFNBQUwsQ0FBZSxDQUFmLENBQVg7QUFBNkIsVUFBRyxDQUFDN1UsSUFBSixFQUFTO0FBQU8sVUFBSXFQLEVBQUUsR0FBQ2hZLFFBQVEsQ0FBQ29iLGNBQVQsQ0FBd0J6UyxJQUF4QixDQUFQO0FBQXFDLFVBQUcsQ0FBQ3FQLEVBQUosRUFBTyxPQUE3RyxDQUFvSDtBQUM3VDs7QUFDQTNWLGdCQUFVLENBQUM7QUFBQSxlQUFJMlYsRUFBRSxDQUFDeUYsY0FBSCxFQUFKO0FBQUEsT0FBRCxFQUF5QixDQUF6QixDQUFWO0FBQXVDOzs7NkJBQVE7QUFBQyxpQkFBdUMsRUFBNkI7O0FBQUEsZ0JBQXVDO0FBQUEsdUJBQXNCaGUsbUJBQU8sQ0FBQyxnR0FBRCxDQUE3QjtBQUFBLFlBQUtpZSxlQUFMLFlBQUtBLGVBQUw7O0FBQW9FLGVBQU0sYUFBYWpELE1BQU0sV0FBTixDQUFleGEsYUFBZixDQUE2QnlkLGVBQTdCLEVBQTZDLElBQTdDLEVBQWtELEtBQUszRixLQUFMLENBQVdLLFFBQTdELENBQW5CO0FBQTJGO0FBQUM7Ozs7RUFmc1FxQyxNQUFNLFdBQU4sQ0FBZWdDLFM7O0FBZXBSLElBQUlyQyxPQUFPLEdBQUMsQ0FBQyxHQUFFUSxLQUFLLFdBQVIsR0FBWjtBQUFnQzFiLE9BQU8sQ0FBQ2tiLE9BQVIsR0FBZ0JBLE9BQWhCOztBQUF3QixJQUFJakcsUUFBUTtBQUFBLDJFQUFDLGlCQUF3QndKLEtBQXhCO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxvQkFBZ0VBLEtBQUssS0FBRyxLQUFLLENBQWIsR0FBZSxFQUFmLEdBQWtCQSxLQUFsRixFQUE4Q0MsZ0JBQTlDLFNBQW1DckIsVUFBbkMsRUFBd0Y7O0FBQ3pkLHNCQUF3QztBQUFDQSx3QkFBVSxHQUFDcUIsZ0JBQVg7QUFBNkI7O0FBRDJUO0FBQUEsbUJBQ25TNUIsVUFBVSxDQUFDNkIsY0FBWCxDQUEwQixPQUExQixDQURtUzs7QUFBQTtBQUFBO0FBQ2xUQyxlQURrVCx5QkFDdlQxRyxJQUR1VDtBQUM5UzJHLGVBRDhTLHlCQUM5U0EsR0FEOFM7QUFDaFFyQixlQUFHLEdBQUNvQixHQUFKOztBQUFRLGdCQUFHQyxHQUFHLElBQUVBLEdBQUcsQ0FBQ0MsZUFBWixFQUE0QjtBQUFDckIseUJBQVcsR0FBQyxxQkFBQ3NCLEtBQUQsRUFBUztBQUFBLG9CQUFLL2QsRUFBTCxHQUF5RCtkLEtBQXpELENBQUsvZCxFQUFMO0FBQUEsb0JBQVFvTixJQUFSLEdBQXlEMlEsS0FBekQsQ0FBUTNRLElBQVI7QUFBQSxvQkFBYTRRLFNBQWIsR0FBeURELEtBQXpELENBQWFDLFNBQWI7QUFBQSxvQkFBdUIxUSxLQUF2QixHQUF5RHlRLEtBQXpELENBQXVCelEsS0FBdkI7QUFBQSxvQkFBNkIyUSxRQUE3QixHQUF5REYsS0FBekQsQ0FBNkJFLFFBQTdCO0FBQUEsb0JBQXNDQyxTQUF0QyxHQUF5REgsS0FBekQsQ0FBc0NHLFNBQXRDO0FBQUEsb0JBQWdEQyxPQUFoRCxHQUF5REosS0FBekQsQ0FBZ0RJLE9BQWhELEVBQStEOztBQUMxUCxvQkFBSUMsUUFBUSxHQUFDdGIsSUFBSSxDQUFDdWIsR0FBTCxLQUFXLEdBQVgsSUFBZ0JuTSxJQUFJLENBQUNvTSxLQUFMLENBQVdwTSxJQUFJLENBQUNxTSxNQUFMLE1BQWUsT0FBSyxDQUFwQixDQUFYLElBQW1DLElBQW5ELENBQWI7QUFBc0Usb0JBQUlDLGNBQUo7O0FBQW1CLG9CQUFHTCxPQUFPLElBQUVBLE9BQU8sQ0FBQ3JhLE1BQXBCLEVBQTJCO0FBQUMwYSxnQ0FBYyxHQUFDTCxPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVdILFNBQTFCO0FBQXFDOztBQUFBSCxtQkFBRyxDQUFDQyxlQUFKLENBQW9CO0FBQUM5ZCxvQkFBRSxFQUFDQSxFQUFFLElBQUVvZSxRQUFSO0FBQWlCaFIsc0JBQUksRUFBSkEsSUFBakI7QUFBc0I0USwyQkFBUyxFQUFDQSxTQUFTLElBQUVRLGNBQTNDO0FBQTBEbFIsdUJBQUssRUFBQ0EsS0FBSyxJQUFFLElBQVAsR0FBWTJRLFFBQVosR0FBcUIzUSxLQUFyRjtBQUEyRm1SLHVCQUFLLEVBQUNQLFNBQVMsS0FBRyxNQUFaLElBQW9CQSxTQUFTLEtBQUcsU0FBaEMsR0FBMEMsUUFBMUMsR0FBbUQ7QUFBcEosaUJBQXBCO0FBQXVMLGVBRDNLO0FBQzZLOztBQUFJUSxzQkFGMEMsR0FFL0JsVixHQUYrQjtBQUFBO0FBRXZCO0FBRnVCO0FBQUEsbUJBRUVzUyxVQUFVLENBQUM2QyxRQUFYLENBQW9CekgsSUFBcEIsQ0FGRjs7QUFBQTtBQUFBO0FBRWZxRixxQkFGZSwwQkFFcEJyRixJQUZvQjs7QUFBQTs7QUFBQSx3QkFFNkYzWCxtQkFBTyxDQUFDLGtEQUFELENBRnBHLEVBRXlFcWYsa0JBRnpFLGFBRXlFQSxrQkFGekU7O0FBQUEsZ0JBRXFIQSxrQkFBa0IsQ0FBQ3JDLFNBQUQsQ0FGdkk7QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0JBRTBKLElBQUl6UixLQUFKLENBQVUsNERBQTBEb00sSUFBMUQsR0FBK0QsSUFBekUsQ0FGMUo7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUV5UDtBQUMxbkJ3SCxzQkFBVSxjQUFWOztBQUhpWTtBQUcvVyxzQkFBd0M7QUFBQSwwQkFBbUJuZixtQkFBTyxDQUFDLGdHQUFELENBQTFCLEVBQUtzZixZQUFMLGFBQUtBLFlBQUwsRUFBaUU7QUFDM0g7O0FBQ0Esa0JBQUdILFVBQUgsRUFBYztBQUFDLG9CQUFHQSxVQUFVLEtBQUdsVixHQUFoQixFQUFvQjtBQUFDckgsNEJBQVUsQ0FBQyxZQUFJO0FBQUMsd0JBQUkrRixLQUFKOztBQUFVLHdCQUFHO0FBQUM7QUFDbEU7QUFDQTtBQUNBLDRCQUFNLElBQUk0QyxLQUFKLENBQVU0VCxVQUFVLENBQUNqYSxPQUFyQixDQUFOO0FBQXFDLHFCQUh5QixDQUd6QixPQUFNaUUsQ0FBTixFQUFRO0FBQUNSLDJCQUFLLEdBQUNRLENBQU47QUFBUzs7QUFBQVIseUJBQUssQ0FBQ2tGLElBQU4sR0FBV3NSLFVBQVUsQ0FBQ3RSLElBQXRCO0FBQTJCbEYseUJBQUssQ0FBQzRXLEtBQU4sR0FBWUosVUFBVSxDQUFDSSxLQUF2QjtBQUE2Qix3QkFBSUMsSUFBSSxHQUFDRixZQUFZLENBQUMzVyxLQUFELENBQXJCO0FBQTZCLDBCQUFNNlcsSUFBTjtBQUFZLG1CQUgxRyxDQUFWO0FBR3VILGlCQUg1SSxDQUc0STtBQUMzSjtBQUplLHFCQUtYO0FBQUM1Yyw4QkFBVSxDQUFDLFlBQUk7QUFBQyw0QkFBTXVjLFVBQU47QUFBa0IscUJBQXhCLENBQVY7QUFBcUM7QUFBQztBQUFDOztBQVZxVixpQkFVbFZyYixNQUFNLENBQUMyYixtQkFWMlU7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxtQkFVaFQzYixNQUFNLENBQUMyYixtQkFBUCxDQUEyQjFELFVBQTNCLENBVmdUOztBQUFBO0FBVXhRdGMsbUJBQU8sQ0FBQ21ZLE1BQVIsR0FBZUEsTUFBTSxHQUFDLENBQUMsR0FBRTFDLE9BQU8sQ0FBQ3dLLFlBQVgsRUFBeUIvSCxJQUF6QixFQUE4QmlFLEtBQTlCLEVBQW9DUyxNQUFwQyxFQUEyQztBQUFDc0QsMEJBQVksRUFBQ3JILEtBQWQ7QUFBb0JpRSx3QkFBVSxFQUFWQSxVQUFwQjtBQUErQlUsaUJBQUcsRUFBSEEsR0FBL0I7QUFBbUNELHVCQUFTLEVBQVRBLFNBQW5DO0FBQTZDNEMscUJBQU8sRUFBUEEsT0FBN0M7QUFBcUQzVixpQkFBRyxFQUFDa1YsVUFBekQ7QUFBb0VuRCx3QkFBVSxFQUFWQSxVQUFwRTtBQUErRTZELDBCQUFZLEVBQUMsc0JBQUNDLEtBQUQsRUFBTzdDLEdBQVAsRUFBYTtBQUFBLG9CQUFLRCxTQUFMLEdBQTBCOEMsS0FBMUIsQ0FBSzlDLFNBQUw7QUFBQSxvQkFBZTFFLEtBQWYsR0FBMEJ3SCxLQUExQixDQUFleEgsS0FBZjtBQUFBLG9CQUFxQnJPLEdBQXJCLEdBQTBCNlYsS0FBMUIsQ0FBcUI3VixHQUFyQjtBQUFnQ3dRLHNCQUFNLENBQUM7QUFBQ3dDLHFCQUFHLEVBQUhBLEdBQUQ7QUFBS0QsMkJBQVMsRUFBVEEsU0FBTDtBQUFlMUUsdUJBQUssRUFBTEEsS0FBZjtBQUFxQnJPLHFCQUFHLEVBQUhBO0FBQXJCLGlCQUFELENBQU47QUFBbUM7QUFBNUssYUFBM0MsQ0FBdEIsQ0FWd1EsQ0FVeEI7O0FBQ3pXLGdCQUFHckIsS0FBSCxFQUE4QixFQUNtTjs7QUFBSW1YLHFCQVo0SSxHQVlsSTtBQUFDOUMsaUJBQUcsRUFBSEEsR0FBRDtBQUFLRCx1QkFBUyxFQUFUQSxTQUFMO0FBQWUxRSxtQkFBSyxFQUFMQSxLQUFmO0FBQXFCck8saUJBQUcsRUFBQ2tWO0FBQXpCLGFBWmtJOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVlyRDFFLGtCQUFNLENBQUNzRixTQUFELENBQU47QUFacUQsNkNBWTVCcEYsT0FaNEI7O0FBQUE7QUFBQTs7QUFBQSw2Q0FZMkI7QUFBQ0EscUJBQU8sRUFBUEEsT0FBRDtBQUFTRixvQkFBTSxFQUFOQSxNQUFUO0FBQWdCc0YsdUJBQVMsRUFBVEE7QUFBaEIsYUFaM0I7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FBRDs7QUFBQSxXQUFnQnJMLFFBQWhCO0FBQUE7QUFBQTs7QUFBQSxTQUFnQkEsUUFBaEI7QUFBQSxHQUFaOztBQVlzRWpWLE9BQU8sV0FBUCxHQUFnQmlWLFFBQWhCOztTQUF3QytGLE07O0VBQy9XO0FBQ25IO0FBQ0E7Ozs7cUVBSG1kLGtCQUFzQm5DLEtBQXRCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFBZ0NBLEtBQUssQ0FBQ3JPLEdBQXRDO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsbUJBQWlEeVEsV0FBVyxDQUFDcEMsS0FBRCxDQUE1RDs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUFzRjBILFFBQVEsQ0FBQzFILEtBQUQsQ0FBOUY7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBa0gsc0JBQXdDO0FBQUM7QUFDOW1CMVYsd0JBQVUsQ0FBQyxZQUFJO0FBQUM7QUFBVyxlQUFqQixDQUFWO0FBQThCOztBQURxYjtBQUFBLG1CQUMvYThYLFdBQVcsQ0FBQyxDQUFDLEdBQUVHLFNBQVMsV0FBWixFQUFzQixDQUFDLEdBQUVBLFNBQVMsV0FBWixFQUFzQixFQUF0QixFQUF5QnZDLEtBQXpCLENBQXRCLEVBQXNELEVBQXRELEVBQXlEO0FBQUNyTyxpQkFBRztBQUFKLGFBQXpELENBQUQsQ0FEb2E7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRzs7OztBQUluZCxTQUFTeVEsV0FBVCxDQUFxQnBDLEtBQXJCLEVBQTJCO0FBQUEsTUFBSzJFLEdBQUwsR0FBYzNFLEtBQWQsQ0FBSzJFLEdBQUw7QUFBQSxNQUFTaFQsR0FBVCxHQUFjcU8sS0FBZCxDQUFTck8sR0FBVCxFQUFvQjtBQUMvQzs7QUFDQSxZQUF1QztBQUFDO0FBQ3hDO0FBQ0E2UyxjQUFVLENBQUNwVixvQkFBWCxHQUZ1QyxDQUVMO0FBQ2xDOztBQUNBLFdBQU9zWSxRQUFRLENBQUM7QUFBQy9DLFNBQUcsRUFBQztBQUFBLGVBQUksSUFBSjtBQUFBLE9BQUw7QUFBYzNFLFdBQUssRUFBQyxFQUFwQjtBQUF1QjBFLGVBQVMsRUFBQztBQUFBLGVBQUksSUFBSjtBQUFBLE9BQWpDO0FBQTBDL1MsU0FBRyxFQUFDO0FBQTlDLEtBQUQsQ0FBZjtBQUFzRTs7QUFBQSxNQUFHckIsS0FBSCxFQUE4QixFQU56RSxDQU93Tjs7O0FBQ25QdkUsU0FBTyxDQUFDc0UsS0FBUixDQUFjc0IsR0FBZDtBQUFtQixTQUFPc1MsVUFBVSxDQUFDNkMsUUFBWCxDQUFvQixTQUFwQixFQUErQjlVLElBQS9CLENBQW9DLFVBQUMyVixLQUFELEVBQVM7QUFBQSxRQUFVbEQsY0FBVixHQUEwQmtELEtBQTFCLENBQUt0SSxJQUFMLEVBQWdDO0FBQ3ZHO0FBQ0E7O0FBQ0EsUUFBSXVJLE9BQU8sR0FBQ04sT0FBTyxDQUFDM0MsR0FBRCxDQUFuQjtBQUF5QixRQUFJa0QsTUFBTSxHQUFDO0FBQUNuRCxlQUFTLEVBQUNELGNBQVg7QUFBMEJtRCxhQUFPLEVBQVBBLE9BQTFCO0FBQWtDdEksWUFBTSxFQUFOQSxNQUFsQztBQUF5Q3dJLFNBQUcsRUFBQztBQUFDblcsV0FBRyxFQUFIQSxHQUFEO0FBQUswTCxnQkFBUSxFQUFDZ0MsSUFBZDtBQUFtQmlFLGFBQUssRUFBTEEsS0FBbkI7QUFBeUJTLGNBQU0sRUFBTkEsTUFBekI7QUFBZ0M2RCxlQUFPLEVBQVBBO0FBQWhDO0FBQTdDLEtBQVg7QUFBa0csV0FBTy9QLE9BQU8sQ0FBQ0MsT0FBUixDQUFnQmtJLEtBQUssQ0FBQ0EsS0FBTixHQUFZQSxLQUFLLENBQUNBLEtBQWxCLEdBQXdCLENBQUMsR0FBRWlELE1BQU0sQ0FBQzhFLG1CQUFWLEVBQStCcEQsR0FBL0IsRUFBbUNrRCxNQUFuQyxDQUF4QyxFQUFvRjdWLElBQXBGLENBQXlGLFVBQUFnVyxTQUFTO0FBQUEsYUFBRU4sUUFBUSxDQUFDLENBQUMsR0FBRW5GLFNBQVMsV0FBWixFQUFzQixDQUFDLEdBQUVBLFNBQVMsV0FBWixFQUFzQixFQUF0QixFQUF5QnZDLEtBQXpCLENBQXRCLEVBQXNELEVBQXRELEVBQXlEO0FBQUNyTyxXQUFHLEVBQUhBLEdBQUQ7QUFBSytTLGlCQUFTLEVBQUNELGNBQWY7QUFBOEJ6RSxhQUFLLEVBQUNnSTtBQUFwQyxPQUF6RCxDQUFELENBQVY7QUFBQSxLQUFsRyxDQUFQO0FBQWdPLEdBSGpVLENBQVA7QUFHMlUsQyxDQUFBOzs7QUFDOVYsSUFBSUMsZUFBZSxHQUFDLE9BQU90RixTQUFTLFdBQVQsQ0FBa0J1RixPQUF6QixLQUFtQyxVQUF2RDtBQUFrRSxJQUFJQyxTQUFTLEdBQUMsSUFBZDs7QUFBbUIsU0FBU0Msa0JBQVQsQ0FBNEJDLE9BQTVCLEVBQW9DQyxLQUFwQyxFQUEwQztBQUFDLE1BQUdoWSxLQUFILEVBQTRDLGFBQTVDLE1BQXVSO0FBQUM7QUFDeFosUUFBRzJTLE1BQU0sQ0FBQ3NGLEVBQVYsRUFBYTtBQUFDQyxpQkFBVyxDQUFDQyxJQUFaLENBQWlCLGNBQWpCO0FBQWtDLEtBRHVXLENBQ3ZXOzs7QUFDaEQsUUFBR1IsZUFBSCxFQUFtQjtBQUFDdEYsZUFBUyxXQUFULENBQWtCdUYsT0FBbEIsQ0FBMEJHLE9BQTFCLEVBQWtDQyxLQUFsQyxFQUF3Q0ksbUJBQXhDOztBQUE2RFQscUJBQWUsR0FBQyxLQUFoQjs7QUFBc0IsVUFBR3JELFdBQVcsSUFBRTNCLE1BQU0sQ0FBQ3NGLEVBQXZCLEVBQTBCO0FBQUMsU0FBQyxHQUFFbkYsbUJBQW1CLFdBQXRCLEVBQWdDd0IsV0FBaEM7QUFBOEM7QUFBQyxLQUFqTCxNQUFxTDtBQUFDakMsZUFBUyxXQUFULENBQWtCUixNQUFsQixDQUF5QmtHLE9BQXpCLEVBQWlDQyxLQUFqQyxFQUF1Q0ssa0JBQXZDO0FBQTREO0FBQUM7QUFBQzs7QUFBQSxTQUFTRCxtQkFBVCxHQUE4QjtBQUFDLE1BQUcsQ0FBQ3pGLE1BQU0sQ0FBQ3NGLEVBQVgsRUFBYztBQUFPQyxhQUFXLENBQUNDLElBQVosQ0FBaUIsY0FBakIsRUFBdEIsQ0FBdUQ7O0FBQ3pVRCxhQUFXLENBQUNJLE9BQVosQ0FBb0IsMEJBQXBCLEVBQStDLGlCQUEvQyxFQUFpRSxjQUFqRTtBQUFpRkosYUFBVyxDQUFDSSxPQUFaLENBQW9CLG1CQUFwQixFQUF3QyxjQUF4QyxFQUF1RCxjQUF2RDs7QUFBdUUsTUFBR2hFLFdBQUgsRUFBZTtBQUFDNEQsZUFBVyxDQUFDSyxnQkFBWixDQUE2QixtQkFBN0IsRUFBa0QxYyxPQUFsRCxDQUEwRHlZLFdBQTFEO0FBQXdFOztBQUFBa0UsWUFBVTtBQUFJOztBQUFBLFNBQVNILGtCQUFULEdBQTZCO0FBQUMsTUFBRyxDQUFDMUYsTUFBTSxDQUFDc0YsRUFBWCxFQUFjO0FBQU9DLGFBQVcsQ0FBQ0MsSUFBWixDQUFpQixhQUFqQixFQUF0QixDQUFzRDs7QUFDalYsTUFBSU0sZUFBZSxHQUFDUCxXQUFXLENBQUNLLGdCQUFaLENBQTZCLGFBQTdCLEVBQTJDLE1BQTNDLENBQXBCOztBQUF1RSxNQUFHLENBQUNFLGVBQWUsQ0FBQzljLE1BQXBCLEVBQTJCO0FBQUM7QUFBUTs7QUFBQXVjLGFBQVcsQ0FBQ0ksT0FBWixDQUFvQixnQ0FBcEIsRUFBcURHLGVBQWUsQ0FBQyxDQUFELENBQWYsQ0FBbUJ4VCxJQUF4RSxFQUE2RSxjQUE3RTtBQUE2RmlULGFBQVcsQ0FBQ0ksT0FBWixDQUFvQixnQkFBcEIsRUFBcUMsY0FBckMsRUFBb0QsYUFBcEQ7O0FBQW1FLE1BQUdoRSxXQUFILEVBQWU7QUFBQzRELGVBQVcsQ0FBQ0ssZ0JBQVosQ0FBNkIsZ0JBQTdCLEVBQStDMWMsT0FBL0MsQ0FBdUR5WSxXQUF2RDtBQUFvRTRELGVBQVcsQ0FBQ0ssZ0JBQVosQ0FBNkIsZ0NBQTdCLEVBQStEMWMsT0FBL0QsQ0FBdUV5WSxXQUF2RTtBQUFxRjs7QUFBQWtFLFlBQVU7QUFBRyxHQUFDLGdDQUFELEVBQWtDLGdCQUFsQyxFQUFvRDNjLE9BQXBELENBQTRELFVBQUF5YyxPQUFPO0FBQUEsV0FBRUosV0FBVyxDQUFDUSxhQUFaLENBQTBCSixPQUExQixDQUFGO0FBQUEsR0FBbkU7QUFBMEc7O0FBQUEsU0FBU0UsVUFBVCxHQUFxQjtBQUFDO0FBQUMsR0FBQyxjQUFELEVBQWdCLGNBQWhCLEVBQStCLGFBQS9CLEVBQTZDLGFBQTdDLEVBQTREM2MsT0FBNUQsQ0FBb0UsVUFBQXNjLElBQUk7QUFBQSxXQUFFRCxXQUFXLENBQUNNLFVBQVosQ0FBdUJMLElBQXZCLENBQUY7QUFBQSxHQUF4RTtBQUF5Rzs7QUFBQSxTQUFTUSxZQUFULENBQXNCQyxLQUF0QixFQUE0QjtBQUFBLE1BQUs3SSxRQUFMLEdBQWU2SSxLQUFmLENBQUs3SSxRQUFMO0FBQXFCLFNBQU0sYUFBYXFDLE1BQU0sV0FBTixDQUFleGEsYUFBZixDQUE2QjJjLFNBQTdCLEVBQXVDO0FBQUN0WSxNQUFFLEVBQUMsWUFBQThELEtBQUs7QUFBQSxhQUFFK1IsV0FBVyxDQUFDO0FBQUN1QyxXQUFHLEVBQUhBLEdBQUQ7QUFBS2hULFdBQUcsRUFBQ3RCO0FBQVQsT0FBRCxDQUFYLFVBQW1DLFVBQUFzQixHQUFHO0FBQUEsZUFBRTVGLE9BQU8sQ0FBQ3NFLEtBQVIsQ0FBYyx3QkFBZCxFQUF1Q3NCLEdBQXZDLENBQUY7QUFBQSxPQUF0QyxDQUFGO0FBQUE7QUFBVCxHQUF2QyxFQUF3SSxhQUFhK1EsTUFBTSxXQUFOLENBQWV4YSxhQUFmLENBQTZCNGEsY0FBYyxDQUFDcUcsYUFBZixDQUE2QkMsUUFBMUQsRUFBbUU7QUFBQzNULFNBQUssRUFBQyxDQUFDLEdBQUVtSCxPQUFPLENBQUN5TSx3QkFBWCxFQUFxQy9KLE1BQXJDO0FBQVAsR0FBbkUsRUFBd0gsYUFBYW9ELE1BQU0sV0FBTixDQUFleGEsYUFBZixDQUE2QjBhLG1CQUFtQixDQUFDMEcsa0JBQXBCLENBQXVDRixRQUFwRSxFQUE2RTtBQUFDM1QsU0FBSyxFQUFDNE87QUFBUCxHQUE3RSxFQUFnR2hFLFFBQWhHLENBQXJJLENBQXJKLENBQW5CO0FBQTBaOztLQUFsYzRJLFk7O0FBQWtjLElBQUkzQixPQUFPLEdBQUMsU0FBUkEsT0FBUSxDQUFBM0MsR0FBRztBQUFBLFNBQUUsVUFBQTNFLEtBQUssRUFBRTtBQUFDLFFBQUl1SixRQUFRLEdBQUMsQ0FBQyxHQUFFaEgsU0FBUyxXQUFaLEVBQXNCLENBQUMsR0FBRUEsU0FBUyxXQUFaLEVBQXNCLEVBQXRCLEVBQXlCdkMsS0FBekIsQ0FBdEIsRUFBc0QsRUFBdEQsRUFBeUQ7QUFBQzBFLGVBQVMsRUFBVEEsU0FBRDtBQUFXL1MsU0FBRyxFQUFIQSxHQUFYO0FBQWUyTixZQUFNLEVBQU5BO0FBQWYsS0FBekQsQ0FBYjtBQUE4RixXQUFNLGFBQWFvRCxNQUFNLFdBQU4sQ0FBZXhhLGFBQWYsQ0FBNkIrZ0IsWUFBN0IsRUFBMEMsSUFBMUMsRUFBK0MsYUFBYXZHLE1BQU0sV0FBTixDQUFleGEsYUFBZixDQUE2QnljLEdBQTdCLEVBQWlDNEUsUUFBakMsQ0FBNUQsQ0FBbkI7QUFBNEgsR0FBcE87QUFBQSxDQUFmOztTQUFtUTdCLFE7Ozs7O3VFQUFmLGtCQUF3QjhCLEtBQXhCO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBbUM3RSxlQUFuQyxHQUE0RDZFLEtBQTVELENBQW1DN0UsR0FBbkMsRUFBdUNELFNBQXZDLEdBQTREOEUsS0FBNUQsQ0FBdUM5RSxTQUF2QyxFQUFpRDFFLEtBQWpELEdBQTREd0osS0FBNUQsQ0FBaUR4SixLQUFqRCxFQUF1RHJPLEdBQXZELEdBQTRENlgsS0FBNUQsQ0FBdUQ3WCxHQUF2RCxFQUFrRTtBQUM1NkM7O0FBRDAyQyxrQkFFdjJDLENBQUNxTyxLQUFELElBQVEwRSxTQUFSLElBQW1CQSxTQUFTLEtBQUdELGNBQS9CLElBQStDRixZQUFZLENBQUNHLFNBQWIsS0FBeUJELGNBRit4QztBQUFBO0FBQUE7QUFBQTs7QUFBQSx1QkFFcnVDbkYsTUFGcXVDLEVBRTN3Q2pDLFFBRjJ3QyxZQUUzd0NBLFFBRjJ3QyxFQUU1dkNvTSxNQUY0dkMsWUFFbHdDbkcsS0FGa3dDLEVBRTl1Q29HLE9BRjh1QyxZQUVydkMzRixNQUZxdkM7QUFFMXRDNkQsbUJBRjB0QyxHQUVsdENOLE9BQU8sQ0FBQzNDLEdBQUQsQ0FGMnNDO0FBRWpzQ2tELGtCQUZpc0MsR0FFMXJDO0FBQUN2SSxvQkFBTSxFQUFOQSxNQUFEO0FBQVFzSSxxQkFBTyxFQUFQQSxPQUFSO0FBQWdCbEQsdUJBQVMsRUFBQ0QsY0FBMUI7QUFBeUNxRCxpQkFBRyxFQUFDO0FBQUNuVyxtQkFBRyxFQUFIQSxHQUFEO0FBQUswTCx3QkFBUSxFQUFSQSxRQUFMO0FBQWNpRyxxQkFBSyxFQUFDbUcsTUFBcEI7QUFBMkIxRixzQkFBTSxFQUFDMkYsT0FBbEM7QUFBMEM5Qix1QkFBTyxFQUFQQTtBQUExQztBQUE3QyxhQUYwckM7QUFBQTtBQUFBLG1CQUU5a0MsQ0FBQyxHQUFFM0UsTUFBTSxDQUFDOEUsbUJBQVYsRUFBK0JwRCxHQUEvQixFQUFtQ2tELE1BQW5DLENBRjhrQzs7QUFBQTtBQUV6bEM3SCxpQkFGeWxDOztBQUFBO0FBRWxpQzBFLHFCQUFTLEdBQUNBLFNBQVMsSUFBRUgsWUFBWSxDQUFDRyxTQUFsQztBQUE0QzFFLGlCQUFLLEdBQUNBLEtBQUssSUFBRXVFLFlBQVksQ0FBQ3ZFLEtBQTFCO0FBQW9DdUosb0JBRms5QixHQUV6OEIsQ0FBQyxHQUFFaEgsU0FBUyxXQUFaLEVBQXNCLENBQUMsR0FBRUEsU0FBUyxXQUFaLEVBQXNCLEVBQXRCLEVBQXlCdkMsS0FBekIsQ0FBdEIsRUFBc0QsRUFBdEQsRUFBeUQ7QUFBQzBFLHVCQUFTLEVBQVRBLFNBQUQ7QUFBVy9TLGlCQUFHLEVBQUhBLEdBQVg7QUFBZTJOLG9CQUFNLEVBQU5BO0FBQWYsYUFBekQsQ0FGeThCLEVBRXgzQjs7QUFDbGZpRix3QkFBWSxHQUFDZ0YsUUFBYjtBQUFzQmxILG1CQUFPLENBQUNzSCxJQUFSLENBQWEsd0JBQWIsRUFBc0M7QUFBQ2pGLHVCQUFTLEVBQVRBLFNBQUQ7QUFBV0QsNEJBQWMsRUFBZEEsY0FBWDtBQUEwQjhFLHNCQUFRLEVBQVJBO0FBQTFCLGFBQXRDO0FBQStFSyxnQkFIcXdDLEdBR2h3QyxhQUFhbEgsTUFBTSxXQUFOLENBQWV4YSxhQUFmLENBQTZCK2dCLFlBQTdCLEVBQTBDLElBQTFDLEVBQStDLGFBQWF2RyxNQUFNLFdBQU4sQ0FBZXhhLGFBQWYsQ0FBNkJ5YyxHQUE3QixFQUFpQzRFLFFBQWpDLENBQTVELENBSG12QyxFQUczb0M7O0FBQy9ObkIsOEJBQWtCLENBQUM5WCxNQUFBLEdBQStCLGFBQWFvUyxTQUE1QyxHQUE4R2tILElBQS9HLEVBQW9IdEYsVUFBcEgsQ0FBbEI7QUFBa0pqQyxtQkFBTyxDQUFDc0gsSUFBUixDQUFhLHVCQUFiLEVBQXFDO0FBQUNqRix1QkFBUyxFQUFUQSxTQUFEO0FBQVdELDRCQUFjLEVBQWRBLGNBQVg7QUFBMEI4RSxzQkFBUSxFQUFSQTtBQUExQixhQUFyQzs7QUFKd3RDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JEMTJDLHVEQUFhOztBQUFBLElBQUlqYixzQkFBc0IsR0FBQzVHLG1CQUFPLENBQUMsb0hBQUQsQ0FBbEM7O0FBQW1GLElBQUk2Ryx1QkFBdUIsR0FBQzdHLG1CQUFPLENBQUMsc0hBQUQsQ0FBbkM7O0FBQXFGLElBQUl1WCxJQUFJLEdBQUMxUSx1QkFBdUIsQ0FBQzdHLG1CQUFPLENBQUMsb0RBQUQsQ0FBUixDQUFoQzs7QUFBZ0QsSUFBSW1pQixvQkFBb0IsR0FBQ3ZiLHNCQUFzQixDQUFDNUcsbUJBQU8sQ0FBQyxpR0FBRCxDQUFSLENBQS9DOztBQUF3RixJQUFJb2lCLHNCQUFzQixHQUFDeGIsc0JBQXNCLENBQUM1RyxtQkFBTyxDQUFDLHVHQUFELENBQVIsQ0FBakQ7O0FBQTZGLElBQUlxaUIsMkJBQTJCLEdBQUN6YixzQkFBc0IsQ0FBQzVHLG1CQUFPLENBQUMsaUhBQUQsQ0FBUixDQUF0RDs7QUFBdUcsSUFBSXNpQixnQkFBZ0IsR0FBQzFiLHNCQUFzQixDQUFDNUcsbUJBQU8sQ0FBQyx5RkFBRCxDQUFSLENBQTNDOztBQUFnRixJQUFJdWlCLG1CQUFtQixHQUFDM2Isc0JBQXNCLENBQUM1RyxtQkFBTyxDQUFDLDZGQUFELENBQVIsQ0FBOUM7O0FBQXFGLElBQUl3aUIsS0FBSyxHQUFDeGlCLG1CQUFPLENBQUMsK0RBQUQsQ0FBakI7QUFBZ0M7QUFBb0M7QUFDMXVCO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFxQixDLENBQUM7O0FBQ3RCLElBQUcsQ0FBQzhELE1BQU0sQ0FBQ0MsV0FBWCxFQUF1QjtBQUFDRCxRQUFNLENBQUNDLFdBQVAsR0FBbUJvZSxvQkFBb0IsV0FBdkM7QUFBaUQ7O2NBQWlDcmUsTTtJQUFkdVIsVyxXQUFmeUIsYSxDQUFlekIsVztBQUFxQixJQUFJalUsTUFBTSxHQUFDaVUsV0FBVyxJQUFFLEVBQXhCO0FBQTJCLElBQUl5SCxVQUFVLEdBQUMsQ0FBQyxHQUFFdUYsMkJBQTJCLFdBQTlCLEVBQXdDO0FBQUNoTixhQUFXLEVBQUNqVTtBQUFiLENBQXhDLENBQWY7QUFBNkUwQyxNQUFNLENBQUN5VCxJQUFQLEdBQVlBLElBQVo7QUFBaUIsQ0FBQyxHQUFFQSxJQUFJLFdBQVAsRUFBaUI7QUFBQ3VGLFlBQVUsRUFBVkE7QUFBRCxDQUFqQixFQUErQnhTLElBQS9CLENBQW9DLFVBQUM4SyxJQUFELEVBQVE7QUFBQSxNQUFLdUYsT0FBTCxHQUErQnZGLElBQS9CLENBQUt1RixPQUFMO0FBQUEsTUFBYW9GLFNBQWIsR0FBK0IzSyxJQUEvQixDQUFhMkssU0FBYjtBQUFBLE1BQXVCdEYsTUFBdkIsR0FBK0JyRixJQUEvQixDQUF1QnFGLE1BQXZCO0FBQW9DLEdBQUMsR0FBRTJILHNCQUFzQixXQUF6QixFQUFtQztBQUFDL00sZUFBVyxFQUFDalU7QUFBYixHQUFuQztBQUF5RCxNQUFHd0gsSUFBSCxFQUFzQyxDQUFDLEdBQUUwWixnQkFBZ0IsV0FBbkI7O0FBQStCLE1BQUcxWixLQUFBLElBQXdDO0FBQ25lLElBQUUsT0FBT0EsT0FBUCxLQUFpQixXQUFqQixJQUE4QixjQUFhQSxPQUFPLENBQUM2WixRQUFyRCxDQUR3YixFQUN6WDtBQUFDLEtBQUMsR0FBRUYsbUJBQW1CLFdBQXRCO0FBQW1DLEdBRG1MLENBQ25MOzs7QUFDbkcsR0FBQyxHQUFFQyxLQUFLLENBQUM3TixjQUFULEVBQXlCLFlBQUk7QUFBQzhGLFVBQU0sQ0FBQ3NGLFNBQUQsQ0FBTjtBQUFtQixHQUFqRDtBQUFtRCxNQUFJMkMsVUFBSjtBQUFlL0gsU0FBTyxDQUFDbkYsRUFBUixDQUFXLHdCQUFYLEVBQW9DLFVBQUNnSixLQUFELEVBQVM7QUFBQSxRQUFLeEIsU0FBTCxHQUErQndCLEtBQS9CLENBQUt4QixTQUFMO0FBQUEsUUFBZUQsY0FBZixHQUErQnlCLEtBQS9CLENBQWV6QixjQUFmLEVBQXFDOztBQUNwSixRQUFHLENBQUMyRixVQUFELElBQWExRixTQUFTLEtBQUdELGNBQTVCLEVBQTJDO0FBQUEscUJBQThCalosTUFBOUI7QUFBQSxVQUFLNmUsV0FBTCxZQUFLQSxXQUFMO0FBQUEsVUFBaUJDLFdBQWpCLFlBQWlCQSxXQUFqQjtBQUFxQ0YsZ0JBQVUsR0FBQztBQUFDNU4sU0FBQyxFQUFDNk4sV0FBSDtBQUFlRSxTQUFDLEVBQUNEO0FBQWpCLE9BQVg7QUFBMEM7QUFBQyxHQUR6RDtBQUMyRGpJLFNBQU8sQ0FBQ25GLEVBQVIsQ0FBVyx1QkFBWCxFQUFtQyxVQUFDc0ssS0FBRCxFQUFTO0FBQUEsUUFBSzlDLFNBQUwsR0FBK0I4QyxLQUEvQixDQUFLOUMsU0FBTDtBQUFBLFFBQWVELGNBQWYsR0FBK0IrQyxLQUEvQixDQUFlL0MsY0FBZjs7QUFBcUMsUUFBRzJGLFVBQVUsSUFBRTFGLFNBQVMsS0FBR0QsY0FBM0IsRUFBMEM7QUFBQztBQUFELHdCQUMvTzJGLFVBRCtPO0FBQUEsVUFDcFA1TixDQURvUCxlQUNwUEEsQ0FEb1A7QUFBQSxVQUNsUCtOLENBRGtQLGVBQ2xQQSxDQURrUDtBQUNwTy9lLFlBQU0sQ0FBQ2dmLE1BQVAsQ0FBY2hPLENBQWQsRUFBZ0IrTixDQUFoQjtBQUFtQkgsZ0JBQVUsR0FBQyxJQUFYO0FBQWlCO0FBQUMsR0FEb0U7QUFDakUsQ0FKOEssV0FJdEssVUFBQXpZLEdBQUcsRUFBRTtBQUFDNUYsU0FBTyxDQUFDc0UsS0FBUixDQUFjLHNCQUFkLEVBQXFDc0IsR0FBckM7QUFBMkMsQ0FKcUg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ04xTyw4Q0FBYTs7Ozs7O0FBQUEsSUFBSXJELHNCQUFzQixHQUFDNUcsbUJBQU8sQ0FBQyxvSEFBRCxDQUFsQzs7QUFBbUZQLE9BQU8sQ0FBQ1UsVUFBUixHQUFtQixJQUFuQjtBQUF3QlYsT0FBTyxXQUFQLEdBQWdCLEtBQUssQ0FBckI7O0FBQXVCLElBQUlzakIsSUFBSSxHQUFDL2lCLG1CQUFPLENBQUMsb0RBQUQsQ0FBaEI7O0FBQXdCLElBQUltYixLQUFLLEdBQUN2VSxzQkFBc0IsQ0FBQzVHLG1CQUFPLENBQUMsaUZBQUQsQ0FBUixDQUFoQzs7QUFBcUUsSUFBSXFiLFVBQVUsR0FBQ3JiLG1CQUFPLENBQUMseUhBQUQsQ0FBdEI7O0FBQXVFLElBQUlnakIsYUFBYSxHQUFDaGpCLG1CQUFPLENBQUMsK0hBQUQsQ0FBekI7O0FBQTZFLElBQUlpakIsV0FBVyxHQUFDampCLG1CQUFPLENBQUMsMkhBQUQsQ0FBdkI7O0FBQXlFLElBQUlrVixPQUFPLEdBQUNsVixtQkFBTyxDQUFDLHFHQUFELENBQW5COztBQUEwRCxTQUFTa2pCLE1BQVQsQ0FBZ0JDLEdBQWhCLEVBQW9CQyxJQUFwQixFQUF5QjtBQUFDLE1BQUc7QUFBQ0EsUUFBSSxHQUFDN2lCLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixNQUF2QixDQUFMO0FBQW9DLFdBQU80aUIsSUFBSSxDQUFDQyxPQUFMLENBQWFDLFFBQWIsQ0FBc0JILEdBQXRCLENBQVA7QUFBbUMsR0FBM0UsQ0FBMkUsT0FBTTlnQixPQUFOLEVBQWMsQ0FBRTtBQUFDOztBQUFBLElBQUlraEIsV0FBVyxHQUFDTCxNQUFNLENBQUMsU0FBRCxDQUFOLElBQW1CLENBQUNBLE1BQU0sQ0FBQyxVQUFELENBQTFCLEdBQXVDO0FBQ2hyQjtBQUNBLFNBRnlvQixHQUUvbkI7QUFDVjtBQUNBLFVBSnluQjtBQUk5bUIsSUFBSU0sV0FBVyxJQUFFLGNBQWFqakIsUUFBUSxDQUFDQyxhQUFULENBQXVCLFFBQXZCLENBQWYsQ0FBZjtBQUFnRTs7QUFBNEIsU0FBU2lqQixjQUFULENBQXdCQyxLQUF4QixFQUE4QjtBQUFDLE1BQUdBLEtBQUssQ0FBQyxDQUFELENBQUwsS0FBVyxHQUFkLEVBQWtCO0FBQUMsVUFBTSxJQUFJblksS0FBSixDQUFVLGlEQUErQ21ZLEtBQS9DLEdBQXFELElBQS9ELENBQU47QUFBNEU7O0FBQUFBLE9BQUssR0FBQ0EsS0FBSyxDQUFDeGpCLE9BQU4sQ0FBYyxVQUFkLEVBQXlCLEdBQXpCLENBQU47QUFBb0MsTUFBR3dqQixLQUFLLEtBQUcsR0FBWCxFQUFlLE9BQU9BLEtBQVA7QUFBYSxTQUFPQSxLQUFLLENBQUN4akIsT0FBTixDQUFjLEtBQWQsRUFBb0IsRUFBcEIsQ0FBUDtBQUFnQzs7QUFBQSxTQUFTeWpCLFVBQVQsQ0FBb0J6TixJQUFwQixFQUF5QmlOLEdBQXpCLEVBQTZCUyxFQUE3QixFQUFnQztBQUFDLFNBQU8sSUFBSXpULE9BQUosQ0FBWSxVQUFDMFQsR0FBRCxFQUFLQyxHQUFMLEVBQVNWLElBQVQsRUFBZ0I7QUFBQ0EsUUFBSSxHQUFDN2lCLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixNQUF2QixDQUFMO0FBQW9DNGlCLFFBQUksQ0FBQ1csV0FBTCxHQUFpQm5iLFNBQWpCO0FBQXFDd2EsUUFBSSxDQUFDbE4sSUFBTCxHQUFVQSxJQUFWO0FBQWVrTixRQUFJLENBQUNELEdBQUwsR0FBU0EsR0FBVDtBQUFhLFFBQUdTLEVBQUgsRUFBTVIsSUFBSSxDQUFDUSxFQUFMLEdBQVFBLEVBQVI7QUFBV1IsUUFBSSxDQUFDalcsTUFBTCxHQUFZMFcsR0FBWjtBQUFnQlQsUUFBSSxDQUFDbGYsT0FBTCxHQUFhNGYsR0FBYjtBQUFpQnZqQixZQUFRLENBQUMyWixJQUFULENBQWNoWixXQUFkLENBQTBCa2lCLElBQTFCO0FBQWlDLEdBQXJOLENBQVA7QUFBK047O0lBQU1ZLFU7QUFBVyxzQkFBWW5JLE9BQVosRUFBb0J4RyxXQUFwQixFQUFnQztBQUFBOztBQUFDLFNBQUt3RyxPQUFMLEdBQWFBLE9BQWI7QUFBcUIsU0FBS3hHLFdBQUwsR0FBaUJBLFdBQWpCO0FBQTZCLFNBQUs0TyxTQUFMLEdBQWUsRUFBZjtBQUFrQixTQUFLQyxrQkFBTCxHQUF3QixDQUFDLEdBQUUvSSxLQUFLLFdBQVIsR0FBeEI7QUFBNEMsU0FBS2dKLGFBQUwsR0FBbUIsRUFBbkI7O0FBQXNCLFFBQUd2YixLQUFILEVBQXNDLEVBQTZMO0FBQUE7OztBQUFtQyxTQUFLd2IsbUJBQUwsR0FBeUIsSUFBSWpVLE9BQUosQ0FBWSxVQUFBQyxPQUFPLEVBQUU7QUFBQyxVQUFHdE0sTUFBTSxDQUFDdWdCLGNBQVYsRUFBeUI7QUFBQ2pVLGVBQU8sQ0FBQ3RNLE1BQU0sQ0FBQ3VnQixjQUFSLENBQVA7QUFBZ0MsT0FBMUQsTUFBOEQ7QUFBQ3ZnQixjQUFNLENBQUN3Z0IsaUJBQVAsR0FBeUIsWUFBSTtBQUFDbFUsaUJBQU8sQ0FBQ3RNLE1BQU0sQ0FBQ3VnQixjQUFSLENBQVA7QUFBZ0MsU0FBOUQ7QUFBZ0U7QUFBQyxLQUF0SixDQUF6QjtBQUFrTCxHLENBQUE7Ozs7O29DQUNycUNYLEssRUFBTTtBQUFBOztBQUFDLGFBQU8sS0FBS2EscUJBQUwsQ0FBMkJqYSxJQUEzQixDQUFnQyxVQUFBa2EsR0FBRztBQUFBLGVBQUVBLEdBQUcsQ0FBQ2QsS0FBRCxDQUFILElBQVljLEdBQUcsQ0FBQ2QsS0FBRCxDQUFILENBQVdqZSxHQUFYLENBQWUsVUFBQXNILEdBQUc7QUFBQSxpQkFBRSxLQUFJLENBQUNzSSxXQUFMLEdBQWlCLFNBQWpCLEdBQTJCb1AsU0FBUyxDQUFDMVgsR0FBRCxDQUF0QztBQUFBLFNBQWxCLENBQVosSUFBNEUsRUFBOUU7QUFBQSxPQUFuQyxDQUFQO0FBQTZIO0FBQUE7Ozs7Ozs7Z0NBR25JbUosSSxFQUFLbUcsTSxFQUFPO0FBQUE7O0FBQUMsVUFBSXFJLGNBQWM7QUFBQztBQUFtQixlQUFsQ0EsY0FBa0MsQ0FBQTFpQixJQUFJLEVBQUU7QUFBQ0EsWUFBSSxHQUFDLENBQUMsR0FBRWtULE9BQU8sQ0FBQ3lQLFdBQVgsRUFBd0IzaUIsSUFBeEIsQ0FBTDtBQUFtQyxlQUFPLE1BQUksQ0FBQ3FULFdBQUwsR0FBaUIsY0FBakIsR0FBZ0MsTUFBSSxDQUFDd0csT0FBckMsSUFBOEM3WixJQUFJLEtBQUcsR0FBUCxHQUFXLFFBQVgsR0FBb0JBLElBQWxFLElBQXdFLE9BQS9FO0FBQXdGLE9BQXhLOztBQUFELGtCQUEyTSxDQUFDLEdBQUUrZ0IsSUFBSSxDQUFDdmdCLEtBQVIsRUFBZTBULElBQWYsRUFBb0IsSUFBcEIsQ0FBM007QUFBQSxVQUF1TDBPLFlBQXZMLFNBQThLalAsUUFBOUs7QUFBQSxVQUFvTWlHLEtBQXBNLFNBQW9NQSxLQUFwTTs7QUFBQSxrQkFBOFAsQ0FBQyxHQUFFbUgsSUFBSSxDQUFDdmdCLEtBQVIsRUFBZTZaLE1BQWYsQ0FBOVA7QUFBQSxVQUFrUHdJLFVBQWxQLFNBQXlPbFAsUUFBek87O0FBQXFSLFVBQUkrTixLQUFLLEdBQUNELGNBQWMsQ0FBQ21CLFlBQUQsQ0FBeEI7QUFBdUMsVUFBSUUsU0FBUyxHQUFDLENBQUMsR0FBRXpKLFVBQVUsQ0FBQ2tDLGNBQWQsRUFBOEJtRyxLQUE5QixDQUFkO0FBQUEsVUFBbURxQixpQkFBbkQ7O0FBQXFFLFVBQUdELFNBQUgsRUFBYTtBQUFDLFlBQUlFLFlBQVksR0FBQyxDQUFDLEdBQUUvQixXQUFXLENBQUNnQyxhQUFmLEVBQThCdkIsS0FBOUIsQ0FBakI7QUFBc0QsWUFBSXdCLGFBQWEsR0FBQ0YsWUFBWSxDQUFDRyxNQUEvQjtBQUFzQyxZQUFJQyxjQUFjLEdBQUM7QUFDM2hCLFNBQUMsR0FBRXBDLGFBQWEsQ0FBQ3FDLGVBQWpCLEVBQWtDTCxZQUFsQyxFQUFnREgsVUFBaEQsS0FBNkQ7QUFDN0Q7QUFDQWpKLGFBSHdnQjtBQUdsZ0JtSix5QkFBaUIsR0FBQ3JCLEtBQWxCOztBQUF3QixZQUFHLENBQUNsVixNQUFNLENBQUM4VyxJQUFQLENBQVlKLGFBQVosRUFBMkJLLEtBQTNCLENBQWlDLFVBQUFDLEtBQUssRUFBRTtBQUFDLGNBQUl6WCxLQUFLLEdBQUNxWCxjQUFjLENBQUNJLEtBQUQsQ0FBeEI7QUFBZ0MsY0FBSUMsTUFBTSxHQUFDUCxhQUFhLENBQUNNLEtBQUQsQ0FBYixDQUFxQkMsTUFBaEMsQ0FBakMsQ0FBd0U7QUFDbEo7O0FBQ0EsY0FBR0EsTUFBTSxJQUFFLENBQUNDLEtBQUssQ0FBQ0MsT0FBTixDQUFjNVgsS0FBZCxDQUFaLEVBQWlDQSxLQUFLLEdBQUMsQ0FBQ0EsS0FBRCxDQUFOO0FBQWMsaUJBQU95WCxLQUFLLElBQUlKLGNBQVQsTUFBMEI7QUFDaEZMLDJCQUFpQixHQUFDQSxpQkFBaUIsQ0FBQzdrQixPQUFsQixDQUEwQixPQUFLdWxCLE1BQU0sR0FBQyxLQUFELEdBQU8sRUFBbEIsSUFBc0JELEtBQXRCLEdBQTRCLEdBQXRELEVBQTBEQyxNQUFNLEdBQUMxWCxLQUFLLENBQUN0SSxHQUFOLENBQVUrTyxrQkFBVixFQUE4QjVVLElBQTlCLENBQW1DLEdBQW5DLENBQUQsR0FBeUM0VSxrQkFBa0IsQ0FBQ3pHLEtBQUQsQ0FBM0gsQ0FEb0MsQ0FBUDtBQUN5RyxTQUh0SCxDQUFKLEVBRzRIO0FBQUNnWCwyQkFBaUIsR0FBQyxFQUFsQixDQUFELENBQXNCO0FBQ2hMO0FBQ0E7QUFDQztBQUFDOztBQUFBLGFBQU9ELFNBQVMsR0FBQ0MsaUJBQWlCLElBQUVMLGNBQWMsQ0FBQ0ssaUJBQUQsQ0FBbEMsR0FBc0RMLGNBQWMsQ0FBQ2hCLEtBQUQsQ0FBcEY7QUFBNkY7QUFBQTs7Ozs7OztpQ0FHN0V4TixJLEVBQUttRyxNLEVBQU87QUFBQTs7QUFBQSxrQkFBNEIsQ0FBQyxHQUFFMEcsSUFBSSxDQUFDdmdCLEtBQVIsRUFBZTBULElBQWYsRUFBb0IsSUFBcEIsQ0FBNUI7QUFBQSxVQUFjME8sWUFBZCxTQUFLalAsUUFBTDs7QUFBc0QsVUFBSStOLEtBQUssR0FBQ0QsY0FBYyxDQUFDbUIsWUFBRCxDQUF4QjtBQUF1QyxhQUFPLEtBQUtSLG1CQUFMLENBQXlCOVosSUFBekIsQ0FBOEIsVUFBQ3NiLENBQUQsRUFBR0MsU0FBSDtBQUFBLGVBQWU7QUFDL0tELFdBQUMsQ0FBQ0UsR0FBRixDQUFNcEMsS0FBTixPQUFlO0FBQ2ZtQyxtQkFBUyxHQUFDLE1BQUksQ0FBQ0UsV0FBTCxDQUFpQjdQLElBQWpCLEVBQXNCbUcsTUFBdEIsQ0FEVixLQUMwQztBQUMxQyxXQUFDOWIsUUFBUSxDQUFDK1YsYUFBVCxDQUF1QixnQkFBY2lOLFdBQWQsR0FBMEIsY0FBMUIsR0FBeUNzQyxTQUF6QyxHQUFtRCxLQUExRSxDQUZELElBRW1GO0FBQ25GbEMsb0JBQVUsQ0FBQ2tDLFNBQUQsRUFBV3RDLFdBQVgsRUFBdUIsT0FBdkI7QUFKc0o7QUFBQSxPQUE5QixDQUFQO0FBSS9FOzs7NkJBQVNHLEssRUFBTTtBQUFDLGFBQU8sS0FBS3RGLGNBQUwsQ0FBb0JzRixLQUFwQixDQUFQO0FBQW1DOzs7bUNBQWVBLEssRUFBTTtBQUFBOztBQUFDQSxXQUFLLEdBQUNELGNBQWMsQ0FBQ0MsS0FBRCxDQUFwQjtBQUE0QixhQUFPLElBQUl2VCxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFTQyxNQUFULEVBQWtCO0FBQUMsWUFBSXlDLElBQUksR0FBQyxTQUFMQSxJQUFLLENBQUNzQyxJQUFELEVBQVE7QUFBQSxjQUFLek0sS0FBTCxHQUFxQnlNLElBQXJCLENBQUt6TSxLQUFMO0FBQUEsY0FBV2dQLElBQVgsR0FBcUJ2QyxJQUFyQixDQUFXdUMsSUFBWDtBQUFBLGNBQWdCMkcsR0FBaEIsR0FBcUJsSixJQUFyQixDQUFnQmtKLEdBQWhCOztBQUEwQixnQkFBSSxDQUFDNEYsa0JBQUwsQ0FBd0I4QixHQUF4QixDQUE0QnRDLEtBQTVCLEVBQWtDNVEsSUFBbEM7O0FBQXdDLGlCQUFPLE1BQUksQ0FBQ3FSLGFBQUwsQ0FBbUJULEtBQW5CLENBQVA7O0FBQWlDLGNBQUcvYSxLQUFILEVBQVM7QUFBQzBILGtCQUFNLENBQUMxSCxLQUFELENBQU47QUFBZSxXQUF6QixNQUE2QjtBQUFDeUgsbUJBQU8sQ0FBQztBQUFDdUgsa0JBQUksRUFBSkEsSUFBRDtBQUFNMkcsaUJBQUcsRUFBSEE7QUFBTixhQUFELENBQVA7QUFBcUI7QUFBQyxTQUF4SyxDQUFELENBQTBLOzs7QUFDaFcsWUFBSTJILFVBQVUsR0FBQyxNQUFJLENBQUNoQyxTQUFMLENBQWVQLEtBQWYsQ0FBZjs7QUFBcUMsWUFBR3VDLFVBQUgsRUFBYztBQUFBLGNBQUt0ZCxLQUFMLEdBQXFCc2QsVUFBckIsQ0FBS3RkLEtBQUw7QUFBQSxjQUFXZ1AsSUFBWCxHQUFxQnNPLFVBQXJCLENBQVd0TyxJQUFYO0FBQUEsY0FBZ0IyRyxHQUFoQixHQUFxQjJILFVBQXJCLENBQWdCM0gsR0FBaEI7QUFBZ0MzVixlQUFLLEdBQUMwSCxNQUFNLENBQUMxSCxLQUFELENBQVAsR0FBZXlILE9BQU8sQ0FBQztBQUFDdUgsZ0JBQUksRUFBSkEsSUFBRDtBQUFNMkcsZUFBRyxFQUFIQTtBQUFOLFdBQUQsQ0FBM0I7QUFBd0M7QUFBUSxTQURtRCxDQUNuRDs7O0FBQ25JLGNBQUksQ0FBQzRGLGtCQUFMLENBQXdCMU8sRUFBeEIsQ0FBMkJrTyxLQUEzQixFQUFpQzVRLElBQWpDLEVBRnNMLENBRS9JO0FBQ3ZDOzs7QUFDQSxZQUFHdlMsUUFBUSxDQUFDK1YsYUFBVCxDQUF1Qiw2QkFBMkJvTixLQUEzQixHQUFpQyxLQUF4RCxDQUFILEVBQWtFO0FBQUM7QUFBUTs7QUFBQSxZQUFHLENBQUMsTUFBSSxDQUFDUyxhQUFMLENBQW1CVCxLQUFuQixDQUFKLEVBQThCO0FBQUMsZ0JBQUksQ0FBQ1MsYUFBTCxDQUFtQlQsS0FBbkIsSUFBMEIsSUFBMUI7O0FBQStCLGNBQUc5YSxLQUFILEVBQXNDLEVBQXRDLE1BRXBHO0FBQUMsa0JBQUksQ0FBQ3NkLFNBQUwsQ0FBZXhDLEtBQWY7QUFBdUI7QUFBQztBQUFDLE9BTnlGLENBQVA7QUFNL0U7Ozs4QkFBVUEsSyxFQUFNO0FBQUNBLFdBQUssR0FBQ0QsY0FBYyxDQUFDQyxLQUFELENBQXBCO0FBQTRCLFVBQUl5QyxXQUFXLEdBQUN6QyxLQUFLLEtBQUcsR0FBUixHQUFZLFdBQVosR0FBd0JBLEtBQUssR0FBQyxLQUE5QztBQUFvRCxVQUFJM1csR0FBRyxHQUFDLEtBQUtzSSxXQUFMLEdBQWlCLGdCQUFqQixHQUFrQ2Isa0JBQWtCLENBQUMsS0FBS3FILE9BQU4sQ0FBcEQsR0FBbUUsUUFBbkUsR0FBNEU0SSxTQUFTLENBQUMwQixXQUFELENBQTdGO0FBQTJHLFdBQUtDLFVBQUwsQ0FBZ0JyWixHQUFoQixFQUFvQjJXLEtBQXBCLEVBQTBCLElBQTFCO0FBQWlDOzs7K0JBQVczVyxHLEVBQUkyVyxLLEVBQU0yQyxNLEVBQU87QUFBQTs7QUFBQyxVQUFJQyxNQUFNLEdBQUMvbEIsUUFBUSxDQUFDQyxhQUFULENBQXVCLFFBQXZCLENBQVg7O0FBQTRDLFVBQUdvSSxLQUFILEVBQWdELEVBRXZYOztBQUFBMGQsWUFBTSxDQUFDdkMsV0FBUCxHQUFtQm5iLFNBQW5CO0FBQXVDMGQsWUFBTSxDQUFDQyxHQUFQLEdBQVd4WixHQUFYOztBQUFldVosWUFBTSxDQUFDcGlCLE9BQVAsR0FBZSxZQUFJO0FBQUMsWUFBSXlFLEtBQUssR0FBQyxJQUFJNEMsS0FBSixDQUFVLDBCQUF3QndCLEdBQWxDLENBQVY7QUFBaURwRSxhQUFLLENBQUM2ZCxJQUFOLEdBQVcsaUJBQVg7O0FBQTZCLGNBQUksQ0FBQ3RDLGtCQUFMLENBQXdCakMsSUFBeEIsQ0FBNkJ5QixLQUE3QixFQUFtQztBQUFDL2EsZUFBSyxFQUFMQTtBQUFELFNBQW5DO0FBQTZDLE9BQS9JOztBQUFnSnBJLGNBQVEsQ0FBQ1UsSUFBVCxDQUFjQyxXQUFkLENBQTBCb2xCLE1BQTFCO0FBQW1DLEssQ0FBQTs7OztpQ0FDN1E1QyxLLEVBQU0rQyxLLEVBQU07QUFBQTs7QUFBQyxVQUFJcmYsUUFBUSxHQUFDLFNBQVRBLFFBQVMsR0FBSTtBQUFDLFlBQUc7QUFBQyxjQUFJa1gsR0FBRyxHQUFDbUksS0FBSyxFQUFiO0FBQWdCLGNBQUlDLFFBQVEsR0FBQztBQUFDL08sZ0JBQUksRUFBQzJHLEdBQUcsV0FBSCxJQUFhQSxHQUFuQjtBQUF1QkEsZUFBRyxFQUFIQTtBQUF2QixXQUFiO0FBQXlDLGdCQUFJLENBQUMyRixTQUFMLENBQWVQLEtBQWYsSUFBc0JnRCxRQUF0Qjs7QUFBK0IsZ0JBQUksQ0FBQ3hDLGtCQUFMLENBQXdCakMsSUFBeEIsQ0FBNkJ5QixLQUE3QixFQUFtQ2dELFFBQW5DO0FBQThDLFNBQTFJLENBQTBJLE9BQU0vZCxLQUFOLEVBQVk7QUFBQyxnQkFBSSxDQUFDc2IsU0FBTCxDQUFlUCxLQUFmLElBQXNCO0FBQUMvYSxpQkFBSyxFQUFMQTtBQUFELFdBQXRCOztBQUE4QixnQkFBSSxDQUFDdWIsa0JBQUwsQ0FBd0JqQyxJQUF4QixDQUE2QnlCLEtBQTdCLEVBQW1DO0FBQUMvYSxpQkFBSyxFQUFMQTtBQUFELFdBQW5DO0FBQTZDO0FBQUMsT0FBclA7O0FBQXNQLGdCQUF1QztBQUFDO0FBQ3hUO0FBQ0EsWUFBR25KLEtBQUEsSUFBWUEsTUFBTSxDQUFDa0ssR0FBUCxDQUFXQyxNQUFYLE9BQXNCLE1BQXJDLEVBQTRDO0FBQUN0RixpQkFBTyxDQUFDRCxHQUFSLENBQVksc0VBQW9Fc2YsS0FBcEUsR0FBMEUsSUFBdEY7O0FBQTRGLGNBQUlyWixLQUFLLEdBQUMsU0FBTkEsS0FBTSxDQUFBVixNQUFNLEVBQUU7QUFBQyxnQkFBR0EsTUFBTSxLQUFHLE1BQVosRUFBbUI7QUFBQ25LLG9CQUFNLENBQUNrSyxHQUFQLENBQVdHLG1CQUFYLENBQStCUSxLQUEvQjtBQUFzQ2pELHNCQUFRO0FBQUk7QUFBQyxXQUExRjs7QUFBMkY1SCxnQkFBTSxDQUFDa0ssR0FBUCxDQUFXQyxNQUFYLENBQWtCVSxLQUFsQjtBQUF5QjtBQUFRO0FBQUM7O0FBQUFqRCxjQUFRO0FBQUk7QUFBQTs7Ozs7Ozs2QkFHcFFzYyxLLEVBQU1pRCxZLEVBQWE7QUFBQTs7QUFBQztBQUNsQztBQUNBLFVBQUlDLEVBQUo7O0FBQU8sVUFBR0EsRUFBRSxHQUFDQyxTQUFTLENBQUNDLFVBQWhCLEVBQTJCO0FBQUM7QUFDbkMsWUFBR0YsRUFBRSxDQUFDRyxRQUFILElBQWEsS0FBS3ZoQixJQUFMLENBQVVvaEIsRUFBRSxDQUFDSSxhQUFiLENBQWhCLEVBQTRDLE9BQU83VyxPQUFPLENBQUNDLE9BQVIsRUFBUDtBQUEwQjtBQUFBOzs7QUFBcUIsVUFBSXJELEdBQUo7O0FBQVEsVUFBRzRaLFlBQUgsRUFBZ0I7QUFBQzVaLFdBQUcsR0FBQzJXLEtBQUo7QUFBVyxPQUE1QixNQUFnQztBQUFDQSxhQUFLLEdBQUNELGNBQWMsQ0FBQ0MsS0FBRCxDQUFwQjtBQUE0QixZQUFJeUMsV0FBVyxHQUFDLENBQUN6QyxLQUFLLEtBQUcsR0FBUixHQUFZLFFBQVosR0FBcUJBLEtBQXRCLElBQTZCLEtBQTdDOztBQUFtRCxZQUFHOWEsS0FBSCxFQUFnRCxFQUF3RDs7QUFBQW1FLFdBQUcsR0FBQyxLQUFLc0ksV0FBTCxHQUFpQixnQkFBakIsR0FBa0NiLGtCQUFrQixDQUFDLEtBQUtxSCxPQUFOLENBQXBELEdBQW1FLFFBQW5FLEdBQTRFNEksU0FBUyxDQUFDMEIsV0FBRCxDQUF6RjtBQUF3Rzs7QUFBQSxhQUFPaFcsT0FBTyxDQUFDNUIsR0FBUixDQUFZaE8sUUFBUSxDQUFDK1YsYUFBVCxDQUF1QixnQkFBY2lOLFdBQWQsR0FBMEIsY0FBMUIsR0FBeUN4VyxHQUF6QyxHQUE2QywrQkFBN0MsR0FBNkUyVyxLQUE3RSxHQUFtRixLQUExRyxJQUFpSCxFQUFqSCxHQUFvSCxDQUFDQyxVQUFVLENBQUM1VyxHQUFELEVBQUt3VyxXQUFMLEVBQWlCeFcsR0FBRyxDQUFDOUcsS0FBSixDQUFVLFFBQVYsSUFBb0IsT0FBcEIsR0FBNEIsUUFBN0MsQ0FBWCxFQUFrRTJDLE1BQUEsSUFBbUQsS0FBckgsQ0FBaEksRUFBbVYwQixJQUFuVixFQUF3VjtBQUNsd0Isa0JBQUksQ0FBRSxDQURvYSxFQUNuYTtBQUNQLGtCQUFJLENBQUUsQ0FGb2EsQ0FBUDtBQUUxWjs7Ozs7O0FBQUM3SyxPQUFPLFdBQVAsR0FBZ0J1a0IsVUFBaEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNDViw4Q0FBYTs7QUFBQXZrQixPQUFPLENBQUNVLFVBQVIsR0FBbUIsSUFBbkI7QUFBd0JWLE9BQU8sV0FBUCxHQUFnQixLQUFLLENBQXJCOztBQUF1QixJQUFJd25CLFVBQVUsR0FBQ2puQixtQkFBTyxDQUFDLHdFQUFELENBQXRCOztBQUFxQyxJQUFJMFUsUUFBUSxHQUFDLFNBQVRBLFFBQVMsQ0FBQXdJLFdBQVcsRUFBRTtBQUFDLEdBQUMsR0FBRStKLFVBQVUsQ0FBQ0MsTUFBZCxFQUFzQmhLLFdBQXRCO0FBQW1DLEdBQUMsR0FBRStKLFVBQVUsQ0FBQ0UsTUFBZCxFQUFzQmpLLFdBQXRCO0FBQW1DLEdBQUMsR0FBRStKLFVBQVUsQ0FBQ0csTUFBZCxFQUFzQmxLLFdBQXRCO0FBQW1DLEdBQUMsR0FBRStKLFVBQVUsQ0FBQ0ksTUFBZCxFQUFzQm5LLFdBQXRCO0FBQW1DLEdBQUMsR0FBRStKLFVBQVUsQ0FBQ0ssT0FBZCxFQUF1QnBLLFdBQXZCO0FBQXFDLENBQTVNOztBQUE2TXpkLE9BQU8sV0FBUCxHQUFnQmlWLFFBQWhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBOVMsOENBQWE7Ozs7Ozs7Ozs7OztBQUFBLElBQUk3Tix1QkFBdUIsR0FBQzdHLG1CQUFPLENBQUMsc0hBQUQsQ0FBbkM7O0FBQXFGLElBQUk0RyxzQkFBc0IsR0FBQzVHLG1CQUFPLENBQUMsb0hBQUQsQ0FBbEM7O0FBQW1GUCxPQUFPLENBQUNVLFVBQVIsR0FBbUIsSUFBbkI7QUFBd0JWLE9BQU8sQ0FBQzhuQixTQUFSLEdBQWtCQSxTQUFsQjtBQUE0QjluQixPQUFPLENBQUNraUIsd0JBQVIsR0FBaUNBLHdCQUFqQztBQUEwRGxpQixPQUFPLENBQUNpZ0IsWUFBUixHQUFxQmpnQixPQUFPLENBQUMrbkIsVUFBUixHQUFtQi9uQixPQUFPLFdBQVAsR0FBZ0IsS0FBSyxDQUE3RDs7QUFBK0QsSUFBSXViLE1BQU0sR0FBQ3BVLHNCQUFzQixDQUFDNUcsbUJBQU8sQ0FBQyw0Q0FBRCxDQUFSLENBQWpDOztBQUFvRCxJQUFJeW5CLFFBQVEsR0FBQzVnQix1QkFBdUIsQ0FBQzdHLG1CQUFPLENBQUMsbUdBQUQsQ0FBUixDQUFwQzs7QUFBa0ZQLE9BQU8sQ0FBQ2lvQixNQUFSLEdBQWVELFFBQVEsV0FBdkI7QUFBZ0Nob0IsT0FBTyxDQUFDa29CLFVBQVIsR0FBbUJGLFFBQVEsQ0FBQ0UsVUFBNUI7O0FBQXVDLElBQUl2TSxjQUFjLEdBQUNwYixtQkFBTyxDQUFDLHFHQUFELENBQTFCOztBQUFnRSxJQUFJNG5CLFdBQVcsR0FBQ2hoQixzQkFBc0IsQ0FBQzVHLG1CQUFPLENBQUMscUVBQUQsQ0FBUixDQUF0Qzs7QUFBaUVQLE9BQU8sQ0FBQytuQixVQUFSLEdBQW1CSSxXQUFXLFdBQTlCO0FBQXVDOztBQUFtQixJQUFJQyxlQUFlLEdBQUM7QUFBQ2pRLFFBQU0sRUFBQyxJQUFSO0FBQWE7QUFDM3dCa1EsZ0JBQWMsRUFBQyxFQUQrdUI7QUFDNXVCeFMsT0FENHVCLGlCQUN0dUI1USxFQURzdUIsRUFDbnVCO0FBQUMsUUFBRyxLQUFLa1QsTUFBUixFQUFlLE9BQU9sVCxFQUFFLEVBQVQ7O0FBQVksY0FBK0I7QUFBQyxXQUFLb2pCLGNBQUwsQ0FBb0JoakIsSUFBcEIsQ0FBeUJKLEVBQXpCO0FBQThCO0FBQUM7QUFEd29CLENBQXBCLEMsQ0FDbG5COztBQUN4SCxJQUFJcWpCLGlCQUFpQixHQUFDLENBQUMsVUFBRCxFQUFZLE9BQVosRUFBb0IsT0FBcEIsRUFBNEIsUUFBNUIsRUFBcUMsWUFBckMsRUFBa0QsWUFBbEQsRUFBK0QsVUFBL0QsQ0FBdEI7QUFBaUcsSUFBSUMsWUFBWSxHQUFDLENBQUMsa0JBQUQsRUFBb0IscUJBQXBCLEVBQTBDLHFCQUExQyxFQUFnRSxrQkFBaEUsRUFBbUYsaUJBQW5GLEVBQXFHLG9CQUFyRyxDQUFqQjtBQUE0SSxJQUFJQyxnQkFBZ0IsR0FBQyxDQUFDLE1BQUQsRUFBUSxTQUFSLEVBQWtCLFFBQWxCLEVBQTJCLE1BQTNCLEVBQWtDLFVBQWxDLEVBQTZDLGdCQUE3QyxDQUFyQixDLENBQW9GOztBQUNqVXpaLE1BQU0sQ0FBQzBaLGNBQVAsQ0FBc0JMLGVBQXRCLEVBQXNDLFFBQXRDLEVBQStDO0FBQUNoWixLQUFELGlCQUFNO0FBQUMsV0FBTzRZLFFBQVEsV0FBUixDQUFpQmxTLE1BQXhCO0FBQWdDO0FBQXZDLENBQS9DO0FBQXlGd1MsaUJBQWlCLENBQUN0akIsT0FBbEIsQ0FBMEIsVUFBQTZQLEtBQUssRUFBRTtBQUFDO0FBQzNIO0FBQ0E7QUFDQTtBQUNBOUYsUUFBTSxDQUFDMFosY0FBUCxDQUFzQkwsZUFBdEIsRUFBc0N2VCxLQUF0QyxFQUE0QztBQUFDekYsT0FBRCxpQkFBTTtBQUFDLFVBQUkrSSxNQUFNLEdBQUN1USxTQUFTLEVBQXBCO0FBQXVCLGFBQU92USxNQUFNLENBQUN0RCxLQUFELENBQWI7QUFBc0I7QUFBcEQsR0FBNUM7QUFBb0csQ0FKWDtBQUlhMlQsZ0JBQWdCLENBQUN4akIsT0FBakIsQ0FBeUIsVUFBQTZQLEtBQUssRUFBRTtBQUFDO0FBQ3ZJOztBQUFDdVQsaUJBQWUsQ0FBQ3ZULEtBQUQsQ0FBZixHQUF1QixZQUFVO0FBQUMsUUFBSXNELE1BQU0sR0FBQ3VRLFNBQVMsRUFBcEI7QUFBdUIsV0FBT3ZRLE1BQU0sQ0FBQ3RELEtBQUQsQ0FBTixPQUFBc0QsTUFBTSxFQUFXd1EsU0FBWCxDQUFiO0FBQW9DLEdBQTdGO0FBQStGLENBRE07QUFDSkosWUFBWSxDQUFDdmpCLE9BQWIsQ0FBcUIsVUFBQXZDLEtBQUssRUFBRTtBQUFDMmxCLGlCQUFlLENBQUN2UyxLQUFoQixDQUFzQixZQUFJO0FBQUNtUyxZQUFRLFdBQVIsQ0FBaUJsUyxNQUFqQixDQUF3QkMsRUFBeEIsQ0FBMkJ0VCxLQUEzQixFQUFpQyxZQUFVO0FBQUMsVUFBSW1tQixVQUFVLEdBQUMsT0FBS25tQixLQUFLLENBQUNvbUIsTUFBTixDQUFhLENBQWIsRUFBZ0JDLFdBQWhCLEVBQUwsR0FBbUNybUIsS0FBSyxDQUFDNmIsU0FBTixDQUFnQixDQUFoQixDQUFsRDtBQUFxRSxVQUFJeUssZ0JBQWdCLEdBQUNYLGVBQXJCOztBQUFxQyxVQUFHVyxnQkFBZ0IsQ0FBQ0gsVUFBRCxDQUFuQixFQUFnQztBQUFDLFlBQUc7QUFBQ0csMEJBQWdCLENBQUNILFVBQUQsQ0FBaEIsT0FBQUcsZ0JBQWdCLEVBQWdCSixTQUFoQixDQUFoQjtBQUE0QyxTQUFoRCxDQUFnRCxPQUFNbmUsR0FBTixFQUFVO0FBQUM7QUFDNVk1RixpQkFBTyxDQUFDc0UsS0FBUixDQUFjLDBDQUF3QzBmLFVBQXRELEVBRDJZLENBQ3pVOztBQUNsRWhrQixpQkFBTyxDQUFDc0UsS0FBUixDQUFjc0IsR0FBRyxDQUFDL0UsT0FBSixHQUFZLElBQVosR0FBaUIrRSxHQUFHLENBQUNzVixLQUFuQztBQUEyQztBQUFDO0FBQUMsS0FGNkc7QUFFMUcsR0FGK0U7QUFFNUUsQ0FGK0M7O0FBRTdDLFNBQVM0SSxTQUFULEdBQW9CO0FBQUMsTUFBRyxDQUFDTixlQUFlLENBQUNqUSxNQUFwQixFQUEyQjtBQUFDLFFBQUkxUyxPQUFPLEdBQUMsZ0NBQThCLHlFQUExQztBQUFvSCxVQUFNLElBQUlxRyxLQUFKLENBQVVyRyxPQUFWLENBQU47QUFBMEI7O0FBQUEsU0FBTzJpQixlQUFlLENBQUNqUSxNQUF2QjtBQUErQixDLENBQUE7OztBQUNuUixJQUFJbEQsUUFBUSxHQUFDbVQsZUFBYixDLENBQTZCOztBQUM3QnBvQixPQUFPLFdBQVAsR0FBZ0JpVixRQUFoQjs7QUFBeUIsU0FBUzZTLFNBQVQsR0FBb0I7QUFBQTs7QUFBQyxTQUFPdk0sTUFBTSxXQUFOLENBQWV5TixVQUFmLENBQTBCck4sY0FBYyxDQUFDcUcsYUFBekMsQ0FBUDtBQUFnRSxDLENBQUE7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0dBTGtDOEYsUzs7QUFNbEMsSUFBSTdILFlBQVksR0FBQyxTQUFTQSxZQUFULEdBQXVCO0FBQUMsT0FBSSxJQUFJZ0osSUFBSSxHQUFDTixTQUFTLENBQUM3akIsTUFBbkIsRUFBMEJva0IsSUFBSSxHQUFDLElBQUlqRCxLQUFKLENBQVVnRCxJQUFWLENBQS9CLEVBQStDRSxJQUFJLEdBQUMsQ0FBeEQsRUFBMERBLElBQUksR0FBQ0YsSUFBL0QsRUFBb0VFLElBQUksRUFBeEUsRUFBMkU7QUFBQ0QsUUFBSSxDQUFDQyxJQUFELENBQUosR0FBV1IsU0FBUyxDQUFDUSxJQUFELENBQXBCO0FBQTRCOztBQUFBZixpQkFBZSxDQUFDalEsTUFBaEIsY0FBMkI2UCxRQUFRLFdBQW5DLEVBQStDa0IsSUFBL0M7QUFBcURkLGlCQUFlLENBQUNDLGNBQWhCLENBQStCcmpCLE9BQS9CLENBQXVDLFVBQUFDLEVBQUU7QUFBQSxXQUFFQSxFQUFFLEVBQUo7QUFBQSxHQUF6QztBQUFpRG1qQixpQkFBZSxDQUFDQyxjQUFoQixHQUErQixFQUEvQjtBQUFrQyxTQUFPRCxlQUFlLENBQUNqUSxNQUF2QjtBQUErQixDQUF4VCxDLENBQXlUOzs7QUFDelRuWSxPQUFPLENBQUNpZ0IsWUFBUixHQUFxQkEsWUFBckI7O0FBQWtDLFNBQVNpQyx3QkFBVCxDQUFrQy9KLE1BQWxDLEVBQXlDO0FBQUMsTUFBSTFDLE9BQU8sR0FBQzBDLE1BQVo7QUFBbUIsTUFBSWlSLFFBQVEsR0FBQyxFQUFiOztBQUFwQiw2Q0FBd0RkLGlCQUF4RDtBQUFBOztBQUFBO0FBQW9DLHdEQUFzQztBQUFBLFVBQTlCZSxRQUE4Qjs7QUFBQyxVQUFHLE9BQU81VCxPQUFPLENBQUM0VCxRQUFELENBQWQsS0FBMkIsUUFBOUIsRUFBdUM7QUFBQ0QsZ0JBQVEsQ0FBQ0MsUUFBRCxDQUFSLEdBQW1CdGEsTUFBTSxDQUFDdWEsTUFBUCxDQUFjLEVBQWQsRUFBaUI3VCxPQUFPLENBQUM0VCxRQUFELENBQXhCLENBQW5CLENBQUQsQ0FBd0Q7O0FBQ3JQO0FBQVU7O0FBQUFELGNBQVEsQ0FBQ0MsUUFBRCxDQUFSLEdBQW1CNVQsT0FBTyxDQUFDNFQsUUFBRCxDQUExQjtBQUFzQyxLQUQyQixDQUMzQjs7QUFEMkI7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFM0VELFVBQVEsQ0FBQ3RULE1BQVQsR0FBZ0JrUyxRQUFRLFdBQVIsQ0FBaUJsUyxNQUFqQztBQUF3QzBTLGtCQUFnQixDQUFDeGpCLE9BQWpCLENBQXlCLFVBQUE2UCxLQUFLLEVBQUU7QUFBQ3VVLFlBQVEsQ0FBQ3ZVLEtBQUQsQ0FBUixHQUFnQixZQUFVO0FBQUMsYUFBT1ksT0FBTyxDQUFDWixLQUFELENBQVAsT0FBQVksT0FBTyxFQUFXa1QsU0FBWCxDQUFkO0FBQXFDLEtBQWhFO0FBQWtFLEdBQW5HO0FBQXFHLFNBQU9TLFFBQVA7QUFBaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JCOUosOENBQWE7O0FBQUEsSUFBSWppQixzQkFBc0IsR0FBQzVHLG1CQUFPLENBQUMsb0hBQUQsQ0FBbEM7O0FBQW1GUCxPQUFPLENBQUNVLFVBQVIsR0FBbUIsSUFBbkI7QUFBd0JWLE9BQU8sV0FBUCxHQUFnQituQixVQUFoQjs7QUFBMkIsSUFBSXhNLE1BQU0sR0FBQ3BVLHNCQUFzQixDQUFDNUcsbUJBQU8sQ0FBQyw0Q0FBRCxDQUFSLENBQWpDOztBQUFvRCxJQUFJa1YsT0FBTyxHQUFDbFYsbUJBQU8sQ0FBQywyREFBRCxDQUFuQjs7QUFBZ0MsU0FBU3duQixVQUFULENBQW9Cd0IsaUJBQXBCLEVBQXNDO0FBQUMsV0FBU0MsaUJBQVQsQ0FBMkIzUSxLQUEzQixFQUFpQztBQUFDLFdBQU0sYUFBYTBDLE1BQU0sV0FBTixDQUFleGEsYUFBZixDQUE2QndvQixpQkFBN0IsRUFBK0N4YSxNQUFNLENBQUN1YSxNQUFQLENBQWM7QUFBQ25SLFlBQU0sRUFBQyxDQUFDLEdBQUUxQyxPQUFPLENBQUNxUyxTQUFYO0FBQVIsS0FBZCxFQUErQ2pQLEtBQS9DLENBQS9DLENBQW5CO0FBQTBIOztBQUFBMlEsbUJBQWlCLENBQUNDLGVBQWxCLEdBQWtDRixpQkFBaUIsQ0FBQ0UsZUFBcEQsQ0FBbUU7QUFBbkU7QUFDemFELG1CQUFpQixDQUFDRSxtQkFBbEIsR0FBc0NILGlCQUFpQixDQUFDRyxtQkFBeEQ7O0FBQTRFLFlBQXVDO0FBQUMsUUFBSXRiLElBQUksR0FBQ21iLGlCQUFpQixDQUFDSSxXQUFsQixJQUErQkosaUJBQWlCLENBQUNuYixJQUFqRCxJQUF1RCxTQUFoRTtBQUEwRW9iLHFCQUFpQixDQUFDRyxXQUFsQixHQUE4QixnQkFBY3ZiLElBQWQsR0FBbUIsR0FBakQ7QUFBc0Q7O0FBQUEsU0FBT29iLGlCQUFQO0FBQTBCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0QvUXpwQiwrREFBTSxDQUFDQyxPQUFQLEdBQWUsVUFBUzBKLENBQVQsRUFBV3FULENBQVgsRUFBYTtBQUFDOztBQUFhLE1BQUkxQyxDQUFDLEdBQUMsRUFBTjs7QUFBUyxXQUFTdVAsbUJBQVQsQ0FBNkI3TSxDQUE3QixFQUErQjtBQUFDLFFBQUcxQyxDQUFDLENBQUMwQyxDQUFELENBQUosRUFBUTtBQUFDLGFBQU8xQyxDQUFDLENBQUMwQyxDQUFELENBQUQsQ0FBSy9jLE9BQVo7QUFBb0I7O0FBQUEsUUFBSStTLENBQUMsR0FBQ3NILENBQUMsQ0FBQzBDLENBQUQsQ0FBRCxHQUFLO0FBQUNsWSxPQUFDLEVBQUNrWSxDQUFIO0FBQUs4TSxPQUFDLEVBQUMsS0FBUDtBQUFhN3BCLGFBQU8sRUFBQztBQUFyQixLQUFYO0FBQW9DMEosS0FBQyxDQUFDcVQsQ0FBRCxDQUFELENBQUtqTixJQUFMLENBQVVpRCxDQUFDLENBQUMvUyxPQUFaLEVBQW9CK1MsQ0FBcEIsRUFBc0JBLENBQUMsQ0FBQy9TLE9BQXhCLEVBQWdDNHBCLG1CQUFoQztBQUFxRDdXLEtBQUMsQ0FBQzhXLENBQUYsR0FBSSxJQUFKO0FBQVMsV0FBTzlXLENBQUMsQ0FBQy9TLE9BQVQ7QUFBaUI7O0FBQUE0cEIscUJBQW1CLENBQUNFLEVBQXBCLEdBQXVCQyxTQUFTLEdBQUMsR0FBakM7O0FBQXFDLFdBQVNDLE9BQVQsR0FBa0I7QUFBQyxXQUFPSixtQkFBbUIsQ0FBQyxHQUFELENBQTFCO0FBQWdDOztBQUFBLFNBQU9JLE9BQU8sRUFBZDtBQUFpQixDQUE3VCxDQUE4VDtBQUFDLE9BQUksV0FBU3RnQixDQUFULEVBQVc7QUFBQzs7QUFBYUEsS0FBQyxDQUFDMUosT0FBRixHQUFXLFlBQTBCO0FBQUEscUZBQUwsRUFBSztBQUFBLGdDQUF4QkMsU0FBd0I7QUFBQSxVQUFkeUosQ0FBYywrQkFBWixLQUFZOztBQUFDLFVBQU1xVCxDQUFDLEdBQUMsQ0FBQyw2RkFBRCxFQUErRiwwREFBL0YsRUFBMko1YyxJQUEzSixDQUFnSyxHQUFoSyxDQUFSO0FBQTZLLGFBQU8sSUFBSUMsTUFBSixDQUFXMmMsQ0FBWCxFQUFhclQsQ0FBQyxHQUFDckosU0FBRCxHQUFXLEdBQXpCLENBQVA7QUFBcUMsS0FBeFA7QUFBMFAsR0FBeFI7QUFBeVIsT0FBSSxXQUFTcUosQ0FBVCxFQUFXcVQsQ0FBWCxFQUFhMUMsQ0FBYixFQUFlO0FBQUM7O0FBQWEsUUFBTXRILENBQUMsR0FBQ3NILENBQUMsQ0FBQyxHQUFELENBQVQ7O0FBQWUzUSxLQUFDLENBQUMxSixPQUFGLEdBQVcsVUFBQTBKLENBQUM7QUFBQSxhQUFFLE9BQU9BLENBQVAsS0FBVyxRQUFYLEdBQW9CQSxDQUFDLENBQUNqSixPQUFGLENBQVVzUyxDQUFDLEVBQVgsRUFBYyxFQUFkLENBQXBCLEdBQXNDckosQ0FBeEM7QUFBQSxLQUFaO0FBQXVEO0FBQWhZLENBQTlULENBQWY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBLDhDQUFhOztBQUNiLElBQUl1Z0IsWUFBWSxHQUFJLFFBQVEsS0FBS0EsWUFBZCxJQUErQixVQUFVcEwsR0FBVixFQUFlO0FBQzdELE1BQUlBLEdBQUcsSUFBSUEsR0FBRyxDQUFDbmUsVUFBZixFQUEyQixPQUFPbWUsR0FBUDtBQUMzQixNQUFJNVgsTUFBTSxHQUFHLEVBQWI7QUFDQSxNQUFJNFgsR0FBRyxJQUFJLElBQVgsRUFBaUIsS0FBSyxJQUFJdlMsQ0FBVCxJQUFjdVMsR0FBZDtBQUFtQixRQUFJOVAsTUFBTSxDQUFDYyxjQUFQLENBQXNCQyxJQUF0QixDQUEyQitPLEdBQTNCLEVBQWdDdlMsQ0FBaEMsQ0FBSixFQUF3Q3JGLE1BQU0sQ0FBQ3FGLENBQUQsQ0FBTixHQUFZdVMsR0FBRyxDQUFDdlMsQ0FBRCxDQUFmO0FBQTNEO0FBQ2pCckYsUUFBTSxDQUFDLFNBQUQsQ0FBTixHQUFvQjRYLEdBQXBCO0FBQ0EsU0FBTzVYLE1BQVA7QUFDSCxDQU5EOztBQU9BOEgsTUFBTSxDQUFDMFosY0FBUCxDQUFzQnpvQixPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFc08sT0FBSyxFQUFFO0FBQVQsQ0FBN0M7O0FBQ0EsSUFBTTRiLEtBQUssR0FBR0QsWUFBWSxDQUFDMXBCLG1CQUFPLENBQUMsNENBQUQsQ0FBUixDQUExQjs7QUFDQVAsT0FBTyxDQUFDbWlCLGtCQUFSLEdBQTZCK0gsS0FBSyxDQUFDQyxhQUFOLENBQW9CLElBQXBCLENBQTdCOztBQUNBLFVBQTJDO0FBQ3ZDbnFCLFNBQU8sQ0FBQ21pQixrQkFBUixDQUEyQndILFdBQTNCLEdBQXlDLG9CQUF6QztBQUNIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNiRCw4Q0FBYTtBQUNiOzs7Ozs7Ozs7Ozs7QUFXQTVhLE1BQU0sQ0FBQzBaLGNBQVAsQ0FBc0J6b0IsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRXNPLE9BQUssRUFBRTtBQUFULENBQTdDOztBQUNBLFNBQVM4YixJQUFULEdBQWdCO0FBQ1osTUFBTXRiLEdBQUcsR0FBR0MsTUFBTSxDQUFDQyxNQUFQLENBQWMsSUFBZCxDQUFaO0FBQ0EsU0FBTztBQUNIK0csTUFERyxjQUNBekUsSUFEQSxFQUNNdEosT0FETixFQUNlO0FBQ2Q7QUFDQSxPQUFDOEcsR0FBRyxDQUFDd0MsSUFBRCxDQUFILEtBQWN4QyxHQUFHLENBQUN3QyxJQUFELENBQUgsR0FBWSxFQUExQixDQUFELEVBQWdDak0sSUFBaEMsQ0FBcUMyQyxPQUFyQztBQUNILEtBSkU7QUFLSHVlLE9BTEcsZUFLQ2pWLElBTEQsRUFLT3RKLE9BTFAsRUFLZ0I7QUFDZixVQUFJOEcsR0FBRyxDQUFDd0MsSUFBRCxDQUFQLEVBQWU7QUFDWDtBQUNBeEMsV0FBRyxDQUFDd0MsSUFBRCxDQUFILENBQVUvSyxNQUFWLENBQWlCdUksR0FBRyxDQUFDd0MsSUFBRCxDQUFILENBQVV2TSxPQUFWLENBQWtCaUQsT0FBbEIsTUFBK0IsQ0FBaEQsRUFBbUQsQ0FBbkQ7QUFDSDtBQUNKLEtBVkU7QUFXSHdhLFFBWEcsZ0JBV0VsUixJQVhGLEVBV2lCO0FBQUEsd0NBQU4rWSxJQUFNO0FBQU5BLFlBQU07QUFBQTs7QUFDaEI7QUFDQTtBQUNBLE9BQUN2YixHQUFHLENBQUN3QyxJQUFELENBQUgsSUFBYSxFQUFkLEVBQWtCMUIsS0FBbEIsR0FBMEI1SixHQUExQixDQUE4QixVQUFDZ0MsT0FBRCxFQUFhO0FBQ3ZDQSxlQUFPLE1BQVAsU0FBV3FpQixJQUFYO0FBQ0gsT0FGRDtBQUdIO0FBakJFLEdBQVA7QUFtQkg7O0FBQ0RycUIsT0FBTyxXQUFQLEdBQWtCb3FCLElBQWxCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuQ0EsOENBQWE7O0FBQ2IsSUFBSUgsWUFBWSxHQUFJLFFBQVEsS0FBS0EsWUFBZCxJQUErQixVQUFVcEwsR0FBVixFQUFlO0FBQzdELE1BQUlBLEdBQUcsSUFBSUEsR0FBRyxDQUFDbmUsVUFBZixFQUEyQixPQUFPbWUsR0FBUDtBQUMzQixNQUFJNVgsTUFBTSxHQUFHLEVBQWI7QUFDQSxNQUFJNFgsR0FBRyxJQUFJLElBQVgsRUFBaUIsS0FBSyxJQUFJdlMsQ0FBVCxJQUFjdVMsR0FBZDtBQUFtQixRQUFJOVAsTUFBTSxDQUFDYyxjQUFQLENBQXNCQyxJQUF0QixDQUEyQitPLEdBQTNCLEVBQWdDdlMsQ0FBaEMsQ0FBSixFQUF3Q3JGLE1BQU0sQ0FBQ3FGLENBQUQsQ0FBTixHQUFZdVMsR0FBRyxDQUFDdlMsQ0FBRCxDQUFmO0FBQTNEO0FBQ2pCckYsUUFBTSxDQUFDLFNBQUQsQ0FBTixHQUFvQjRYLEdBQXBCO0FBQ0EsU0FBTzVYLE1BQVA7QUFDSCxDQU5EOztBQU9BOEgsTUFBTSxDQUFDMFosY0FBUCxDQUFzQnpvQixPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFc08sT0FBSyxFQUFFO0FBQVQsQ0FBN0M7O0FBQ0EsSUFBTTRiLEtBQUssR0FBR0QsWUFBWSxDQUFDMXBCLG1CQUFPLENBQUMsNENBQUQsQ0FBUixDQUExQjs7QUFDQVAsT0FBTyxDQUFDZ2lCLGFBQVIsR0FBd0JrSSxLQUFLLENBQUNDLGFBQU4sQ0FBb0IsSUFBcEIsQ0FBeEI7O0FBQ0EsVUFBMkM7QUFDdkNucUIsU0FBTyxDQUFDZ2lCLGFBQVIsQ0FBc0IySCxXQUF0QixHQUFvQyxlQUFwQztBQUNIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNiRCw4Q0FBYTs7Ozs7Ozs7Ozs7O0FBQ2IsSUFBSVcsZUFBZSxHQUFJLFFBQVEsS0FBS0EsZUFBZCxJQUFrQyxVQUFVekwsR0FBVixFQUFlO0FBQ25FLFNBQVFBLEdBQUcsSUFBSUEsR0FBRyxDQUFDbmUsVUFBWixHQUEwQm1lLEdBQTFCLEdBQWdDO0FBQUUsZUFBV0E7QUFBYixHQUF2QztBQUNILENBRkQ7O0FBR0E5UCxNQUFNLENBQUMwWixjQUFQLENBQXNCem9CLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVzTyxPQUFLLEVBQUU7QUFBVCxDQUE3Qzs7QUFDQSxJQUFNaWMsS0FBSyxHQUFHaHFCLG1CQUFPLENBQUMsb0RBQUQsQ0FBckI7O0FBQ0EsSUFBTWlxQixNQUFNLEdBQUdGLGVBQWUsQ0FBQy9wQixtQkFBTyxDQUFDLGlFQUFELENBQVIsQ0FBOUI7O0FBQ0EsSUFBTWtxQixPQUFPLEdBQUdscUIsbUJBQU8sQ0FBQyxtRUFBRCxDQUF2Qjs7QUFDQSxJQUFNbXFCLFlBQVksR0FBR25xQixtQkFBTyxDQUFDLCtGQUFELENBQTVCOztBQUNBLElBQU1vcUIsZUFBZSxHQUFHcHFCLG1CQUFPLENBQUMscUdBQUQsQ0FBL0I7O0FBQ0EsSUFBTXFxQixhQUFhLEdBQUdycUIsbUJBQU8sQ0FBQyxpR0FBRCxDQUE3Qjs7QUFDQSxJQUFNc3FCLFFBQVEsR0FBRzFoQixNQUFBLElBQXNDLEVBQXZEOztBQUNBLFNBQVMyaEIsV0FBVCxDQUFxQnZvQixJQUFyQixFQUEyQjtBQUN2QixTQUFPQSxJQUFJLENBQUN3QyxPQUFMLENBQWE4bEIsUUFBYixNQUEyQixDQUEzQixHQUErQkEsUUFBUSxHQUFHdG9CLElBQTFDLEdBQWlEQSxJQUF4RDtBQUNIOztBQUNEdkMsT0FBTyxDQUFDOHFCLFdBQVIsR0FBc0JBLFdBQXRCOztBQUNBLFNBQVM1RixXQUFULENBQXFCM2lCLElBQXJCLEVBQTJCO0FBQ3ZCLFNBQU9BLElBQUksQ0FBQ3dDLE9BQUwsQ0FBYThsQixRQUFiLE1BQTJCLENBQTNCLEdBQ0R0b0IsSUFBSSxDQUFDMGIsTUFBTCxDQUFZNE0sUUFBUSxDQUFDL2xCLE1BQXJCLEtBQWdDLEdBRC9CLEdBRUR2QyxJQUZOO0FBR0g7O0FBQ0R2QyxPQUFPLENBQUNrbEIsV0FBUixHQUFzQkEsV0FBdEI7O0FBQ0EsU0FBUzZGLE9BQVQsQ0FBaUJ4b0IsSUFBakIsRUFBdUI7QUFDbkIsU0FBT0EsSUFBSSxDQUFDOUIsT0FBTCxDQUFhLEtBQWIsRUFBb0IsRUFBcEIsS0FBMkIsR0FBbEM7QUFDSDs7QUFDRCxJQUFNdXFCLFlBQVksR0FBRyxTQUFmQSxZQUFlLENBQUN6b0IsSUFBRDtBQUFBLFNBQVV3b0IsT0FBTyxDQUFDLENBQUN4b0IsSUFBRCxJQUFTQSxJQUFJLEtBQUssR0FBbEIsR0FBd0IsUUFBeEIsR0FBbUNBLElBQXBDLENBQWpCO0FBQUEsQ0FBckI7O0FBQ0EsU0FBUzBvQixhQUFULENBQXVCL1UsUUFBdkIsRUFBaUNpRyxLQUFqQyxFQUF3QytPLGNBQXhDLEVBQXdEam1CLEVBQXhELEVBQTREO0FBQ3hELE1BQUlrbUIsUUFBUSxHQUFHRCxjQUFjLEdBQUcsQ0FBSCxHQUFPLENBQXBDOztBQUNBLFdBQVNFLFdBQVQsR0FBdUI7QUFDbkIsV0FBT0MsS0FBSyxDQUFDWixPQUFPLENBQUNhLG9CQUFSLENBQTZCO0FBQ3RDcFYsY0FBUSxFQUFFNFUsV0FBVyxFQUNyQjtBQURxQiw0QkFFTnpULGFBQWEsQ0FBQytFLE9BRlIsU0FFa0I4SSxXQUFXLENBQUNoUCxRQUFELENBRjdCLFdBRGlCO0FBSXRDaUcsV0FBSyxFQUFMQTtBQUpzQyxLQUE3QixDQUFELEVBS1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EvTCxpQkFBVyxFQUFFO0FBWmIsS0FMUSxDQUFMLENBa0JKdkYsSUFsQkksQ0FrQkMsVUFBQXVaLEdBQUcsRUFBSTtBQUNYLFVBQUksQ0FBQ0EsR0FBRyxDQUFDbUgsRUFBVCxFQUFhO0FBQ1QsWUFBSSxFQUFFSixRQUFGLEdBQWEsQ0FBYixJQUFrQi9HLEdBQUcsQ0FBQ2xhLE1BQUosSUFBYyxHQUFwQyxFQUF5QztBQUNyQyxpQkFBT2toQixXQUFXLEVBQWxCO0FBQ0g7O0FBQ0QsY0FBTSxJQUFJdGYsS0FBSiwrQkFBTjtBQUNIOztBQUNELGFBQU9zWSxHQUFHLENBQUN4ZCxJQUFKLEVBQVA7QUFDSCxLQTFCTSxDQUFQO0FBMkJIOztBQUNELFNBQU93a0IsV0FBVyxHQUNidmdCLElBREUsQ0FDRyxVQUFBbkksSUFBSSxFQUFJO0FBQ2QsV0FBT3VDLEVBQUUsR0FBR0EsRUFBRSxDQUFDdkMsSUFBRCxDQUFMLEdBQWNBLElBQXZCO0FBQ0gsR0FITSxXQUlJLFVBQUM4SCxHQUFELEVBQVM7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsUUFBSSxDQUFDMGdCLGNBQUwsRUFBcUI7QUFDakI7QUFDQTFnQixTQUFHLENBQUN1YyxJQUFKLEdBQVcsaUJBQVg7QUFDSDs7QUFDRCxVQUFNdmMsR0FBTjtBQUNILEdBYk0sQ0FBUDtBQWNIOztJQUNLeWQsTTtBQUNGLGtCQUFZL1IsUUFBWixFQUFzQmlHLEtBQXRCLEVBQTZCZ0ksRUFBN0IsUUFBd0g7QUFBQTs7QUFBQSxRQUFyRmpFLFlBQXFGLFFBQXJGQSxZQUFxRjtBQUFBLFFBQXZFcEQsVUFBdUUsUUFBdkVBLFVBQXVFO0FBQUEsUUFBM0RVLEdBQTJELFFBQTNEQSxHQUEyRDtBQUFBLFFBQXREMkMsT0FBc0QsUUFBdERBLE9BQXNEO0FBQUEsUUFBN0M1QyxTQUE2QyxRQUE3Q0EsU0FBNkM7QUFBQSxRQUFsQy9TLEdBQWtDLFFBQWxDQSxHQUFrQztBQUFBLFFBQTdCNFYsWUFBNkIsUUFBN0JBLFlBQTZCO0FBQUEsUUFBZjdELFVBQWUsUUFBZkEsVUFBZTs7QUFBQTs7QUFDcEg7QUFDQSxTQUFLaVAsR0FBTCxHQUFXLEVBQVg7O0FBQ0EsU0FBS0MsVUFBTCxHQUFrQixVQUFDL2hCLENBQUQsRUFBTztBQUNyQixVQUFJLENBQUNBLENBQUMsQ0FBQzhELEtBQVAsRUFBYztBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRVLFlBVUYwSSxTQVZFLEdBVWtCLEtBVmxCLENBVUZBLFFBVkU7QUFBQSxZQVVRaUcsTUFWUixHQVVrQixLQVZsQixDQVVRQSxLQVZSOztBQVdWLGFBQUksQ0FBQ3VQLFdBQUwsQ0FBaUIsY0FBakIsRUFBaUNqQixPQUFPLENBQUNhLG9CQUFSLENBQTZCO0FBQUVwVixrQkFBUSxFQUFSQSxTQUFGO0FBQVlpRyxlQUFLLEVBQUxBO0FBQVosU0FBN0IsQ0FBakMsRUFBb0ZzTyxPQUFPLENBQUM1TixNQUFSLEVBQXBGOztBQUNBO0FBQ0gsT0Fkb0IsQ0FlckI7QUFDQTs7O0FBQ0EsVUFBSW5ULENBQUMsQ0FBQzhELEtBQUYsSUFDQSxLQUFJLENBQUNxUSxLQURMLElBRUFuVSxDQUFDLENBQUM4RCxLQUFGLENBQVEyVyxFQUFSLEtBQWUsS0FBSSxDQUFDdkgsTUFGcEIsSUFHQTJOLEtBQUssQ0FBQ3huQixLQUFOLENBQVkyRyxDQUFDLENBQUM4RCxLQUFGLENBQVFGLEdBQXBCLEVBQXlCNEksUUFBekIsS0FBc0MsS0FBSSxDQUFDQSxRQUgvQyxFQUd5RDtBQUNyRDtBQUNILE9BdEJvQixDQXVCckI7QUFDQTs7O0FBQ0EsVUFBSSxLQUFJLENBQUN5VixJQUFMLElBQWEsQ0FBQyxLQUFJLENBQUNBLElBQUwsQ0FBVWppQixDQUFDLENBQUM4RCxLQUFaLENBQWxCLEVBQXNDO0FBQ2xDO0FBQ0g7O0FBM0JvQixxQkE0QlE5RCxDQUFDLENBQUM4RCxLQTVCVjtBQUFBLFVBNEJiRixHQTVCYSxZQTRCYkEsR0E1QmE7QUFBQSxVQTRCUjZXLEVBNUJRLFlBNEJSQSxFQTVCUTtBQUFBLFVBNEJKeGdCLE9BNUJJLFlBNEJKQSxPQTVCSTs7QUE2QnJCLGdCQUEyQztBQUN2QyxZQUFJLE9BQU8ySixHQUFQLEtBQWUsV0FBZixJQUE4QixPQUFPNlcsRUFBUCxLQUFjLFdBQWhELEVBQTZEO0FBQ3pEdmYsaUJBQU8sQ0FBQ2tELElBQVIsQ0FBYSwwSEFBYjtBQUNIO0FBQ0o7O0FBQ0QsV0FBSSxDQUFDckgsT0FBTCxDQUFhNk0sR0FBYixFQUFrQjZXLEVBQWxCLEVBQXNCeGdCLE9BQXRCO0FBQ0gsS0FuQ0Q7O0FBb0NBLFNBQUtpb0IsY0FBTCxHQUFzQixVQUFDaFAsTUFBRCxFQUFZO0FBQzlCLFVBQU0xRyxRQUFRLEdBQUc4VSxZQUFZLENBQUNULEtBQUssQ0FBQ3huQixLQUFOLENBQVk2WixNQUFaLEVBQW9CMUcsUUFBckIsQ0FBN0I7QUFDQSxhQUFPLFNBQ0R4RixTQURDLEdBRUR1YSxhQUFhLENBQUMvVSxRQUFELEVBQVcsSUFBWCxFQUFpQixLQUFJLENBQUMySCxLQUF0QixFQUE2QixVQUFBbmIsSUFBSTtBQUFBLGVBQUssS0FBSSxDQUFDOG9CLEdBQUwsQ0FBU3RWLFFBQVQsSUFBcUJ4VCxJQUExQjtBQUFBLE9BQWpDLENBRm5CO0FBR0gsS0FMRDs7QUFNQSxTQUFLbXBCLGNBQUwsR0FBc0IsVUFBQ2pQLE1BQUQsRUFBWTtBQUFBLHlCQUNKMk4sS0FBSyxDQUFDeG5CLEtBQU4sQ0FBWTZaLE1BQVosRUFBb0IsSUFBcEIsQ0FESTtBQUFBLFVBQ3hCMUcsUUFEd0IsZ0JBQ3hCQSxRQUR3QjtBQUFBLFVBQ2RpRyxLQURjLGdCQUNkQSxLQURjOztBQUU5QmpHLGNBQVEsR0FBRzhVLFlBQVksQ0FBQzlVLFFBQUQsQ0FBdkI7QUFDQSxhQUFPK1UsYUFBYSxDQUFDL1UsUUFBRCxFQUFXaUcsS0FBWCxFQUFrQixLQUFJLENBQUMwQixLQUF2QixDQUFwQjtBQUNILEtBSkQsQ0E3Q29ILENBa0RwSDs7O0FBQ0EsU0FBS29HLEtBQUwsR0FBYThHLE9BQU8sQ0FBQzdVLFFBQUQsQ0FBcEIsQ0FuRG9ILENBb0RwSDs7QUFDQSxTQUFLbUMsVUFBTCxHQUFrQixFQUFsQixDQXJEb0gsQ0FzRHBIO0FBQ0E7QUFDQTs7QUFDQSxRQUFJbkMsUUFBUSxLQUFLLFNBQWpCLEVBQTRCO0FBQ3hCLFdBQUttQyxVQUFMLENBQWdCLEtBQUs0TCxLQUFyQixJQUE4QjtBQUMxQjFHLGlCQUFTLEVBQVRBLFNBRDBCO0FBRTFCMUUsYUFBSyxFQUFFcUgsWUFGbUI7QUFHMUIxVixXQUFHLEVBQUhBLEdBSDBCO0FBSTFCd1QsZUFBTyxFQUFFa0MsWUFBWSxJQUFJQSxZQUFZLENBQUNsQyxPQUpaO0FBSzFCOE4sZUFBTyxFQUFFNUwsWUFBWSxJQUFJQSxZQUFZLENBQUM0TDtBQUxaLE9BQTlCO0FBT0g7O0FBQ0QsU0FBS3pULFVBQUwsQ0FBZ0IsT0FBaEIsSUFBMkI7QUFBRWtGLGVBQVMsRUFBRUM7QUFBYixLQUEzQixDQWxFb0gsQ0FtRXBIO0FBQ0E7O0FBQ0EsU0FBSzFILE1BQUwsR0FBY21TLE1BQU0sQ0FBQ25TLE1BQXJCO0FBQ0EsU0FBS2dILFVBQUwsR0FBa0JBLFVBQWxCO0FBQ0EsU0FBSzVHLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsU0FBS2lHLEtBQUwsR0FBYUEsS0FBYixDQXhFb0gsQ0F5RXBIO0FBQ0E7O0FBQ0EsU0FBS1MsTUFBTCxHQUNJO0FBQ0E4TixnQkFBWSxDQUFDNU0sY0FBYixDQUE0QjVILFFBQTVCLEtBQXlDbUIsYUFBYSxDQUFDMFUsVUFBdkQsR0FBb0U3VixRQUFwRSxHQUErRWlPLEVBRm5GO0FBR0EsU0FBSzBHLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsU0FBS21CLEdBQUwsR0FBVzVMLFlBQVg7QUFDQSxTQUFLNkwsR0FBTCxHQUFXLElBQVg7QUFDQSxTQUFLQyxRQUFMLEdBQWdCL0wsT0FBaEIsQ0FqRm9ILENBa0ZwSDtBQUNBOztBQUNBLFNBQUt0QyxLQUFMLEdBQWEsSUFBYjtBQUNBLFNBQUt0QixVQUFMLEdBQWtCQSxVQUFsQjs7QUFDQSxjQUFtQztBQUMvQjtBQUNBO0FBQ0EsVUFBSTRILEVBQUUsQ0FBQ2xHLE1BQUgsQ0FBVSxDQUFWLEVBQWEsQ0FBYixNQUFvQixJQUF4QixFQUE4QjtBQUMxQjtBQUNBO0FBQ0EsYUFBS3lOLFdBQUwsQ0FBaUIsY0FBakIsRUFBaUNqQixPQUFPLENBQUNhLG9CQUFSLENBQTZCO0FBQUVwVixrQkFBUSxFQUFSQSxRQUFGO0FBQVlpRyxlQUFLLEVBQUxBO0FBQVosU0FBN0IsQ0FBakMsRUFBb0ZnSSxFQUFwRjtBQUNIOztBQUNEOWYsWUFBTSxDQUFDb04sZ0JBQVAsQ0FBd0IsVUFBeEIsRUFBb0MsS0FBS2dhLFVBQXpDO0FBQ0g7QUFDSixHLENBQ0Q7Ozs7OzJCQVdPeEgsSyxFQUFPcEYsRyxFQUFLO0FBQ2YsVUFBTXRCLFNBQVMsR0FBR3NCLEdBQUcsV0FBSCxJQUFlQSxHQUFqQztBQUNBLFVBQU1uYyxJQUFJLEdBQUcsS0FBSzJWLFVBQUwsQ0FBZ0I0TCxLQUFoQixDQUFiOztBQUNBLFVBQUksQ0FBQ3ZoQixJQUFMLEVBQVc7QUFDUCxjQUFNLElBQUlvSixLQUFKLDRDQUE4Q21ZLEtBQTlDLEVBQU47QUFDSDs7QUFDRCxVQUFNa0ksT0FBTyxHQUFHcGQsTUFBTSxDQUFDdWEsTUFBUCxDQUFjdmEsTUFBTSxDQUFDdWEsTUFBUCxDQUFjLEVBQWQsRUFBa0I1bUIsSUFBbEIsQ0FBZCxFQUF1QztBQUFFNmEsaUJBQVMsRUFBVEEsU0FBRjtBQUFhUyxlQUFPLEVBQUVhLEdBQUcsQ0FBQ2IsT0FBMUI7QUFBbUM4TixlQUFPLEVBQUVqTixHQUFHLENBQUNpTjtBQUFoRCxPQUF2QyxDQUFoQjtBQUNBLFdBQUt6VCxVQUFMLENBQWdCNEwsS0FBaEIsSUFBeUJrSSxPQUF6QixDQVBlLENBUWY7O0FBQ0EsVUFBSWxJLEtBQUssS0FBSyxPQUFkLEVBQXVCO0FBQ25CLGFBQUttSSxNQUFMLENBQVksS0FBSy9ULFVBQUwsQ0FBZ0IsS0FBSzRMLEtBQXJCLENBQVo7QUFDQTtBQUNIOztBQUNELFVBQUlBLEtBQUssS0FBSyxLQUFLQSxLQUFuQixFQUEwQjtBQUN0QixhQUFLbUksTUFBTCxDQUFZRCxPQUFaO0FBQ0g7QUFDSjs7OzZCQUNRO0FBQ0w5bkIsWUFBTSxDQUFDcUcsUUFBUCxDQUFnQkMsTUFBaEI7QUFDSDtBQUNEOzs7Ozs7MkJBR087QUFDSHRHLFlBQU0sQ0FBQ2dvQixPQUFQLENBQWVDLElBQWY7QUFDSDtBQUNEOzs7Ozs7Ozs7eUJBTUtoZixHLEVBQTZCO0FBQUEsVUFBeEI2VyxFQUF3Qix1RUFBbkI3VyxHQUFtQjtBQUFBLFVBQWQzSixPQUFjLHVFQUFKLEVBQUk7QUFDOUIsYUFBTyxLQUFLNG9CLE1BQUwsQ0FBWSxXQUFaLEVBQXlCamYsR0FBekIsRUFBOEI2VyxFQUE5QixFQUFrQ3hnQixPQUFsQyxDQUFQO0FBQ0g7QUFDRDs7Ozs7Ozs7OzRCQU1RMkosRyxFQUE2QjtBQUFBLFVBQXhCNlcsRUFBd0IsdUVBQW5CN1csR0FBbUI7QUFBQSxVQUFkM0osT0FBYyx1RUFBSixFQUFJO0FBQ2pDLGFBQU8sS0FBSzRvQixNQUFMLENBQVksY0FBWixFQUE0QmpmLEdBQTVCLEVBQWlDNlcsRUFBakMsRUFBcUN4Z0IsT0FBckMsQ0FBUDtBQUNIOzs7MkJBQ00wSixNLEVBQVFpVyxJLEVBQU1rSixHLEVBQUs3b0IsTyxFQUFTO0FBQUE7O0FBQy9CLGFBQU8sSUFBSStNLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVDLE1BQVYsRUFBcUI7QUFDcEMsWUFBSSxDQUFDak4sT0FBTyxDQUFDdWEsRUFBYixFQUFpQjtBQUNiLGdCQUFJLENBQUNMLEtBQUwsR0FBYSxLQUFiO0FBQ0gsU0FIbUMsQ0FJcEM7OztBQUNBLFlBQUk0TSxPQUFPLENBQUNySixFQUFaLEVBQWdCO0FBQ1pDLHFCQUFXLENBQUNDLElBQVosQ0FBaUIsYUFBakI7QUFDSCxTQVBtQyxDQVFwQztBQUNBOzs7QUFDQSxZQUFJaFUsR0FBRyxHQUFHLE9BQU9nVyxJQUFQLEtBQWdCLFFBQWhCLEdBQTJCbUgsT0FBTyxDQUFDYSxvQkFBUixDQUE2QmhJLElBQTdCLENBQTNCLEdBQWdFQSxJQUExRTtBQUNBLFlBQUlhLEVBQUUsR0FBRyxPQUFPcUksR0FBUCxLQUFlLFFBQWYsR0FBMEIvQixPQUFPLENBQUNhLG9CQUFSLENBQTZCa0IsR0FBN0IsQ0FBMUIsR0FBOERBLEdBQXZFO0FBQ0FsZixXQUFHLEdBQUd3ZCxXQUFXLENBQUN4ZCxHQUFELENBQWpCO0FBQ0E2VyxVQUFFLEdBQUcyRyxXQUFXLENBQUMzRyxFQUFELENBQWhCLENBYm9DLENBY3BDO0FBQ0E7O0FBQ0EsWUFBSWhiLEtBQUosRUFBOEMsZ0NBTzdDOztBQUNELGNBQUksQ0FBQ3NqQixrQkFBTCxDQUF3QnRJLEVBQXhCLEVBeEJvQyxDQXlCcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsWUFBSSxDQUFDeGdCLE9BQU8sQ0FBQ3VhLEVBQVQsSUFBZSxNQUFJLENBQUN3TyxlQUFMLENBQXFCdkksRUFBckIsQ0FBbkIsRUFBNkM7QUFDekMsZ0JBQUksQ0FBQ3ZILE1BQUwsR0FBY3VILEVBQWQ7QUFDQThELGdCQUFNLENBQUNuUyxNQUFQLENBQWMwTSxJQUFkLENBQW1CLGlCQUFuQixFQUFzQzJCLEVBQXRDOztBQUNBLGdCQUFJLENBQUN1SCxXQUFMLENBQWlCcmUsTUFBakIsRUFBeUJDLEdBQXpCLEVBQThCNlcsRUFBOUIsRUFBa0N4Z0IsT0FBbEM7O0FBQ0EsZ0JBQUksQ0FBQ2lhLFlBQUwsQ0FBa0J1RyxFQUFsQjs7QUFDQThELGdCQUFNLENBQUNuUyxNQUFQLENBQWMwTSxJQUFkLENBQW1CLG9CQUFuQixFQUF5QzJCLEVBQXpDO0FBQ0EsaUJBQU94VCxPQUFPLENBQUMsSUFBRCxDQUFkO0FBQ0g7O0FBckNtQyw0QkFzQ0U0WixLQUFLLENBQUN4bkIsS0FBTixDQUFZdUssR0FBWixFQUFpQixJQUFqQixDQXRDRjtBQUFBLFlBc0M1QjRJLFFBdEM0QixpQkFzQzVCQSxRQXRDNEI7QUFBQSxZQXNDbEJpRyxLQXRDa0IsaUJBc0NsQkEsS0F0Q2tCO0FBQUEsWUFzQ1h3USxRQXRDVyxpQkFzQ1hBLFFBdENXOztBQXVDcEMsWUFBSSxDQUFDelcsUUFBRCxJQUFheVcsUUFBakIsRUFBMkI7QUFDdkIsb0JBQTJDO0FBQ3ZDLGtCQUFNLElBQUk3Z0IsS0FBSiwwQ0FBNEN3QixHQUE1QyxzREFBTjtBQUNIOztBQUNELGlCQUFPcUQsT0FBTyxDQUFDLEtBQUQsQ0FBZDtBQUNILFNBNUNtQyxDQTZDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsWUFBSSxDQUFDLE1BQUksQ0FBQ2ljLFFBQUwsQ0FBY3pJLEVBQWQsQ0FBTCxFQUF3QjtBQUNwQjlXLGdCQUFNLEdBQUcsY0FBVDtBQUNIOztBQUNELFlBQU00VyxLQUFLLEdBQUc4RyxPQUFPLENBQUM3VSxRQUFELENBQXJCO0FBckRvQywrQkFzRFJ2UyxPQXREUSxDQXNENUJ3YSxPQXRENEI7QUFBQSxZQXNENUJBLE9BdEQ0QixpQ0FzRGxCLEtBdERrQjs7QUF1RHBDLFlBQUl1TSxZQUFZLENBQUM1TSxjQUFiLENBQTRCbUcsS0FBNUIsQ0FBSixFQUF3QztBQUFBLDhCQUNIc0csS0FBSyxDQUFDeG5CLEtBQU4sQ0FBWW9oQixFQUFaLENBREc7QUFBQSxjQUNsQmlCLFVBRGtCLGlCQUM1QmxQLFFBRDRCOztBQUVwQyxjQUFNMlcsVUFBVSxHQUFHakMsYUFBYSxDQUFDcEYsYUFBZCxDQUE0QnZCLEtBQTVCLENBQW5CO0FBQ0EsY0FBTTZJLFVBQVUsR0FBR25DLGVBQWUsQ0FBQy9FLGVBQWhCLENBQWdDaUgsVUFBaEMsRUFBNEN6SCxVQUE1QyxDQUFuQjs7QUFDQSxjQUFJLENBQUMwSCxVQUFMLEVBQWlCO0FBQ2IsZ0JBQU1DLGFBQWEsR0FBR2hlLE1BQU0sQ0FBQzhXLElBQVAsQ0FBWWdILFVBQVUsQ0FBQ25ILE1BQXZCLEVBQStCN2YsTUFBL0IsQ0FBc0MsVUFBQWtnQixLQUFLO0FBQUEscUJBQUksQ0FBQzVKLEtBQUssQ0FBQzRKLEtBQUQsQ0FBVjtBQUFBLGFBQTNDLENBQXRCOztBQUNBLGdCQUFJZ0gsYUFBYSxDQUFDam9CLE1BQWQsR0FBdUIsQ0FBM0IsRUFBOEI7QUFDMUIsd0JBQTJDO0FBQ3ZDRix1QkFBTyxDQUFDa0QsSUFBUixDQUFhLGtGQUNNaWxCLGFBQWEsQ0FBQzVzQixJQUFkLENBQW1CLElBQW5CLENBRE4sNkJBQWI7QUFFSDs7QUFDRCxxQkFBT3lRLE1BQU0sQ0FBQyxJQUFJOUUsS0FBSixDQUFVLG1DQUE4QnNaLFVBQTlCLHNEQUFzRm5CLEtBQXRGLHdFQUFWLENBQUQsQ0FBYjtBQUVIO0FBQ0osV0FWRCxNQVdLO0FBQ0Q7QUFDQWxWLGtCQUFNLENBQUN1YSxNQUFQLENBQWNuTixLQUFkLEVBQXFCMlEsVUFBckI7QUFDSDtBQUNKOztBQUNEN0UsY0FBTSxDQUFDblMsTUFBUCxDQUFjME0sSUFBZCxDQUFtQixrQkFBbkIsRUFBdUMyQixFQUF2QyxFQTNFb0MsQ0E0RXBDOztBQUNBLGNBQUksQ0FBQzZJLFlBQUwsQ0FBa0IvSSxLQUFsQixFQUF5Qi9OLFFBQXpCLEVBQW1DaUcsS0FBbkMsRUFBMENnSSxFQUExQyxFQUE4Q2hHLE9BQTlDLEVBQXVEdFQsSUFBdkQsQ0FBNEQsVUFBQW9pQixTQUFTLEVBQUk7QUFBQSxjQUM3RC9qQixLQUQ2RCxHQUNuRCtqQixTQURtRCxDQUM3RC9qQixLQUQ2RDs7QUFFckUsY0FBSUEsS0FBSyxJQUFJQSxLQUFLLENBQUNna0IsU0FBbkIsRUFBOEI7QUFDMUIsbUJBQU92YyxPQUFPLENBQUMsS0FBRCxDQUFkO0FBQ0g7O0FBQ0RzWCxnQkFBTSxDQUFDblMsTUFBUCxDQUFjME0sSUFBZCxDQUFtQixxQkFBbkIsRUFBMEMyQixFQUExQzs7QUFDQSxnQkFBSSxDQUFDdUgsV0FBTCxDQUFpQnJlLE1BQWpCLEVBQXlCQyxHQUF6QixFQUE4QjZXLEVBQTlCLEVBQWtDeGdCLE9BQWxDOztBQUNBLG9CQUEyQztBQUN2QyxnQkFBTXdwQixPQUFPLEdBQUcsTUFBSSxDQUFDOVUsVUFBTCxDQUFnQixPQUFoQixFQUF5QmtGLFNBQXpDO0FBQ0FsWixrQkFBTSxDQUFDeVQsSUFBUCxDQUFZQyxhQUFaLEdBQ0lvVixPQUFPLENBQUMxRCxlQUFSLEtBQTRCMEQsT0FBTyxDQUFDekQsbUJBQXBDLElBQ0ksQ0FBQ3VELFNBQVMsQ0FBQzFQLFNBQVYsQ0FBb0JrTSxlQUY3QjtBQUdIOztBQUNELGdCQUFJLENBQUMyRCxHQUFMLENBQVNuSixLQUFULEVBQWdCL04sUUFBaEIsRUFBMEJpRyxLQUExQixFQUFpQ2dJLEVBQWpDLEVBQXFDOEksU0FBckM7O0FBQ0EsY0FBSS9qQixLQUFKLEVBQVc7QUFDUCtlLGtCQUFNLENBQUNuUyxNQUFQLENBQWMwTSxJQUFkLENBQW1CLGtCQUFuQixFQUF1Q3RaLEtBQXZDLEVBQThDaWIsRUFBOUM7QUFDQSxrQkFBTWpiLEtBQU47QUFDSDs7QUFDRCtlLGdCQUFNLENBQUNuUyxNQUFQLENBQWMwTSxJQUFkLENBQW1CLHFCQUFuQixFQUEwQzJCLEVBQTFDO0FBQ0EsaUJBQU94VCxPQUFPLENBQUMsSUFBRCxDQUFkO0FBQ0gsU0FwQkQsRUFvQkdDLE1BcEJIO0FBcUJILE9BbEdNLENBQVA7QUFtR0g7OztnQ0FDV3ZELE0sRUFBUUMsRyxFQUFLNlcsRSxFQUFrQjtBQUFBLFVBQWR4Z0IsT0FBYyx1RUFBSixFQUFJOztBQUN2QyxnQkFBMkM7QUFDdkMsWUFBSSxPQUFPVSxNQUFNLENBQUNnb0IsT0FBZCxLQUEwQixXQUE5QixFQUEyQztBQUN2Q3puQixpQkFBTyxDQUFDc0UsS0FBUjtBQUNBO0FBQ0g7O0FBQ0QsWUFBSSxPQUFPN0UsTUFBTSxDQUFDZ29CLE9BQVAsQ0FBZWhmLE1BQWYsQ0FBUCxLQUFrQyxXQUF0QyxFQUFtRDtBQUMvQ3pJLGlCQUFPLENBQUNzRSxLQUFSLG1DQUF5Q21FLE1BQXpDO0FBQ0E7QUFDSDtBQUNKOztBQUNELFVBQUlBLE1BQU0sS0FBSyxXQUFYLElBQTBCb2QsT0FBTyxDQUFDNU4sTUFBUixPQUFxQnNILEVBQW5ELEVBQXVEO0FBQ25EOWYsY0FBTSxDQUFDZ29CLE9BQVAsQ0FBZWhmLE1BQWYsRUFBdUI7QUFDbkJDLGFBQUcsRUFBSEEsR0FEbUI7QUFFbkI2VyxZQUFFLEVBQUZBLEVBRm1CO0FBR25CeGdCLGlCQUFPLEVBQVBBO0FBSG1CLFNBQXZCLEVBS0E7QUFDQTtBQUNBO0FBQ0EsVUFSQSxFQVFJd2dCLEVBUko7QUFTSDtBQUNKOzs7aUNBQ1lGLEssRUFBTy9OLFEsRUFBVWlHLEssRUFBT2dJLEUsRUFBcUI7QUFBQTs7QUFBQSxVQUFqQmhHLE9BQWlCLHVFQUFQLEtBQU87QUFDdEQsVUFBTWtQLGVBQWUsR0FBRyxLQUFLaFYsVUFBTCxDQUFnQjRMLEtBQWhCLENBQXhCLENBRHNELENBRXREO0FBQ0E7O0FBQ0EsVUFBSTlGLE9BQU8sSUFBSWtQLGVBQVgsSUFBOEIsS0FBS3BKLEtBQUwsS0FBZUEsS0FBakQsRUFBd0Q7QUFDcEQsZUFBT3ZULE9BQU8sQ0FBQ0MsT0FBUixDQUFnQjBjLGVBQWhCLENBQVA7QUFDSDs7QUFDRCxVQUFNQyxXQUFXLEdBQUcsU0FBZEEsV0FBYyxDQUFDOWlCLEdBQUQsRUFBTStpQixhQUFOLEVBQXdCO0FBQ3hDLGVBQU8sSUFBSTdjLE9BQUosQ0FBWSxVQUFBQyxPQUFPLEVBQUk7QUFDMUIsY0FBSW5HLEdBQUcsQ0FBQ3VjLElBQUosS0FBYSxpQkFBYixJQUFrQ3dHLGFBQXRDLEVBQXFEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQWxwQixrQkFBTSxDQUFDcUcsUUFBUCxDQUFnQitMLElBQWhCLEdBQXVCME4sRUFBdkIsQ0FOaUQsQ0FPakQ7QUFDQTs7QUFDQTNaLGVBQUcsQ0FBQzBpQixTQUFKLEdBQWdCLElBQWhCLENBVGlELENBVWpEOztBQUNBLG1CQUFPdmMsT0FBTyxDQUFDO0FBQUV6SCxtQkFBSyxFQUFFc0I7QUFBVCxhQUFELENBQWQ7QUFDSDs7QUFDRCxjQUFJQSxHQUFHLENBQUMwaUIsU0FBUixFQUFtQjtBQUNmO0FBQ0EsbUJBQU92YyxPQUFPLENBQUM7QUFBRXpILG1CQUFLLEVBQUVzQjtBQUFULGFBQUQsQ0FBZDtBQUNIOztBQUNEbUcsaUJBQU8sQ0FBQyxNQUFJLENBQUM2YyxjQUFMLENBQW9CLFNBQXBCLEVBQ0gzaUIsSUFERyxDQUNFLFVBQUF1WixHQUFHLEVBQUk7QUFBQSxnQkFDQzdHLFNBREQsR0FDZTZHLEdBRGYsQ0FDTGxNLElBREs7QUFFYixnQkFBTStVLFNBQVMsR0FBRztBQUFFMVAsdUJBQVMsRUFBVEEsU0FBRjtBQUFhL1MsaUJBQUcsRUFBSEE7QUFBYixhQUFsQjtBQUNBLG1CQUFPLElBQUlrRyxPQUFKLENBQVksVUFBQUMsT0FBTyxFQUFJO0FBQzFCLG9CQUFJLENBQUM4WSxlQUFMLENBQXFCbE0sU0FBckIsRUFBZ0M7QUFDNUIvUyxtQkFBRyxFQUFIQSxHQUQ0QjtBQUU1QjBMLHdCQUFRLEVBQVJBLFFBRjRCO0FBRzVCaUcscUJBQUssRUFBTEE7QUFINEIsZUFBaEMsRUFJR3RSLElBSkgsQ0FJUSxVQUFBZ08sS0FBSyxFQUFJO0FBQ2JvVSx5QkFBUyxDQUFDcFUsS0FBVixHQUFrQkEsS0FBbEI7QUFDQW9VLHlCQUFTLENBQUMvakIsS0FBVixHQUFrQnNCLEdBQWxCO0FBQ0FtRyx1QkFBTyxDQUFDc2MsU0FBRCxDQUFQO0FBQ0gsZUFSRCxFQVFHLFVBQUFRLE1BQU0sRUFBSTtBQUNUN29CLHVCQUFPLENBQUNzRSxLQUFSLENBQWMseUNBQWQsRUFBeUR1a0IsTUFBekQ7QUFDQVIseUJBQVMsQ0FBQy9qQixLQUFWLEdBQWtCc0IsR0FBbEI7QUFDQXlpQix5QkFBUyxDQUFDcFUsS0FBVixHQUFrQixFQUFsQjtBQUNBbEksdUJBQU8sQ0FBQ3NjLFNBQUQsQ0FBUDtBQUNILGVBYkQ7QUFjSCxhQWZNLENBQVA7QUFnQkgsV0FwQk8sV0FxQkcsVUFBQXppQixHQUFHO0FBQUEsbUJBQUk4aUIsV0FBVyxDQUFDOWlCLEdBQUQsRUFBTSxJQUFOLENBQWY7QUFBQSxXQXJCTixDQUFELENBQVA7QUFzQkgsU0F4Q00sQ0FBUDtBQXlDSCxPQTFDRDs7QUEyQ0EsYUFBTyxJQUFJa0csT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVUMsTUFBVixFQUFxQjtBQUNwQyxZQUFJeWMsZUFBSixFQUFxQjtBQUNqQixpQkFBTzFjLE9BQU8sQ0FBQzBjLGVBQUQsQ0FBZDtBQUNIOztBQUNELGNBQUksQ0FBQ0csY0FBTCxDQUFvQnZKLEtBQXBCLEVBQTJCcFosSUFBM0IsQ0FBZ0MsVUFBQXVaLEdBQUc7QUFBQSxpQkFBSXpULE9BQU8sQ0FBQztBQUMzQzRNLHFCQUFTLEVBQUU2RyxHQUFHLENBQUNsTSxJQUQ0QjtBQUUzQzhGLG1CQUFPLEVBQUVvRyxHQUFHLENBQUN2RixHQUFKLENBQVFiLE9BRjBCO0FBRzNDOE4sbUJBQU8sRUFBRTFILEdBQUcsQ0FBQ3ZGLEdBQUosQ0FBUWlOO0FBSDBCLFdBQUQsQ0FBWDtBQUFBLFNBQW5DLEVBSUlsYixNQUpKO0FBS0gsT0FUTSxFQVVGL0YsSUFWRSxDQVVHLFVBQUNvaUIsU0FBRCxFQUFlO0FBQUEsWUFDYjFQLFNBRGEsR0FDbUIwUCxTQURuQixDQUNiMVAsU0FEYTtBQUFBLFlBQ0ZTLE9BREUsR0FDbUJpUCxTQURuQixDQUNGalAsT0FERTtBQUFBLFlBQ084TixPQURQLEdBQ21CbUIsU0FEbkIsQ0FDT25CLE9BRFA7O0FBRXJCLGtCQUEyQztBQUFBLHlCQUNSdnJCLG1CQUFPLENBQUMsa0RBQUQsQ0FEQztBQUFBLGNBQy9CcWYsa0JBRCtCLFlBQy9CQSxrQkFEK0I7O0FBRXZDLGNBQUksQ0FBQ0Esa0JBQWtCLENBQUNyQyxTQUFELENBQXZCLEVBQW9DO0FBQ2hDLGtCQUFNLElBQUl6UixLQUFKLGtFQUFtRW9LLFFBQW5FLFFBQU47QUFDSDtBQUNKOztBQUNELGVBQU8sTUFBSSxDQUFDd1gsUUFBTCxDQUFjO0FBQUEsaUJBQU0xUCxPQUFPLEdBQzVCLE1BQUksQ0FBQzROLGNBQUwsQ0FBb0J6SCxFQUFwQixDQUQ0QixHQUU1QjJILE9BQU8sR0FDSCxNQUFJLENBQUNELGNBQUwsQ0FBb0IxSCxFQUFwQixDQURHLEdBRUgsTUFBSSxDQUFDc0YsZUFBTCxDQUFxQmxNLFNBQXJCLEVBQ0Y7QUFDQTtBQUNJckgsb0JBQVEsRUFBUkEsUUFESjtBQUVJaUcsaUJBQUssRUFBTEEsS0FGSjtBQUdJUyxrQkFBTSxFQUFFdUg7QUFIWixXQUZFLENBSlc7QUFBQSxTQUFkLEVBVUt0WixJQVZMLENBVVUsVUFBQWdPLEtBQUssRUFBSTtBQUN0Qm9VLG1CQUFTLENBQUNwVSxLQUFWLEdBQWtCQSxLQUFsQjtBQUNBLGdCQUFJLENBQUNSLFVBQUwsQ0FBZ0I0TCxLQUFoQixJQUF5QmdKLFNBQXpCO0FBQ0EsaUJBQU9BLFNBQVA7QUFDSCxTQWRNLENBQVA7QUFlSCxPQWpDTSxXQWtDSUssV0FsQ0osQ0FBUDtBQW1DSDs7O3dCQUNHckosSyxFQUFPL04sUSxFQUFVaUcsSyxFQUFPZ0ksRSxFQUFJemhCLEksRUFBTTtBQUNsQyxXQUFLNlosVUFBTCxHQUFrQixLQUFsQjtBQUNBLFdBQUswSCxLQUFMLEdBQWFBLEtBQWI7QUFDQSxXQUFLL04sUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxXQUFLaUcsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsV0FBS1MsTUFBTCxHQUFjdUgsRUFBZDtBQUNBLFdBQUtpSSxNQUFMLENBQVkxcEIsSUFBWjtBQUNIO0FBQ0Q7Ozs7Ozs7bUNBSWV1QyxFLEVBQUk7QUFDZixXQUFLMG1CLElBQUwsR0FBWTFtQixFQUFaO0FBQ0g7OztvQ0FDZWtmLEUsRUFBSTtBQUNoQixVQUFJLENBQUMsS0FBS3ZILE1BQVYsRUFDSSxPQUFPLEtBQVA7O0FBRlksK0JBR2dCLEtBQUtBLE1BQUwsQ0FBWWhYLEtBQVosQ0FBa0IsR0FBbEIsQ0FIaEI7QUFBQTtBQUFBLFVBR1QrbkIsWUFIUztBQUFBLFVBR0tDLE9BSEw7O0FBQUEsc0JBSWdCekosRUFBRSxDQUFDdmUsS0FBSCxDQUFTLEdBQVQsQ0FKaEI7QUFBQTtBQUFBLFVBSVRpb0IsWUFKUztBQUFBLFVBSUtDLE9BSkwsa0JBS2hCOzs7QUFDQSxVQUFJQSxPQUFPLElBQUlILFlBQVksS0FBS0UsWUFBNUIsSUFBNENELE9BQU8sS0FBS0UsT0FBNUQsRUFBcUU7QUFDakUsZUFBTyxJQUFQO0FBQ0gsT0FSZSxDQVNoQjs7O0FBQ0EsVUFBSUgsWUFBWSxLQUFLRSxZQUFyQixFQUFtQztBQUMvQixlQUFPLEtBQVA7QUFDSCxPQVplLENBYWhCO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxhQUFPRCxPQUFPLEtBQUtFLE9BQW5CO0FBQ0g7OztpQ0FDWTNKLEUsRUFBSTtBQUFBLHVCQUNJQSxFQUFFLENBQUN2ZSxLQUFILENBQVMsR0FBVCxDQURKO0FBQUE7QUFBQSxVQUNKNkQsSUFESSxrQkFFYjs7O0FBQ0EsVUFBSUEsSUFBSSxLQUFLLEVBQWIsRUFBaUI7QUFDYnBGLGNBQU0sQ0FBQzBwQixRQUFQLENBQWdCLENBQWhCLEVBQW1CLENBQW5CO0FBQ0E7QUFDSCxPQU5ZLENBT2I7OztBQUNBLFVBQU1DLElBQUksR0FBR2x0QixRQUFRLENBQUNvYixjQUFULENBQXdCelMsSUFBeEIsQ0FBYjs7QUFDQSxVQUFJdWtCLElBQUosRUFBVTtBQUNOQSxZQUFJLENBQUN6UCxjQUFMO0FBQ0E7QUFDSCxPQVpZLENBYWI7QUFDQTs7O0FBQ0EsVUFBTTBQLE1BQU0sR0FBR250QixRQUFRLENBQUNvdEIsaUJBQVQsQ0FBMkJ6a0IsSUFBM0IsRUFBaUMsQ0FBakMsQ0FBZjs7QUFDQSxVQUFJd2tCLE1BQUosRUFBWTtBQUNSQSxjQUFNLENBQUMxUCxjQUFQO0FBQ0g7QUFDSjs7OzZCQUNRM0IsTSxFQUFRO0FBQ2IsYUFBTyxLQUFLQSxNQUFMLEtBQWdCQSxNQUF2QjtBQUNIO0FBQ0Q7Ozs7Ozs7Ozs2QkFNU3RQLEcsRUFBaUM7QUFBQTs7QUFBQSxVQUE1QnNQLE1BQTRCLHVFQUFuQnRQLEdBQW1CO0FBQUEsVUFBZDNKLE9BQWMsdUVBQUosRUFBSTtBQUN0QyxhQUFPLElBQUkrTSxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVQyxNQUFWLEVBQXFCO0FBQUEsNEJBQ0wyWixLQUFLLENBQUN4bkIsS0FBTixDQUFZdUssR0FBWixDQURLO0FBQUEsWUFDNUI0SSxRQUQ0QixpQkFDNUJBLFFBRDRCO0FBQUEsWUFDbEJ5VyxRQURrQixpQkFDbEJBLFFBRGtCOztBQUVwQyxZQUFJLENBQUN6VyxRQUFELElBQWF5VyxRQUFqQixFQUEyQjtBQUN2QixvQkFBMkM7QUFDdkMsa0JBQU0sSUFBSTdnQixLQUFKLDBDQUE0Q3dCLEdBQTVDLHNEQUFOO0FBQ0g7O0FBQ0Q7QUFDSCxTQVBtQyxDQVFwQzs7O0FBQ0Esa0JBQTJDO0FBQ3ZDO0FBQ0g7O0FBQ0QsWUFBTTJXLEtBQUssR0FBR2lCLFdBQVcsQ0FBQzZGLE9BQU8sQ0FBQzdVLFFBQUQsQ0FBUixDQUF6QjtBQUNBeEYsZUFBTyxDQUFDNUIsR0FBUixDQUFZLENBQ1IsTUFBSSxDQUFDZ08sVUFBTCxDQUFnQnFSLFlBQWhCLENBQTZCN2dCLEdBQTdCLEVBQWtDNFgsV0FBVyxDQUFDdEksTUFBRCxDQUE3QyxDQURRLEVBRVIsTUFBSSxDQUFDRSxVQUFMLENBQWdCblosT0FBTyxDQUFDeXFCLFFBQVIsR0FBbUIsVUFBbkIsR0FBZ0MsVUFBaEQsRUFBNERuSyxLQUE1RCxDQUZRLENBQVosRUFHR3BaLElBSEgsQ0FHUTtBQUFBLGlCQUFNOEYsT0FBTyxFQUFiO0FBQUEsU0FIUixFQUd5QkMsTUFIekI7QUFJSCxPQWpCTSxDQUFQO0FBa0JIOzs7O3NHQUNvQnFULEs7Ozs7OztBQUNiaUoseUIsR0FBWSxLOztBQUNWemMsc0IsR0FBVSxLQUFLd2IsR0FBTCxHQUFXLFlBQU07QUFDN0JpQiwyQkFBUyxHQUFHLElBQVo7QUFDSCxpQjs7QUFDRGpKLHFCQUFLLEdBQUdpQixXQUFXLENBQUNqQixLQUFELENBQW5COzt1QkFDOEIsS0FBS25ILFVBQUwsQ0FBZ0I2QyxRQUFoQixDQUF5QnNFLEtBQXpCLEM7OztBQUF4Qm9LLCtCOztxQkFDRm5CLFM7Ozs7O0FBQ01oa0IscUIsR0FBUSxJQUFJNEMsS0FBSixpREFBa0RtWSxLQUFsRCxRO0FBQ2QvYSxxQkFBSyxDQUFDZ2tCLFNBQU4sR0FBa0IsSUFBbEI7c0JBQ01oa0IsSzs7O0FBRVYsb0JBQUl1SCxNQUFNLEtBQUssS0FBS3diLEdBQXBCLEVBQXlCO0FBQ3JCLHVCQUFLQSxHQUFMLEdBQVcsSUFBWDtBQUNIOztpREFDTW9DLGU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2QkFFRmpwQixFLEVBQUk7QUFBQTs7QUFDVCxVQUFJOG5CLFNBQVMsR0FBRyxLQUFoQjs7QUFDQSxVQUFNemMsTUFBTSxHQUFHLFNBQVRBLE1BQVMsR0FBTTtBQUNqQnljLGlCQUFTLEdBQUcsSUFBWjtBQUNILE9BRkQ7O0FBR0EsV0FBS2pCLEdBQUwsR0FBV3hiLE1BQVg7QUFDQSxhQUFPckwsRUFBRSxHQUFHeUYsSUFBTCxDQUFVLFVBQUFuSSxJQUFJLEVBQUk7QUFDckIsWUFBSStOLE1BQU0sS0FBSyxNQUFJLENBQUN3YixHQUFwQixFQUF5QjtBQUNyQixnQkFBSSxDQUFDQSxHQUFMLEdBQVcsSUFBWDtBQUNIOztBQUNELFlBQUlpQixTQUFKLEVBQWU7QUFDWCxjQUFNMWlCLEdBQUcsR0FBRyxJQUFJc0IsS0FBSixDQUFVLGlDQUFWLENBQVo7QUFDQXRCLGFBQUcsQ0FBQzBpQixTQUFKLEdBQWdCLElBQWhCO0FBQ0EsZ0JBQU0xaUIsR0FBTjtBQUNIOztBQUNELGVBQU85SCxJQUFQO0FBQ0gsT0FWTSxDQUFQO0FBV0g7OztvQ0FDZTZhLFMsRUFBV29ELEcsRUFBSztBQUFBLFVBQ1RuRCxHQURTLEdBQ0QsS0FBS25GLFVBQUwsQ0FBZ0IsT0FBaEIsQ0FEQyxDQUNwQmtGLFNBRG9COztBQUU1QixVQUFNa0QsT0FBTyxHQUFHLEtBQUt5TCxRQUFMLENBQWMxTyxHQUFkLENBQWhCOztBQUNBbUQsU0FBRyxDQUFDRixPQUFKLEdBQWNBLE9BQWQ7QUFDQSxhQUFPZ0ssT0FBTyxDQUFDN0osbUJBQVIsQ0FBNEJwRCxHQUE1QixFQUFpQztBQUNwQ2lELGVBQU8sRUFBUEEsT0FEb0M7QUFFcENsRCxpQkFBUyxFQUFUQSxTQUZvQztBQUdwQ3BGLGNBQU0sRUFBRSxJQUg0QjtBQUlwQ3dJLFdBQUcsRUFBSEE7QUFKb0MsT0FBakMsQ0FBUDtBQU1IOzs7dUNBQ2tCd0QsRSxFQUFJO0FBQ25CLFVBQUksS0FBSzhILEdBQVQsRUFBYztBQUNWLFlBQU12aUIsQ0FBQyxHQUFHLElBQUlvQyxLQUFKLENBQVUsaUJBQVYsQ0FBVjtBQUNBcEMsU0FBQyxDQUFDd2pCLFNBQUYsR0FBYyxJQUFkO0FBQ0FqRixjQUFNLENBQUNuUyxNQUFQLENBQWMwTSxJQUFkLENBQW1CLGtCQUFuQixFQUF1QzlZLENBQXZDLEVBQTBDeWEsRUFBMUM7QUFDQSxhQUFLOEgsR0FBTDtBQUNBLGFBQUtBLEdBQUwsR0FBVyxJQUFYO0FBQ0g7QUFDSjs7OzJCQUNNdnBCLEksRUFBTTtBQUNULFdBQUtzcEIsR0FBTCxDQUFTdHBCLElBQVQsRUFBZSxLQUFLMlYsVUFBTCxDQUFnQixPQUFoQixFQUF5QmtGLFNBQXhDO0FBQ0g7Ozs2Q0FwWitCalEsRyxFQUFLO0FBQ2pDLFVBQUluRSxLQUFKLEVBQThDLGdDQUE5QyxNQUtLO0FBQ0QsZUFBT21FLEdBQVA7QUFDSDtBQUNKOzs7Ozs7QUE2WUx0TixPQUFPLFdBQVAsR0FBa0Jpb0IsTUFBbEI7QUFDQUEsTUFBTSxDQUFDblMsTUFBUCxHQUFnQjBVLE1BQU0sV0FBTixFQUFoQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbGtCQSw4Q0FBYTs7QUFDYnpiLE1BQU0sQ0FBQzBaLGNBQVAsQ0FBc0J6b0IsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRXNPLE9BQUssRUFBRTtBQUFULENBQTdDLEUsQ0FDQTs7QUFDQSxJQUFNZ2dCLFVBQVUsR0FBRyxzQkFBbkI7O0FBQ0EsU0FBU3hRLGNBQVQsQ0FBd0JtRyxLQUF4QixFQUErQjtBQUMzQixTQUFPcUssVUFBVSxDQUFDdm9CLElBQVgsQ0FBZ0JrZSxLQUFoQixDQUFQO0FBQ0g7O0FBQ0Rqa0IsT0FBTyxDQUFDOGQsY0FBUixHQUF5QkEsY0FBekI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1BBLDhDQUFhOztBQUNiL08sTUFBTSxDQUFDMFosY0FBUCxDQUFzQnpvQixPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFc08sT0FBSyxFQUFFO0FBQVQsQ0FBN0M7O0FBQ0EsU0FBU3NYLGVBQVQsQ0FBeUJpSCxVQUF6QixFQUFxQztBQUFBLE1BQ3pCMEIsRUFEeUIsR0FDVjFCLFVBRFUsQ0FDekIwQixFQUR5QjtBQUFBLE1BQ3JCN0ksTUFEcUIsR0FDVm1ILFVBRFUsQ0FDckJuSCxNQURxQjtBQUVqQyxTQUFPLFVBQUN4UCxRQUFELEVBQWM7QUFDakIsUUFBTTRXLFVBQVUsR0FBR3lCLEVBQUUsQ0FBQ3JvQixJQUFILENBQVFnUSxRQUFSLENBQW5COztBQUNBLFFBQUksQ0FBQzRXLFVBQUwsRUFBaUI7QUFDYixhQUFPLEtBQVA7QUFDSDs7QUFDRCxRQUFNcmhCLE1BQU0sR0FBRyxTQUFUQSxNQUFTLENBQUNzYSxLQUFELEVBQVc7QUFDdEIsVUFBSTtBQUNBLGVBQU95SSxrQkFBa0IsQ0FBQ3pJLEtBQUQsQ0FBekI7QUFDSCxPQUZELENBR0EsT0FBTzBJLENBQVAsRUFBVTtBQUNOLFlBQU1qa0IsR0FBRyxHQUFHLElBQUlzQixLQUFKLENBQVUsd0JBQVYsQ0FBWjtBQUNBdEIsV0FBRyxDQUFDdWMsSUFBSixHQUFXLGVBQVg7QUFDQSxjQUFNdmMsR0FBTjtBQUNIO0FBQ0osS0FURDs7QUFVQSxRQUFNa2tCLE1BQU0sR0FBRyxFQUFmO0FBQ0EzZixVQUFNLENBQUM4VyxJQUFQLENBQVlILE1BQVosRUFBb0IxZ0IsT0FBcEIsQ0FBNEIsVUFBQzJwQixRQUFELEVBQWM7QUFDdEMsVUFBTUMsQ0FBQyxHQUFHbEosTUFBTSxDQUFDaUosUUFBRCxDQUFoQjtBQUNBLFVBQU1FLENBQUMsR0FBRy9CLFVBQVUsQ0FBQzhCLENBQUMsQ0FBQ0UsR0FBSCxDQUFwQjs7QUFDQSxVQUFJRCxDQUFDLEtBQUt4dUIsU0FBVixFQUFxQjtBQUNqQnF1QixjQUFNLENBQUNDLFFBQUQsQ0FBTixHQUFtQixDQUFDRSxDQUFDLENBQUM5cEIsT0FBRixDQUFVLEdBQVYsQ0FBRCxHQUNiOHBCLENBQUMsQ0FBQ2pwQixLQUFGLENBQVEsR0FBUixFQUFhSSxHQUFiLENBQWlCLFVBQUErb0IsS0FBSztBQUFBLGlCQUFJdGpCLE1BQU0sQ0FBQ3NqQixLQUFELENBQVY7QUFBQSxTQUF0QixDQURhLEdBRWJILENBQUMsQ0FBQzVJLE1BQUYsR0FDSSxDQUFDdmEsTUFBTSxDQUFDb2pCLENBQUQsQ0FBUCxDQURKLEdBRUlwakIsTUFBTSxDQUFDb2pCLENBQUQsQ0FKaEI7QUFLSDtBQUNKLEtBVkQ7QUFXQSxXQUFPSCxNQUFQO0FBQ0gsR0E1QkQ7QUE2Qkg7O0FBQ0QxdUIsT0FBTyxDQUFDNGxCLGVBQVIsR0FBMEJBLGVBQTFCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsQ0EsOENBQWE7O0FBQ2I3VyxNQUFNLENBQUMwWixjQUFQLENBQXNCem9CLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVzTyxPQUFLLEVBQUU7QUFBVCxDQUE3QyxFLENBQ0E7QUFDQTs7QUFDQSxTQUFTMGdCLFdBQVQsQ0FBcUJDLEdBQXJCLEVBQTBCO0FBQ3RCLFNBQU9BLEdBQUcsQ0FBQ3h1QixPQUFKLENBQVksc0JBQVosRUFBb0MsTUFBcEMsQ0FBUDtBQUNIOztBQUNELFNBQVMra0IsYUFBVCxDQUF1QjBKLGVBQXZCLEVBQXdDO0FBQ3BDO0FBQ0EsTUFBTUMsWUFBWSxHQUFHSCxXQUFXLENBQUNFLGVBQWUsQ0FBQ3p1QixPQUFoQixDQUF3QixLQUF4QixFQUErQixFQUEvQixLQUFzQyxHQUF2QyxDQUFoQztBQUNBLE1BQU1pbEIsTUFBTSxHQUFHLEVBQWY7QUFDQSxNQUFJMEosVUFBVSxHQUFHLENBQWpCO0FBQ0EsTUFBTUMsa0JBQWtCLEdBQUdGLFlBQVksQ0FBQzF1QixPQUFiLENBQXFCLDZCQUFyQixFQUFvRCxVQUFDZ3VCLENBQUQsRUFBSWEsRUFBSixFQUFXO0FBQ3RGLFFBQU1DLFVBQVUsR0FBRyxhQUFheHBCLElBQWIsQ0FBa0J1cEIsRUFBbEIsQ0FBbkI7QUFDQTVKLFVBQU0sQ0FBQzRKLEVBQUUsQ0FDTDtBQURLLEtBRUo3dUIsT0FGRSxDQUVNLDBCQUZOLEVBRWtDLElBRmxDLEVBR0ZBLE9BSEUsQ0FHTSxRQUhOLEVBR2dCLEVBSGhCLENBQUQsQ0FJTjtBQUpNLEtBQU4sR0FLSTtBQUFFcXVCLFNBQUcsRUFBRU0sVUFBVSxFQUFqQjtBQUFxQnBKLFlBQU0sRUFBRXVKO0FBQTdCLEtBTEo7QUFNQSxXQUFPQSxVQUFVLEdBQUcsUUFBSCxHQUFjLFdBQS9CO0FBQ0gsR0FUMEIsQ0FBM0I7QUFVQSxNQUFJQyx1QkFBSixDQWZvQyxDQWdCcEM7QUFDQTs7QUFDQSxhQUFtQyxFQVdsQzs7QUFDRCxTQUFPemdCLE1BQU0sQ0FBQ3VhLE1BQVAsQ0FBYztBQUFFaUYsTUFBRSxFQUFFLElBQUludUIsTUFBSixDQUFXLE1BQU1pdkIsa0JBQU4sR0FBMkIsU0FBdEMsRUFBaUQsR0FBakQsQ0FBTjtBQUE2RDNKLFVBQU0sRUFBTkE7QUFBN0QsR0FBZCxFQUFzRjhKLHVCQUF1QixHQUM5RztBQUNFQyxjQUFVLGFBQU1ELHVCQUFOO0FBRFosR0FEOEcsR0FJOUcsRUFKQyxDQUFQO0FBS0g7O0FBQ0R4dkIsT0FBTyxDQUFDd2xCLGFBQVIsR0FBd0JBLGFBQXhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQ0EsOENBQWE7O0FBQ2J6VyxNQUFNLENBQUMwWixjQUFQLENBQXNCem9CLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVzTyxPQUFLLEVBQUU7QUFBVCxDQUE3QztBQUNBLElBQUkrTixhQUFKOztBQUNBcmMsT0FBTyxXQUFQLEdBQWtCLFlBQU07QUFDcEIsU0FBT3FjLGFBQVA7QUFDSCxDQUZEOztBQUdBLFNBQVNJLFNBQVQsQ0FBbUJpVCxXQUFuQixFQUFnQztBQUM1QnJULGVBQWEsR0FBR3FULFdBQWhCO0FBQ0g7O0FBQ0QxdkIsT0FBTyxDQUFDeWMsU0FBUixHQUFvQkEsU0FBcEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1RBLDhDQUFhOzs7Ozs7QUFDYjFOLE1BQU0sQ0FBQzBaLGNBQVAsQ0FBc0J6b0IsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRXNPLE9BQUssRUFBRTtBQUFULENBQTdDOztBQUNBLElBQU1pYyxLQUFLLEdBQUdocUIsbUJBQU8sQ0FBQyxvREFBRCxDQUFyQjtBQUNBOzs7OztBQUdBLFNBQVNvdkIsUUFBVCxDQUFrQnZxQixFQUFsQixFQUFzQjtBQUNsQixNQUFJd3FCLElBQUksR0FBRyxLQUFYO0FBQ0EsTUFBSTNvQixNQUFKO0FBQ0EsU0FBUSxZQUFhO0FBQ2pCLFFBQUksQ0FBQzJvQixJQUFMLEVBQVc7QUFDUEEsVUFBSSxHQUFHLElBQVA7QUFDQTNvQixZQUFNLEdBQUc3QixFQUFFLE1BQUYsbUJBQVQ7QUFDSDs7QUFDRCxXQUFPNkIsTUFBUDtBQUNILEdBTkQ7QUFPSDs7QUFDRGpILE9BQU8sQ0FBQzJ2QixRQUFSLEdBQW1CQSxRQUFuQjs7QUFDQSxTQUFTRSxpQkFBVCxHQUE2QjtBQUFBLHlCQUNZeHJCLE1BQU0sQ0FBQ3FHLFFBRG5CO0FBQUEsTUFDakJpaUIsUUFEaUIsb0JBQ2pCQSxRQURpQjtBQUFBLE1BQ1BtRCxRQURPLG9CQUNQQSxRQURPO0FBQUEsTUFDR0MsSUFESCxvQkFDR0EsSUFESDtBQUV6QixtQkFBVXBELFFBQVYsZUFBdUJtRCxRQUF2QixTQUFrQ0MsSUFBSSxHQUFHLE1BQU1BLElBQVQsR0FBZ0IsRUFBdEQ7QUFDSDs7QUFDRC92QixPQUFPLENBQUM2dkIsaUJBQVIsR0FBNEJBLGlCQUE1Qjs7QUFDQSxTQUFTaFQsTUFBVCxHQUFrQjtBQUFBLE1BQ05wRyxJQURNLEdBQ0dwUyxNQUFNLENBQUNxRyxRQURWLENBQ04rTCxJQURNO0FBRWQsTUFBTXVaLE1BQU0sR0FBR0gsaUJBQWlCLEVBQWhDO0FBQ0EsU0FBT3BaLElBQUksQ0FBQzZILFNBQUwsQ0FBZTBSLE1BQU0sQ0FBQ2xyQixNQUF0QixDQUFQO0FBQ0g7O0FBQ0Q5RSxPQUFPLENBQUM2YyxNQUFSLEdBQWlCQSxNQUFqQjs7QUFDQSxTQUFTb1QsY0FBVCxDQUF3QjFTLFNBQXhCLEVBQW1DO0FBQy9CLFNBQU8sT0FBT0EsU0FBUCxLQUFxQixRQUFyQixHQUNEQSxTQURDLEdBRURBLFNBQVMsQ0FBQ29NLFdBQVYsSUFBeUJwTSxTQUFTLENBQUNuUCxJQUFuQyxJQUEyQyxTQUZqRDtBQUdIOztBQUNEcE8sT0FBTyxDQUFDaXdCLGNBQVIsR0FBeUJBLGNBQXpCOztBQUNBLFNBQVNDLFNBQVQsQ0FBbUI5TCxHQUFuQixFQUF3QjtBQUNwQixTQUFPQSxHQUFHLENBQUMrTCxRQUFKLElBQWdCL0wsR0FBRyxDQUFDZ00sV0FBM0I7QUFDSDs7QUFDRHB3QixPQUFPLENBQUNrd0IsU0FBUixHQUFvQkEsU0FBcEI7O1NBQ2V0UCxtQjs7Ozs7a0ZBQWYsaUJBQW1DcEQsR0FBbkMsRUFBd0NtRCxHQUF4QztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0JBR1ksQ0FBQzBQLEVBQUUsR0FBRzdTLEdBQUcsQ0FBQ2hTLFNBQVYsTUFBeUIsSUFBekIsSUFBaUM2a0IsRUFBRSxLQUFLLEtBQUssQ0FBN0MsR0FBaUQsS0FBSyxDQUF0RCxHQUEwREEsRUFBRSxDQUFDNUcsZUFIekU7QUFBQTtBQUFBO0FBQUE7O0FBSWtCaGtCLG1CQUpsQixlQUlnQ3dxQixjQUFjLENBQUN6UyxHQUFELENBSjlDO0FBQUEsa0JBS2tCLElBQUkxUixLQUFKLENBQVVyRyxPQUFWLENBTGxCOztBQUFBO0FBUUk7QUFDTTJlLGVBVFYsR0FTZ0J6RCxHQUFHLENBQUN5RCxHQUFKLElBQVl6RCxHQUFHLENBQUNBLEdBQUosSUFBV0EsR0FBRyxDQUFDQSxHQUFKLENBQVF5RCxHQVQvQzs7QUFBQSxnQkFVUzVHLEdBQUcsQ0FBQ2lNLGVBVmI7QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0JBV1k5SSxHQUFHLENBQUNBLEdBQUosSUFBV0EsR0FBRyxDQUFDcEQsU0FYM0I7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxtQkFjaUNxRCxtQkFBbUIsQ0FBQ0QsR0FBRyxDQUFDcEQsU0FBTCxFQUFnQm9ELEdBQUcsQ0FBQ0EsR0FBcEIsQ0FkcEQ7O0FBQUE7QUFBQTtBQUFBO0FBY2dCMlAsdUJBZGhCO0FBQUE7O0FBQUE7QUFBQSw2Q0FpQmUsRUFqQmY7O0FBQUE7QUFBQTtBQUFBLG1CQW1Cd0I5UyxHQUFHLENBQUNpTSxlQUFKLENBQW9COUksR0FBcEIsQ0FuQnhCOztBQUFBO0FBbUJVOUgsaUJBbkJWOztBQUFBLGtCQW9CUXVMLEdBQUcsSUFBSThMLFNBQVMsQ0FBQzlMLEdBQUQsQ0FwQnhCO0FBQUE7QUFBQTtBQUFBOztBQUFBLDZDQXFCZXZMLEtBckJmOztBQUFBO0FBQUEsZ0JBdUJTQSxLQXZCVDtBQUFBO0FBQUE7QUFBQTs7QUF3QmNwVCxvQkF4QmQsZUF3QjRCd3FCLGNBQWMsQ0FBQ3pTLEdBQUQsQ0F4QjFDLDJFQXdCOEczRSxLQXhCOUc7QUFBQSxrQkF5QmMsSUFBSS9NLEtBQUosQ0FBVXJHLFFBQVYsQ0F6QmQ7O0FBQUE7QUEyQkksc0JBQTJDO0FBQ3ZDLGtCQUFJc0osTUFBTSxDQUFDOFcsSUFBUCxDQUFZaE4sS0FBWixFQUFtQi9ULE1BQW5CLEtBQThCLENBQTlCLElBQW1DLENBQUM2YixHQUFHLENBQUNBLEdBQTVDLEVBQWlEO0FBQzdDL2IsdUJBQU8sQ0FBQ2tELElBQVIsV0FBZ0Jtb0IsY0FBYyxDQUFDelMsR0FBRCxDQUE5QjtBQUNIO0FBQ0o7O0FBL0JMLDZDQWdDVzNFLEtBaENYOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEc7Ozs7QUFrQ0E3WSxPQUFPLENBQUM0Z0IsbUJBQVIsR0FBOEJBLG1CQUE5QjtBQUNBNWdCLE9BQU8sQ0FBQ3V3QixhQUFSLEdBQXdCLENBQ3BCLE1BRG9CLEVBRXBCLE1BRm9CLEVBR3BCLE1BSG9CLEVBSXBCLFVBSm9CLEVBS3BCLE1BTG9CLEVBTXBCLE1BTm9CLEVBT3BCLFVBUG9CLEVBUXBCLE1BUm9CLEVBU3BCLFVBVG9CLEVBVXBCLE9BVm9CLEVBV3BCLFFBWG9CLEVBWXBCLFNBWm9CLENBQXhCOztBQWNBLFNBQVNqRixvQkFBVCxDQUE4QmhlLEdBQTlCLEVBQW1DM0osT0FBbkMsRUFBNEM7QUFDeEMsWUFBNEM7QUFDeEMsUUFBSTJKLEdBQUcsS0FBSyxJQUFSLElBQWdCLE9BQU9BLEdBQVAsS0FBZSxRQUFuQyxFQUE2QztBQUN6Q3lCLFlBQU0sQ0FBQzhXLElBQVAsQ0FBWXZZLEdBQVosRUFBaUJ0SSxPQUFqQixDQUF5QixVQUFBd3JCLEdBQUcsRUFBSTtBQUM1QixZQUFJeHdCLE9BQU8sQ0FBQ3V3QixhQUFSLENBQXNCeHJCLE9BQXRCLENBQThCeXJCLEdBQTlCLE1BQXVDLENBQUMsQ0FBNUMsRUFBK0M7QUFDM0M1ckIsaUJBQU8sQ0FBQ2tELElBQVIsNkRBQWtFMG9CLEdBQWxFO0FBQ0g7QUFDSixPQUpEO0FBS0g7QUFDSjs7QUFDRCxTQUFPakcsS0FBSyxDQUFDa0csTUFBTixDQUFhbmpCLEdBQWIsRUFBa0IzSixPQUFsQixDQUFQO0FBQ0g7O0FBQ0QzRCxPQUFPLENBQUNzckIsb0JBQVIsR0FBK0JBLG9CQUEvQjtBQUNBdHJCLE9BQU8sQ0FBQzB3QixFQUFSLEdBQWEsT0FBT3JQLFdBQVAsS0FBdUIsV0FBcEM7QUFDQXJoQixPQUFPLENBQUNvaEIsRUFBUixHQUFhcGhCLE9BQU8sQ0FBQzB3QixFQUFSLElBQ1QsT0FBT3JQLFdBQVcsQ0FBQ0MsSUFBbkIsS0FBNEIsVUFEbkIsSUFFVCxPQUFPRCxXQUFXLENBQUNJLE9BQW5CLEtBQStCLFVBRm5DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLE9BQU87QUFDcEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTyx5Q0FBeUM7QUFDaEQ7QUFDQSxPQUFPLDhDQUE4QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLCtDQUErQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw0REFBNEQ7QUFDbkU7QUFDQTtBQUNBLE9BQU8sNENBQTRDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw0Q0FBNEM7QUFDbkQ7QUFDQSxPQUFPLHFDQUFxQztBQUM1QztBQUNBLE9BQU8sd0RBQXdEO0FBQy9ELE9BQU8seURBQXlEO0FBQ2hFLE9BQU8saURBQWlEO0FBQ3hELE9BQU8sdUNBQXVDO0FBQzlDLE9BQU8sbUNBQW1DO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sMkNBQTJDO0FBQ2xEO0FBQ0EsT0FBTyw2Q0FBNkM7QUFDcEQsT0FBTyw4Q0FBOEM7QUFDckQsT0FBTyw4Q0FBOEM7QUFDckQsT0FBTyw4Q0FBOEM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxtRUFBbUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0NBQXNDO0FBQzdDO0FBQ0E7QUFDQSxPQUFPLHlDQUF5QztBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0Isb0NBQW9DO0FBQ3BELGtCQUFrQjtBQUNsQixpQkFBaUIsZ0NBQWdDO0FBQ2pELGVBQWUsbUJBQW1CO0FBQ2xDLHlCQUF5QixZQUFZO0FBQ3JDLHFCQUFxQixnQkFBZ0I7QUFDckMsaUJBQWlCLDZCQUE2QjtBQUM5QyxhQUFhLGdCQUFnQjtBQUM3QixlQUFlO0FBQ2YsY0FBYztBQUNkLG9CQUFvQiwyQkFBMkI7QUFDL0MsbUJBQW1CLFlBQVk7QUFDL0IsbUJBQW1CLHdCQUF3QjtBQUMzQyxnQkFBZ0IsYUFBYTtBQUM3QixrQkFBa0IsZ0VBQWdFO0FBQ2xGLGVBQWU7QUFDZixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDBDQUEwQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrQ0FBa0M7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsR0FBRztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSw4QkFBOEIsZUFBZTtBQUM3Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBMEU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLG1DQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQUEsb0dBQUM7QUFDTjtBQUNBO0FBQ0EsT0FBTyxFQVNKO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ2pvQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7Ozs7OztBQ3ZMdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUEwQixvQkFBb0IsU0FBRTtBQUNsRDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4dEJBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThEOztBQUU5RCwwREFBMEQ7O0FBRTFEOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCLDJCQUEyQjs7QUFFM0IsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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Q0FBaUMsaUNBQWlDLEdBQUcscUJBQXFCLGtKQUFrSixRQUFRLE1BQU0sR0FBRyxHQUFHLFNBQVMsMEJBQTBCLHFCQUFxQixJQUFJLHdDQUF3QyxTQUFTLDBCQUEwQixvQkFBb0IsSUFBSSw2Q0FBNkMsU0FBUywwQkFBMEIseUJBQXlCLElBQUksbUNBQW1DLGNBQWMsR0FBRyxTQUFTLDBCQUEwQixnQkFBZ0IseUNBQXlDLHlDQUF5QyxnQkFBZ0IsSUFBSSxXQUFXLHFCQUFxQixJQUFJLFVBQVUsU0FBUyxZQUFZLHFDQUFxQyxTQUFTLGFBQWEsZ0VBQWdFLCtCQUErQixHQUFHLGVBQWUsUUFBUSxHQUFHLFNBQVMsMEJBQTBCLFVBQVUsNEJBQTRCLHVCQUF1QixFQUFFLGlDQUFpQyx1QkFBdUIsaUNBQWlDLFlBQVksYUFBYSxlQUFlLGtCQUFrQix3Q0FBd0MsaUJBQWlCLHFDQUFxQyxvQkFBb0IsNkJBQTZCLGNBQWMsNENBQTRDLGdDQUFnQyxFQUFFLE1BQU0sTUFBTSxxQkFBcUIsU0FBUyxLQUFLLDJCQUEyQixVQUFVLE1BQU0saUJBQWlCLDBEQUEwRCxHQUFHLElBQUksZ0JBQWdCLG1EQUF1RjtBQUN4MEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNEQSwwQyIsImZpbGUiOiJzdGF0aWMvcnVudGltZS9tYWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5OyIsImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXM7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkOyIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG52YXIgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcmVxdWlyZShcIi4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0XCIpO1xuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBzZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0OyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwiZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9leHRlbmRzOyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZjsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZlwiKTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0czsiLCJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0OyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDtcbiAgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuICBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9O1xuXG4gIHJldHVybiBjYWNoZTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7XG4gIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7XG5cbiAgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdldChvYmopO1xuICB9XG5cbiAgdmFyIG5ld09iaiA9IHt9O1xuICB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDtcblxuICAgICAgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqO1xuXG4gIGlmIChjYWNoZSkge1xuICAgIGNhY2hlLnNldChvYmosIG5ld09iaik7XG4gIH1cblxuICByZXR1cm4gbmV3T2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkOyIsImZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0OyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5TGltaXQ7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0OyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuOyIsImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mOyIsInZhciBhcnJheVdpdGhIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdFwiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVJlc3RcIik7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXk7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheVwiKTtcblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBCdXMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaW50ZXJuYWwvYnVzXCIpKTtcbnZhciBwYXJzZVN0YWNrXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9oZWxwZXJzL3BhcnNlU3RhY2tcIik7XG52YXIgaXNSZWdpc3RlcmVkID0gZmFsc2U7XG52YXIgc3RhY2tUcmFjZUxpbWl0ID0gdW5kZWZpbmVkO1xuZnVuY3Rpb24gb25VbmhhbmRsZWRFcnJvcihldikge1xuICAgIHZhciBlcnJvciA9IGV2ID09PSBudWxsIHx8IGV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldi5lcnJvcjtcbiAgICBpZiAoIWVycm9yIHx8ICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikgfHwgdHlwZW9mIGVycm9yLnN0YWNrICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBIG5vbi1lcnJvciB3YXMgdGhyb3duLCB3ZSBkb24ndCBoYXZlIGFueXRoaW5nIHRvIHNob3cuIDotKFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlID0gZXJyb3I7XG4gICAgQnVzLmVtaXQoe1xuICAgICAgICB0eXBlOiBCdXMuVFlQRV9VTkhBTkRMRURfRVJST1IsXG4gICAgICAgIHJlYXNvbjogZXJyb3IsXG4gICAgICAgIGZyYW1lczogcGFyc2VTdGFja18xLnBhcnNlU3RhY2soZS5zdGFjaylcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG9uVW5oYW5kbGVkUmVqZWN0aW9uKGV2KSB7XG4gICAgdmFyIHJlYXNvbiA9IGV2ID09PSBudWxsIHx8IGV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldi5yZWFzb247XG4gICAgaWYgKCFyZWFzb24gfHxcbiAgICAgICAgIShyZWFzb24gaW5zdGFuY2VvZiBFcnJvcikgfHxcbiAgICAgICAgdHlwZW9mIHJlYXNvbi5zdGFjayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQSBub24tZXJyb3Igd2FzIHRocm93biwgd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBzaG93LiA6LShcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZSA9IHJlYXNvbjtcbiAgICBCdXMuZW1pdCh7XG4gICAgICAgIHR5cGU6IEJ1cy5UWVBFX1VOSEFORExFRF9SRUpFQ1RJT04sXG4gICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICBmcmFtZXM6IHBhcnNlU3RhY2tfMS5wYXJzZVN0YWNrKGUuc3RhY2spXG4gICAgfSk7XG59XG5mdW5jdGlvbiByZWdpc3RlcigpIHtcbiAgICBpZiAoaXNSZWdpc3RlcmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNSZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICB2YXIgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDUwO1xuICAgICAgICBzdGFja1RyYWNlTGltaXQgPSBsaW1pdDtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7IH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvblVuaGFuZGxlZEVycm9yKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgb25VbmhhbmRsZWRSZWplY3Rpb24pO1xufVxuZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuZnVuY3Rpb24gdW5yZWdpc3RlcigpIHtcbiAgICBpZiAoIWlzUmVnaXN0ZXJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlzUmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIGlmIChzdGFja1RyYWNlTGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gc3RhY2tUcmFjZUxpbWl0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgIHN0YWNrVHJhY2VMaW1pdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25VbmhhbmRsZWRFcnJvcik7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIG9uVW5oYW5kbGVkUmVqZWN0aW9uKTtcbn1cbmV4cG9ydHMudW5yZWdpc3RlciA9IHVucmVnaXN0ZXI7XG5mdW5jdGlvbiBvbkJ1aWxkT2soKSB7XG4gICAgQnVzLmVtaXQoeyB0eXBlOiBCdXMuVFlQRV9CVUlMRF9PSyB9KTtcbn1cbmV4cG9ydHMub25CdWlsZE9rID0gb25CdWlsZE9rO1xuZnVuY3Rpb24gb25CdWlsZEVycm9yKG1lc3NhZ2UpIHtcbiAgICBCdXMuZW1pdCh7IHR5cGU6IEJ1cy5UWVBFX0JVSUxEX0VSUk9SLCBtZXNzYWdlOiBtZXNzYWdlIH0pO1xufVxuZXhwb3J0cy5vbkJ1aWxkRXJyb3IgPSBvbkJ1aWxkRXJyb3I7XG5mdW5jdGlvbiBvblJlZnJlc2goKSB7XG4gICAgQnVzLmVtaXQoeyB0eXBlOiBCdXMuVFlQRV9SRUZGUkVTSCB9KTtcbn1cbmV4cG9ydHMub25SZWZyZXNoID0gb25SZWZyZXNoO1xudmFyIG5vZGVTdGFja0ZyYW1lc18xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvaGVscGVycy9ub2RlU3RhY2tGcmFtZXNcIik7XG5leHBvcnRzLmdldE5vZGVFcnJvciA9IG5vZGVTdGFja0ZyYW1lc18xLmdldE5vZGVFcnJvcjtcbnZhciBSZWFjdERldk92ZXJsYXlfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL1JlYWN0RGV2T3ZlcmxheVwiKTtcbmV4cG9ydHMuUmVhY3REZXZPdmVybGF5ID0gUmVhY3REZXZPdmVybGF5XzFbXCJkZWZhdWx0XCJdO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgcmVhY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIEVycm9yQm91bmRhcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVycm9yQm91bmRhcnksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXJyb3JCb3VuZGFyeSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRlID0geyBlcnJvcjogbnVsbCB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEVycm9yQm91bmRhcnkucHJvdG90eXBlLmNvbXBvbmVudERpZENhdGNoID0gZnVuY3Rpb24gKGVycm9yLCBcbiAgICAvLyBMb29zZWx5IHR5cGVkIGJlY2F1c2UgaXQgZGVwZW5kcyBvbiB0aGUgUmVhY3QgdmVyc2lvbiBhbmQgd2FzXG4gICAgLy8gYWNjaWRlbnRhbGx5IGV4Y2x1ZGVkIGluIHNvbWUgdmVyc2lvbnMuXG4gICAgZXJyb3JJbmZvKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25FcnJvcihlcnJvciwgKGVycm9ySW5mbyA9PT0gbnVsbCB8fCBlcnJvckluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9ySW5mby5jb21wb25lbnRTdGFjaykgfHwgbnVsbCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcjogZXJyb3IgfSk7XG4gICAgfTtcbiAgICBFcnJvckJvdW5kYXJ5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yXG4gICAgICAgICAgICA/IC8vIFRoZSBjb21wb25lbnQgaGFzIHRvIGJlIHVubW91bnRlZCBvciBlbHNlIGl0IHdvdWxkIGNvbnRpbnVlIHRvIGVycm9yXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH07XG4gICAgcmV0dXJuIEVycm9yQm91bmRhcnk7XG59KHJlYWN0XzFbXCJkZWZhdWx0XCJdLlB1cmVDb21wb25lbnQpKTtcbmV4cG9ydHMuRXJyb3JCb3VuZGFyeSA9IEVycm9yQm91bmRhcnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWQgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIEJ1cyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9idXNcIikpO1xudmFyIFNoYWRvd1BvcnRhbF8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9TaGFkb3dQb3J0YWxcIik7XG52YXIgRXJyb3JzXzEgPSByZXF1aXJlKFwiLi9jb250YWluZXIvRXJyb3JzXCIpO1xudmFyIEJ1aWxkRXJyb3JfMSA9IHJlcXVpcmUoXCIuL2NvbnRhaW5lci9CdWlsZEVycm9yXCIpO1xudmFyIEVycm9yQm91bmRhcnlfMSA9IHJlcXVpcmUoXCIuL0Vycm9yQm91bmRhcnlcIik7XG52YXIgQmFzZV8xID0gcmVxdWlyZShcIi4vc3R5bGVzL0Jhc2VcIik7XG52YXIgQ29tcG9uZW50U3R5bGVzXzEgPSByZXF1aXJlKFwiLi9zdHlsZXMvQ29tcG9uZW50U3R5bGVzXCIpO1xudmFyIENzc1Jlc2V0XzEgPSByZXF1aXJlKFwiLi9zdHlsZXMvQ3NzUmVzZXRcIik7XG5mdW5jdGlvbiByZWR1Y2VyKHN0YXRlLCBldikge1xuICAgIHN3aXRjaCAoZXYudHlwZSkge1xuICAgICAgICBjYXNlIEJ1cy5UWVBFX0JVSUxEX09LOiB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlKSwgeyBidWlsZEVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgQnVzLlRZUEVfQlVJTERfRVJST1I6IHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RhdGUpLCB7IGJ1aWxkRXJyb3I6IGV2Lm1lc3NhZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBCdXMuVFlQRV9SRUZGUkVTSDoge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdGF0ZSksIHsgYnVpbGRFcnJvcjogbnVsbCwgZXJyb3JzOiBbXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEJ1cy5UWVBFX1VOSEFORExFRF9FUlJPUjpcbiAgICAgICAgY2FzZSBCdXMuVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OOiB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlKSwgeyBuZXh0SWQ6IHN0YXRlLm5leHRJZCArIDEsIGVycm9yczogX19zcHJlYWQoc3RhdGUuZXJyb3JzLCBbeyBpZDogc3RhdGUubmV4dElkLCBldmVudDogZXYgfV0pIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgIHZhciBfMSA9IGV2O1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gUmVhY3REZXZPdmVybGF5KF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XG4gICAgdmFyIF9iID0gX19yZWFkKFJlYWN0LnVzZVJlZHVjZXIocmVkdWNlciwgeyBuZXh0SWQ6IDEsIGJ1aWxkRXJyb3I6IG51bGwsIGVycm9yczogW10gfSksIDIpLCBzdGF0ZSA9IF9iWzBdLCBkaXNwYXRjaCA9IF9iWzFdO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIEJ1cy5vbihkaXNwYXRjaCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBCdXMub2ZmKGRpc3BhdGNoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgb25Db21wb25lbnRFcnJvciA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlcnJvciwgY29tcG9uZW50U3RhY2spIHtcbiAgICAgICAgLy8gVE9ETzogc3BlY2lhbCBoYW5kbGluZ1xuICAgIH0sIFtdKTtcbiAgICB2YXIgaGFzQnVpbGRFcnJvciA9IHN0YXRlLmJ1aWxkRXJyb3IgIT0gbnVsbDtcbiAgICB2YXIgaGFzUnVudGltZUVycm9ycyA9IEJvb2xlYW4oc3RhdGUuZXJyb3JzLmxlbmd0aCk7XG4gICAgdmFyIGlzTW91bnRlZCA9IGhhc0J1aWxkRXJyb3IgfHwgaGFzUnVudGltZUVycm9ycztcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeV8xLkVycm9yQm91bmRhcnksIHsgb25FcnJvcjogb25Db21wb25lbnRFcnJvciB9LCBjaGlsZHJlbiAhPT0gbnVsbCAmJiBjaGlsZHJlbiAhPT0gdm9pZCAwID8gY2hpbGRyZW4gOiBudWxsKSxcbiAgICAgICAgaXNNb3VudGVkID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2hhZG93UG9ydGFsXzEuU2hhZG93UG9ydGFsLCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDc3NSZXNldF8xLkNzc1Jlc2V0LCBudWxsKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFzZV8xLkJhc2UsIG51bGwpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnRTdHlsZXNfMS5Db21wb25lbnRTdHlsZXMsIG51bGwpLFxuICAgICAgICAgICAgaGFzQnVpbGRFcnJvciA/IChSZWFjdC5jcmVhdGVFbGVtZW50KEJ1aWxkRXJyb3JfMS5CdWlsZEVycm9yLCB7IG1lc3NhZ2U6IHN0YXRlLmJ1aWxkRXJyb3IgfSkpIDogaGFzUnVudGltZUVycm9ycyA/IChSZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yc18xLkVycm9ycywgeyBlcnJvcnM6IHN0YXRlLmVycm9ycyB9KSkgOiAodW5kZWZpbmVkKSkpIDogKHVuZGVmaW5lZCkpKTtcbn1cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUmVhY3REZXZPdmVybGF5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuVFlQRV9CVUlMRF9PSyA9ICdidWlsZC1vayc7XG5leHBvcnRzLlRZUEVfQlVJTERfRVJST1IgPSAnYnVpbGQtZXJyb3InO1xuZXhwb3J0cy5UWVBFX1JFRkZSRVNIID0gJ2Zhc3QtcmVmcmVzaCc7XG5leHBvcnRzLlRZUEVfVU5IQU5ETEVEX0VSUk9SID0gJ3VuaGFuZGxlZC1lcnJvcic7XG5leHBvcnRzLlRZUEVfVU5IQU5ETEVEX1JFSkVDVElPTiA9ICd1bmhhbmRsZWQtcmVqZWN0aW9uJztcbnZhciBoYW5kbGVycyA9IG5ldyBTZXQoKTtcbnZhciBxdWV1ZSA9IFtdO1xuZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgLy8gRHJhaW5pbmcgc2hvdWxkIG5ldmVyIGhhcHBlbiBzeW5jaHJvbm91c2x5IGluIGNhc2UgbXVsdGlwbGUgaGFuZGxlcnMgYXJlXG4gICAgLy8gcmVnaXN0ZXJlZC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXYgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gaGFuZGxlcihldik7IH0pO1xuICAgICAgICB9O1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgIC8vIFVudGlsIHdlIGFyZSBvdXQgb2YgZXZlbnRzOlxuICAgICAgICBCb29sZWFuKHF1ZXVlLmxlbmd0aCkgJiZcbiAgICAgICAgICAgIC8vIE9yLCBpZiBhbGwgaGFuZGxlcnMgcmVtb3ZlZCB0aGVtc2VsdmVzIGFzIGEgcmVzdWx0IG9mIGhhbmRsaW5nIHRoZVxuICAgICAgICAgICAgLy8gZXZlbnQocylcbiAgICAgICAgICAgIEJvb2xlYW4oaGFuZGxlcnMuc2l6ZSkpIHtcbiAgICAgICAgICAgIF9sb29wXzEoKTtcbiAgICAgICAgfVxuICAgIH0sIDEpO1xufVxuZnVuY3Rpb24gZW1pdChldikge1xuICAgIHF1ZXVlLnB1c2goT2JqZWN0LmZyZWV6ZShfX2Fzc2lnbih7fSwgZXYpKSk7XG4gICAgZHJhaW4oKTtcbn1cbmV4cG9ydHMuZW1pdCA9IGVtaXQ7XG5mdW5jdGlvbiBvbihmbikge1xuICAgIGlmIChoYW5kbGVycy5oYXMoZm4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFuZGxlcnMuYWRkKGZuKTtcbiAgICBkcmFpbigpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5vbiA9IG9uO1xuZnVuY3Rpb24gb2ZmKGZuKSB7XG4gICAgaWYgKGhhbmRsZXJzLmhhcyhmbikpIHtcbiAgICAgICAgaGFuZGxlcnNbXCJkZWxldGVcIl0oZm4pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5vZmYgPSBvZmY7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGFuc2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFuc2VyXCIpKTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIHN0cmlwX2Fuc2lfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwic3RyaXAtYW5zaVwiKSk7XG52YXIgc3RhY2tfZnJhbWVfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL3N0YWNrLWZyYW1lXCIpO1xuZXhwb3J0cy5Db2RlRnJhbWUgPSBmdW5jdGlvbiBDb2RlRnJhbWUoX2EpIHtcbiAgICB2YXIgc3RhY2tGcmFtZSA9IF9hLnN0YWNrRnJhbWUsIGNvZGVGcmFtZSA9IF9hLmNvZGVGcmFtZTtcbiAgICAvLyBTdHJpcCBsZWFkaW5nIHNwYWNlcyBvdXQgb2YgdGhlIGNvZGUgZnJhbWU6XG4gICAgdmFyIGZvcm1hdHRlZEZyYW1lID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IGNvZGVGcmFtZS5zcGxpdCgvXFxyP1xcbi9nKTtcbiAgICAgICAgdmFyIHByZWZpeExlbmd0aCA9IGxpbmVzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChsaW5lKSB7IHJldHVybiAvXj4/ICtcXGQrICtcXHwgKCAqKS8uZXhlYyhzdHJpcF9hbnNpXzFbXCJkZWZhdWx0XCJdKGxpbmUpKTsgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYucG9wKCk7IH0pXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChjLCBuKSB7IHJldHVybiAoaXNOYU4oYykgPyBuLmxlbmd0aCA6IE1hdGgubWluKGMsIG4ubGVuZ3RoKSk7IH0sIE5hTik7XG4gICAgICAgIGlmIChwcmVmaXhMZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgcF8xID0gJyAnLnJlcGVhdChwcmVmaXhMZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZSwgYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB+KGEgPSBsaW5lLmluZGV4T2YoJ3wnKSlcbiAgICAgICAgICAgICAgICAgICAgPyBsaW5lLnN1YnN0cmluZygwLCBhKSArIGxpbmUuc3Vic3RyaW5nKGEpLnJlcGxhY2UocF8xLCAnJylcbiAgICAgICAgICAgICAgICAgICAgOiBsaW5lO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgIH0sIFtjb2RlRnJhbWVdKTtcbiAgICB2YXIgZGVjb2RlZCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYW5zZXJfMVtcImRlZmF1bHRcIl0uYW5zaVRvSnNvbihmb3JtYXR0ZWRGcmFtZSwge1xuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIHVzZV9jbGFzc2VzOiB0cnVlLFxuICAgICAgICAgICAgcmVtb3ZlX2VtcHR5OiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0sIFtmb3JtYXR0ZWRGcmFtZV0pO1xuICAgIHZhciBvcGVuID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzdGFja0ZyYW1lKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKGtleSwgKChfYSA9IHN0YWNrRnJhbWVba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZmV0Y2goXCIvX19uZXh0anNfbGF1bmNoLWVkaXRvcj9cIiArIHBhcmFtcy50b1N0cmluZygpKS50aGVuKGZ1bmN0aW9uICgpIHsgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwb3J0IGVycm9yXG4gICAgICAgIH0pO1xuICAgIH0sIFtzdGFja0ZyYW1lXSk7XG4gICAgLy8gVE9ETzogbWFrZSB0aGUgY2FyZXQgYWJzb2x1dGVcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtbmV4dGpzLWNvZGVmcmFtZVwiOiB0cnVlIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHsgcm9sZTogXCJsaW5rXCIsIG9uQ2xpY2s6IG9wZW4sIHRhYkluZGV4OiAxLCB0aXRsZTogXCJDbGljayB0byBvcGVuIGluIHlvdXIgZWRpdG9yXCIgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgc3RhY2tfZnJhbWVfMS5nZXRGcmFtZVNvdXJjZShzdGFja0ZyYW1lKSxcbiAgICAgICAgICAgICAgICBcIiBAIFwiLFxuICAgICAgICAgICAgICAgIHN0YWNrRnJhbWUubWV0aG9kTmFtZSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlV2lkdGg6IFwiMlwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTE4IDEzdjZhMiAyIDAgMCAxLTIgMkg1YTIgMiAwIDAgMS0yLTJWOGEyIDIgMCAwIDEgMi0yaDZcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicG9seWxpbmVcIiwgeyBwb2ludHM6IFwiMTUgMyAyMSAzIDIxIDlcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7IHgxOiBcIjEwXCIsIHkxOiBcIjE0XCIsIHgyOiBcIjIxXCIsIHkyOiBcIjNcIiB9KSkpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaHJcIiwgbnVsbCksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgbnVsbCwgZGVjb2RlZC5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsga2V5OiBcImZyYW1lLVwiICsgaW5kZXgsIHN0eWxlOiBfX2Fzc2lnbih7IGNvbG9yOiBlbnRyeS5mZyA/IFwidmFyKC0tY29sb3ItXCIgKyBlbnRyeS5mZyArIFwiKVwiIDogdW5kZWZpbmVkIH0sIChlbnRyeS5kZWNvcmF0aW9uID09PSAnYm9sZCdcbiAgICAgICAgICAgICAgICA/IHsgZm9udFdlaWdodDogODAwIH1cbiAgICAgICAgICAgICAgICA6IGVudHJ5LmRlY29yYXRpb24gPT09ICdpdGFsaWMnXG4gICAgICAgICAgICAgICAgICAgID8geyBmb250U3R5bGU6ICdpdGFsaWMnIH1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpKSB9LCBlbnRyeS5jb250ZW50KSk7IH0pKSkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBDb2RlRnJhbWVfMSA9IHJlcXVpcmUoXCIuL0NvZGVGcmFtZVwiKTtcbmV4cG9ydHMuQ29kZUZyYW1lID0gQ29kZUZyYW1lXzEuQ29kZUZyYW1lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xudmFyIHN0eWxlcyA9IG5vb3BfdGVtcGxhdGVfMS5ub29wKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXTo6c2VsZWN0aW9uLFxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gKjo6c2VsZWN0aW9uIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1zZWxlY3Rpb24pO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gKiB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IGhyIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiAwO1xcblxcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci13aWR0aDogMDtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4O1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsYWNrKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gcCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBwOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBwID4gc3ZnIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIGhlaWdodDogMWVtO1xcbiAgICBtYXJnaW4tbGVmdDogMC41cmVtO1xcbiAgfVxcblwiXSwgW1wiXFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWJnKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktZmcpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV06OnNlbGVjdGlvbixcXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdICo6OnNlbGVjdGlvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktc2VsZWN0aW9uKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdICoge1xcbiAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+ICoge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc2l6ZS1nYXApICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpXFxuICAgICAgY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBociB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogMDtcXG5cXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItd2lkdGg6IDA7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDtcXG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWJyaWdodC1ibGFjayk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IHAge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gcDpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gcCA+IHN2ZyB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBoZWlnaHQ6IDFlbTtcXG4gICAgbWFyZ2luLWxlZnQ6IDAuNXJlbTtcXG4gIH1cXG5cIl0pKSk7XG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgdXNlX29uX2NsaWNrX291dHNpZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9ob29rcy91c2Utb24tY2xpY2stb3V0c2lkZVwiKTtcbnZhciBEaWFsb2cgPSBmdW5jdGlvbiBEaWFsb2coX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgdHlwZSA9IF9hLnR5cGUsIG9uQ2xvc2UgPSBfYS5vbkNsb3NlLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJ0eXBlXCIsIFwib25DbG9zZVwiXSk7XG4gICAgdmFyIF9iID0gX19yZWFkKFJlYWN0LnVzZVN0YXRlKG51bGwpLCAyKSwgZGlhbG9nID0gX2JbMF0sIHNldERpYWxvZyA9IF9iWzFdO1xuICAgIHZhciBvbkRpYWxvZyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHNldERpYWxvZyhub2RlKTtcbiAgICB9LCBbXSk7XG4gICAgdXNlX29uX2NsaWNrX291dHNpZGVfMS51c2VPbkNsaWNrT3V0c2lkZShkaWFsb2csIG9uQ2xvc2UpO1xuICAgIC8vIE1ha2UgSFRNTEVsZW1lbnRzIHdpdGggYHJvbGU9bGlua2AgYWNjZXNzaWJsZSB0byBiZSB0cmlnZ2VyZWQgYnkgdGhlXG4gICAgLy8ga2V5Ym9hcmQsIGkuZS4gW0VudGVyXS5cbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZGlhbG9nID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcm9vdCA9IGRpYWxvZy5nZXRSb290Tm9kZSgpO1xuICAgICAgICAvLyBBbHdheXMgdHJ1ZSwgYnV0IHdlIGRvIHRoaXMgZm9yIFR5cGVTY3JpcHQ6XG4gICAgICAgIGlmICghKHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaGFkb3dSb290ID0gcm9vdDtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlcihlKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBzaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicgJiZcbiAgICAgICAgICAgICAgICBlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgZWwuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICdsaW5rJykge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGVsLmNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2hhZG93Um9vdC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFkb3dSb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTsgfTtcbiAgICB9LCBbZGlhbG9nXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBvbkRpYWxvZywgXCJkYXRhLW5leHRqcy1kaWFsb2dcIjogdHJ1ZSwgdGFiSW5kZXg6IC0xLCByb2xlOiBcImRpYWxvZ1wiLCBcImFyaWEtbGFiZWxsZWRieVwiOiBwcm9wc1snYXJpYS1sYWJlbGxlZGJ5J10sIFwiYXJpYS1kZXNjcmliZWRieVwiOiBwcm9wc1snYXJpYS1kZXNjcmliZWRieSddLCBcImFyaWEtbW9kYWxcIjogXCJ0cnVlXCIgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lclwiOiB0cnVlLCBjbGFzc05hbWU6IFwiYmFubmVyLVwiICsgdHlwZSB9KSxcbiAgICAgICAgY2hpbGRyZW4pKTtcbn07XG5leHBvcnRzLkRpYWxvZyA9IERpYWxvZztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIERpYWxvZ0JvZHkgPSBmdW5jdGlvbiBEaWFsb2dCb2R5KF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtbmV4dGpzLWRpYWxvZy1ib2R5XCI6IHRydWUsIGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sIGNoaWxkcmVuKSk7XG59O1xuZXhwb3J0cy5EaWFsb2dCb2R5ID0gRGlhbG9nQm9keTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIERpYWxvZ0NvbnRlbnQgPSBmdW5jdGlvbiBEaWFsb2dDb250ZW50KF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtbmV4dGpzLWRpYWxvZy1jb250ZW50XCI6IHRydWUsIGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sIGNoaWxkcmVuKSk7XG59O1xuZXhwb3J0cy5EaWFsb2dDb250ZW50ID0gRGlhbG9nQ29udGVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIERpYWxvZ0hlYWRlciA9IGZ1bmN0aW9uIERpYWxvZ0hlYWRlcihfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWU7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy1kaWFsb2ctaGVhZGVyXCI6IHRydWUsIGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sIGNoaWxkcmVuKSk7XG59O1xuZXhwb3J0cy5EaWFsb2dIZWFkZXIgPSBEaWFsb2dIZWFkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgRGlhbG9nXzEgPSByZXF1aXJlKFwiLi9EaWFsb2dcIik7XG5leHBvcnRzLkRpYWxvZyA9IERpYWxvZ18xLkRpYWxvZztcbnZhciBEaWFsb2dCb2R5XzEgPSByZXF1aXJlKFwiLi9EaWFsb2dCb2R5XCIpO1xuZXhwb3J0cy5EaWFsb2dCb2R5ID0gRGlhbG9nQm9keV8xLkRpYWxvZ0JvZHk7XG52YXIgRGlhbG9nQ29udGVudF8xID0gcmVxdWlyZShcIi4vRGlhbG9nQ29udGVudFwiKTtcbmV4cG9ydHMuRGlhbG9nQ29udGVudCA9IERpYWxvZ0NvbnRlbnRfMS5EaWFsb2dDb250ZW50O1xudmFyIERpYWxvZ0hlYWRlcl8xID0gcmVxdWlyZShcIi4vRGlhbG9nSGVhZGVyXCIpO1xuZXhwb3J0cy5EaWFsb2dIZWFkZXIgPSBEaWFsb2dIZWFkZXJfMS5EaWFsb2dIZWFkZXI7XG52YXIgc3R5bGVzXzEgPSByZXF1aXJlKFwiLi9zdHlsZXNcIik7XG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlc18xLnN0eWxlcztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgICByZXR1cm4gY29va2VkO1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbm9vcF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcbnZhciBzdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBtYXJnaW4tcmlnaHQ6IGF1dG87XFxuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgICBvdXRsaW5lOiBub25lO1xcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXApO1xcbiAgICBib3gtc2hhZG93OiAwIHZhcigtLXNpemUtZ2FwLWhhbGYpIHZhcigtLXNpemUtZ2FwLWRvdWJsZSlcXG4gICAgICByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbiAgICBtYXgtaGVpZ2h0OiBjYWxjKDEwMCUgLSAzLjVyZW0pO1xcbiAgICBvdmVyZmxvdy15OiBoaWRkZW47XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogNTc2cHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogNTQwcHg7XFxuICAgICAgYm94LXNoYWRvdzogMCB2YXIoLS1zaXplLWdhcCkgdmFyKC0tc2l6ZS1nYXAtcXVhZCkgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgICBtYXgtd2lkdGg6IDcyMHB4O1xcbiAgICB9XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogOTYwcHg7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXS5iYW5uZXItd2FybmluZyB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS15ZWxsb3cpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdLmJhbm5lci1lcnJvciB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdOjphZnRlciB7XFxuICAgIHotaW5kZXg6IDI7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICAvKiBiYW5uZXIgd2lkdGg6ICovXFxuICAgIGJvcmRlci10b3Atd2lkdGg6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAwO1xcbiAgICBib3JkZXItdG9wLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLWJvdHRvbS1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci10b3AtY29sb3I6IGluaGVyaXQ7XFxuICAgIGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1jb250ZW50XSB7XFxuICAgIG92ZXJmbG93LXk6IGF1dG87XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICAvKiBjYWxjKHBhZGRpbmcgKyBiYW5uZXIgd2lkdGggb2Zmc2V0KSAqL1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdID4gW2RhdGEtbmV4dGpzLWRpYWxvZy1oZWFkZXJdIHtcXG4gICAgZmxleC1zaHJpbms6IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdID4gW2RhdGEtbmV4dGpzLWRpYWxvZy1ib2R5XSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgZmxleDogMSAxIGF1dG87XFxuICB9XFxuXCJdLCBbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIG1hcmdpbi1yaWdodDogYXV0bztcXG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICAgIG91dGxpbmU6IG5vbmU7XFxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgIGJveC1zaGFkb3c6IDAgdmFyKC0tc2l6ZS1nYXAtaGFsZikgdmFyKC0tc2l6ZS1nYXAtZG91YmxlKVxcbiAgICAgIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICAgIG1heC1oZWlnaHQ6IGNhbGMoMTAwJSAtIDMuNXJlbSk7XFxuICAgIG92ZXJmbG93LXk6IGhpZGRlbjtcXG4gIH1cXG5cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA1NzZweCkge1xcbiAgICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XFxuICAgICAgbWF4LXdpZHRoOiA1NDBweDtcXG4gICAgICBib3gtc2hhZG93OiAwIHZhcigtLXNpemUtZ2FwKSB2YXIoLS1zaXplLWdhcC1xdWFkKSByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbiAgICB9XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogNzIwcHg7XFxuICAgIH1cXG4gIH1cXG5cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkge1xcbiAgICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XFxuICAgICAgbWF4LXdpZHRoOiA5NjBweDtcXG4gICAgfVxcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdLmJhbm5lci13YXJuaW5nIHtcXG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXllbGxvdyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lcl0uYmFubmVyLWVycm9yIHtcXG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lcl06OmFmdGVyIHtcXG4gICAgei1pbmRleDogMjtcXG4gICAgY29udGVudDogJyc7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIC8qIGJhbm5lciB3aWR0aDogKi9cXG4gICAgYm9yZGVyLXRvcC13aWR0aDogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDA7XFxuICAgIGJvcmRlci10b3Atc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItYm90dG9tLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLXRvcC1jb2xvcjogaW5oZXJpdDtcXG4gICAgYm9yZGVyLWJvdHRvbS1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdIHtcXG4gICAgb3ZlcmZsb3cteTogYXV0bztcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIC8qIGNhbGMocGFkZGluZyArIGJhbm5lciB3aWR0aCBvZmZzZXQpICovXFxuICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxcbiAgICAgIHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctY29udGVudF0gPiBbZGF0YS1uZXh0anMtZGlhbG9nLWhlYWRlcl0ge1xcbiAgICBmbGV4LXNocmluazogMDtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctY29udGVudF0gPiBbZGF0YS1uZXh0anMtZGlhbG9nLWJvZHldIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBmbGV4OiAxIDEgYXV0bztcXG4gIH1cXG5cIl0pKSk7XG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgTGVmdFJpZ2h0RGlhbG9nSGVhZGVyID0gZnVuY3Rpb24gTGVmdFJpZ2h0RGlhbG9nSGVhZGVyKF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgcHJldmlvdXMgPSBfYS5wcmV2aW91cywgbmV4dCA9IF9hLm5leHQsIGNsb3NlID0gX2EuY2xvc2U7XG4gICAgdmFyIGJ1dHRvbkxlZnQgPSBSZWFjdC51c2VSZWYoKTtcbiAgICB2YXIgYnV0dG9uUmlnaHQgPSBSZWFjdC51c2VSZWYoKTtcbiAgICB2YXIgYnV0dG9uQ2xvc2UgPSBSZWFjdC51c2VSZWYoKTtcbiAgICB2YXIgX2IgPSBfX3JlYWQoUmVhY3QudXNlU3RhdGUobnVsbCksIDIpLCBuYXYgPSBfYlswXSwgc2V0TmF2ID0gX2JbMV07XG4gICAgdmFyIG9uTmF2ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHNldE5hdihlbCk7XG4gICAgfSwgW10pO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuYXYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb290ID0gbmF2LmdldFJvb3ROb2RlKCk7XG4gICAgICAgIHZhciBkID0gc2VsZi5kb2N1bWVudDtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlcihlKSB7XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdBcnJvd0xlZnQnKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uTGVmdC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkxlZnQuY3VycmVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2aW91cyAmJiBwcmV2aW91cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS5rZXkgPT09ICdBcnJvd1JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJ1dHRvblJpZ2h0LmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uUmlnaHQuY3VycmVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0ICYmIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gcm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoYSAmJiBhICE9PSBidXR0b25DbG9zZS5jdXJyZW50ICYmIGEgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTtcbiAgICAgICAgaWYgKHJvb3QgIT09IGQpIHtcbiAgICAgICAgICAgIGQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIGlmIChyb290ICE9PSBkKSB7XG4gICAgICAgICAgICAgICAgZC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW2Nsb3NlLCBuYXYsIG5leHQsIHByZXZpb3VzXSk7XG4gICAgLy8gVW5sb2NrIGZvY3VzIGZvciBicm93c2VycyBsaWtlIEZpcmVmb3gsIHRoYXQgYnJlYWsgYWxsIHVzZXIgZm9jdXMgaWYgdGhlXG4gICAgLy8gY3VycmVudGx5IGZvY3VzZWQgaXRlbSBiZWNvbWVzIGRpc2FibGVkLlxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuYXYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb290ID0gbmF2LmdldFJvb3ROb2RlKCk7XG4gICAgICAgIC8vIEFsd2F5cyB0cnVlLCBidXQgd2UgZG8gdGhpcyBmb3IgVHlwZVNjcmlwdDpcbiAgICAgICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICAgICAgICB2YXIgYSA9IHJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IGJ1dHRvbkxlZnQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBidXR0b25MZWZ0LmN1cnJlbnQuYmx1cigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChhID09PSBidXR0b25SaWdodC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvblJpZ2h0LmN1cnJlbnQuYmx1cigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtuYXYsIG5leHQsIHByZXZpb3VzXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodFwiOiB0cnVlLCBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibmF2XCIsIHsgcmVmOiBvbk5hdiB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHJlZjogYnV0dG9uTGVmdCwgdHlwZTogXCJidXR0b25cIiwgZGlzYWJsZWQ6IHByZXZpb3VzID09IG51bGwgPyB0cnVlIDogdW5kZWZpbmVkLCBcImFyaWEtZGlzYWJsZWRcIjogcHJldmlvdXMgPT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWQsIG9uQ2xpY2s6IHByZXZpb3VzICE9PSBudWxsICYmIHByZXZpb3VzICE9PSB2b2lkIDAgPyBwcmV2aW91cyA6IHVuZGVmaW5lZCB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB2aWV3Qm94OiBcIjAgMCAxNCAxNFwiLCBmaWxsOiBcIm5vbmVcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTYuOTk5OTYgMS4xNjY2NkwxLjE2NjYzIDYuOTk5OTlMNi45OTk5NiAxMi44MzMzTTEyLjgzMzMgNi45OTk5OUgxLjk5OTk2SDEyLjgzMzNaXCIsIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlV2lkdGg6IFwiMlwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIgfSkpKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyByZWY6IGJ1dHRvblJpZ2h0LCB0eXBlOiBcImJ1dHRvblwiLCBkaXNhYmxlZDogbmV4dCA9PSBudWxsID8gdHJ1ZSA6IHVuZGVmaW5lZCwgXCJhcmlhLWRpc2FibGVkXCI6IG5leHQgPT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWQsIG9uQ2xpY2s6IG5leHQgIT09IG51bGwgJiYgbmV4dCAhPT0gdm9pZCAwID8gbmV4dCA6IHVuZGVmaW5lZCB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB2aWV3Qm94OiBcIjAgMCAxNCAxNFwiLCBmaWxsOiBcIm5vbmVcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTYuOTk5OTYgMS4xNjY2NkwxMi44MzMzIDYuOTk5OTlMNi45OTk5NiAxMi44MzMzTTEuMTY2NjMgNi45OTk5OUgxMkgxLjE2NjYzWlwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiIH0pKSksXG4gICAgICAgICAgICBcIlxcdTAwQTBcIixcbiAgICAgICAgICAgIGNoaWxkcmVuKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHJlZjogYnV0dG9uQ2xvc2UsIHR5cGU6IFwiYnV0dG9uXCIsIG9uQ2xpY2s6IGNsb3NlLCBcImFyaWEtbGFiZWxcIjogXCJDbG9zZVwiIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgd2lkdGg6IFwiMjRcIiwgaGVpZ2h0OiBcIjI0XCIsIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwibm9uZVwiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTggNkw2IDE4XCIsIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlV2lkdGg6IFwiMlwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIgfSksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNNiA2TDE4IDE4XCIsIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlV2lkdGg6IFwiMlwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIgfSkpKSkpKTtcbn07XG5leHBvcnRzLkxlZnRSaWdodERpYWxvZ0hlYWRlciA9IExlZnRSaWdodERpYWxvZ0hlYWRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBMZWZ0UmlnaHREaWFsb2dIZWFkZXJfMSA9IHJlcXVpcmUoXCIuL0xlZnRSaWdodERpYWxvZ0hlYWRlclwiKTtcbmV4cG9ydHMuTGVmdFJpZ2h0RGlhbG9nSGVhZGVyID0gTGVmdFJpZ2h0RGlhbG9nSGVhZGVyXzEuTGVmdFJpZ2h0RGlhbG9nSGVhZGVyO1xudmFyIHN0eWxlc18xID0gcmVxdWlyZShcIi4vc3R5bGVzXCIpO1xuZXhwb3J0cy5zdHlsZXMgPSBzdHlsZXNfMS5zdHlsZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gICAgcmV0dXJuIGNvb2tlZDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XG52YXIgc3R5bGVzID0gbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbiB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG5cXG4gICAgd2lkdGg6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XFxuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXApKTtcXG4gICAgZm9udC1zaXplOiAwO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuMSk7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjI1cyBlYXNlO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbiA+IHN2ZyB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc2l6ZS1nYXApICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuMik7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uOmRpc2FibGVkIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDg1LCA4NSwgMC4xKTtcXG4gICAgY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuNCk7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uOmZpcnN0LW9mLXR5cGUge1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcC1oYWxmKSAwIDAgdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIG1hcmdpbi1yaWdodDogMXB4O1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpsYXN0LW9mLXR5cGUge1xcbiAgICBib3JkZXItcmFkaXVzOiAwIHZhcigtLXNpemUtZ2FwLWhhbGYpIHZhcigtLXNpemUtZ2FwLWhhbGYpIDA7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gYnV0dG9uOmxhc3Qtb2YtdHlwZSB7XFxuICAgIGJvcmRlcjogMDtcXG4gICAgcGFkZGluZzogMDtcXG5cXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGFwcGVhcmFuY2U6IG5vbmU7XFxuXFxuICAgIG9wYWNpdHk6IDAuNDtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjI1cyBlYXNlO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IGJ1dHRvbjpsYXN0LW9mLXR5cGU6aG92ZXIge1xcbiAgICBvcGFjaXR5OiAwLjc7XFxuICB9XFxuXCJdLCBbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b24ge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuXFxuICAgIHdpZHRoOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcCkpO1xcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XFxuICAgIGZvbnQtc2l6ZTogMDtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjEpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4yNXMgZWFzZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b24gPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjIpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpkaXNhYmxlZCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuMSk7XFxuICAgIGNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjQpO1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpmaXJzdC1vZi10eXBlIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZikgMCAwIHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDFweDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246bGFzdC1vZi10eXBlIHtcXG4gICAgYm9yZGVyLXJhZGl1czogMCB2YXIoLS1zaXplLWdhcC1oYWxmKSB2YXIoLS1zaXplLWdhcC1oYWxmKSAwO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IGJ1dHRvbjpsYXN0LW9mLXR5cGUge1xcbiAgICBib3JkZXI6IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBhcHBlYXJhbmNlOiBub25lO1xcblxcbiAgICBvcGFjaXR5OiAwLjQ7XFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4yNXMgZWFzZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBidXR0b246bGFzdC1vZi10eXBlOmhvdmVyIHtcXG4gICAgb3BhY2l0eTogMC43O1xcbiAgfVxcblwiXSkpKTtcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgZGlzYWJsZWRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYWxseS5qcy9tYWludGFpbi9kaXNhYmxlZFwiKSk7XG52YXIgdGFiX2ZvY3VzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFsbHkuanMvbWFpbnRhaW4vdGFiLWZvY3VzXCIpKTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIGJvZHlfbG9ja2VyXzEgPSByZXF1aXJlKFwiLi9ib2R5LWxvY2tlclwiKTtcbnZhciBPdmVybGF5ID0gZnVuY3Rpb24gT3ZlcmxheShfYSkge1xuICAgIHZhciBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWUsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGZpeGVkID0gX2EuZml4ZWQ7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYm9keV9sb2NrZXJfMS5sb2NrKCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBib2R5X2xvY2tlcl8xLnVubG9jaygpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB2YXIgX2IgPSBfX3JlYWQoUmVhY3QudXNlU3RhdGUobnVsbCksIDIpLCBvdmVybGF5ID0gX2JbMF0sIHNldE92ZXJsYXkgPSBfYlsxXTtcbiAgICB2YXIgb25PdmVybGF5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHNldE92ZXJsYXkoZWwpO1xuICAgIH0sIFtdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAob3ZlcmxheSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhbmRsZTEgPSBkaXNhYmxlZF8xW1wiZGVmYXVsdFwiXSh7IGZpbHRlcjogb3ZlcmxheSB9KTtcbiAgICAgICAgdmFyIGhhbmRsZTIgPSB0YWJfZm9jdXNfMVtcImRlZmF1bHRcIl0oeyBjb250ZXh0OiBvdmVybGF5IH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaGFuZGxlMS5kaXNlbmdhZ2UoKTtcbiAgICAgICAgICAgIGhhbmRsZTIuZGlzZW5nYWdlKCk7XG4gICAgICAgIH07XG4gICAgfSwgW292ZXJsYXldKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtbmV4dGpzLWRpYWxvZy1vdmVybGF5XCI6IHRydWUsIGNsYXNzTmFtZTogY2xhc3NOYW1lLCByZWY6IG9uT3ZlcmxheSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3BcIjogdHJ1ZSwgXCJkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3AtZml4ZWRcIjogZml4ZWQgPyB0cnVlIDogdW5kZWZpbmVkIH0pLFxuICAgICAgICBjaGlsZHJlbikpO1xufTtcbmV4cG9ydHMuT3ZlcmxheSA9IE92ZXJsYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgcHJldmlvdXNCb2R5UGFkZGluZ1JpZ2h0O1xudmFyIHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZztcbnZhciBhY3RpdmVMb2NrcyA9IDA7XG5mdW5jdGlvbiBsb2NrKCkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoYWN0aXZlTG9ja3MrKyA+IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Nyb2xsQmFyR2FwID0gd2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgIGlmIChzY3JvbGxCYXJHYXAgPiAwKSB7XG4gICAgICAgICAgICBwcmV2aW91c0JvZHlQYWRkaW5nUmlnaHQgPSBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodDtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gc2Nyb2xsQmFyR2FwICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZyA9IGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3c7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB9KTtcbn1cbmV4cG9ydHMubG9jayA9IGxvY2s7XG5mdW5jdGlvbiB1bmxvY2soKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChhY3RpdmVMb2NrcyA9PT0gMCB8fCAtLWFjdGl2ZUxvY2tzICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZpb3VzQm9keVBhZGRpbmdSaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHByZXZpb3VzQm9keVBhZGRpbmdSaWdodDtcbiAgICAgICAgICAgIHByZXZpb3VzQm9keVBhZGRpbmdSaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBwcmV2aW91c0JvZHlPdmVyZmxvd1NldHRpbmc7XG4gICAgICAgICAgICBwcmV2aW91c0JvZHlPdmVyZmxvd1NldHRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMudW5sb2NrID0gdW5sb2NrO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIE92ZXJsYXlfMSA9IHJlcXVpcmUoXCIuL092ZXJsYXlcIik7XG5leHBvcnRzLk92ZXJsYXkgPSBPdmVybGF5XzEuT3ZlcmxheTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgICByZXR1cm4gY29va2VkO1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbm9vcF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcbnZhciBzdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLW92ZXJsYXldIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB0b3A6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBib3R0b206IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICB6LWluZGV4OiA5MDAwO1xcblxcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIHBhZGRpbmc6IDEwdmggMTVweCAwO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYWNrZHJvcF0ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxNywgMTcsIDE3LCAwLjIpO1xcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcbiAgICB6LWluZGV4OiAtMTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3AtZml4ZWRdIHtcXG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG4gICAgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6IGJsdXIoOHB4KTtcXG4gICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDhweCk7XFxuICB9XFxuXCJdLCBbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheV0ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgIHotaW5kZXg6IDkwMDA7XFxuXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgcGFkZGluZzogMTB2aCAxNXB4IDA7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhY2tkcm9wXSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE3LCAxNywgMTcsIDAuMik7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxuICAgIHotaW5kZXg6IC0xO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYWNrZHJvcC1maXhlZF0ge1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgICAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjogYmx1cig4cHgpO1xcbiAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoOHB4KTtcXG4gIH1cXG5cIl0pKSk7XG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgcmVhY3RfZG9tXzEgPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpO1xuZXhwb3J0cy5TaGFkb3dQb3J0YWwgPSBmdW5jdGlvbiBQb3J0YWwoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcbiAgICB2YXIgbW91bnROb2RlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciBwb3J0YWxOb2RlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciBzaGFkb3dOb2RlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciBfYiA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZSgpLCAyKSwgZm9yY2VVcGRhdGUgPSBfYlsxXTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3duZXJEb2N1bWVudCA9IG1vdW50Tm9kZS5jdXJyZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIHBvcnRhbE5vZGUuY3VycmVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbmV4dGpzLXBvcnRhbCcpO1xuICAgICAgICBzaGFkb3dOb2RlLmN1cnJlbnQgPSBwb3J0YWxOb2RlLmN1cnJlbnQuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICBvd25lckRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocG9ydGFsTm9kZS5jdXJyZW50KTtcbiAgICAgICAgZm9yY2VVcGRhdGUoe30pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBvcnRhbE5vZGUuY3VycmVudCAmJiBwb3J0YWxOb2RlLmN1cnJlbnQub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHBvcnRhbE5vZGUuY3VycmVudC5vd25lckRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocG9ydGFsTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHNoYWRvd05vZGUuY3VycmVudCA/IChyZWFjdF9kb21fMS5jcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHNoYWRvd05vZGUuY3VycmVudCkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgcmVmOiBtb3VudE5vZGUgfSkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgYW5zZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYW5zZXJcIikpO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5leHBvcnRzLlRlcm1pbmFsID0gZnVuY3Rpb24gVGVybWluYWwoX2EpIHtcbiAgICB2YXIgY29udGVudCA9IF9hLmNvbnRlbnQ7XG4gICAgdmFyIGRlY29kZWQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFuc2VyXzFbXCJkZWZhdWx0XCJdLmFuc2lUb0pzb24oY29udGVudCwge1xuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIHVzZV9jbGFzc2VzOiB0cnVlLFxuICAgICAgICAgICAgcmVtb3ZlX2VtcHR5OiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0sIFtjb250ZW50XSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy10ZXJtaW5hbFwiOiB0cnVlIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgbnVsbCwgZGVjb2RlZC5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsga2V5OiBcInRlcm1pbmFsLWVudHJ5LVwiICsgaW5kZXgsIHN0eWxlOiBfX2Fzc2lnbih7IGNvbG9yOiBlbnRyeS5mZyA/IFwidmFyKC0tY29sb3ItXCIgKyBlbnRyeS5mZyArIFwiKVwiIDogdW5kZWZpbmVkIH0sIChlbnRyeS5kZWNvcmF0aW9uID09PSAnYm9sZCdcbiAgICAgICAgICAgICAgICA/IHsgZm9udFdlaWdodDogODAwIH1cbiAgICAgICAgICAgICAgICA6IGVudHJ5LmRlY29yYXRpb24gPT09ICdpdGFsaWMnXG4gICAgICAgICAgICAgICAgICAgID8geyBmb250U3R5bGU6ICdpdGFsaWMnIH1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpKSB9LCBlbnRyeS5jb250ZW50KSk7IH0pKSkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBUZXJtaW5hbF8xID0gcmVxdWlyZShcIi4vVGVybWluYWxcIik7XG5leHBvcnRzLlRlcm1pbmFsID0gVGVybWluYWxfMS5UZXJtaW5hbDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgICByZXR1cm4gY29va2VkO1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbm9vcF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcbnZhciBzdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdOjpzZWxlY3Rpb24sXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdICo6OnNlbGVjdGlvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktc2VsZWN0aW9uKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gPiAqIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxcbiAgICAgIGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gcHJlIHtcXG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xcbiAgfVxcblwiXSwgW1wiXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdOjpzZWxlY3Rpb24sXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdICo6OnNlbGVjdGlvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktc2VsZWN0aW9uKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gPiAqIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxcbiAgICAgIGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gcHJlIHtcXG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xcbiAgfVxcblwiXSkpKTtcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbmV4cG9ydHMuVG9hc3QgPSBmdW5jdGlvbiBUb2FzdChfYSkge1xuICAgIHZhciBvbkNsaWNrID0gX2Eub25DbGljaywgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtdG9hc3RcIjogdHJ1ZSwgb25DbGljazogb25DbGljaywgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtdG9hc3Qtd3JhcHBlclwiOiB0cnVlIH0sIGNoaWxkcmVuKSkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBzdHlsZXNfMSA9IHJlcXVpcmUoXCIuL3N0eWxlc1wiKTtcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzXzEuc3R5bGVzO1xudmFyIFRvYXN0XzEgPSByZXF1aXJlKFwiLi9Ub2FzdFwiKTtcbmV4cG9ydHMuVG9hc3QgPSBUb2FzdF8xLlRvYXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xudmFyIHN0eWxlcyA9IG5vb3BfdGVtcGxhdGVfMS5ub29wKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIFtkYXRhLW5leHRqcy10b2FzdF0ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGJvdHRvbTogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gICAgbGVmdDogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gICAgbWF4LXdpZHRoOiA0MjBweDtcXG4gICAgei1pbmRleDogOTAwMDtcXG4gIH1cXG5cXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA0NDBweCkge1xcbiAgICBbZGF0YS1uZXh0anMtdG9hc3RdIHtcXG4gICAgICBtYXgtd2lkdGg6IDkwdnc7XFxuICAgICAgbGVmdDogNXZ3O1xcbiAgICB9XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtdG9hc3Qtd3JhcHBlcl0ge1xcbiAgICBwYWRkaW5nOiAxcmVtO1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcC1oYWxmKTtcXG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICBib3gtc2hhZG93OiAwcHggdmFyKC0tc2l6ZS1nYXAtZG91YmxlKSB2YXIoLS1zaXplLWdhcC1xdWFkKVxcbiAgICAgIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICB9XFxuXCJdLCBbXCJcXG4gIFtkYXRhLW5leHRqcy10b2FzdF0ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGJvdHRvbTogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gICAgbGVmdDogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gICAgbWF4LXdpZHRoOiA0MjBweDtcXG4gICAgei1pbmRleDogOTAwMDtcXG4gIH1cXG5cXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA0NDBweCkge1xcbiAgICBbZGF0YS1uZXh0anMtdG9hc3RdIHtcXG4gICAgICBtYXgtd2lkdGg6IDkwdnc7XFxuICAgICAgbGVmdDogNXZ3O1xcbiAgICB9XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtdG9hc3Qtd3JhcHBlcl0ge1xcbiAgICBwYWRkaW5nOiAxcmVtO1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcC1oYWxmKTtcXG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICBib3gtc2hhZG93OiAwcHggdmFyKC0tc2l6ZS1nYXAtZG91YmxlKSB2YXIoLS1zaXplLWdhcC1xdWFkKVxcbiAgICAgIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICB9XFxuXCJdKSkpO1xuZXhwb3J0cy5zdHlsZXMgPSBzdHlsZXM7XG52YXIgdGVtcGxhdGVPYmplY3RfMTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgICByZXR1cm4gY29va2VkO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBEaWFsb2dfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL0RpYWxvZ1wiKTtcbnZhciBPdmVybGF5XzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9PdmVybGF5XCIpO1xudmFyIFRlcm1pbmFsXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9UZXJtaW5hbFwiKTtcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuZXhwb3J0cy5CdWlsZEVycm9yID0gZnVuY3Rpb24gQnVpbGRFcnJvcihfYSkge1xuICAgIHZhciBtZXNzYWdlID0gX2EubWVzc2FnZTtcbiAgICB2YXIgbm9vcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHsgfSwgW10pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChPdmVybGF5XzEuT3ZlcmxheSwgeyBmaXhlZDogdHJ1ZSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZywgeyB0eXBlOiBcImVycm9yXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IFwibmV4dGpzX19jb250YWluZXJfYnVpbGRfZXJyb3JfbGFiZWxcIiwgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IFwibmV4dGpzX19jb250YWluZXJfYnVpbGRfZXJyb3JfZGVzY1wiLCBvbkNsb3NlOiBub29wIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0NvbnRlbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEaWFsb2dfMS5EaWFsb2dIZWFkZXIsIHsgY2xhc3NOYW1lOiBcIm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItaGVhZGVyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHsgaWQ6IFwibmV4dGpzX19jb250YWluZXJfYnVpbGRfZXJyb3JfbGFiZWxcIiB9LCBcIkZhaWxlZCB0byBjb21waWxlXCIpKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0JvZHksIHsgY2xhc3NOYW1lOiBcIm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItYm9keVwiIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGVybWluYWxfMS5UZXJtaW5hbCwgeyBjb250ZW50OiBtZXNzYWdlIH0pLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZm9vdGVyXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCB7IGlkOiBcIm5leHRqc19fY29udGFpbmVyX2J1aWxkX2Vycm9yX2Rlc2NcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzbWFsbFwiLCBudWxsLCBcIlRoaXMgZXJyb3Igb2NjdXJlZCBkdXJpbmcgdGhlIGJ1aWxkIHByb2Nlc3MgYW5kIGNhbiBvbmx5IGJlIGRpc21pc3NlZCBieSBmaXhpbmcgdGhlIGVycm9yLlwiKSkpKSkpKSk7XG59O1xuZXhwb3J0cy5zdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1oZWFkZXIgPiBoNCB7XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogMDtcXG4gIH1cXG5cXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgZm9vdGVyIHtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc2l6ZS1nYXApO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItYm9keSBmb290ZXIgcCB7XFxuICAgIG1hcmdpbjogMDtcXG4gIH1cXG5cXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgc21hbGwge1xcbiAgICBjb2xvcjogIzc1NzU3NTtcXG4gIH1cXG5cIl0sIFtcIlxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItaGVhZGVyID4gaDQge1xcbiAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IGZvb3RlciB7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgZm9vdGVyIHAge1xcbiAgICBtYXJnaW46IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IHNtYWxsIHtcXG4gICAgY29sb3I6ICM3NTc1NzU7XFxuICB9XFxuXCJdKSkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gICAgcmV0dXJuIGNvb2tlZDtcbn07XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBidXNfMSA9IHJlcXVpcmUoXCIuLi9idXNcIik7XG52YXIgRGlhbG9nXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9EaWFsb2dcIik7XG52YXIgTGVmdFJpZ2h0RGlhbG9nSGVhZGVyXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9MZWZ0UmlnaHREaWFsb2dIZWFkZXJcIik7XG52YXIgT3ZlcmxheV8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvT3ZlcmxheVwiKTtcbnZhciBUb2FzdF8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvVG9hc3RcIik7XG52YXIgbm9kZVN0YWNrRnJhbWVzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub2RlU3RhY2tGcmFtZXNcIik7XG52YXIgbm9vcF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcbnZhciBzdGFja19mcmFtZV8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvc3RhY2stZnJhbWVcIik7XG52YXIgUnVudGltZUVycm9yXzEgPSByZXF1aXJlKFwiLi9SdW50aW1lRXJyb3JcIik7XG5mdW5jdGlvbiBnZXRFcnJvclNpZ25hdHVyZShldikge1xuICAgIHZhciBldmVudCA9IGV2LmV2ZW50O1xuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIGJ1c18xLlRZUEVfVU5IQU5ETEVEX0VSUk9SOlxuICAgICAgICBjYXNlIGJ1c18xLlRZUEVfVU5IQU5ETEVEX1JFSkVDVElPTjoge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnJlYXNvbi5uYW1lICsgXCI6OlwiICsgZXZlbnQucmVhc29uLm1lc3NhZ2UgKyBcIjo6XCIgKyBldmVudC5yZWFzb24uc3RhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgXyA9IGV2ZW50O1xuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGdldEVycm9yQnlUeXBlKGV2KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWQsIGV2ZW50LCBfYSwgX2IsIF87XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlkID0gZXYuaWQsIGV2ZW50ID0gZXYuZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIF9hID0gZXZlbnQudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBidXNfMS5UWVBFX1VOSEFORExFRF9FUlJPUjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGJ1c18xLlRZUEVfVU5IQU5ETEVEX1JFSkVDVElPTjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bnRpbWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXZlbnQucmVhc29uXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHN0YWNrX2ZyYW1lXzEuZ2V0T3JpZ2luYWxTdGFja0ZyYW1lcyhldmVudC5mcmFtZXMpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2IuZnJhbWVzID0gX2Muc2VudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2IpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIF8gPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlIHN5c3RlbSBpbnZhcmlhbnQgdmlvbGF0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5FcnJvcnMgPSBmdW5jdGlvbiBFcnJvcnMoX2EpIHtcbiAgICB2YXIgZXJyb3JzID0gX2EuZXJyb3JzO1xuICAgIHZhciBfYiA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZSh7fSksIDIpLCBsb29rdXBzID0gX2JbMF0sIHNldExvb2t1cHMgPSBfYlsxXTtcbiAgICB2YXIgX2MgPSBfX3JlYWQoUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZWFkeSA9IFtdO1xuICAgICAgICB2YXIgbmV4dCA9IG51bGw7XG4gICAgICAgIC8vIEVuc3VyZSBlcnJvcnMgYXJlIGRpc3BsYXllZCBpbiB0aGUgb3JkZXIgdGhleSBvY2N1cnJlZCBpbjpcbiAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgZXJyb3JzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIHZhciBlID0gZXJyb3JzW2lkeF07XG4gICAgICAgICAgICB2YXIgaWQgPSBlLmlkO1xuICAgICAgICAgICAgaWYgKGlkIGluIGxvb2t1cHMpIHtcbiAgICAgICAgICAgICAgICByZWFkeS5wdXNoKGxvb2t1cHNbaWRdKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgZXJyb3JzXG4gICAgICAgICAgICBpZiAoaWR4ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gZXJyb3JzW2lkeCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChnZXRFcnJvclNpZ25hdHVyZShwcmV2KSA9PT0gZ2V0RXJyb3JTaWduYXR1cmUoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCA9IGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3JlYWR5LCBuZXh0XTtcbiAgICB9LCBbZXJyb3JzLCBsb29rdXBzXSksIDIpLCByZWFkeUVycm9ycyA9IF9jWzBdLCBuZXh0RXJyb3IgPSBfY1sxXTtcbiAgICB2YXIgaXNMb2FkaW5nID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZWFkeUVycm9ycy5sZW5ndGggPCAxICYmIEJvb2xlYW4oZXJyb3JzLmxlbmd0aCk7XG4gICAgfSwgW2Vycm9ycy5sZW5ndGgsIHJlYWR5RXJyb3JzLmxlbmd0aF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuZXh0RXJyb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGdldEVycm9yQnlUeXBlKG5leHRFcnJvcikudGhlbihmdW5jdGlvbiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGNhcmUgaWYgdGhlIGRlc2lyZWQgZXJyb3IgY2hhbmdlZCB3aGlsZSB3ZSB3ZXJlIHJlc29sdmluZyxcbiAgICAgICAgICAgIC8vIHRodXMgd2UncmUgbm90IHRyYWNraW5nIGl0IHVzaW5nIGEgcmVmLiBPbmNlIHRoZSB3b3JrIGhhcyBiZWVuIGRvbmUsXG4gICAgICAgICAgICAvLyB3ZSdsbCBzdG9yZSBpdC5cbiAgICAgICAgICAgIHNldExvb2t1cHMoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbSksIChfYSA9IHt9LCBfYVtyZXNvbHZlZC5pZF0gPSByZXNvbHZlZCwgX2EpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogaGFuZGxlIHRoaXMsIHRob3VnaCBhbiBlZGdlIGNhc2VcbiAgICAgICAgfSk7XG4gICAgfSwgW25leHRFcnJvcl0pO1xuICAgIHZhciBfZCA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZShmYWxzZSksIDIpLCBpc01pbmltaXplZCA9IF9kWzBdLCBzZXRNaW5pbWl6ZWQgPSBfZFsxXTtcbiAgICB2YXIgX2UgPSBfX3JlYWQoUmVhY3QudXNlU3RhdGUoMCksIDIpLCBhY3RpdmVJZHggPSBfZVswXSwgc2V0QWN0aXZlSW5kZXggPSBfZVsxXTtcbiAgICB2YXIgcHJldmlvdXMgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgICAgICBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc2V0QWN0aXZlSW5kZXgoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIE1hdGgubWF4KDAsIHYgLSAxKTsgfSk7XG4gICAgfSwgW10pO1xuICAgIHZhciBuZXh0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNldEFjdGl2ZUluZGV4KGZ1bmN0aW9uICh2KSB7IHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWFkeUVycm9ycy5sZW5ndGggLSAxLCB2ICsgMSkpOyB9KTtcbiAgICB9LCBbcmVhZHlFcnJvcnMubGVuZ3RoXSk7XG4gICAgdmFyIGFjdGl2ZUVycm9yID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHJlYWR5RXJyb3JzW2FjdGl2ZUlkeF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7IH0sIFthY3RpdmVJZHgsIHJlYWR5RXJyb3JzXSk7XG4gICAgLy8gUmVzZXQgY29tcG9uZW50IHN0YXRlIHdoZW4gdGhlcmUgYXJlIG5vIGVycm9ycyB0byBiZSBkaXNwbGF5ZWQuXG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgbGV0cyBoYW5kbGUgaXQuXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICBzZXRMb29rdXBzKHt9KTtcbiAgICAgICAgICAgIHNldE1pbmltaXplZChmYWxzZSk7XG4gICAgICAgICAgICBzZXRBY3RpdmVJbmRleCgwKTtcbiAgICAgICAgfVxuICAgIH0sIFtlcnJvcnMubGVuZ3RoXSk7XG4gICAgdmFyIG1pbmltaXplID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNldE1pbmltaXplZCh0cnVlKTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHJlb3BlbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZXRNaW5pbWl6ZWQoZmFsc2UpO1xuICAgIH0sIFtdKTtcbiAgICAvLyBUaGlzIGNvbXBvbmVudCBzaG91bGRuJ3QgYmUgcmVuZGVyZWQgd2l0aCBubyBlcnJvcnMsIGJ1dCBpZiBpdCBpcywgbGV0J3NcbiAgICAvLyBoYW5kbGUgaXQgZ3JhY2VmdWxseSBieSByZW5kZXJpbmcgbm90aGluZy5cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc0xvYWRpbmcpIHtcbiAgICAgICAgLy8gVE9ETzogYmV0dGVyIGxvYWRpbmcgc3RhdGVcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoT3ZlcmxheV8xLk92ZXJsYXksIG51bGwpO1xuICAgIH1cbiAgICBpZiAoaXNNaW5pbWl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFRvYXN0XzEuVG9hc3QsIHsgY2xhc3NOYW1lOiBcIm5leHRqcy10b2FzdC1lcnJvcnMtcGFyZW50XCIsIG9uQ2xpY2s6IHJlb3BlbiB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJuZXh0anMtdG9hc3QtZXJyb3JzXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IFwiMjRcIiwgaGVpZ2h0OiBcIjI0XCIsIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwgeyBjeDogXCIxMlwiLCBjeTogXCIxMlwiLCByOiBcIjEwXCIgfSksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHsgeDE6IFwiMTJcIiwgeTE6IFwiOFwiLCB4MjogXCIxMlwiLCB5MjogXCIxMlwiIH0pLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7IHgxOiBcIjEyXCIsIHkxOiBcIjE2XCIsIHgyOiBcIjEyLjAxXCIsIHkyOiBcIjE2XCIgfSkpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlYWR5RXJyb3JzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgXCIgZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgcmVhZHlFcnJvcnMubGVuZ3RoID4gMSA/ICdzJyA6ICcnKSkpKTtcbiAgICB9XG4gICAgdmFyIGlzU2VydmVyRXJyb3IgPSBub2RlU3RhY2tGcmFtZXNfMS5pc05vZGVFcnJvcihhY3RpdmVFcnJvci5lcnJvcik7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KE92ZXJsYXlfMS5PdmVybGF5LCBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZywgeyB0eXBlOiBcImVycm9yXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IFwibmV4dGpzX19jb250YWluZXJfZXJyb3JzX2xhYmVsXCIsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBcIm5leHRqc19fY29udGFpbmVyX2Vycm9yc19kZXNjXCIsIG9uQ2xvc2U6IG1pbmltaXplIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0NvbnRlbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEaWFsb2dfMS5EaWFsb2dIZWFkZXIsIHsgY2xhc3NOYW1lOiBcIm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlclwiIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGVmdFJpZ2h0RGlhbG9nSGVhZGVyXzEuTGVmdFJpZ2h0RGlhbG9nSGVhZGVyLCB7IHByZXZpb3VzOiBhY3RpdmVJZHggPiAwID8gcHJldmlvdXMgOiBudWxsLCBuZXh0OiBhY3RpdmVJZHggPCByZWFkeUVycm9ycy5sZW5ndGggLSAxID8gbmV4dCA6IG51bGwsIGNsb3NlOiBtaW5pbWl6ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNtYWxsXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgYWN0aXZlSWR4ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgb2ZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnICcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgcmVhZHlFcnJvcnMubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiB1bmhhbmRsZWQgZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkeUVycm9ycy5sZW5ndGggPCAyID8gJycgOiAncycpKSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImgxXCIsIHsgaWQ6IFwibmV4dGpzX19jb250YWluZXJfZXJyb3JzX2xhYmVsXCIgfSwgaXNTZXJ2ZXJFcnJvciA/ICdTZXJ2ZXIgRXJyb3InIDogJ1VuaGFuZGxlZCBSdW50aW1lIEVycm9yJyksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHsgaWQ6IFwibmV4dGpzX19jb250YWluZXJfZXJyb3JzX2Rlc2NcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlRXJyb3IuZXJyb3IubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiOiBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUVycm9yLmVycm9yLm1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAgICBpc1NlcnZlckVycm9yID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzbWFsbFwiLCBudWxsLCBcIlRoaXMgZXJyb3IgaGFwcGVuZWQgd2hpbGUgZ2VuZXJhdGluZyB0aGUgcGFnZS4gQW55IGNvbnNvbGUgbG9ncyB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgdGVybWluYWwgd2luZG93LlwiKSkpIDogKHVuZGVmaW5lZCkpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGlhbG9nXzEuRGlhbG9nQm9keSwgeyBjbGFzc05hbWU6IFwibmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtYm9keVwiIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUnVudGltZUVycm9yXzEuUnVudGltZUVycm9yLCB7IGtleTogYWN0aXZlRXJyb3IuaWQudG9TdHJpbmcoKSwgZXJyb3I6IGFjdGl2ZUVycm9yIH0pKSkpKSk7XG59O1xuZXhwb3J0cy5zdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gaDEge1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1iaWcpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgc21hbGwge1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTEpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgc21hbGwgPiBzcGFuIHtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBwIHtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZyk7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gZGl2ID4gc21hbGwge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgfVxcblxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWJvZHkgPiBoNTpub3QoOmZpcnN0LWNoaWxkKSB7XFxuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtYm9keSA+IGg1IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXApO1xcbiAgfVxcblxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMtcGFyZW50IHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBlYXNlO1xcbiAgfVxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMtcGFyZW50OmhvdmVyIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xcbiAgfVxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycyA+IHN2ZyB7XFxuICAgIG1hcmdpbi1yaWdodDogdmFyKC0tc2l6ZS1nYXApO1xcbiAgfVxcblwiXSwgW1wiXFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gaDEge1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1iaWcpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgc21hbGwge1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTEpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgc21hbGwgPiBzcGFuIHtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBwIHtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZyk7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gZGl2ID4gc21hbGwge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgfVxcblxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWJvZHkgPiBoNTpub3QoOmZpcnN0LWNoaWxkKSB7XFxuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtYm9keSA+IGg1IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXApO1xcbiAgfVxcblxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMtcGFyZW50IHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBlYXNlO1xcbiAgfVxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMtcGFyZW50OmhvdmVyIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xcbiAgfVxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycyA+IHN2ZyB7XFxuICAgIG1hcmdpbi1yaWdodDogdmFyKC0tc2l6ZS1nYXApO1xcbiAgfVxcblwiXSkpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIENvZGVGcmFtZV8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvQ29kZUZyYW1lXCIpO1xudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XG52YXIgc3RhY2tfZnJhbWVfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3N0YWNrLWZyYW1lXCIpO1xudmFyIENhbGxTdGFja0ZyYW1lID0gZnVuY3Rpb24gQ2FsbFN0YWNrRnJhbWUoX2EpIHtcbiAgICAvLyBUT0RPOiBhYmlsaXR5IHRvIGV4cGFuZCByZXNvbHZlZCBmcmFtZXNcbiAgICAvLyBUT0RPOiByZW5kZXIgZXJyb3Igb3IgZXh0ZXJuYWwgaW5kaWNhdG9yXG4gICAgdmFyIGZyYW1lID0gX2EuZnJhbWU7XG4gICAgdmFyIF9iO1xuICAgIHZhciBmID0gKF9iID0gZnJhbWUub3JpZ2luYWxTdGFja0ZyYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmcmFtZS5zb3VyY2VTdGFja0ZyYW1lO1xuICAgIHZhciBoYXNTb3VyY2UgPSBCb29sZWFuKGZyYW1lLm9yaWdpbmFsQ29kZUZyYW1lKTtcbiAgICB2YXIgb3BlbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWhhc1NvdXJjZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGYpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoa2V5LCAoKF9hID0gZltrZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJykudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5mZXRjaChcIi9fX25leHRqc19sYXVuY2gtZWRpdG9yP1wiICsgcGFyYW1zLnRvU3RyaW5nKCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBvcnQgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgfSwgW2hhc1NvdXJjZSwgZl0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZVwiOiB0cnVlIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNlwiLCB7IFwiZGF0YS1uZXh0anMtZnJhbWUtZXhwYW5kZWRcIjogQm9vbGVhbihmcmFtZS5leHBhbmRlZCkgfSwgZi5tZXRob2ROYW1lKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1oYXMtc291cmNlXCI6IGhhc1NvdXJjZSA/ICd0cnVlJyA6IHVuZGVmaW5lZCwgdGFiSW5kZXg6IGhhc1NvdXJjZSA/IDEwIDogdW5kZWZpbmVkLCByb2xlOiBoYXNTb3VyY2UgPyAnbGluaycgOiB1bmRlZmluZWQsIG9uQ2xpY2s6IG9wZW4sIHRpdGxlOiBoYXNTb3VyY2UgPyAnQ2xpY2sgdG8gb3BlbiBpbiB5b3VyIGVkaXRvcicgOiB1bmRlZmluZWQgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIHN0YWNrX2ZyYW1lXzEuZ2V0RnJhbWVTb3VyY2UoZikpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xOCAxM3Y2YTIgMiAwIDAgMS0yIDJINWEyIDIgMCAwIDEtMi0yVjhhMiAyIDAgMCAxIDItMmg2XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIsIHsgcG9pbnRzOiBcIjE1IDMgMjEgMyAyMSA5XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVcIiwgeyB4MTogXCIxMFwiLCB5MTogXCIxNFwiLCB4MjogXCIyMVwiLCB5MjogXCIzXCIgfSkpKSkpO1xufTtcbnZhciBSdW50aW1lRXJyb3IgPSBmdW5jdGlvbiBSdW50aW1lRXJyb3IoX2EpIHtcbiAgICB2YXIgZXJyb3IgPSBfYS5lcnJvcjtcbiAgICB2YXIgZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXJyb3IuZnJhbWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5leHBhbmRlZCAmJlxuICAgICAgICAgICAgICAgIEJvb2xlYW4oZW50cnkub3JpZ2luYWxDb2RlRnJhbWUpICYmXG4gICAgICAgICAgICAgICAgQm9vbGVhbihlbnRyeS5vcmlnaW5hbFN0YWNrRnJhbWUpO1xuICAgICAgICB9KTtcbiAgICB9LCBbZXJyb3IuZnJhbWVzXSk7XG4gICAgdmFyIGZpcnN0RnJhbWUgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gZXJyb3IuZnJhbWVzW2ZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgIH0sIFtlcnJvci5mcmFtZXMsIGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXhdKTtcbiAgICB2YXIgYWxsTGVhZGluZ0ZyYW1lcyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCA8IDBcbiAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgIDogZXJyb3IuZnJhbWVzLnNsaWNlKDAsIGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXgpO1xuICAgIH0sIFtlcnJvci5mcmFtZXMsIGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXhdKTtcbiAgICB2YXIgX2IgPSBfX3JlYWQoUmVhY3QudXNlU3RhdGUoZmlyc3RGcmFtZSA9PSBudWxsKSwgMiksIGFsbCA9IF9iWzBdLCBzZXRBbGwgPSBfYlsxXTtcbiAgICB2YXIgdG9nZ2xlQWxsID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRBbGwoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICF2OyB9KTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIGxlYWRpbmdGcmFtZXMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFsbExlYWRpbmdGcmFtZXMuZmlsdGVyKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLmV4cGFuZGVkIHx8IGFsbDsgfSk7IH0sIFthbGwsIGFsbExlYWRpbmdGcmFtZXNdKTtcbiAgICB2YXIgYWxsQ2FsbFN0YWNrRnJhbWVzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvci5mcmFtZXMuc2xpY2UoZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCArIDEpOyB9LCBbZXJyb3IuZnJhbWVzLCBmaXJzdEZpcnN0UGFydHlGcmFtZUluZGV4XSk7XG4gICAgdmFyIHZpc2libGVDYWxsU3RhY2tGcmFtZXMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFsbENhbGxTdGFja0ZyYW1lcy5maWx0ZXIoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYuZXhwYW5kZWQgfHwgYWxsOyB9KTsgfSwgW2FsbCwgYWxsQ2FsbFN0YWNrRnJhbWVzXSk7XG4gICAgdmFyIGNhblNob3dNb3JlID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoYWxsQ2FsbFN0YWNrRnJhbWVzLmxlbmd0aCAhPT0gdmlzaWJsZUNhbGxTdGFja0ZyYW1lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIChhbGwgJiYgZmlyc3RGcmFtZSAhPSBudWxsKSk7XG4gICAgfSwgW1xuICAgICAgICBhbGwsXG4gICAgICAgIGFsbENhbGxTdGFja0ZyYW1lcy5sZW5ndGgsXG4gICAgICAgIGZpcnN0RnJhbWUsXG4gICAgICAgIHZpc2libGVDYWxsU3RhY2tGcmFtZXMubGVuZ3RoLFxuICAgIF0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgZmlyc3RGcmFtZSA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg1XCIsIG51bGwsIFwiU291cmNlXCIpLFxuICAgICAgICAgICAgbGVhZGluZ0ZyYW1lcy5tYXAoZnVuY3Rpb24gKGZyYW1lLCBpbmRleCkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsbFN0YWNrRnJhbWUsIHsga2V5OiBcImxlYWRpbmctZnJhbWUtXCIgKyBpbmRleCArIFwiLVwiICsgYWxsLCBmcmFtZTogZnJhbWUgfSkpOyB9KSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29kZUZyYW1lXzEuQ29kZUZyYW1lLCB7IHN0YWNrRnJhbWU6IGZpcnN0RnJhbWUub3JpZ2luYWxTdGFja0ZyYW1lLCBjb2RlRnJhbWU6IGZpcnN0RnJhbWUub3JpZ2luYWxDb2RlRnJhbWUgfSkpKSA6ICh1bmRlZmluZWQpLFxuICAgICAgICB2aXNpYmxlQ2FsbFN0YWNrRnJhbWVzLmxlbmd0aCA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg1XCIsIG51bGwsIFwiQ2FsbCBTdGFja1wiKSxcbiAgICAgICAgICAgIHZpc2libGVDYWxsU3RhY2tGcmFtZXMubWFwKGZ1bmN0aW9uIChmcmFtZSwgaW5kZXgpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KENhbGxTdGFja0ZyYW1lLCB7IGtleTogXCJjYWxsLXN0YWNrLVwiICsgaW5kZXggKyBcIi1cIiArIGFsbCwgZnJhbWU6IGZyYW1lIH0pKTsgfSkpKSA6ICh1bmRlZmluZWQpLFxuICAgICAgICBjYW5TaG93TW9yZSA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHRhYkluZGV4OiAxMCwgXCJkYXRhLW5leHRqcy1kYXRhLXJ1bnRpbWUtZXJyb3ItY29sbGFwc2VkLWFjdGlvblwiOiB0cnVlLCB0eXBlOiBcImJ1dHRvblwiLCBvbkNsaWNrOiB0b2dnbGVBbGwgfSxcbiAgICAgICAgICAgICAgICBhbGwgPyAnSGlkZScgOiAnU2hvdycsXG4gICAgICAgICAgICAgICAgXCIgY29sbGFwc2VkIGZyYW1lc1wiKSkpIDogKHVuZGVmaW5lZCkpKTtcbn07XG5leHBvcnRzLlJ1bnRpbWVFcnJvciA9IFJ1bnRpbWVFcnJvcjtcbmV4cG9ydHMuc3R5bGVzID0gbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgYnV0dG9uW2RhdGEtbmV4dGpzLWRhdGEtcnVudGltZS1lcnJvci1jb2xsYXBzZWQtYWN0aW9uXSB7XFxuICAgIGJhY2tncm91bmQ6IG5vbmU7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTMpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdOm5vdCg6bGFzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDYge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICAgIGNvbG9yOiAjMjIyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDZbZGF0YS1uZXh0anMtZnJhbWUtZXhwYW5kZWQ9J2ZhbHNlJ10ge1xcbiAgICBjb2xvcjogIzY2NjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHBhZGRpbmctbGVmdDogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgY29sb3I6ICM5OTk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXYgPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXApO1xcblxcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV0ge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXTpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdID4gc3ZnIHtcXG4gICAgZGlzcGxheTogdW5zZXQ7XFxuICB9XFxuXCJdLCBbXCJcXG4gIGJ1dHRvbltkYXRhLW5leHRqcy1kYXRhLXJ1bnRpbWUtZXJyb3ItY29sbGFwc2VkLWFjdGlvbl0ge1xcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgbGluZS1oZWlnaHQ6IHZhcigtLXNpemUtZm9udC1iaWdnZXIpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYWNjZW50cy0zKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXTpub3QoOmxhc3QtY2hpbGQpIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGg2IHtcXG4gICAgbWFyZ2luLXRvcDogMDtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXApO1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgICBjb2xvcjogIzIyMjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGg2W2RhdGEtbmV4dGpzLWZyYW1lLWV4cGFuZGVkPSdmYWxzZSddIHtcXG4gICAgY29sb3I6ICM2NjY7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXYge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBwYWRkaW5nLWxlZnQ6IGNhbGModmFyKC0tc2l6ZS1nYXApICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGNvbG9yOiAjOTk5O1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2ID4gc3ZnIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIGhlaWdodDogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgbWFyZ2luLWxlZnQ6IHZhcigtLXNpemUtZ2FwKTtcXG5cXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV06aG92ZXIge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXSA+IHN2ZyB7XFxuICAgIGRpc3BsYXk6IHVuc2V0O1xcbiAgfVxcblwiXSkpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBzdGFja3RyYWNlX3BhcnNlcl8xID0gcmVxdWlyZShcInN0YWNrdHJhY2UtcGFyc2VyXCIpO1xuZnVuY3Rpb24gZ2V0RmlsZXN5c3RlbUZyYW1lKGZyYW1lKSB7XG4gICAgdmFyIGYgPSBfX2Fzc2lnbih7fSwgZnJhbWUpO1xuICAgIGlmICh0eXBlb2YgZi5maWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIFBvc2l4OlxuICAgICAgICBmLmZpbGUuc3RhcnRzV2l0aCgnLycpIHx8XG4gICAgICAgICAgICAvLyBXaW4zMjpcbiAgICAgICAgICAgIC9eW2Etel06XFxcXC9pLnRlc3QoZi5maWxlKSB8fFxuICAgICAgICAgICAgLy8gV2luMzIgVU5DOlxuICAgICAgICAgICAgZi5maWxlLnN0YXJ0c1dpdGgoJ1xcXFxcXFxcJykpIHtcbiAgICAgICAgICAgIGYuZmlsZSA9IFwiZmlsZTovL1wiICsgZi5maWxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmO1xufVxuZXhwb3J0cy5nZXRGaWxlc3lzdGVtRnJhbWUgPSBnZXRGaWxlc3lzdGVtRnJhbWU7XG52YXIgc3ltYm9sTm9kZUVycm9yID0gU3ltYm9sKCdOZXh0anNOb2RlRXJyb3InKTtcbmZ1bmN0aW9uIGlzTm9kZUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHN5bWJvbE5vZGVFcnJvciBpbiBlcnJvcjtcbn1cbmV4cG9ydHMuaXNOb2RlRXJyb3IgPSBpc05vZGVFcnJvcjtcbmZ1bmN0aW9uIGdldE5vZGVFcnJvcihlcnJvcikge1xuICAgIHZhciBuO1xuICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgbiA9IGU7XG4gICAgfVxuICAgIG4ubmFtZSA9IGVycm9yLm5hbWU7XG4gICAgdHJ5IHtcbiAgICAgICAgbi5zdGFjayA9IHN0YWNrdHJhY2VfcGFyc2VyXzEucGFyc2UoZXJyb3Iuc3RhY2spXG4gICAgICAgICAgICAubWFwKGdldEZpbGVzeXN0ZW1GcmFtZSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBcIiAgICBhdCBcIiArIGYubWV0aG9kTmFtZTtcbiAgICAgICAgICAgIGlmIChmLmZpbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9jID0gZi5maWxlO1xuICAgICAgICAgICAgICAgIGlmIChmLmxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jICs9IFwiOlwiICsgZi5saW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZi5jb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYyArPSBcIjpcIiArIGYuY29sdW1uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0ciArPSBcIiAoXCIgKyBsb2MgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICBuLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBzeW1ib2xOb2RlRXJyb3IsIHtcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiBuO1xufVxuZXhwb3J0cy5nZXROb2RlRXJyb3IgPSBnZXROb2RlRXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5mdW5jdGlvbiBub29wKHN0cmluZ3MpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGtleXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBsYXN0SW5kZXggPSBzdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIChzdHJpbmdzLnNsaWNlKDAsIGxhc3RJbmRleCkucmVkdWNlKGZ1bmN0aW9uIChwLCBzLCBpKSB7IHJldHVybiBwICsgcyArIGtleXNbaV07IH0sICcnKSArXG4gICAgICAgIHN0cmluZ3NbbGFzdEluZGV4XSk7XG59XG5leHBvcnRzLm5vb3AgPSBub29wO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIHN0YWNrdHJhY2VfcGFyc2VyXzEgPSByZXF1aXJlKFwic3RhY2t0cmFjZS1wYXJzZXJcIik7XG52YXIgcmVnZXhOZXh0U3RhdGljID0gL1xcL19uZXh0KFxcL3N0YXRpY1xcLy4rKS9nO1xuZnVuY3Rpb24gcGFyc2VTdGFjayhzdGFjaykge1xuICAgIHZhciBmcmFtZXMgPSBzdGFja3RyYWNlX3BhcnNlcl8xLnBhcnNlKHN0YWNrKTtcbiAgICByZXR1cm4gZnJhbWVzLm1hcChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBuZXcgVVJMKGZyYW1lLmZpbGUpO1xuICAgICAgICAgICAgdmFyIHJlcyA9IHJlZ2V4TmV4dFN0YXRpYy5leGVjKHVybC5wYXRobmFtZSk7XG4gICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3REaXIgPSAoX2IgPSAoX2EgPSBwcm9jZXNzLmVudi5fX05FWFRfRElTVF9ESVIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlKC9cXFxcL2csICcvJykpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0RGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLmZpbGUgPSAnZmlsZTovLycgKyBkaXN0RGlyLmNvbmNhdChyZXMucG9wKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2MpIHsgfVxuICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgfSk7XG59XG5leHBvcnRzLnBhcnNlU3RhY2sgPSBwYXJzZVN0YWNrO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmZ1bmN0aW9uIGdldE9yaWdpbmFsU3RhY2tGcmFtZXMoZnJhbWVzKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGZyYW1lcy5tYXAoZnVuY3Rpb24gKGZyYW1lKSB7IHJldHVybiBnZXRPcmlnaW5hbFN0YWNrRnJhbWUoZnJhbWUpOyB9KSk7XG59XG5leHBvcnRzLmdldE9yaWdpbmFsU3RhY2tGcmFtZXMgPSBnZXRPcmlnaW5hbFN0YWNrRnJhbWVzO1xuZnVuY3Rpb24gZ2V0T3JpZ2luYWxTdGFja0ZyYW1lKHNvdXJjZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgZnVuY3Rpb24gX2dldE9yaWdpbmFsU3RhY2tGcmFtZSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcywga2V5LCBjb250cm9sbGVyLCB0bSwgcmVzLCBfYywgX2QsIF9lLCBib2R5O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2YubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChrZXksICgoX2EgPSBzb3VyY2Vba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sbGVyLmFib3J0KCk7IH0sIDMwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2VsZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmV0Y2goXCIvX19uZXh0anNfb3JpZ2luYWwtc3RhY2stZnJhbWU/XCIgKyBwYXJhbXMudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlbXCJmaW5hbGx5XCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCFyZXMub2sgfHwgcmVzLnN0YXR1cyA9PT0gMjA0KSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBfZCA9IChfYyA9IFByb21pc2UpLnJlamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lID0gRXJyb3IuYmluZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlcy50ZXh0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfZC5hcHBseShfYywgW25ldyAoX2UuYXBwbHkoRXJyb3IsIFt2b2lkIDAsIF9mLnNlbnQoKV0pKSgpXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIHJlcy5qc29uKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVybmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQ6ICgoX2IgPSBib2R5Lm9yaWdpbmFsU3RhY2tGcmFtZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZpbGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhYm9keS5vcmlnaW5hbFN0YWNrRnJhbWUuZmlsZS5pbmNsdWRlcygnbm9kZV9tb2R1bGVzJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVN0YWNrRnJhbWU6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFja0ZyYW1lOiBib2R5Lm9yaWdpbmFsU3RhY2tGcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxDb2RlRnJhbWU6IGJvZHkub3JpZ2luYWxDb2RlRnJhbWUgfHwgbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCEoKChfYSA9IHNvdXJjZS5maWxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnRzV2l0aCgnd2VicGFjay1pbnRlcm5hbDonKSkgfHwgKChfYiA9IHNvdXJjZS5maWxlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhcnRzV2l0aCgnZmlsZTonKSkpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICAgICAgcmVhc29uOiBudWxsLFxuICAgICAgICAgICAgZXh0ZXJuYWw6IHRydWUsXG4gICAgICAgICAgICBleHBhbmRlZDogZmFsc2UsXG4gICAgICAgICAgICBzb3VyY2VTdGFja0ZyYW1lOiBzb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbFN0YWNrRnJhbWU6IG51bGwsXG4gICAgICAgICAgICBvcmlnaW5hbENvZGVGcmFtZTogbnVsbFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXRPcmlnaW5hbFN0YWNrRnJhbWUoKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICBlcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgIHJlYXNvbjogKF9iID0gKF9hID0gZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLm1lc3NhZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnVW5rbm93biBFcnJvcicsXG4gICAgICAgICAgICBleHRlcm5hbDogZmFsc2UsXG4gICAgICAgICAgICBleHBhbmRlZDogZmFsc2UsXG4gICAgICAgICAgICBzb3VyY2VTdGFja0ZyYW1lOiBzb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbFN0YWNrRnJhbWU6IG51bGwsXG4gICAgICAgICAgICBvcmlnaW5hbENvZGVGcmFtZTogbnVsbFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0T3JpZ2luYWxTdGFja0ZyYW1lID0gZ2V0T3JpZ2luYWxTdGFja0ZyYW1lO1xuZnVuY3Rpb24gZ2V0RnJhbWVTb3VyY2UoZnJhbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciB1ID0gbmV3IFVSTChmcmFtZS5maWxlKTtcbiAgICAgICAgLy8gU3RyaXAgdGhlIG9yaWdpbiBmb3Igc2FtZS1vcmlnaW4gc2NyaXB0cy5cbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgKChfYSA9IGdsb2JhbFRoaXMubG9jYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcmlnaW4pICE9PSB1Lm9yaWdpbikge1xuICAgICAgICAgICAgLy8gVVJMcyBjYW4gYmUgdmFsaWQgd2l0aG91dCBhbiBgb3JpZ2luYCwgc28gbG9uZyBhcyB0aGV5IGhhdmUgYVxuICAgICAgICAgICAgLy8gYHByb3RvY29sYC4gSG93ZXZlciwgYG9yaWdpbmAgaXMgcHJlZmVycmVkLlxuICAgICAgICAgICAgaWYgKHUub3JpZ2luID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gdS5wcm90b2NvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciArPSB1Lm9yaWdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJpcCBxdWVyeSBzdHJpbmcgaW5mb3JtYXRpb24gYXMgaXQncyB0eXBpY2FsbHkgdG9vIHZlcmJvc2UgdG8gYmVcbiAgICAgICAgLy8gbWVhbmluZ2Z1bC5cbiAgICAgICAgc3RyICs9IHUucGF0aG5hbWU7XG4gICAgICAgIHN0ciArPSAnICc7XG4gICAgfVxuICAgIGNhdGNoIChfYikge1xuICAgICAgICBzdHIgKz0gKGZyYW1lLmZpbGUgfHwgJyh1bmtub3duKScpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoZnJhbWUubGluZU51bWJlciAhPSBudWxsKSB7XG4gICAgICAgIGlmIChmcmFtZS5jb2x1bW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyICs9IFwiKFwiICsgZnJhbWUubGluZU51bWJlciArIFwiOlwiICsgZnJhbWUuY29sdW1uICsgXCIpIFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyICs9IFwiKFwiICsgZnJhbWUubGluZU51bWJlciArIFwiKSBcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyLnNsaWNlKDAsIC0xKTtcbn1cbmV4cG9ydHMuZ2V0RnJhbWVTb3VyY2UgPSBnZXRGcmFtZVNvdXJjZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xuZnVuY3Rpb24gdXNlT25DbGlja091dHNpZGUoZWwsIGhhbmRsZXIpIHtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGNsaWNraW5nIHJlZidzIGVsZW1lbnQgb3IgZGVzY2VuZGVudCBlbGVtZW50c1xuICAgICAgICAgICAgaWYgKCFlbCB8fCBlbC5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVyKGUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcm9vdCA9IGVsLmdldFJvb3ROb2RlKCk7XG4gICAgICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbGlzdGVuZXIpO1xuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGxpc3RlbmVyKTtcbiAgICAgICAgfTtcbiAgICB9LCBbaGFuZGxlciwgZWxdKTtcbn1cbmV4cG9ydHMudXNlT25DbGlja091dHNpZGUgPSB1c2VPbkNsaWNrT3V0c2lkZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgICByZXR1cm4gY29va2VkO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuZnVuY3Rpb24gQmFzZSgpIHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgICBfX2h0bWw6IG5vb3BfdGVtcGxhdGVfMS5ub29wKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgICAgOmhvc3Qge1xcbiAgICAgICAgICAgIC0tc2l6ZS1nYXAtaGFsZjogMC4yNXJlbTsgLyogNHB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWdhcDogMC41cmVtOyAvKiA4cHggKi9cXG4gICAgICAgICAgICAtLXNpemUtZ2FwLWRvdWJsZTogMXJlbTsgLyogMTZweCAqL1xcbiAgICAgICAgICAgIC0tc2l6ZS1nYXAtcXVhZDogMnJlbTsgLyogMzJweCAqL1xcblxcbiAgICAgICAgICAgIC0tc2l6ZS1mb250LXNtYWxsOiAwLjg3NXJlbTsgLyogMTRweCAqL1xcbiAgICAgICAgICAgIC0tc2l6ZS1mb250OiAxcmVtOyAvKiAxNnB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWZvbnQtYmlnOiAxLjI1cmVtOyAvKiAyMHB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWZvbnQtYmlnZ2VyOiAxLjVyZW07IC8qIDI0cHggKi9cXG5cXG4gICAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMTogIzgwODA4MDtcXG4gICAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMjogIzIyMjIyMjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMzogIzQwNDA0MDtcXG5cXG4gICAgICAgICAgICAtLWZvbnQtc3RhY2stbW9ub3NwYWNlOiAnU0ZNb25vLVJlZ3VsYXInLCBDb25zb2xhcyxcXG4gICAgICAgICAgICAgICdMaWJlcmF0aW9uIE1vbm8nLCBNZW5sbywgQ291cmllciwgbW9ub3NwYWNlO1xcblxcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1zZWxlY3Rpb246IHJnYmEoOTUsIDEyNiwgMTUxLCAwLjQ4KTtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYmc6ICMxMTExMTE7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWZnOiAjY2NjY2NjO1xcblxcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS13aGl0ZTogIzc3Nzc3NztcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYmxhY2s6ICMxNDE0MTQ7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJsdWU6ICMwMGFhZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWN5YW46ICM4OGRkZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWdyZWVuOiAjOThlYzY1O1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1tYWdlbnRhOiAjYWE4OGZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1yZWQ6ICNmZjU1NTU7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXllbGxvdzogI2ZmY2MzMztcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlOiAjZmZmZmZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtYmxhY2s6ICM3Nzc3Nzc7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ibHVlOiAjMzNiYmZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtY3lhbjogI2JiZWNmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWdyZWVuOiAjYjZmMjkyO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtbWFnZW50YTogI2NlYmJmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXJlZDogI2ZmODg4ODtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXllbGxvdzogI2ZmZDk2NjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICAubW9ubyB7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBoMSxcXG4gICAgICAgICAgaDIsXFxuICAgICAgICAgIGgzLFxcbiAgICAgICAgICBoNCxcXG4gICAgICAgICAgaDUsXFxuICAgICAgICAgIGg2IHtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGgxIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDIuNXJlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBoMiB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAycmVtO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGgzIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDEuNzVyZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDQge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41cmVtO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGg1IHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDEuMjVyZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDYge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMXJlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgXCJdLCBbXCJcXG4gICAgICAgICAgOmhvc3Qge1xcbiAgICAgICAgICAgIC0tc2l6ZS1nYXAtaGFsZjogMC4yNXJlbTsgLyogNHB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWdhcDogMC41cmVtOyAvKiA4cHggKi9cXG4gICAgICAgICAgICAtLXNpemUtZ2FwLWRvdWJsZTogMXJlbTsgLyogMTZweCAqL1xcbiAgICAgICAgICAgIC0tc2l6ZS1nYXAtcXVhZDogMnJlbTsgLyogMzJweCAqL1xcblxcbiAgICAgICAgICAgIC0tc2l6ZS1mb250LXNtYWxsOiAwLjg3NXJlbTsgLyogMTRweCAqL1xcbiAgICAgICAgICAgIC0tc2l6ZS1mb250OiAxcmVtOyAvKiAxNnB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWZvbnQtYmlnOiAxLjI1cmVtOyAvKiAyMHB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWZvbnQtYmlnZ2VyOiAxLjVyZW07IC8qIDI0cHggKi9cXG5cXG4gICAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMTogIzgwODA4MDtcXG4gICAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMjogIzIyMjIyMjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMzogIzQwNDA0MDtcXG5cXG4gICAgICAgICAgICAtLWZvbnQtc3RhY2stbW9ub3NwYWNlOiAnU0ZNb25vLVJlZ3VsYXInLCBDb25zb2xhcyxcXG4gICAgICAgICAgICAgICdMaWJlcmF0aW9uIE1vbm8nLCBNZW5sbywgQ291cmllciwgbW9ub3NwYWNlO1xcblxcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1zZWxlY3Rpb246IHJnYmEoOTUsIDEyNiwgMTUxLCAwLjQ4KTtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYmc6ICMxMTExMTE7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWZnOiAjY2NjY2NjO1xcblxcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS13aGl0ZTogIzc3Nzc3NztcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYmxhY2s6ICMxNDE0MTQ7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJsdWU6ICMwMGFhZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWN5YW46ICM4OGRkZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWdyZWVuOiAjOThlYzY1O1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1tYWdlbnRhOiAjYWE4OGZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1yZWQ6ICNmZjU1NTU7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXllbGxvdzogI2ZmY2MzMztcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlOiAjZmZmZmZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtYmxhY2s6ICM3Nzc3Nzc7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ibHVlOiAjMzNiYmZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtY3lhbjogI2JiZWNmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWdyZWVuOiAjYjZmMjkyO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtbWFnZW50YTogI2NlYmJmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXJlZDogI2ZmODg4ODtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXllbGxvdzogI2ZmZDk2NjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICAubW9ubyB7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBoMSxcXG4gICAgICAgICAgaDIsXFxuICAgICAgICAgIGgzLFxcbiAgICAgICAgICBoNCxcXG4gICAgICAgICAgaDUsXFxuICAgICAgICAgIGg2IHtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGgxIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDIuNXJlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBoMiB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAycmVtO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGgzIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDEuNzVyZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDQge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41cmVtO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGg1IHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDEuMjVyZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDYge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMXJlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgXCJdKSkpXG4gICAgICAgIH0gfSkpO1xufVxuZXhwb3J0cy5CYXNlID0gQmFzZTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIHN0eWxlc18xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvQ29kZUZyYW1lL3N0eWxlc1wiKTtcbnZhciBEaWFsb2dfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL0RpYWxvZ1wiKTtcbnZhciBzdHlsZXNfMiA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL0xlZnRSaWdodERpYWxvZ0hlYWRlci9zdHlsZXNcIik7XG52YXIgc3R5bGVzXzMgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9PdmVybGF5L3N0eWxlc1wiKTtcbnZhciBzdHlsZXNfNCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL1Rlcm1pbmFsL3N0eWxlc1wiKTtcbnZhciBUb2FzdF8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvVG9hc3RcIik7XG52YXIgQnVpbGRFcnJvcl8xID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9CdWlsZEVycm9yXCIpO1xudmFyIEVycm9yc18xID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9FcnJvcnNcIik7XG52YXIgUnVudGltZUVycm9yXzEgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL1J1bnRpbWVFcnJvclwiKTtcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuZnVuY3Rpb24gQ29tcG9uZW50U3R5bGVzKCkge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInN0eWxlXCIsIHsgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICAgIF9faHRtbDogbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcblxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgXCJdLCBbXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG5cXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgIFwiXSkpLCBzdHlsZXNfMy5zdHlsZXMsIFRvYXN0XzEuc3R5bGVzLCBEaWFsb2dfMS5zdHlsZXMsIHN0eWxlc18yLnN0eWxlcywgc3R5bGVzXzEuc3R5bGVzLCBzdHlsZXNfNC5zdHlsZXMsIEJ1aWxkRXJyb3JfMS5zdHlsZXMsIEVycm9yc18xLnN0eWxlcywgUnVudGltZUVycm9yXzEuc3R5bGVzKVxuICAgICAgICB9IH0pKTtcbn1cbmV4cG9ydHMuQ29tcG9uZW50U3R5bGVzID0gQ29tcG9uZW50U3R5bGVzO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gICAgcmV0dXJuIGNvb2tlZDtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgbm9vcF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcbmZ1bmN0aW9uIENzc1Jlc2V0KCkge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInN0eWxlXCIsIHsgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICAgIF9faHRtbDogbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgICAgYWxsOiBpbml0aWFsO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIC8qIVxcbiAgICAgICAgICAgKiBCb290c3RyYXAgUmVib290IHY0LjQuMSAoaHR0cHM6Ly9nZXRib290c3RyYXAuY29tLylcXG4gICAgICAgICAgICogQ29weXJpZ2h0IDIwMTEtMjAxOSBUaGUgQm9vdHN0cmFwIEF1dGhvcnNcXG4gICAgICAgICAgICogQ29weXJpZ2h0IDIwMTEtMjAxOSBUd2l0dGVyLCBJbmMuXFxuICAgICAgICAgICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXFxuICAgICAgICAgICAqIEZvcmtlZCBmcm9tIE5vcm1hbGl6ZS5jc3MsIGxpY2Vuc2VkIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kKVxcbiAgICAgICAgICAgKi9cXG4gICAgICAgICAgKixcXG4gICAgICAgICAgKjo6YmVmb3JlLFxcbiAgICAgICAgICAqOjphZnRlciB7XFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEuMTU7XFxuICAgICAgICAgICAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xcbiAgICAgICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhcnRpY2xlLFxcbiAgICAgICAgICBhc2lkZSxcXG4gICAgICAgICAgZmlnY2FwdGlvbixcXG4gICAgICAgICAgZmlndXJlLFxcbiAgICAgICAgICBmb290ZXIsXFxuICAgICAgICAgIGhlYWRlcixcXG4gICAgICAgICAgaGdyb3VwLFxcbiAgICAgICAgICBtYWluLFxcbiAgICAgICAgICBuYXYsXFxuICAgICAgICAgIHNlY3Rpb24ge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NlZ29lIFVJJywgUm9ib3RvLFxcbiAgICAgICAgICAgICAgJ0hlbHZldGljYSBOZXVlJywgQXJpYWwsICdOb3RvIFNhbnMnLCBzYW5zLXNlcmlmLFxcbiAgICAgICAgICAgICAgJ0FwcGxlIENvbG9yIEVtb2ppJywgJ1NlZ29lIFVJIEVtb2ppJywgJ1NlZ29lIFVJIFN5bWJvbCcsXFxuICAgICAgICAgICAgICAnTm90byBDb2xvciBFbW9qaSc7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxcmVtO1xcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEuNTtcXG4gICAgICAgICAgICBjb2xvcjogIzIxMjUyOTtcXG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3RhYmluZGV4PSctMSddOmZvY3VzOm5vdCg6Zm9jdXMtdmlzaWJsZSkge1xcbiAgICAgICAgICAgIG91dGxpbmU6IDAgIWltcG9ydGFudDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBociB7XFxuICAgICAgICAgICAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxuICAgICAgICAgICAgaGVpZ2h0OiAwO1xcbiAgICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGgxLFxcbiAgICAgICAgICBoMixcXG4gICAgICAgICAgaDMsXFxuICAgICAgICAgIGg0LFxcbiAgICAgICAgICBoNSxcXG4gICAgICAgICAgaDYge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHAge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhYmJyW3RpdGxlXSxcXG4gICAgICAgICAgYWJicltkYXRhLW9yaWdpbmFsLXRpdGxlXSB7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxuICAgICAgICAgICAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgICAgICAgICAgIGN1cnNvcjogaGVscDtcXG4gICAgICAgICAgICBib3JkZXItYm90dG9tOiAwO1xcbiAgICAgICAgICAgIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uLXNraXAtaW5rOiBub25lO1xcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbi1za2lwLWluazogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhZGRyZXNzIHtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgICAgICAgICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvbCxcXG4gICAgICAgICAgdWwsXFxuICAgICAgICAgIGRsIHtcXG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgb2wgb2wsXFxuICAgICAgICAgIHVsIHVsLFxcbiAgICAgICAgICBvbCB1bCxcXG4gICAgICAgICAgdWwgb2wge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZHQge1xcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZGQge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gICAgICAgICAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBibG9ja3F1b3RlIHtcXG4gICAgICAgICAgICBtYXJnaW46IDAgMCAxcmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGIsXFxuICAgICAgICAgIHN0cm9uZyB7XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzbWFsbCB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiA4MCU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3ViLFxcbiAgICAgICAgICBzdXAge1xcbiAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgICAgICBmb250LXNpemU6IDc1JTtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMDtcXG4gICAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3ViIHtcXG4gICAgICAgICAgICBib3R0b206IC0wLjI1ZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3VwIHtcXG4gICAgICAgICAgICB0b3A6IC0wLjVlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhIHtcXG4gICAgICAgICAgICBjb2xvcjogIzAwN2JmZjtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYTpob3ZlciB7XFxuICAgICAgICAgICAgY29sb3I6ICMwMDU2YjM7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYTpub3QoW2hyZWZdKSB7XFxuICAgICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGE6bm90KFtocmVmXSk6aG92ZXIge1xcbiAgICAgICAgICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwcmUsXFxuICAgICAgICAgIGNvZGUsXFxuICAgICAgICAgIGtiZCxcXG4gICAgICAgICAgc2FtcCB7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IFNGTW9uby1SZWd1bGFyLCBNZW5sbywgTW9uYWNvLCBDb25zb2xhcyxcXG4gICAgICAgICAgICAgICdMaWJlcmF0aW9uIE1vbm8nLCAnQ291cmllciBOZXcnLCBtb25vc3BhY2U7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcHJlIHtcXG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZmlndXJlIHtcXG4gICAgICAgICAgICBtYXJnaW46IDAgMCAxcmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGltZyB7XFxuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgICAgICAgICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3ZnIHtcXG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGFibGUge1xcbiAgICAgICAgICAgIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgY2FwdGlvbiB7XFxuICAgICAgICAgICAgcGFkZGluZy10b3A6IDAuNzVyZW07XFxuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206IDAuNzVyZW07XFxuICAgICAgICAgICAgY29sb3I6ICM2Yzc1N2Q7XFxuICAgICAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgICAgICAgICBjYXB0aW9uLXNpZGU6IGJvdHRvbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aCB7XFxuICAgICAgICAgICAgdGV4dC1hbGlnbjogaW5oZXJpdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBsYWJlbCB7XFxuICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24ge1xcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnV0dG9uOmZvY3VzIHtcXG4gICAgICAgICAgICBvdXRsaW5lOiAxcHggZG90dGVkO1xcbiAgICAgICAgICAgIG91dGxpbmU6IDVweCBhdXRvIC13ZWJraXQtZm9jdXMtcmluZy1jb2xvcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnB1dCxcXG4gICAgICAgICAgYnV0dG9uLFxcbiAgICAgICAgICBzZWxlY3QsXFxuICAgICAgICAgIG9wdGdyb3VwLFxcbiAgICAgICAgICB0ZXh0YXJlYSB7XFxuICAgICAgICAgICAgbWFyZ2luOiAwO1xcbiAgICAgICAgICAgIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIGlucHV0IHtcXG4gICAgICAgICAgICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIHNlbGVjdCB7XFxuICAgICAgICAgICAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc2VsZWN0IHtcXG4gICAgICAgICAgICB3b3JkLXdyYXA6IG5vcm1hbDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIFt0eXBlPSdidXR0b24nXSxcXG4gICAgICAgICAgW3R5cGU9J3Jlc2V0J10sXFxuICAgICAgICAgIFt0eXBlPSdzdWJtaXQnXSB7XFxuICAgICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnV0dG9uOm5vdCg6ZGlzYWJsZWQpLFxcbiAgICAgICAgICBbdHlwZT0nYnV0dG9uJ106bm90KDpkaXNhYmxlZCksXFxuICAgICAgICAgIFt0eXBlPSdyZXNldCddOm5vdCg6ZGlzYWJsZWQpLFxcbiAgICAgICAgICBbdHlwZT0nc3VibWl0J106bm90KDpkaXNhYmxlZCkge1xcbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b246Oi1tb3otZm9jdXMtaW5uZXIsXFxuICAgICAgICAgIFt0eXBlPSdidXR0b24nXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgICAgW3R5cGU9J3Jlc2V0J106Oi1tb3otZm9jdXMtaW5uZXIsXFxuICAgICAgICAgIFt0eXBlPSdzdWJtaXQnXTo6LW1vei1mb2N1cy1pbm5lciB7XFxuICAgICAgICAgICAgcGFkZGluZzogMDtcXG4gICAgICAgICAgICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW5wdXRbdHlwZT0ncmFkaW8nXSxcXG4gICAgICAgICAgaW5wdXRbdHlwZT0nY2hlY2tib3gnXSB7XFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlucHV0W3R5cGU9J2RhdGUnXSxcXG4gICAgICAgICAgaW5wdXRbdHlwZT0ndGltZSddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdkYXRldGltZS1sb2NhbCddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdtb250aCddIHtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGxpc3Rib3g7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGV4dGFyZWEge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICAgICAgICAgIHJlc2l6ZTogdmVydGljYWw7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZmllbGRzZXQge1xcbiAgICAgICAgICAgIG1pbi13aWR0aDogMDtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbjogMDtcXG4gICAgICAgICAgICBib3JkZXI6IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbGVnZW5kIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgcGFkZGluZzogMDtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxLjVyZW07XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICAgICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgICAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwcm9ncmVzcyB7XFxuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIFt0eXBlPSdudW1iZXInXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXG4gICAgICAgICAgW3R5cGU9J251bWJlciddOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcXG4gICAgICAgICAgICBoZWlnaHQ6IGF1dG87XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3R5cGU9J3NlYXJjaCddIHtcXG4gICAgICAgICAgICBvdXRsaW5lLW9mZnNldDogLTJweDtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3R5cGU9J3NlYXJjaCddOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAgICAgICAgICAgZm9udDogaW5oZXJpdDtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvdXRwdXQge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdW1tYXJ5IHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRlbXBsYXRlIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIFtoaWRkZW5dIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIFwiXSwgW1wiXFxuICAgICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgICBhbGw6IGluaXRpYWw7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgLyohXFxuICAgICAgICAgICAqIEJvb3RzdHJhcCBSZWJvb3QgdjQuNC4xIChodHRwczovL2dldGJvb3RzdHJhcC5jb20vKVxcbiAgICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMS0yMDE5IFRoZSBCb290c3RyYXAgQXV0aG9yc1xcbiAgICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMS0yMDE5IFR3aXR0ZXIsIEluYy5cXG4gICAgICAgICAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcXG4gICAgICAgICAgICogRm9ya2VkIGZyb20gTm9ybWFsaXplLmNzcywgbGljZW5zZWQgTUlUIChodHRwczovL2dpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQpXFxuICAgICAgICAgICAqL1xcbiAgICAgICAgICAqLFxcbiAgICAgICAgICAqOjpiZWZvcmUsXFxuICAgICAgICAgICo6OmFmdGVyIHtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMS4xNTtcXG4gICAgICAgICAgICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7XFxuICAgICAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFydGljbGUsXFxuICAgICAgICAgIGFzaWRlLFxcbiAgICAgICAgICBmaWdjYXB0aW9uLFxcbiAgICAgICAgICBmaWd1cmUsXFxuICAgICAgICAgIGZvb3RlcixcXG4gICAgICAgICAgaGVhZGVyLFxcbiAgICAgICAgICBoZ3JvdXAsXFxuICAgICAgICAgIG1haW4sXFxuICAgICAgICAgIG5hdixcXG4gICAgICAgICAgc2VjdGlvbiB7XFxuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgOmhvc3Qge1xcbiAgICAgICAgICAgIG1hcmdpbjogMDtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU2Vnb2UgVUknLCBSb2JvdG8sXFxuICAgICAgICAgICAgICAnSGVsdmV0aWNhIE5ldWUnLCBBcmlhbCwgJ05vdG8gU2FucycsIHNhbnMtc2VyaWYsXFxuICAgICAgICAgICAgICAnQXBwbGUgQ29sb3IgRW1vamknLCAnU2Vnb2UgVUkgRW1vamknLCAnU2Vnb2UgVUkgU3ltYm9sJyxcXG4gICAgICAgICAgICAgICdOb3RvIENvbG9yIEVtb2ppJztcXG4gICAgICAgICAgICBmb250LXNpemU6IDFyZW07XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICAgICAgICAgIGNvbG9yOiAjMjEyNTI5O1xcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBbdGFiaW5kZXg9Jy0xJ106Zm9jdXM6bm90KDpmb2N1cy12aXNpYmxlKSB7XFxuICAgICAgICAgICAgb3V0bGluZTogMCAhaW1wb3J0YW50O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGhyIHtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG4gICAgICAgICAgICBoZWlnaHQ6IDA7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IHZpc2libGU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaDEsXFxuICAgICAgICAgIGgyLFxcbiAgICAgICAgICBoMyxcXG4gICAgICAgICAgaDQsXFxuICAgICAgICAgIGg1LFxcbiAgICAgICAgICBoNiB7XFxuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcCB7XFxuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFiYnJbdGl0bGVdLFxcbiAgICAgICAgICBhYmJyW2RhdGEtb3JpZ2luYWwtdGl0bGVdIHtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgICAgICAgICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICAgICAgICAgICAgY3Vyc29yOiBoZWxwO1xcbiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDA7XFxuICAgICAgICAgICAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb24tc2tpcC1pbms6IG5vbmU7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uLXNraXAtaW5rOiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFkZHJlc3Mge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICAgICAgICAgICAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG9sLFxcbiAgICAgICAgICB1bCxcXG4gICAgICAgICAgZGwge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvbCBvbCxcXG4gICAgICAgICAgdWwgdWwsXFxuICAgICAgICAgIG9sIHVsLFxcbiAgICAgICAgICB1bCBvbCB7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkdCB7XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkZCB7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbiAgICAgICAgICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJsb2NrcXVvdGUge1xcbiAgICAgICAgICAgIG1hcmdpbjogMCAwIDFyZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYixcXG4gICAgICAgICAgc3Ryb25nIHtcXG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZGVyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHNtYWxsIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDgwJTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdWIsXFxuICAgICAgICAgIHN1cCB7XFxuICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogNzUlO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAwO1xcbiAgICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdWIge1xcbiAgICAgICAgICAgIGJvdHRvbTogLTAuMjVlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdXAge1xcbiAgICAgICAgICAgIHRvcDogLTAuNWVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGEge1xcbiAgICAgICAgICAgIGNvbG9yOiAjMDA3YmZmO1xcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhOmhvdmVyIHtcXG4gICAgICAgICAgICBjb2xvcjogIzAwNTZiMztcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhOm5vdChbaHJlZl0pIHtcXG4gICAgICAgICAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYTpub3QoW2hyZWZdKTpob3ZlciB7XFxuICAgICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHByZSxcXG4gICAgICAgICAgY29kZSxcXG4gICAgICAgICAga2JkLFxcbiAgICAgICAgICBzYW1wIHtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogU0ZNb25vLVJlZ3VsYXIsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLFxcbiAgICAgICAgICAgICAgJ0xpYmVyYXRpb24gTW9ubycsICdDb3VyaWVyIE5ldycsIG1vbm9zcGFjZTtcXG4gICAgICAgICAgICBmb250LXNpemU6IDFlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwcmUge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gICAgICAgICAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmaWd1cmUge1xcbiAgICAgICAgICAgIG1hcmdpbjogMCAwIDFyZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW1nIHtcXG4gICAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICAgICAgICAgIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdmcge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0YWJsZSB7XFxuICAgICAgICAgICAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBjYXB0aW9uIHtcXG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMC43NXJlbTtcXG4gICAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogMC43NXJlbTtcXG4gICAgICAgICAgICBjb2xvcjogIzZjNzU3ZDtcXG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAgICAgICAgIGNhcHRpb24tc2lkZTogYm90dG9tO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRoIHtcXG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBpbmhlcml0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGxhYmVsIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbiB7XFxuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b246Zm9jdXMge1xcbiAgICAgICAgICAgIG91dGxpbmU6IDFweCBkb3R0ZWQ7XFxuICAgICAgICAgICAgb3V0bGluZTogNXB4IGF1dG8gLXdlYmtpdC1mb2N1cy1yaW5nLWNvbG9yO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlucHV0LFxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIHNlbGVjdCxcXG4gICAgICAgICAgb3B0Z3JvdXAsXFxuICAgICAgICAgIHRleHRhcmVhIHtcXG4gICAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxuICAgICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbixcXG4gICAgICAgICAgaW5wdXQge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbixcXG4gICAgICAgICAgc2VsZWN0IHtcXG4gICAgICAgICAgICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzZWxlY3Qge1xcbiAgICAgICAgICAgIHdvcmQtd3JhcDogbm9ybWFsO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbixcXG4gICAgICAgICAgW3R5cGU9J2J1dHRvbiddLFxcbiAgICAgICAgICBbdHlwZT0ncmVzZXQnXSxcXG4gICAgICAgICAgW3R5cGU9J3N1Ym1pdCddIHtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b246bm90KDpkaXNhYmxlZCksXFxuICAgICAgICAgIFt0eXBlPSdidXR0b24nXTpub3QoOmRpc2FibGVkKSxcXG4gICAgICAgICAgW3R5cGU9J3Jlc2V0J106bm90KDpkaXNhYmxlZCksXFxuICAgICAgICAgIFt0eXBlPSdzdWJtaXQnXTpub3QoOmRpc2FibGVkKSB7XFxuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgICAgW3R5cGU9J2J1dHRvbiddOjotbW96LWZvY3VzLWlubmVyLFxcbiAgICAgICAgICBbdHlwZT0ncmVzZXQnXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgICAgW3R5cGU9J3N1Ym1pdCddOjotbW96LWZvY3VzLWlubmVyIHtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICAgIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdyYWRpbyddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdjaGVja2JveCddIHtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW5wdXRbdHlwZT0nZGF0ZSddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSd0aW1lJ10sXFxuICAgICAgICAgIGlucHV0W3R5cGU9J2RhdGV0aW1lLWxvY2FsJ10sXFxuICAgICAgICAgIGlucHV0W3R5cGU9J21vbnRoJ10ge1xcbiAgICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbGlzdGJveDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0ZXh0YXJlYSB7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgICAgICAgICAgcmVzaXplOiB2ZXJ0aWNhbDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmaWVsZHNldCB7XFxuICAgICAgICAgICAgbWluLXdpZHRoOiAwO1xcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICAgICAgbWFyZ2luOiAwO1xcbiAgICAgICAgICAgIGJvcmRlcjogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBsZWdlbmQge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICAgIG1heC13aWR0aDogMTAwJTtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gICAgICAgICAgICBmb250LXNpemU6IDEuNXJlbTtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gICAgICAgICAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgICAgICAgICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHByb2dyZXNzIHtcXG4gICAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3R5cGU9J251bWJlciddOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxcbiAgICAgICAgICBbdHlwZT0nbnVtYmVyJ106Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xcbiAgICAgICAgICAgIGhlaWdodDogYXV0bztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBbdHlwZT0nc2VhcmNoJ10ge1xcbiAgICAgICAgICAgIG91dGxpbmUtb2Zmc2V0OiAtMnB4O1xcbiAgICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBbdHlwZT0nc2VhcmNoJ106Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xcbiAgICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICA6Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcXG4gICAgICAgICAgICBmb250OiBpbmhlcml0O1xcbiAgICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG91dHB1dCB7XFxuICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHN1bW1hcnkge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGxpc3QtaXRlbTtcXG4gICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGVtcGxhdGUge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW2hpZGRlbl0ge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgXCJdKSkpXG4gICAgICAgIH0gfSkpO1xufVxuZXhwb3J0cy5Dc3NSZXNldCA9IENzc1Jlc2V0O1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKHtvbmx5Rmlyc3QgPSBmYWxzZX0gPSB7fSkgPT4ge1xuXHRjb25zdCBwYXR0ZXJuID0gW1xuXHRcdCdbXFxcXHUwMDFCXFxcXHUwMDlCXVtbXFxcXF0oKSM7P10qKD86KD86KD86W2EtekEtWlxcXFxkXSooPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10qKSopP1xcXFx1MDAwNyknLFxuXHRcdCcoPzooPzpcXFxcZHsxLDR9KD86O1xcXFxkezAsNH0pKik/W1xcXFxkQS1QUi1UWmNmLW50cXJ5PT48fl0pKSdcblx0XS5qb2luKCd8Jyk7XG5cblx0cmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgb25seUZpcnN0ID8gdW5kZWZpbmVkIDogJ2cnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nID0+IHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnID8gc3RyaW5nLnJlcGxhY2UoYW5zaVJlZ2V4KCksICcnKSA6IHN0cmluZztcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNvbnRleHQsIGRpc2FibGVkU3RhdGUpIHtcbiAgaWYgKCFzdXBwb3J0cykge1xuICAgIHN1cHBvcnRzID0gKDAsIF9zdXBwb3J0czMuZGVmYXVsdCkoKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gKDAsIF9jb250ZXh0VG9FbGVtZW50Mi5kZWZhdWx0KSh7XG4gICAgbGFiZWw6ICdlbGVtZW50L2Rpc2FibGVkJyxcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH0pO1xuXG4gIC8vIGFjY2VwdCB0cnV0aHkvZmFsc3kgdmFsdWVzXG4gIGRpc2FibGVkU3RhdGUgPSBCb29sZWFuKGRpc2FibGVkU3RhdGUpO1xuICB2YXIgY3VycmVudFN0YXRlID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtYWxseS1kaXNhYmxlZCcpO1xuICAvLyBpZiB0aGVyZSdzIG5vIHZhbHVlIHRvIHNldCwgd2UncmUgcnVubmluZyBhcyBhIGdldHRlclxuICB2YXIgcnVubmluZ0FzR2V0dGVyID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMTtcblxuICBpZiAoKDAsIF9uYXRpdmVEaXNhYmxlZFN1cHBvcnRlZDIuZGVmYXVsdCkoZWxlbWVudCkpIHtcbiAgICBpZiAocnVubmluZ0FzR2V0dGVyKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5kaXNhYmxlZDtcbiAgICB9XG5cbiAgICAvLyBmb3JtIGVsZW1lbnRzIGtub3cgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZSwgd2hpY2ggd2Ugc2hhbGwgdXNlIGluc3RlYWQgb2Ygb3VyIHBvb3IgbWFuJ3MgY29weSBvZiBpdFxuICAgIGVsZW1lbnQuZGlzYWJsZWQgPSBkaXNhYmxlZFN0YXRlO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgaWYgKHJ1bm5pbmdBc0dldHRlcikge1xuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cblxuICBpZiAoY3VycmVudFN0YXRlID09PSBkaXNhYmxlZFN0YXRlKSB7XG4gICAgLy8gbm8gdXBkYXRlIG5lY2Vzc2FyeVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgc2V0RWxlbWVudERpc2FibGVkKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcblxudmFyIF90YWJpbmRleFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbC90YWJpbmRleC12YWx1ZScpO1xuXG52YXIgX3RhYmluZGV4VmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiaW5kZXhWYWx1ZSk7XG5cbnZhciBfbmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuLi9pcy9uYXRpdmUtZGlzYWJsZWQtc3VwcG9ydGVkJyk7XG5cbnZhciBfbmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQpO1xuXG52YXIgX3RvZ2dsZUF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4uL3V0aWwvdG9nZ2xlLWF0dHJpYnV0ZScpO1xuXG52YXIgX3RvZ2dsZUF0dHJpYnV0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b2dnbGVBdHRyaWJ1dGUpO1xuXG52YXIgX3RvZ2dsZUF0dHJpYnV0ZVZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbC90b2dnbGUtYXR0cmlidXRlLXZhbHVlJyk7XG5cbnZhciBfdG9nZ2xlQXR0cmlidXRlVmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9nZ2xlQXR0cmlidXRlVmFsdWUpO1xuXG52YXIgX2xvZ2dlciA9IHJlcXVpcmUoJy4uL3V0aWwvbG9nZ2VyJyk7XG5cbnZhciBfbG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZ2dlcik7XG5cbnZhciBfc3VwcG9ydHMyID0gcmVxdWlyZSgnLi4vc3VwcG9ydHMvc3VwcG9ydHMnKTtcblxudmFyIF9zdXBwb3J0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdXBwb3J0czIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgc3VwcG9ydHMgPSB2b2lkIDA7XG4vKlxuICBVdGlsaXR5IHRvIG1ha2UgYW55IGVsZW1lbnQgaW5lcnQgKGRpc2FibGVkKS4gSW5lcnQgbWVhbnMgdGhlIGVsZW1lbnRzIGNhbm5vdCBiZSBpbnRlcmFjdGVkXG4gIHdpdGggYW5kIHRoZXkgY2Fubm90IGJlIGZvY3VzZWQgdmlhIHNjcmlwdCwgcG9pbnRlciBvciBrZXlib2FyZCAtIGFuZCB0aHVzIG5vdCByZWNlaXZlIGZvY3VzLlxuXG4gIEVsZW1lbnRzIG1hZGUgaW5lcnQgKGRpc2FibGVkKSBieSB0aGlzIHV0aWxpdHkgYXJlIGdpdmVuIHRoZSBhdHRyaWJ1dGUgW2RhdGEtYWxseS1kaXNhYmxlZD1cInRydWVcIl0uXG5cbiAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgaW5lcnQgYXR0cmlidXRlIHdhcyBbcmVtb3ZlZF0oaHR0cHM6Ly9odG1sNS5vcmcvci84NTM2KSBbdHdlZXQgYnkgc3RldmVdKGh0dHBzOi8vdHdpdHRlci5jb20vc3RldmVmYXVsa25lci9zdGF0dXMvNDQzMDc1OTAwMjAxMjU5MDA4KVxuICBidXQgZGVmaW5pdGlvbiBvZiBbaW5lcnQgc3VidHJlZXNdKGh0dHBzOi8vd3d3LnczLm9yZy9odG1sL3dnL2RyYWZ0cy9odG1sL21hc3Rlci9lZGl0aW5nLmh0bWwjaW5lcnQtc3VidHJlZXMpIHJlbWFpbnMuXG5cbiAgW2ltcGxlbWVudGF0aW9uIGlkZWEgYnkgVmFzaWxpc10oaHR0cHM6Ly9jb2RlcGVuLmlvL3Zhc2lsaXN2Zy9wZW4vc2Nvd0kpXG4gIFtpbmVydCBhdHRyaWJ1dGUgcG9seWZpbGwgYnkgR29vZ2xlQ2hyb21lXShodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL2luZXJ0LXBvbHlmaWxsKVxuXG4gIFtHZWNrbyBCdWc6IEluZXJ0IEF0dHJpYnV0ZV0oaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTIxNTA0KVxuICBbQ2hyb21pdW0gQnVnOiBJbmVydCBBdHRyaWJ1dGVdKGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNjk4NDYpXG4gIFtDaHJvbWl1bSBCdWc6IEluZXJ0IFN1YnRyZWVdKGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNDE2OTkpXG4gIFtXZWJLaXQgQnVnOiBJbmVydCBTdWJ0cmVlXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEwOTUyKVxuKi9cblxuZnVuY3Rpb24gZGlzYWJsZWRGb2N1cygpIHtcbiAgX2xvZ2dlcjIuZGVmYXVsdC53YXJuKCd0cnlpbmcgdG8gZm9jdXMgaW5lcnQgZWxlbWVudCcsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBkaXNhYmxlVGFiaW5kZXgoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSkge1xuICBpZiAoZGlzYWJsZWRTdGF0ZSkge1xuICAgIHZhciB0YWJJbmRleCA9ICgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoZWxlbWVudCk7XG4gICAgKDAsIF90b2dnbGVBdHRyaWJ1dGVWYWx1ZTIuZGVmYXVsdCkoe1xuICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgIGF0dHJpYnV0ZTogJ3RhYmluZGV4JyxcbiAgICAgIHRlbXBvcmFyeVZhbHVlOiAnLTEnLFxuICAgICAgc2F2ZVZhbHVlOiB0YWJJbmRleCAhPT0gbnVsbCA/IHRhYkluZGV4IDogJydcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAoMCwgX3RvZ2dsZUF0dHJpYnV0ZVZhbHVlMi5kZWZhdWx0KSh7XG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgYXR0cmlidXRlOiAndGFiaW5kZXgnXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzYWJsZVZpZGVvQ29udHJvbHMoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSkge1xuICAoMCwgX3RvZ2dsZUF0dHJpYnV0ZTIuZGVmYXVsdCkoe1xuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgYXR0cmlidXRlOiAnY29udHJvbHMnLFxuICAgIHJlbW92ZTogZGlzYWJsZWRTdGF0ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGlzYWJsZVN2Z0ZvY3VzYWJsZShlbGVtZW50LCBkaXNhYmxlZFN0YXRlKSB7XG4gICgwLCBfdG9nZ2xlQXR0cmlidXRlVmFsdWUyLmRlZmF1bHQpKHtcbiAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgIGF0dHJpYnV0ZTogJ2ZvY3VzYWJsZScsXG4gICAgdGVtcG9yYXJ5VmFsdWU6IGRpc2FibGVkU3RhdGUgPyAnZmFsc2UnIDogdW5kZWZpbmVkXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkaXNhYmxlU3ZnTGluayhlbGVtZW50LCBkaXNhYmxlZFN0YXRlKSB7XG4gICgwLCBfdG9nZ2xlQXR0cmlidXRlMi5kZWZhdWx0KSh7XG4gICAgZWxlbWVudDogZWxlbWVudCxcbiAgICBhdHRyaWJ1dGU6ICd4bGluazpocmVmJyxcbiAgICByZW1vdmU6IGRpc2FibGVkU3RhdGVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldEFyaWFEaXNhYmxlZChlbGVtZW50LCBkaXNhYmxlZFN0YXRlKSB7XG4gICgwLCBfdG9nZ2xlQXR0cmlidXRlVmFsdWUyLmRlZmF1bHQpKHtcbiAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgIGF0dHJpYnV0ZTogJ2FyaWEtZGlzYWJsZWQnLFxuICAgIHRlbXBvcmFyeVZhbHVlOiBkaXNhYmxlZFN0YXRlID8gJ3RydWUnIDogdW5kZWZpbmVkXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0Rm9jdXMoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSkge1xuICBpZiAoZGlzYWJsZWRTdGF0ZSkge1xuICAgIC8vIG1ha2Ugc3VyZSBubyBzY3JpcHQgY2FuIGZvY3VzIHRoZSBlbGVtZW50XG4gICAgZWxlbWVudC5mb2N1cyA9IGRpc2FibGVkRm9jdXM7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBmb2N1cyBmdW5jdGlvbiBmcm9tIHByb3RvdHlwZVxuICAgIGRlbGV0ZSBlbGVtZW50LmZvY3VzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc2FibGVQb2ludGVyRXZlbnRzKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpIHtcbiAgaWYgKGRpc2FibGVkU3RhdGUpIHtcbiAgICAvLyByZW1lbWJlciBwcmV2aW91cyBwb2ludGVyIGV2ZW50cyBzdGF0dXMgc28gd2UgY2FuIHJlc3RvcmUgaXRcbiAgICB2YXIgcG9pbnRlckV2ZW50cyA9IGVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyB8fCAnJztcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1pbmVydC1wb2ludGVyLWV2ZW50cycsIHBvaW50ZXJFdmVudHMpO1xuICAgIC8vIG1ha2Ugc3VyZSBubyBwb2ludGVyIGludGVyYWN0aW9uIGNhbiBhY2Nlc3MgdGhlIGVsZW1lbnRcbiAgICBlbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdG9yZSB0byBwcmV2aW91cyBwb2ludGVyIGludGVyYWN0aW9uIHN0YXR1c1xuICAgIHZhciBfcG9pbnRlckV2ZW50cyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWluZXJ0LXBvaW50ZXItZXZlbnRzJyk7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtaW5lcnQtcG9pbnRlci1ldmVudHMnKTtcbiAgICBlbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBfcG9pbnRlckV2ZW50cztcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRFbGVtZW50RGlzYWJsZWQoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSkge1xuICBzZXRBcmlhRGlzYWJsZWQoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSk7XG4gIGRpc2FibGVUYWJpbmRleChlbGVtZW50LCBkaXNhYmxlZFN0YXRlKTtcbiAgZGlzYWJsZVNjcmlwdEZvY3VzKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpO1xuICBkaXNhYmxlUG9pbnRlckV2ZW50cyhlbGVtZW50LCBkaXNhYmxlZFN0YXRlKTtcblxuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChub2RlTmFtZSA9PT0gJ3ZpZGVvJyB8fCBub2RlTmFtZSA9PT0gJ2F1ZGlvJykge1xuICAgIC8vIEJsaW5rIGFuZCBHZWNrbyBsZWF2ZSA8dmlkZW8gY29udHJvbHMgdGFiaW5kZXg9XCItMVwiPiBpbiBkb2N1bWVudCBmb2N1cyBuYXZpZ2F0aW9uIHNlcXVlbmNlXG4gICAgLy8gQmxpbmsgbGVhdmVzIDxhdWRpbyBjb250cm9scyB0YWJpbmRleD1cIi0xXCI+IGluIGRvY3VtZW50IGZvY3VzIG5hdmlnYXRpb24gc2VxdWVuY2VcbiAgICBkaXNhYmxlVmlkZW9Db250cm9scyhlbGVtZW50LCBkaXNhYmxlZFN0YXRlKTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3N2ZycgfHwgZWxlbWVudC5vd25lclNWR0VsZW1lbnQpIHtcbiAgICBpZiAoc3VwcG9ydHMuZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUpIHtcbiAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIGtub3dzIGZvY3VzYWJsZT1cImZhbHNlXCIgaW5zdGVhZCBvZiB0YWJpbmRleD1cIi0xXCJcbiAgICAgIGRpc2FibGVTdmdGb2N1c2FibGUoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSk7XG4gICAgfSBlbHNlIGlmICghc3VwcG9ydHMuZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZSAmJiBub2RlTmFtZSA9PT0gJ2EnKSB7XG4gICAgICAvLyBGaXJlZm94IG5laXRoZXIga25vd3MgZm9jdXNhYmxlPVwiZmFsc2VcIiBub3IgdGFiaW5kZXg9XCItMVwiXG4gICAgICBkaXNhYmxlU3ZnTGluayhlbGVtZW50LCBkaXNhYmxlZFN0YXRlKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlzYWJsZWRTdGF0ZSkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWFsbHktZGlzYWJsZWQnLCAndHJ1ZScpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWFsbHktZGlzYWJsZWQnKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc2FibGVkLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgLy8gRWRnZTEzLCBFZGdlMTQ6IGZvcmVpZ25PYmplY3QgZm9jdXMgaGFja1xuICAvLyBodHRwczovL2pzYmluLmNvbS9rdW5laGludWdpL2VkaXQ/aHRtbCxqcyxvdXRwdXRcbiAgLy8gaHR0cHM6Ly9qc2Jpbi5jb20vZmFqYWdpLzMvZWRpdD9odG1sLGpzLG91dHB1dFxuICB2YXIgaXNTdmdFbGVtZW50ID0gZWxlbWVudC5vd25lclNWR0VsZW1lbnQgfHwgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJztcbiAgaWYgKCFpc1N2Z0VsZW1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpbmplY3QgYW5kIGZvY3VzIGFuIDxpbnB1dD4gZWxlbWVudCBpbnRvIHRoZSBTVkcgZWxlbWVudCB0byByZWNlaXZlIGZvY3VzXG4gIHZhciBmb3JlaWduT2JqZWN0ID0gbWFrZUZvY3VzYWJsZUZvcmVpZ25PYmplY3QoKTtcbiAgZWxlbWVudC5hcHBlbmRDaGlsZChmb3JlaWduT2JqZWN0KTtcbiAgdmFyIGlucHV0ID0gZm9yZWlnbk9iamVjdC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICBpbnB1dC5mb2N1cygpO1xuXG4gIC8vIHVwb24gZGlzYWJsaW5nIHRoZSBhY3RpdmVFbGVtZW50LCBJRSBhbmQgRWRnZVxuICAvLyB3aWxsIG5vdCBzaGlmdCBmb2N1cyB0byA8Ym9keT4gbGlrZSBhbGwgdGhlIG90aGVyXG4gIC8vIGJyb3dzZXJzLCBidXQgaW5zdGVhZCBmaW5kIHRoZSBmaXJzdCBmb2N1c2FibGVcbiAgLy8gYW5jZXN0b3IgYW5kIHNoaWZ0IGZvY3VzIHRvIHRoYXRcbiAgaW5wdXQuZGlzYWJsZWQgPSB0cnVlO1xuXG4gIC8vIGNsZWFuIHVwXG4gIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZm9yZWlnbk9iamVjdCk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gbWFrZUZvY3VzYWJsZUZvcmVpZ25PYmplY3QoKSB7XG4gIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBmcmFnbWVudC5pbm5lckhUTUwgPSAnPHN2Zz48Zm9yZWlnbk9iamVjdCB3aWR0aD1cIjMwXCIgaGVpZ2h0PVwiMzBcIj5cXG4gICAgICA8aW5wdXQgdHlwZT1cInRleHRcIi8+XFxuICA8L2ZvcmVpZ25PYmplY3Q+PC9zdmc+JztcblxuICByZXR1cm4gZnJhZ21lbnQuZmlyc3RDaGlsZC5maXJzdENoaWxkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLnN2Zy1mb3JlaWduLW9iamVjdC1oYWNrLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0O1xuXG4gIHZhciBsaXN0ID0gW107XG4gIHZhciBlbGVtZW50ID0gKDAsIF9jb250ZXh0VG9FbGVtZW50Mi5kZWZhdWx0KSh7XG4gICAgbGFiZWw6ICdnZXQvcGFyZW50cycsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9KTtcblxuICB3aGlsZSAoZWxlbWVudCkge1xuICAgIGxpc3QucHVzaChlbGVtZW50KTtcbiAgICAvLyBJRSBkb2VzIGtub3cgc3VwcG9ydCBwYXJlbnRFbGVtZW50IG9uIFNWR0VsZW1lbnRcbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn07XG5cbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8vIFtlbGVtLCBlbGVtLnBhcmVudCwgZWxlbS5wYXJlbnQucGFyZW50LCDigKYsIGh0bWxdXG4vLyB3aWxsIG5vdCBjb250YWluIHRoZSBzaGFkb3dSb290IChET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSBhbmQgc2hhZG93SG9zdFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyZW50cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dDtcblxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xuICAgIGxhYmVsOiAnZ2V0L3NoYWRvdy1ob3N0JyxcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH0pO1xuXG4gIC8vIHdhbGsgdXAgdG8gdGhlIHJvb3RcbiAgdmFyIGNvbnRhaW5lciA9IG51bGw7XG5cbiAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICBjb250YWluZXIgPSBlbGVtZW50O1xuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS5ub2RlVHlwZVxuICAvLyBOT1RFOiBGaXJlZm94IDM0IGRvZXMgbm90IGV4cG9zZSBTaGFkb3dSb290Lmhvc3QgKGJ1dCAzNyBkb2VzKVxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBjb250YWluZXIuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAmJiBjb250YWluZXIuaG9zdCkge1xuICAgIC8vIHRoZSByb290IGlzIGF0dGFjaGVkIHRvIGEgZnJhZ21lbnQgbm9kZSB0aGF0IGhhcyBhIGhvc3RcbiAgICByZXR1cm4gY29udGFpbmVyLmhvc3Q7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkb3ctaG9zdC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHZhciBlbGVtZW50ID0gKDAsIF9jb250ZXh0VG9FbGVtZW50Mi5kZWZhdWx0KSh7XG4gICAgbGFiZWw6ICdpcy9hY3RpdmUtZWxlbWVudCcsXG4gICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfSk7XG5cbiAgdmFyIF9kb2N1bWVudCA9ICgwLCBfZ2V0RG9jdW1lbnQyLmRlZmF1bHQpKGVsZW1lbnQpO1xuICBpZiAoX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBzaGFkb3dIb3N0ID0gKDAsIF9zaGFkb3dIb3N0Mi5kZWZhdWx0KSh7IGNvbnRleHQ6IGVsZW1lbnQgfSk7XG4gIGlmIChzaGFkb3dIb3N0ICYmIHNoYWRvd0hvc3Quc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50ID09PSBlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XG5cbnZhciBfc2hhZG93SG9zdCA9IHJlcXVpcmUoJy4uL2dldC9zaGFkb3ctaG9zdCcpO1xuXG52YXIgX3NoYWRvd0hvc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhZG93SG9zdCk7XG5cbnZhciBfZ2V0RG9jdW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2dldC1kb2N1bWVudCcpO1xuXG52YXIgX2dldERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldERvY3VtZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gRGV0ZXJtaW5lcyBpZiBhbiBlbGVtZW50IGlzIHRoZSBhY3RpdmVFbGVtZW50IHdpdGhpbiBpdHMgY29udGV4dCwgaS5lLiBpdHMgZG9jdW1lbnQgaUZyYW1lIG9yIFNoYWRvd0hvc3RcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3RpdmUtZWxlbWVudC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIGlmICghc3VwcG9ydHMpIHtcbiAgICBzdXBwb3J0cyA9ICgwLCBfc3VwcG9ydHMzLmRlZmF1bHQpKCk7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xuICAgIGxhYmVsOiAnaXMvZGlzYWJsZWQnLFxuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfSk7XG5cbiAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLWFsbHktZGlzYWJsZWQnKSkge1xuICAgIC8vIHRyZWF0IGFsbHkncyBlbGVtZW50L2Rpc2FibGVkIGxpa2UgdGhlIERPTSBuYXRpdmUgZWxlbWVudC5kaXNhYmxlZFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCEoMCwgX25hdGl2ZURpc2FibGVkU3VwcG9ydGVkMi5kZWZhdWx0KShlbGVtZW50KSkge1xuICAgIC8vIG5vbi1mb3JtIGVsZW1lbnRzIGRvIG5vdCBzdXBwb3J0IHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZWxlbWVudC5kaXNhYmxlZCkge1xuICAgIC8vIHRoZSBlbGVtZW50IGl0c2VsZiBpcyBkaXNhYmxlZFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHBhcmVudHMgPSAoMCwgX3BhcmVudHMyLmRlZmF1bHQpKHsgY29udGV4dDogZWxlbWVudCB9KTtcbiAgaWYgKHBhcmVudHMuc29tZShpc0Rpc2FibGVkRmllbGRzZXQpKSB7XG4gICAgLy8gYSBwYXJlbnRhbCA8ZmllbGRzZXQ+IGlzIGRpc2FibGQgYW5kIGluaGVyaXRzIHRoZSBzdGF0ZSBvbnRvIHRoaXMgZWxlbWVudFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCFzdXBwb3J0cy5mb2N1c0Zvcm1EaXNhYmxlZCAmJiBwYXJlbnRzLnNvbWUoaXNEaXNhYmxlZEZvcm0pKSB7XG4gICAgLy8gYSBwYXJlbnRhbCA8Zm9ybT4gaXMgZGlzYWJsZCBhbmQgaW5oZXJpdHMgdGhlIHN0YXRlIG9udG8gdGhpcyBlbGVtZW50XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XG5cbnZhciBfcGFyZW50cyA9IHJlcXVpcmUoJy4uL2dldC9wYXJlbnRzJyk7XG5cbnZhciBfcGFyZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJlbnRzKTtcblxudmFyIF9uYXRpdmVEaXNhYmxlZFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vbmF0aXZlLWRpc2FibGVkLXN1cHBvcnRlZCcpO1xuXG52YXIgX25hdGl2ZURpc2FibGVkU3VwcG9ydGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX25hdGl2ZURpc2FibGVkU3VwcG9ydGVkKTtcblxudmFyIF9zdXBwb3J0czIgPSByZXF1aXJlKCcuLi9zdXBwb3J0cy9zdXBwb3J0cycpO1xuXG52YXIgX3N1cHBvcnRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1cHBvcnRzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIERldGVybWluZSBpZiBhbiBlbGVtZW50IGlzIGRpc2FibGVkIChpLmUuIG5vdCBlZGl0YWJsZSlcblxudmFyIHN1cHBvcnRzID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBpc0Rpc2FibGVkRmllbGRzZXQoZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ2ZpZWxkc2V0JyAmJiBlbGVtZW50LmRpc2FibGVkO1xufVxuXG5mdW5jdGlvbiBpc0Rpc2FibGVkRm9ybShlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnZm9ybScgJiYgZWxlbWVudC5kaXNhYmxlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXNhYmxlZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcGFyZW50cyA9IHJlcXVpcmUoJy4uL2dldC9wYXJlbnRzJyk7XG5cbnZhciBfcGFyZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJlbnRzKTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xuXG52YXIgX2VsZW1lbnRNYXRjaGVzID0gcmVxdWlyZSgnLi4vdXRpbC9lbGVtZW50LW1hdGNoZXMnKTtcblxudmFyIF9lbGVtZW50TWF0Y2hlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lbGVtZW50TWF0Y2hlcyk7XG5cbnZhciBfdGFiaW5kZXhWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWwvdGFiaW5kZXgtdmFsdWUnKTtcblxudmFyIF90YWJpbmRleFZhbHVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYmluZGV4VmFsdWUpO1xuXG52YXIgX3ZhbGlkVGFiaW5kZXggPSByZXF1aXJlKCcuL3ZhbGlkLXRhYmluZGV4Jyk7XG5cbnZhciBfdmFsaWRUYWJpbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92YWxpZFRhYmluZGV4KTtcblxudmFyIF9pcyA9IHJlcXVpcmUoJy4vaXMudXRpbCcpO1xuXG52YXIgX3N1cHBvcnRzMiA9IHJlcXVpcmUoJy4uL3N1cHBvcnRzL3N1cHBvcnRzJyk7XG5cbnZhciBfc3VwcG9ydHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydHMyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHN1cHBvcnRzID0gdm9pZCAwO1xuLy8gZGV0ZXJtaW5lIGlmIGFuIGVsZW1lbnQgc3VwcG9ydHMuY2FuIGJlIGZvY3VzZWQgYnkgc2NyaXB0IHJlZ2FyZGxlc3Ncbi8vIG9mIHRoZSBlbGVtZW50IGFjdHVhbGx5IGJlaW5nIGZvY3VzYWJsZSBhdCB0aGUgdGltZSBvZiBleGVjdXRpb25cbi8vIGkuZS4gPGlucHV0IGRpc2FibGVkPiBpcyBjb25pc2RlcmVkIGZvY3VzLXJlbGV2YW50LCBidXQgbm90IGZvY3VzYWJsZVxuXG5mdW5jdGlvbiBpc0ZvY3VzUmVsZXZhbnRSdWxlcygpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dCxcbiAgICAgIF9yZWYkZXhjZXB0ID0gX3JlZi5leGNlcHQsXG4gICAgICBleGNlcHQgPSBfcmVmJGV4Y2VwdCA9PT0gdW5kZWZpbmVkID8ge1xuICAgIGZsZXhib3g6IGZhbHNlLFxuICAgIHNjcm9sbGFibGU6IGZhbHNlLFxuICAgIHNoYWRvdzogZmFsc2VcbiAgfSA6IF9yZWYkZXhjZXB0O1xuXG4gIGlmICghc3VwcG9ydHMpIHtcbiAgICBzdXBwb3J0cyA9ICgwLCBfc3VwcG9ydHMzLmRlZmF1bHQpKCk7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xuICAgIGxhYmVsOiAnaXMvZm9jdXMtcmVsZXZhbnQnLFxuICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH0pO1xuXG4gIGlmICghZXhjZXB0LnNoYWRvdyAmJiBlbGVtZW50LnNoYWRvd1Jvb3QpIHtcbiAgICAvLyBhIFNoYWRvd0RPTSBob3N0IHJlY2VpdmVzIGZvY3VzIHdoZW4gdGhlIGZvY3VzIG1vdmVzIHRvIGl0cyBjb250ZW50XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW1lbnQudHlwZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAvLyBpbnB1dFt0eXBlPVwiaGlkZGVuXCJdIHN1cHBvcnRzLmNhbm5vdCBiZSBmb2N1c2VkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnIHx8IG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2J1dHRvbicgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2xlZ2VuZCcgJiYgc3VwcG9ydHMuZm9jdXNSZWRpcmVjdExlZ2VuZCkge1xuICAgIC8vIHNwZWNpZmljcyBmaWx0ZXJlZCBpbiBpcy9mb2N1c2FibGVcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2xhYmVsJykge1xuICAgIC8vIHNwZWNpZmljcyBmaWx0ZXJlZCBpbiBpcy9mb2N1c2FibGVcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2FyZWEnKSB7XG4gICAgLy8gc3BlY2lmaWNzIGZpbHRlcmVkIGluIGlzL2ZvY3VzYWJsZVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnYScgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2hyZWYnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnb2JqZWN0JyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndXNlbWFwJykpIHtcbiAgICAvLyBvYmplY3RbdXNlbWFwXSBpcyBub3QgZm9jdXNhYmxlIGluIGFueSBicm93c2VyXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBzdmdUeXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICBpZiAoIXN1cHBvcnRzLmZvY3VzT2JqZWN0U3ZnICYmIHN2Z1R5cGUgPT09ICdpbWFnZS9zdmcreG1sJykge1xuICAgICAgLy8gb2JqZWN0W3R5cGU9XCJpbWFnZS9zdmcreG1sXCJdIGlzIG5vdCBmb2N1c2FibGUgaW4gSW50ZXJuZXQgRXhwbG9yZXJcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFzdXBwb3J0cy5mb2N1c09iamVjdFN3ZiAmJiBzdmdUeXBlID09PSAnYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gnKSB7XG4gICAgICAvLyBvYmplY3RbdHlwZT1cImFwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoXCJdIGlzIG5vdCBmb2N1c2FibGUgaW4gSW50ZXJuZXQgRXhwbG9yZXIgOVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lmcmFtZScgfHwgbm9kZU5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gYnJvd3NpbmcgY29udGV4dCBjb250YWluZXJzXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICdlbWJlZCcgfHwgbm9kZU5hbWUgPT09ICdrZXlnZW4nKSB7XG4gICAgLy8gZW1iZWQgaXMgY29uc2lkZXJlZCBmb2N1cy1yZWxldmFudCBidXQgbm90IGZvY3VzYWJsZVxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzgyXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSB7XG4gICAgLy8gYWxzbyBzZWUgQ1NTIHByb3BlcnR5IHVzZXItbW9kaWZ5IGJlbG93XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICdhdWRpbycgJiYgKHN1cHBvcnRzLmZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRyb2xzJykpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICd2aWRlbycgJiYgKHN1cHBvcnRzLmZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHMgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRyb2xzJykpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoc3VwcG9ydHMuZm9jdXNTdW1tYXJ5ICYmIG5vZGVOYW1lID09PSAnc3VtbWFyeScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciB2YWxpZFRhYmluZGV4ID0gKDAsIF92YWxpZFRhYmluZGV4Mi5kZWZhdWx0KShlbGVtZW50KTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdpbWcnICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCd1c2VtYXAnKSkge1xuICAgIC8vIEdlY2tvLCBUcmlkZW50IGFuZCBFZGdlIGRvIG5vdCBhbGxvdyBhbiBpbWFnZSB3aXRoIGFuIGltYWdlIG1hcCBhbmQgdGFiaW5kZXggdG8gYmUgZm9jdXNlZCxcbiAgICAvLyBpdCBhcHBlYXJzIHRoZSB0YWJpbmRleCBpcyBvdmVycnVsZWQgc28gZm9jdXMgaXMgc3RpbGwgZm9yd2FyZGVkIHRvIHRoZSA8bWFwPlxuICAgIHJldHVybiB2YWxpZFRhYmluZGV4ICYmIHN1cHBvcnRzLmZvY3VzSW1nVXNlbWFwVGFiaW5kZXggfHwgc3VwcG9ydHMuZm9jdXNSZWRpcmVjdEltZ1VzZW1hcDtcbiAgfVxuXG4gIGlmIChzdXBwb3J0cy5mb2N1c1RhYmxlICYmIChub2RlTmFtZSA9PT0gJ3RhYmxlJyB8fCBub2RlTmFtZSA9PT0gJ3RkJykpIHtcbiAgICAvLyBJRTEwLTExIHN1cHBvcnRzLmNhbiBmb2N1cyA8dGFibGU+IGFuZCA8dGQ+XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoc3VwcG9ydHMuZm9jdXNGaWVsZHNldCAmJiBub2RlTmFtZSA9PT0gJ2ZpZWxkc2V0Jykge1xuICAgIC8vIElFMTAtMTEgc3VwcG9ydHMuY2FuIGZvY3VzIDxmaWVsZHNldD5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBpc1N2Z0VsZW1lbnQgPSBub2RlTmFtZSA9PT0gJ3N2Zyc7XG4gIHZhciBpc1N2Z0NvbnRlbnQgPSBlbGVtZW50Lm93bmVyU1ZHRWxlbWVudDtcbiAgdmFyIGZvY3VzYWJsZUF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdmb2N1c2FibGUnKTtcbiAgdmFyIHRhYmluZGV4ID0gKDAsIF90YWJpbmRleFZhbHVlMi5kZWZhdWx0KShlbGVtZW50KTtcblxuICBpZiAobm9kZU5hbWUgPT09ICd1c2UnICYmIHRhYmluZGV4ICE9PSBudWxsICYmICFzdXBwb3J0cy5mb2N1c1N2Z1VzZVRhYmluZGV4KSB7XG4gICAgLy8gPHVzZT4gY2Fubm90IGJlIG1hZGUgZm9jdXNhYmxlIGJ5IGFkZGluZyBhIHRhYmluZGV4IGF0dHJpYnV0ZSBhbnl3aGVyZSBidXQgQmxpbmsgYW5kIFdlYktpdFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2ZvcmVpZ25vYmplY3QnKSB7XG4gICAgLy8gPHVzZT4gY2FuIG9ubHkgYmUgbWFkZSBmb2N1c2FibGUgaW4gQmxpbmsgYW5kIFdlYktpdFxuICAgIHJldHVybiB0YWJpbmRleCAhPT0gbnVsbCAmJiBzdXBwb3J0cy5mb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleDtcbiAgfVxuXG4gIGlmICgoMCwgX2VsZW1lbnRNYXRjaGVzMi5kZWZhdWx0KShlbGVtZW50LCAnc3ZnIGEnKSAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgneGxpbms6aHJlZicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoKGlzU3ZnRWxlbWVudCB8fCBpc1N2Z0NvbnRlbnQpICYmIGVsZW1lbnQuZm9jdXMgJiYgIXN1cHBvcnRzLmZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZSAmJiB0YWJpbmRleCA8IDApIHtcbiAgICAvLyBGaXJlZm94IDUxIGFuZCA1MiB0cmVhdCBhbnkgbmF0aXZlbHkgdGFiYmFibGUgU1ZHIGVsZW1lbnQgd2l0aFxuICAgIC8vIHRhYmluZGV4PVwiLTFcIiBhcyB0YWJiYWJsZSBhbmQgZXZlcnl0aGluZyBlbHNlIGFzIGluZXJ0XG4gICAgLy8gc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzMDIzNDBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNTdmdFbGVtZW50KSB7XG4gICAgcmV0dXJuIHZhbGlkVGFiaW5kZXggfHwgc3VwcG9ydHMuZm9jdXNTdmcgfHwgc3VwcG9ydHMuZm9jdXNTdmdJbklmcmFtZVxuICAgIC8vIEludGVybmV0IEV4cGxvcmVyIHVuZGVyc3RhbmRzIHRoZSBmb2N1c2FibGUgYXR0cmlidXRlIGludHJvZHVjZWQgaW4gU1ZHIFRpbnkgMS4yXG4gICAgfHwgQm9vbGVhbihzdXBwb3J0cy5mb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZSAmJiBmb2N1c2FibGVBdHRyaWJ1dGUgJiYgZm9jdXNhYmxlQXR0cmlidXRlID09PSAndHJ1ZScpO1xuICB9XG5cbiAgaWYgKGlzU3ZnQ29udGVudCkge1xuICAgIGlmIChzdXBwb3J0cy5mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlICYmIHZhbGlkVGFiaW5kZXgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0cy5mb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZSkge1xuICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgdW5kZXJzdGFuZHMgdGhlIGZvY3VzYWJsZSBhdHRyaWJ1dGUgaW50cm9kdWNlZCBpbiBTVkcgVGlueSAxLjJcbiAgICAgIHJldHVybiBmb2N1c2FibGVBdHRyaWJ1dGUgPT09ICd0cnVlJztcbiAgICB9XG4gIH1cblxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZWRpdGluZy5odG1sI3NlcXVlbnRpYWwtZm9jdXMtbmF2aWdhdGlvbi1hbmQtdGhlLXRhYmluZGV4LWF0dHJpYnV0ZVxuICBpZiAodmFsaWRUYWJpbmRleCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gIGlmICgoMCwgX2lzLmlzVXNlck1vZGlmeVdyaXRhYmxlKShzdHlsZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChzdXBwb3J0cy5mb2N1c0ltZ0lzbWFwICYmIG5vZGVOYW1lID09PSAnaW1nJyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaXNtYXAnKSkge1xuICAgIC8vIElFMTAtMTEgY29uc2lkZXJzIHRoZSA8aW1nPiBpbiA8YSBocmVmPjxpbWcgaXNtYXA+IGZvY3VzYWJsZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMjBcbiAgICB2YXIgaGFzTGlua1BhcmVudCA9ICgwLCBfcGFyZW50czIuZGVmYXVsdCkoeyBjb250ZXh0OiBlbGVtZW50IH0pLnNvbWUoZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgcmV0dXJuIHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScgJiYgcGFyZW50Lmhhc0F0dHJpYnV0ZSgnaHJlZicpO1xuICAgIH0pO1xuXG4gICAgaWYgKGhhc0xpbmtQYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMjFcbiAgaWYgKCFleGNlcHQuc2Nyb2xsYWJsZSAmJiBzdXBwb3J0cy5mb2N1c1Njcm9sbENvbnRhaW5lcikge1xuICAgIGlmIChzdXBwb3J0cy5mb2N1c1Njcm9sbENvbnRhaW5lcldpdGhvdXRPdmVyZmxvdykge1xuICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgZG9lcyB3aWxsIGNvbnNpZGVyIHRoZSBzY3JvbGxhYmxlIGFyZWEgZm9jdXNhYmxlXG4gICAgICAvLyBpZiB0aGUgZWxlbWVudCBpcyBhIDxkaXY+IG9yIGEgPHNwYW4+IGFuZCBpdCBpcyBpbiBmYWN0IHNjcm9sbGFibGUsXG4gICAgICAvLyByZWdhcmRsZXNzIG9mIHRoZSBDU1Mgb3ZlcmZsb3cgcHJvcGVydHlcbiAgICAgIGlmICgoMCwgX2lzLmlzU2Nyb2xsYWJsZUNvbnRhaW5lcikoZWxlbWVudCwgbm9kZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKDAsIF9pcy5oYXNDc3NPdmVyZmxvd1Njcm9sbCkoc3R5bGUpKSB7XG4gICAgICAvLyBGaXJlZm94IHJlcXVpcmVzIHByb3BlciBvdmVyZmxvdyBzZXR0aW5nLCBJRSBkb2VzIG5vdCBuZWNlc3NhcmlseVxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL292ZXJmbG93XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWV4Y2VwdC5mbGV4Ym94ICYmIHN1cHBvcnRzLmZvY3VzRmxleGJveENvbnRhaW5lciAmJiAoMCwgX2lzLmhhc0Nzc0Rpc3BsYXlGbGV4KShzdHlsZSkpIHtcbiAgICAvLyBlbGVtZW50cyB3aXRoIGRpc3BsYXk6ZmxleCBhcmUgZm9jdXNhYmxlIGluIElFMTAtMTFcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIGlmICghZXhjZXB0LnNjcm9sbGFibGUgJiYgcGFyZW50KSB7XG4gICAgdmFyIHBhcmVudE5vZGVOYW1lID0gcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHBhcmVudFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50LCBudWxsKTtcbiAgICBpZiAoc3VwcG9ydHMuZm9jdXNTY3JvbGxCb2R5ICYmICgwLCBfaXMuaXNTY3JvbGxhYmxlQ29udGFpbmVyKShwYXJlbnQsIG5vZGVOYW1lLCBwYXJlbnROb2RlTmFtZSwgcGFyZW50U3R5bGUpKSB7XG4gICAgICAvLyBzY3JvbGxhYmxlIGJvZGllcyBhcmUgZm9jdXNhYmxlIEludGVybmV0IEV4cGxvcmVyXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIxXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDaGlsZHJlbiBvZiBmb2N1c2FibGUgZWxlbWVudHMgd2l0aCBkaXNwbGF5OmZsZXggYXJlIGZvY3VzYWJsZSBpbiBJRTEwLTExXG4gICAgaWYgKHN1cHBvcnRzLmZvY3VzQ2hpbGRyZW5PZkZvY3VzYWJsZUZsZXhib3gpIHtcbiAgICAgIGlmICgoMCwgX2lzLmhhc0Nzc0Rpc3BsYXlGbGV4KShwYXJlbnRTdHlsZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTk9URTogZWxlbWVudHMgbWFya2VkIGFzIGluZXJ0IGFyZSBub3QgZm9jdXNhYmxlLFxuICAvLyBidXQgdGhhdCBwcm9wZXJ0eSBpcyBub3QgZXhwb3NlZCB0byB0aGUgRE9NXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjaW5lcnRcblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGJpbmQgZXhjZXB0aW9ucyB0byBhbiBpdGVyYXRvciBjYWxsYmFja1xuaXNGb2N1c1JlbGV2YW50UnVsZXMuZXhjZXB0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZXhjZXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB2YXIgaXNGb2N1c1JlbGV2YW50ID0gZnVuY3Rpb24gaXNGb2N1c1JlbGV2YW50KGNvbnRleHQpIHtcbiAgICByZXR1cm4gaXNGb2N1c1JlbGV2YW50UnVsZXMoe1xuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIGV4Y2VwdDogZXhjZXB0XG4gICAgfSk7XG4gIH07XG5cbiAgaXNGb2N1c1JlbGV2YW50LnJ1bGVzID0gaXNGb2N1c1JlbGV2YW50UnVsZXM7XG4gIHJldHVybiBpc0ZvY3VzUmVsZXZhbnQ7XG59O1xuXG4vLyBwcm92aWRlIGlzRm9jdXNSZWxldmFudChjb250ZXh0KSBhcyBkZWZhdWx0IGl0ZXJhdG9yIGNhbGxiYWNrXG52YXIgaXNGb2N1c1JlbGV2YW50ID0gaXNGb2N1c1JlbGV2YW50UnVsZXMuZXhjZXB0KHt9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRm9jdXNSZWxldmFudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtcmVsZXZhbnQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2ZvY3VzUmVsZXZhbnQgPSByZXF1aXJlKCcuL2ZvY3VzLXJlbGV2YW50Jyk7XG5cbnZhciBfZm9jdXNSZWxldmFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1JlbGV2YW50KTtcblxudmFyIF92YWxpZEFyZWEgPSByZXF1aXJlKCcuL3ZhbGlkLWFyZWEnKTtcblxudmFyIF92YWxpZEFyZWEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmFsaWRBcmVhKTtcblxudmFyIF92aXNpYmxlID0gcmVxdWlyZSgnLi92aXNpYmxlJyk7XG5cbnZhciBfdmlzaWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aXNpYmxlKTtcblxudmFyIF9kaXNhYmxlZCA9IHJlcXVpcmUoJy4vZGlzYWJsZWQnKTtcblxudmFyIF9kaXNhYmxlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXNhYmxlZCk7XG5cbnZhciBfb25seVRhYmJhYmxlID0gcmVxdWlyZSgnLi9vbmx5LXRhYmJhYmxlJyk7XG5cbnZhciBfb25seVRhYmJhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29ubHlUYWJiYWJsZSk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcblxudmFyIF9nZXRGcmFtZUVsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2dldC1mcmFtZS1lbGVtZW50Jyk7XG5cbnZhciBfZ2V0RnJhbWVFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEZyYW1lRWxlbWVudCk7XG5cbnZhciBfdGFiaW5kZXhWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWwvdGFiaW5kZXgtdmFsdWUnKTtcblxudmFyIF90YWJpbmRleFZhbHVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYmluZGV4VmFsdWUpO1xuXG52YXIgX3N1cHBvcnRzMiA9IHJlcXVpcmUoJy4uL3N1cHBvcnRzL3N1cHBvcnRzJyk7XG5cbnZhciBfc3VwcG9ydHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydHMyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHN1cHBvcnRzID0gdm9pZCAwO1xuLy8gZGV0ZXJtaW5lIGlmIGFuIGVsZW1lbnQgY2FuIGJlIGZvY3VzZWRcblxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VkaXRpbmcuaHRtbCNmb2N1cy1tYW5hZ2VtZW50XG5cbi8vIE5PVEU6IFRoZSBmb2xsb3dpbmcga25vd24gaXNzdWVzIGV4aXN0OlxuLy8gICBHZWNrbzogYHN2ZyBhW3hsaW5rfGhyZWZdYCBpcyBub3QgaWRlbnRpZmllZCBhcyBmb2N1c2FibGUgKGJlY2F1c2UgU1ZHRWxlbWVudC5wcm90b3R5cGUuZm9jdXMgaXMgbWlzc2luZylcbi8vICAgQmxpbmssIFdlYktpdDogU1ZHRWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gbWFkZSBmb2N1c2FibGUgYnkgYWRkaW5nIGEgZm9jdXMgZXZlbnQgbGlzdGVuZXIgYXJlIG5vdCBpZGVudGlmaWVkIGFzIGZvY3VzYWJsZVxuXG5mdW5jdGlvbiBpc09ubHlGb2N1c1JlbGV2YW50KGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAobm9kZU5hbWUgPT09ICdlbWJlZCcgfHwgbm9kZU5hbWUgPT09ICdrZXlnZW4nKSB7XG4gICAgLy8gZW1iZWQgaXMgY29uc2lkZXJlZCBmb2N1cy1yZWxldmFudCBidXQgbm90IGZvY3VzYWJsZVxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzgyXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgX3RhYmluZGV4ID0gKDAsIF90YWJpbmRleFZhbHVlMi5kZWZhdWx0KShlbGVtZW50KTtcbiAgaWYgKGVsZW1lbnQuc2hhZG93Um9vdCAmJiBfdGFiaW5kZXggPT09IG51bGwpIHtcbiAgICAvLyBTaGFkb3dET00gaG9zdCBlbGVtZW50cyAqbWF5KiByZWNlaXZlIGZvY3VzXG4gICAgLy8gZXZlbiB0aG91Z2ggdGhleSBhcmUgbm90IGNvbnNpZGVyZWQgZm9jdWFibGVcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2xhYmVsJykge1xuICAgIC8vIDxsYWJlbCB0YWJpbmRleD1cIjBcIj4gaXMgb25seSB0YWJiYWJsZSBpbiBGaXJlZm94LCBub3Qgc2NyaXB0LWZvY3VzYWJsZVxuICAgIC8vIHRoZXJlJ3Mgbm8gd2F5IHRvIG1ha2UgYW4gZWxlbWVudCBmb2N1c2FibGUgb3RoZXIgdGhhbiBieSBhZGRpbmcgYSB0YWJpbmRleCxcbiAgICAvLyBhbmQgZm9jdXMgYmVoYXZpb3Igb2YgdGhlIGxhYmVsIGVsZW1lbnQgc2VlbXMgaGFyZC13aXJlZCB0byBpZ25vcmUgdGFiaW5kZXhcbiAgICAvLyBpbiBzb21lIGJyb3dzZXJzIChsaWtlIEdlY2tvLCBCbGluayBhbmQgV2ViS2l0KVxuICAgIHJldHVybiAhc3VwcG9ydHMuZm9jdXNMYWJlbFRhYmluZGV4IHx8IF90YWJpbmRleCA9PT0gbnVsbDtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2xlZ2VuZCcpIHtcbiAgICByZXR1cm4gX3RhYmluZGV4ID09PSBudWxsO1xuICB9XG5cbiAgaWYgKHN1cHBvcnRzLmZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlICYmIChlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCB8fCBub2RlTmFtZSA9PT0gJ3N2ZycpKSB7XG4gICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgdW5kZXJzdGFuZHMgdGhlIGZvY3VzYWJsZSBhdHRyaWJ1dGUgaW50cm9kdWNlZCBpbiBTVkcgVGlueSAxLjJcbiAgICB2YXIgZm9jdXNhYmxlQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScpO1xuICAgIHJldHVybiBmb2N1c2FibGVBdHRyaWJ1dGUgJiYgZm9jdXNhYmxlQXR0cmlidXRlID09PSAnZmFsc2UnO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW1nJyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndXNlbWFwJykpIHtcbiAgICAvLyBHZWNrbywgVHJpZGVudCBhbmQgRWRnZSBkbyBub3QgYWxsb3cgYW4gaW1hZ2Ugd2l0aCBhbiBpbWFnZSBtYXAgYW5kIHRhYmluZGV4IHRvIGJlIGZvY3VzZWQsXG4gICAgLy8gaXQgYXBwZWFycyB0aGUgdGFiaW5kZXggaXMgb3ZlcnJ1bGVkIHNvIGZvY3VzIGlzIHN0aWxsIGZvcndhcmRlZCB0byB0aGUgPG1hcD5cbiAgICByZXR1cm4gX3RhYmluZGV4ID09PSBudWxsIHx8ICFzdXBwb3J0cy5mb2N1c0ltZ1VzZW1hcFRhYmluZGV4O1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnYXJlYScpIHtcbiAgICAvLyBhbGwgPGFyZWE+cyBhcmUgY29uc2lkZXJlZCByZWxldmFudCxcbiAgICAvLyBidXQgb25seSB0aGUgdmFsaWQgPGFyZWE+cyBhcmUgZm9jdXNhYmxlXG4gICAgcmV0dXJuICEoMCwgX3ZhbGlkQXJlYTIuZGVmYXVsdCkoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRm9jdXNhYmxlUnVsZXMoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXG4gICAgICBfcmVmJGV4Y2VwdCA9IF9yZWYuZXhjZXB0LFxuICAgICAgZXhjZXB0ID0gX3JlZiRleGNlcHQgPT09IHVuZGVmaW5lZCA/IHtcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgdmlzaWJsZTogZmFsc2UsXG4gICAgb25seVRhYmJhYmxlOiBmYWxzZVxuICB9IDogX3JlZiRleGNlcHQ7XG5cbiAgaWYgKCFzdXBwb3J0cykge1xuICAgIHN1cHBvcnRzID0gKDAsIF9zdXBwb3J0czMuZGVmYXVsdCkoKTtcbiAgfVxuXG4gIHZhciBfaXNPbmx5VGFiYmFibGUgPSBfb25seVRhYmJhYmxlMi5kZWZhdWx0LnJ1bGVzLmV4Y2VwdCh7XG4gICAgb25seUZvY3VzYWJsZUJyb3dzaW5nQ29udGV4dDogdHJ1ZSxcbiAgICB2aXNpYmxlOiBleGNlcHQudmlzaWJsZVxuICB9KTtcblxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xuICAgIGxhYmVsOiAnaXMvZm9jdXNhYmxlJyxcbiAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9KTtcblxuICB2YXIgZm9jdXNSZWxldmFudCA9IF9mb2N1c1JlbGV2YW50Mi5kZWZhdWx0LnJ1bGVzKHtcbiAgICBjb250ZXh0OiBlbGVtZW50LFxuICAgIGV4Y2VwdDogZXhjZXB0XG4gIH0pO1xuXG4gIGlmICghZm9jdXNSZWxldmFudCB8fCBpc09ubHlGb2N1c1JlbGV2YW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFleGNlcHQuZGlzYWJsZWQgJiYgKDAsIF9kaXNhYmxlZDIuZGVmYXVsdCkoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWV4Y2VwdC5vbmx5VGFiYmFibGUgJiYgX2lzT25seVRhYmJhYmxlKGVsZW1lbnQpKSB7XG4gICAgLy8gc29tZSBlbGVtZW50cyBtYXkgYmUga2V5Ym9hcmQgZm9jdXNhYmxlLCBidXQgbm90IHNjcmlwdCBmb2N1c2FibGVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBlbGVtZW50cyB0aGF0IGFyZSBub3QgcmVuZGVyZWQsIGNhbm5vdCBiZSBmb2N1c2VkXG4gIGlmICghZXhjZXB0LnZpc2libGUpIHtcbiAgICB2YXIgdmlzaWJpbGl0eU9wdGlvbnMgPSB7XG4gICAgICBjb250ZXh0OiBlbGVtZW50LFxuICAgICAgZXhjZXB0OiB7fVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydHMuZm9jdXNJbkhpZGRlbklmcmFtZSkge1xuICAgICAgLy8gV2ViS2l0IGFuZCBCbGluayBjYW4gZm9jdXMgY29udGVudCBpbiBoaWRkZW4gPGlmcmFtZT4gYW5kIDxvYmplY3Q+XG4gICAgICB2aXNpYmlsaXR5T3B0aW9ucy5leGNlcHQuYnJvd3NpbmdDb250ZXh0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHMuZm9jdXNPYmplY3RTdmdIaWRkZW4pIHtcbiAgICAgIC8vIEJsaW5rIGFsbG93cyBmb2N1c2luZyB0aGUgb2JqZWN0IGVsZW1lbnQsIGV2ZW4gaWYgaXQgaGFzIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgIC8vIEBicm93c2VyLWlzc3VlIEJsaW5rIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODYxOTFcbiAgICAgIHZhciBfbm9kZU5hbWUyID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKF9ub2RlTmFtZTIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZpc2liaWxpdHlPcHRpb25zLmV4Y2VwdC5jc3NWaXNpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIV92aXNpYmxlMi5kZWZhdWx0LnJ1bGVzKHZpc2liaWxpdHlPcHRpb25zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmcmFtZUVsZW1lbnQgPSAoMCwgX2dldEZyYW1lRWxlbWVudDIuZGVmYXVsdCkoZWxlbWVudCk7XG4gIGlmIChmcmFtZUVsZW1lbnQpIHtcbiAgICB2YXIgX25vZGVOYW1lID0gZnJhbWVFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKF9ub2RlTmFtZSA9PT0gJ29iamVjdCcgJiYgIXN1cHBvcnRzLmZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0KSB7XG4gICAgICBpZiAoIWZyYW1lRWxlbWVudC5vZmZzZXRXaWR0aCB8fCAhZnJhbWVFbGVtZW50Lm9mZnNldEhlaWdodCkge1xuICAgICAgICAvLyBXZWJLaXQgY2FuIG5vdCBmb2N1cyBjb250ZW50IGluIDxvYmplY3Q+IGlmIGl0IGRvZXNuJ3QgaGF2ZSBkaW1lbnNpb25zXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChub2RlTmFtZSA9PT0gJ3N2ZycgJiYgc3VwcG9ydHMuZm9jdXNTdmdJbklmcmFtZSAmJiAhZnJhbWVFbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGJpbmQgZXhjZXB0aW9ucyB0byBhbiBpdGVyYXRvciBjYWxsYmFja1xuaXNGb2N1c2FibGVSdWxlcy5leGNlcHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBleGNlcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIHZhciBpc0ZvY3VzYWJsZSA9IGZ1bmN0aW9uIGlzRm9jdXNhYmxlKGNvbnRleHQpIHtcbiAgICByZXR1cm4gaXNGb2N1c2FibGVSdWxlcyh7XG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgZXhjZXB0OiBleGNlcHRcbiAgICB9KTtcbiAgfTtcblxuICBpc0ZvY3VzYWJsZS5ydWxlcyA9IGlzRm9jdXNhYmxlUnVsZXM7XG4gIHJldHVybiBpc0ZvY3VzYWJsZTtcbn07XG5cbi8vIHByb3ZpZGUgaXNGb2N1c1JlbGV2YW50KGNvbnRleHQpIGFzIGRlZmF1bHQgaXRlcmF0b3IgY2FsbGJhY2tcbnZhciBpc0ZvY3VzYWJsZSA9IGlzRm9jdXNhYmxlUnVsZXMuZXhjZXB0KHt9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRm9jdXNhYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1c2FibGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc1VzZXJNb2RpZnlXcml0YWJsZSA9IGlzVXNlck1vZGlmeVdyaXRhYmxlO1xuZXhwb3J0cy5oYXNDc3NPdmVyZmxvd1Njcm9sbCA9IGhhc0Nzc092ZXJmbG93U2Nyb2xsO1xuZXhwb3J0cy5oYXNDc3NEaXNwbGF5RmxleCA9IGhhc0Nzc0Rpc3BsYXlGbGV4O1xuZXhwb3J0cy5pc1Njcm9sbGFibGVDb250YWluZXIgPSBpc1Njcm9sbGFibGVDb250YWluZXI7XG5cbi8vIHRoaXMgaXMgYSBzaGFyZWQgdXRpbGl0eSBmaWxlIGZvciBmb2N1cy1yZWxldmFudC5qcyBhbmQgdGFiYmFibGUuanNcbi8vIHNlcGFyYXRlIHRlc3Rpbmcgb2YgdGhpcyBmaWxlJ3MgZnVuY3Rpb25zIGlzIG5vdCBuZWNlc3NhcnksXG4vLyBhcyB0aGV5J3JlIGltcGxpY2l0bHkgdGVzdGVkIGJ5IHdheSBvZiB0aGUgY29uc3VtZXJzXG5cbmZ1bmN0aW9uIGlzVXNlck1vZGlmeVdyaXRhYmxlKHN0eWxlKSB7XG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8xOTk5L1dELWNzczMtdXNlcmludC0xOTk5MDkxNiN1c2VyLW1vZGlmeVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzE3XG4gIHZhciB1c2VyTW9kaWZ5ID0gc3R5bGUud2Via2l0VXNlck1vZGlmeSB8fCAnJztcbiAgcmV0dXJuIEJvb2xlYW4odXNlck1vZGlmeSAmJiB1c2VyTW9kaWZ5LmluZGV4T2YoJ3dyaXRlJykgIT09IC0xKTtcbn1cblxuZnVuY3Rpb24gaGFzQ3NzT3ZlcmZsb3dTY3JvbGwoc3R5bGUpIHtcbiAgcmV0dXJuIFtzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdycpLCBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdy14JyksIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93LXknKV0uc29tZShmdW5jdGlvbiAob3ZlcmZsb3cpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3cgPT09ICdhdXRvJyB8fCBvdmVyZmxvdyA9PT0gJ3Njcm9sbCc7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoYXNDc3NEaXNwbGF5RmxleChzdHlsZSkge1xuICByZXR1cm4gc3R5bGUuZGlzcGxheS5pbmRleE9mKCdmbGV4JykgPiAtMTtcbn1cblxuZnVuY3Rpb24gaXNTY3JvbGxhYmxlQ29udGFpbmVyKGVsZW1lbnQsIG5vZGVOYW1lLCBwYXJlbnROb2RlTmFtZSwgcGFyZW50U3R5bGUpIHtcbiAgaWYgKG5vZGVOYW1lICE9PSAnZGl2JyAmJiBub2RlTmFtZSAhPT0gJ3NwYW4nKSB7XG4gICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgYWR2YW5jZXMgc2Nyb2xsYWJsZSBjb250YWluZXJzIGFuZCBib2RpZXMgdG8gZm9jdXNhYmxlXG4gICAgLy8gb25seSBpZiB0aGUgc2Nyb2xsYWJsZSBjb250YWluZXIgaXMgPGRpdj4gb3IgPHNwYW4+IC0gdGhpcyBkb2VzICpub3QqXG4gICAgLy8gaGFwcGVuIGZvciA8c2VjdGlvbj4sIDxhcnRpY2xlPiwg4oCmXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHBhcmVudE5vZGVOYW1lICYmIHBhcmVudE5vZGVOYW1lICE9PSAnZGl2JyAmJiBwYXJlbnROb2RlTmFtZSAhPT0gJ3NwYW4nICYmICFoYXNDc3NPdmVyZmxvd1Njcm9sbChwYXJlbnRTdHlsZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRIZWlnaHQgPCBlbGVtZW50LnNjcm9sbEhlaWdodCB8fCBlbGVtZW50Lm9mZnNldFdpZHRoIDwgZWxlbWVudC5zY3JvbGxXaWR0aDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLnV0aWwuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICBpZiAoIXN1cHBvcnRzKSB7XG4gICAgc3VwcG9ydHMgPSAoMCwgX3N1cHBvcnRzMy5kZWZhdWx0KSgpO1xuXG4gICAgaWYgKHN1cHBvcnRzLmZvY3VzRmllbGRzZXREaXNhYmxlZCkge1xuICAgICAgZGVsZXRlIGRpc2FibGVkRWxlbWVudHMuZmllbGRzZXQ7XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzLmZvY3VzRm9ybURpc2FibGVkKSB7XG4gICAgICBkZWxldGUgZGlzYWJsZWRFbGVtZW50cy5mb3JtO1xuICAgIH1cblxuICAgIGRpc2FibGVkRWxlbWVudHNQYXR0ZXJuID0gbmV3IFJlZ0V4cCgnXignICsgT2JqZWN0LmtleXMoZGlzYWJsZWRFbGVtZW50cykuam9pbignfCcpICsgJykkJyk7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xuICAgIGxhYmVsOiAnaXMvbmF0aXZlLWRpc2FibGVkLXN1cHBvcnRlZCcsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9KTtcblxuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBCb29sZWFuKGRpc2FibGVkRWxlbWVudHNQYXR0ZXJuLnRlc3Qobm9kZU5hbWUpKTtcbn07XG5cbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcblxudmFyIF9zdXBwb3J0czIgPSByZXF1aXJlKCcuLi9zdXBwb3J0cy9zdXBwb3J0cycpO1xuXG52YXIgX3N1cHBvcnRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1cHBvcnRzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIERldGVybWluZSBpZiBhbiBlbGVtZW50IHN1cHBvcnRzIHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGVcblxudmFyIHN1cHBvcnRzID0gdm9pZCAwO1xuXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZGlzYWJsZWQtZWxlbWVudHMuaHRtbCNjb25jZXB0LWVsZW1lbnQtZGlzYWJsZWRcbnZhciBkaXNhYmxlZEVsZW1lbnRzUGF0dGVybiA9IHZvaWQgMDtcbnZhciBkaXNhYmxlZEVsZW1lbnRzID0ge1xuICBpbnB1dDogdHJ1ZSxcbiAgc2VsZWN0OiB0cnVlLFxuICB0ZXh0YXJlYTogdHJ1ZSxcbiAgYnV0dG9uOiB0cnVlLFxuICBmaWVsZHNldDogdHJ1ZSxcbiAgZm9ybTogdHJ1ZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXRpdmUtZGlzYWJsZWQtc3VwcG9ydGVkLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF92aXNpYmxlID0gcmVxdWlyZSgnLi92aXNpYmxlJyk7XG5cbnZhciBfdmlzaWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aXNpYmxlKTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xuXG52YXIgX2dldEZyYW1lRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWZyYW1lLWVsZW1lbnQnKTtcblxudmFyIF9nZXRGcmFtZUVsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0RnJhbWVFbGVtZW50KTtcblxudmFyIF90YWJpbmRleFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbC90YWJpbmRleC12YWx1ZScpO1xuXG52YXIgX3RhYmluZGV4VmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiaW5kZXhWYWx1ZSk7XG5cbnZhciBfcGxhdGZvcm0gPSByZXF1aXJlKCcuLi91dGlsL3BsYXRmb3JtJyk7XG5cbnZhciBfcGxhdGZvcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxhdGZvcm0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc09ubHlUYWJiYWJsZVJ1bGVzKCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgICAgX3JlZiRleGNlcHQgPSBfcmVmLmV4Y2VwdCxcbiAgICAgIGV4Y2VwdCA9IF9yZWYkZXhjZXB0ID09PSB1bmRlZmluZWQgPyB7XG4gICAgb25seUZvY3VzYWJsZUJyb3dzaW5nQ29udGV4dDogZmFsc2UsXG4gICAgdmlzaWJsZTogZmFsc2VcbiAgfSA6IF9yZWYkZXhjZXB0O1xuXG4gIHZhciBlbGVtZW50ID0gKDAsIF9jb250ZXh0VG9FbGVtZW50Mi5kZWZhdWx0KSh7XG4gICAgbGFiZWw6ICdpcy9vbmx5LXRhYmJhYmxlJyxcbiAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9KTtcblxuICBpZiAoIWV4Y2VwdC52aXNpYmxlICYmICEoMCwgX3Zpc2libGUyLmRlZmF1bHQpKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFleGNlcHQub25seUZvY3VzYWJsZUJyb3dzaW5nQ29udGV4dCAmJiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkdFQ0tPIHx8IF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5UUklERU5UIHx8IF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5FREdFKSkge1xuICAgIHZhciBmcmFtZUVsZW1lbnQgPSAoMCwgX2dldEZyYW1lRWxlbWVudDIuZGVmYXVsdCkoZWxlbWVudCk7XG4gICAgaWYgKGZyYW1lRWxlbWVudCkge1xuICAgICAgaWYgKCgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoZnJhbWVFbGVtZW50KSA8IDApIHtcbiAgICAgICAgLy8gaWZyYW1lW3RhYmluZGV4PVwiLTFcIl0gYW5kIG9iamVjdFt0YWJpbmRleD1cIi0xXCJdIGluaGVyaXQgdGhlXG4gICAgICAgIC8vIHRhYmJhYmxlIGRlbW90aW9uIG9udG8gZWxlbWVudHMgb2YgdGhlaXIgYnJvd3NpbmcgY29udGV4dHNcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgdmFyIHRhYmluZGV4ID0gKDAsIF90YWJpbmRleFZhbHVlMi5kZWZhdWx0KShlbGVtZW50KTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdsYWJlbCcgJiYgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkdFQ0tPKSB7XG4gICAgLy8gRmlyZWZveCBjYW5ub3QgZm9jdXMsIGJ1dCB0YWIgdG86IGxhYmVsW3RhYmluZGV4PTBdXG4gICAgcmV0dXJuIHRhYmluZGV4ICE9PSBudWxsICYmIHRhYmluZGV4ID49IDA7XG4gIH1cblxuICAvLyBTVkcgRWxlbWVudHMgd2VyZSBrZXlib2FyZCBmb2N1c2FibGUgYnV0IG5vdCBzY3JpcHQgZm9jdXNhYmxlIGJlZm9yZSBGaXJlZm94IDUxLlxuICAvLyBGaXJlZm94IDUxIGFkZGVkIHRoZSBmb2N1cyBtYW5hZ2VtZW50IERPTSBBUEkgKC5mb2N1cyBhbmQgLmJsdXIpIHRvIFNWR0VsZW1lbnQsXG4gIC8vIHNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03Nzg2NTRcbiAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5HRUNLTyAmJiBlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCAmJiAhZWxlbWVudC5mb2N1cykge1xuICAgIGlmIChub2RlTmFtZSA9PT0gJ2EnICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCd4bGluazpocmVmJykpIHtcbiAgICAgIC8vIGFueSBmb2N1c2FibGUgY2hpbGQgb2YgPHN2Zz4gY2Fubm90IGJlIGZvY3VzZWQsIGJ1dCB0YWJiZWQgdG9cbiAgICAgIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuR0VDS08pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBiaW5kIGV4Y2VwdGlvbnMgdG8gYW4gaXRlcmF0b3IgY2FsbGJhY2tcbmlzT25seVRhYmJhYmxlUnVsZXMuZXhjZXB0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZXhjZXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB2YXIgaXNPbmx5VGFiYmFibGUgPSBmdW5jdGlvbiBpc09ubHlUYWJiYWJsZShjb250ZXh0KSB7XG4gICAgcmV0dXJuIGlzT25seVRhYmJhYmxlUnVsZXMoe1xuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIGV4Y2VwdDogZXhjZXB0XG4gICAgfSk7XG4gIH07XG5cbiAgaXNPbmx5VGFiYmFibGUucnVsZXMgPSBpc09ubHlUYWJiYWJsZVJ1bGVzO1xuICByZXR1cm4gaXNPbmx5VGFiYmFibGU7XG59O1xuXG4vLyBwcm92aWRlIGlzT25seVRhYmJhYmxlKGNvbnRleHQpIGFzIGRlZmF1bHQgaXRlcmF0b3IgY2FsbGJhY2tcbnZhciBpc09ubHlUYWJiYWJsZSA9IGlzT25seVRhYmJhYmxlUnVsZXMuZXhjZXB0KHt9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzT25seVRhYmJhYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbmx5LXRhYmJhYmxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF92aXNpYmxlID0gcmVxdWlyZSgnLi92aXNpYmxlJyk7XG5cbnZhciBfdmlzaWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aXNpYmxlKTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xuXG52YXIgX2VsZW1lbnRNYXRjaGVzID0gcmVxdWlyZSgnLi4vdXRpbC9lbGVtZW50LW1hdGNoZXMnKTtcblxudmFyIF9lbGVtZW50TWF0Y2hlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lbGVtZW50TWF0Y2hlcyk7XG5cbnZhciBfdGFiaW5kZXhWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWwvdGFiaW5kZXgtdmFsdWUnKTtcblxudmFyIF90YWJpbmRleFZhbHVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYmluZGV4VmFsdWUpO1xuXG52YXIgX2ZvY3VzUmVsZXZhbnQgPSByZXF1aXJlKCcuL2ZvY3VzLXJlbGV2YW50Jyk7XG5cbnZhciBfZm9jdXNSZWxldmFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1JlbGV2YW50KTtcblxudmFyIF9nZXRGcmFtZUVsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2dldC1mcmFtZS1lbGVtZW50Jyk7XG5cbnZhciBfZ2V0RnJhbWVFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEZyYW1lRWxlbWVudCk7XG5cbnZhciBfcGxhdGZvcm0gPSByZXF1aXJlKCcuLi91dGlsL3BsYXRmb3JtJyk7XG5cbnZhciBfcGxhdGZvcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxhdGZvcm0pO1xuXG52YXIgX2ltYWdlTWFwID0gcmVxdWlyZSgnLi4vdXRpbC9pbWFnZS1tYXAnKTtcblxudmFyIF9pcyA9IHJlcXVpcmUoJy4vaXMudXRpbCcpO1xuXG52YXIgX3N1cHBvcnRzMiA9IHJlcXVpcmUoJy4uL3N1cHBvcnRzL3N1cHBvcnRzJyk7XG5cbnZhciBfc3VwcG9ydHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydHMyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gZGV0ZXJtaW5lIGlmIGFuIGVsZW1lbnQgY2FuIGJlIGZvY3VzZWQgYnkga2V5Ym9hcmQgKGkuZS4gaXMgcGFydCBvZiB0aGUgZG9jdW1lbnQncyBzZXF1ZW50aWFsIGZvY3VzIG5hdmlnYXRpb24gb3JkZXIpXG5cbnZhciBzdXBwb3J0cyA9IHZvaWQgMDtcblxuLy8gSW50ZXJuZXQgRXhwbG9yZXIgMTEgY29uc2lkZXJzIGZpZWxkc2V0LCB0YWJsZSwgdGQgZm9jdXNhYmxlLCBidXQgbm90IHRhYmJhYmxlXG4vLyBJbnRlcm5ldCBFeHBsb3JlciAxMSBjb25zaWRlcnMgYm9keSB0byBoYXZlIFt0YWJpbmRleD0wXSwgYnV0IGRvZXMgbm90IGFsbG93IHRhYmJpbmcgdG8gaXRcbnZhciBmb2N1c2FibGVFbGVtZW50c1BhdHRlcm4gPSAvXihmaWVsZHNldHx0YWJsZXx0ZHxib2R5KSQvO1xuXG5mdW5jdGlvbiBpc1RhYmJhYmxlUnVsZXMoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXG4gICAgICBfcmVmJGV4Y2VwdCA9IF9yZWYuZXhjZXB0LFxuICAgICAgZXhjZXB0ID0gX3JlZiRleGNlcHQgPT09IHVuZGVmaW5lZCA/IHtcbiAgICBmbGV4Ym94OiBmYWxzZSxcbiAgICBzY3JvbGxhYmxlOiBmYWxzZSxcbiAgICBzaGFkb3c6IGZhbHNlLFxuICAgIHZpc2libGU6IGZhbHNlLFxuICAgIG9ubHlUYWJiYWJsZTogZmFsc2VcbiAgfSA6IF9yZWYkZXhjZXB0O1xuXG4gIGlmICghc3VwcG9ydHMpIHtcbiAgICBzdXBwb3J0cyA9ICgwLCBfc3VwcG9ydHMzLmRlZmF1bHQpKCk7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xuICAgIGxhYmVsOiAnaXMvdGFiYmFibGUnLFxuICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH0pO1xuXG4gIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuQkxJTksgJiYgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkFORFJPSUQgJiYgX3BsYXRmb3JtMi5kZWZhdWx0Lm1ham9yVmVyc2lvbiA+IDQyKSB7XG4gICAgLy8gRXh0ZXJuYWwga2V5Ym9hcmQgc3VwcG9ydCB3b3JrZWQgZmluZSBpbiBDSHJvbWUgNDIsIGJ1dCBzdG9wcGVkIHdvcmtpbmcgaW4gQ2hyb21lIDQ1LlxuICAgIC8vIFRoZSBvbi1zY3JlZW4ga2V5Ym9hcmQgZG9lcyBub3QgcHJvdmlkZSBhIHdheSB0byBmb2N1cyB0aGUgbmV4dCBpbnB1dCBlbGVtZW50IChsaWtlIGlPUyBkb2VzKS5cbiAgICAvLyBUaGF0IGxlYXZlcyB1cyB3aXRoIG5vIG9wdGlvbiB0byBhZHZhbmNlIGZvY3VzIGJ5IGtleWJvYXJkLCBlcmdvIG5vdGhpbmcgaXMgdGFiYmFibGUgKGtleWJvYXJkIGZvY3VzYWJsZSkuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGZyYW1lRWxlbWVudCA9ICgwLCBfZ2V0RnJhbWVFbGVtZW50Mi5kZWZhdWx0KShlbGVtZW50KTtcbiAgaWYgKGZyYW1lRWxlbWVudCkge1xuICAgIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuV0VCS0lUICYmIF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5JT1MpIHtcbiAgICAgIC8vIGlPUyBvbmx5IGRvZXMgbm90IGNvbnNpZGVyIGFueXRoaW5nIGZyb20gYW5vdGhlciBicm93c2luZyBjb250ZXh0IGtleWJvYXJkIGZvY3VzYWJsZVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGlmcmFtZVt0YWJpbmRleD1cIi0xXCJdIGFuZCBvYmplY3RbdGFiaW5kZXg9XCItMVwiXSBpbmhlcml0IHRoZVxuICAgIC8vIHRhYmJhYmxlIGRlbW90aW9uIG9udG8gZWxlbWVudHMgb2YgdGhlaXIgYnJvd3NpbmcgY29udGV4dHNcbiAgICBpZiAoKDAsIF90YWJpbmRleFZhbHVlMi5kZWZhdWx0KShmcmFtZUVsZW1lbnQpIDwgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghZXhjZXB0LnZpc2libGUgJiYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5CTElOSyB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuV0VCS0lUKSAmJiAhKDAsIF92aXNpYmxlMi5kZWZhdWx0KShmcmFtZUVsZW1lbnQpKSB7XG4gICAgICAvLyBCbGluayBhbmQgV2ViS2l0IGNvbnNpZGVyIGVsZW1lbnRzIGluIGhpZGRlbiBicm93c2luZyBjb250ZXh0cyBmb2N1c2FibGUsIGJ1dCBub3QgdGFiYmFibGVcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBXZWJraXQgYW5kIEJsaW5rIGRvbid0IGNvbnNpZGVyIGFueXRoaW5nIGluIDxvYmplY3Q+IHRhYmJhYmxlXG4gICAgLy8gQmxpbmsgZml4ZWQgdGhhdCBmaXhlZCBpbiBDaHJvbWUgNTQsIE9wZXJhIDQxXG4gICAgdmFyIGZyYW1lTm9kZU5hbWUgPSBmcmFtZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoZnJhbWVOb2RlTmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBpc0ZpeGVkQmxpbmsgPSBfcGxhdGZvcm0yLmRlZmF1bHQubmFtZSA9PT0gJ0Nocm9tZScgJiYgX3BsYXRmb3JtMi5kZWZhdWx0Lm1ham9yVmVyc2lvbiA+PSA1NCB8fCBfcGxhdGZvcm0yLmRlZmF1bHQubmFtZSA9PT0gJ09wZXJhJyAmJiBfcGxhdGZvcm0yLmRlZmF1bHQubWFqb3JWZXJzaW9uID49IDQxO1xuXG4gICAgICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLldFQktJVCB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuQkxJTksgJiYgIWlzRml4ZWRCbGluaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgX3RhYmluZGV4ID0gKDAsIF90YWJpbmRleFZhbHVlMi5kZWZhdWx0KShlbGVtZW50KTtcbiAgdmFyIHRhYmluZGV4ID0gX3RhYmluZGV4ID09PSBudWxsID8gbnVsbCA6IF90YWJpbmRleCA+PSAwO1xuXG4gIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuRURHRSAmJiBfcGxhdGZvcm0yLmRlZmF1bHQubWFqb3JWZXJzaW9uID49IDE0ICYmIGZyYW1lRWxlbWVudCAmJiBlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCAmJiBfdGFiaW5kZXggPCAwKSB7XG4gICAgLy8gRWRnZSAxNCsgY29uc2lkZXJzIDxhIHhsaW5rOmhyZWY9XCLigKZcIiB0YWJpbmRleD1cIi0xXCI+IGtleWJvYXJkIGZvY3VzYWJsZVxuICAgIC8vIGlmIHRoZSBlbGVtZW50IGlzIGluIGEgbmVzdGVkIGJyb3dzaW5nIGNvbnRleHRcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBoYXNUYWJiYWJsZVRhYmluZGV4T3JOb25lID0gdGFiaW5kZXggIT09IGZhbHNlO1xuICB2YXIgaGFzVGFiYmFibGVUYWJpbmRleCA9IF90YWJpbmRleCAhPT0gbnVsbCAmJiBfdGFiaW5kZXggPj0gMDtcblxuICAvLyBOT1RFOiBGaXJlZm94IDMxIGNvbnNpZGVycyBbY29udGVudGVkaXRhYmxlXSB0byBoYXZlIFt0YWJpbmRleD0tMV0sIGJ1dCBhbGxvd3MgdGFiYmluZyB0byBpdFxuICAvLyBmaXhlZCBpbiBGaXJlZm94IDQwIHRoZSBsYXRlc3QgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTg1NjU3XG4gIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykpIHtcbiAgICAvLyB0YWJiaW5nIGNhbiBzdGlsbCBiZSBkaXNhYmxlZCBieSBleHBsaWNpdGx5IHByb3ZpZGluZyBbdGFiaW5kZXg9XCItMVwiXVxuICAgIHJldHVybiBoYXNUYWJiYWJsZVRhYmluZGV4T3JOb25lO1xuICB9XG5cbiAgaWYgKGZvY3VzYWJsZUVsZW1lbnRzUGF0dGVybi50ZXN0KG5vZGVOYW1lKSAmJiB0YWJpbmRleCAhPT0gdHJ1ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuV0VCS0lUICYmIF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5JT1MpIHtcbiAgICAvLyBpT1Mgb25seSBjb25zaWRlcnMgYSBoYW5kIGZ1bGwgb2YgZWxlbWVudHMgdGFiYmFibGUgKGtleWJvYXJkIGZvY3VzYWJsZSlcbiAgICAvLyB0aGlzIGhvbGRzIHRydWUgZXZlbiB3aXRoIGV4dGVybmFsIGtleWJvYXJkc1xuICAgIHZhciBwb3RlbnRpYWxseVRhYmJhYmxlID0gbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbWVudC50eXBlID09PSAndGV4dCcgfHwgZWxlbWVudC50eXBlID09PSAncGFzc3dvcmQnIHx8IG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJyk7XG5cbiAgICBpZiAoIXBvdGVudGlhbGx5VGFiYmFibGUpIHtcbiAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICAgICAgcG90ZW50aWFsbHlUYWJiYWJsZSA9ICgwLCBfaXMuaXNVc2VyTW9kaWZ5V3JpdGFibGUpKHN0eWxlKTtcbiAgICB9XG5cbiAgICBpZiAoIXBvdGVudGlhbGx5VGFiYmFibGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICd1c2UnICYmIF90YWJpbmRleCAhPT0gbnVsbCkge1xuICAgIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuQkxJTksgfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLldFQktJVCAmJiBfcGxhdGZvcm0yLmRlZmF1bHQubWFqb3JWZXJzaW9uID09PSA5KSB7XG4gICAgICAvLyBJbiBDaHJvbWUgYW5kIFNhZmFyaSA5IHRoZSA8dXNlPiBlbGVtZW50IGlzIGtleWJvYXJkIGZvY3VzYWJsZSBldmVuIGZvciB0YWJpbmRleD1cIi0xXCJcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICgoMCwgX2VsZW1lbnRNYXRjaGVzMi5kZWZhdWx0KShlbGVtZW50LCAnc3ZnIGEnKSAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgneGxpbms6aHJlZicpKSB7XG4gICAgaWYgKGhhc1RhYmJhYmxlVGFiaW5kZXhPck5vbmUpIHtcbiAgICAgIC8vIGluIFRyaWRlbnQgYW5kIEdlY2tvIFNWR0VsZW1lbnQgZG9lcyBub3QgaGFuZGxlIHRoZSB0YWJJbmRleCBwcm9wZXJ0eSBwcm9wZXJseVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuZm9jdXMgJiYgIXN1cHBvcnRzLmZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZSkge1xuICAgICAgLy8gRmlyZWZveCA1MSBhbmQgNTIgdHJlYXQgYW55IG5hdGl2ZWx5IHRhYmJhYmxlIFNWRyBlbGVtZW50IHdpdGhcbiAgICAgIC8vIHRhYmluZGV4PVwiLTFcIiBhcyB0YWJiYWJsZSBhbmQgZXZlcnl0aGluZyBlbHNlIGFzIGluZXJ0XG4gICAgICAvLyBzZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTMwMjM0MFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnc3ZnJyAmJiBzdXBwb3J0cy5mb2N1c1N2Z0luSWZyYW1lICYmIGhhc1RhYmJhYmxlVGFiaW5kZXhPck5vbmUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuVFJJREVOVCB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuRURHRSkge1xuICAgIGlmIChub2RlTmFtZSA9PT0gJ3N2ZycpIHtcbiAgICAgIGlmIChzdXBwb3J0cy5mb2N1c1N2Zykge1xuICAgICAgICAvLyBvbGRlciBJbnRlcm5ldCBFeHBsb3JlcnMgY29uc2lkZXIgPHN2Zz4ga2V5Ym9hcmQgZm9jdXNhYmxlXG4gICAgICAgIC8vIHVubGVzcyB0aGV5IGhhdmUgZm9jc2FibGU9XCJmYWxzZVwiLCBidXQgdGhlbiB0aGV5IHdvdWxkbid0XG4gICAgICAgIC8vIGJlIGZvY3VzYWJsZSBhbmQgdGh1cyBub3QgZXZlbiByZWFjaCB0aGlzIGZpbHRlclxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZWxlbWVudHMgdGhhdCBoYXZlIFtmb2N1c2FibGVdIGFyZSBhdXRvbWF0aWNhbGx5IGtleWJvYXJkIGZvY3VzYWJsZSByZWdhcmRsZXNzIG9mIHRoZSBhdHRyaWJ1dGUncyB2YWx1ZVxuICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdmb2N1c2FibGUnKSB8fCBoYXNUYWJiYWJsZVRhYmluZGV4O1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCkge1xuICAgICAgaWYgKHN1cHBvcnRzLmZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUgJiYgaGFzVGFiYmFibGVUYWJpbmRleCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZWxlbWVudHMgdGhhdCBoYXZlIFtmb2N1c2FibGVdIGFyZSBhdXRvbWF0aWNhbGx5IGtleWJvYXJkIGZvY3VzYWJsZSByZWdhcmRsZXNzIG9mIHRoZSBhdHRyaWJ1dGUncyB2YWx1ZVxuICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdmb2N1c2FibGUnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGVsZW1lbnQudGFiSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBCb29sZWFuKGV4Y2VwdC5vbmx5VGFiYmFibGUpO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnYXVkaW8nKSB7XG4gICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udHJvbHMnKSkge1xuICAgICAgLy8gSW4gSW50ZXJuZXQgRXhwbG9yZXIgdGhlIDxhdWRpbz4gZWxlbWVudCBpcyBmb2N1c2FibGUsIGJ1dCBub3QgdGFiYmFibGUsIGFuZCB0YWJJbmRleCBwcm9wZXJ0eSBpcyB3cm9uZ1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkJMSU5LKSB7XG4gICAgICAvLyBJbiBDaHJvbWUgPGF1ZGlvIGNvbnRyb2xzIHRhYmluZGV4PVwiLTFcIj4gcmVtYWlucyBrZXlib2FyZCBmb2N1c2FibGVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3ZpZGVvJykge1xuICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRyb2xzJykpIHtcbiAgICAgIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuVFJJREVOVCB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuRURHRSkge1xuICAgICAgICAvLyBJbiBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSB0aGUgPHZpZGVvPiBlbGVtZW50IGlzIGZvY3VzYWJsZSwgYnV0IG5vdCB0YWJiYWJsZSwgYW5kIHRhYkluZGV4IHByb3BlcnR5IGlzIHdyb25nXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5CTElOSyB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuR0VDS08pIHtcbiAgICAgIC8vIEluIENocm9tZSBhbmQgRmlyZWZveCA8dmlkZW8gY29udHJvbHMgdGFiaW5kZXg9XCItMVwiPiByZW1haW5zIGtleWJvYXJkIGZvY3VzYWJsZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuQkxJTksgfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLldFQktJVCkge1xuICAgICAgLy8gSW4gYWxsIEJsaW5rIGFuZCBXZWJLaXQgYmFzZWQgYnJvd3NlcnMgPGVtYmVkPiBhbmQgPG9iamVjdD4gYXJlIG5ldmVyIGtleWJvYXJkIGZvY3VzYWJsZSwgZXZlbiB3aXRoIHRhYmluZGV4PVwiMFwiIHNldFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lmcmFtZScpIHtcbiAgICAvLyBJbiBJbnRlcm5ldCBFeHBsb3JlciBhbGwgaWZyYW1lcyBhcmUgb25seSBmb2N1c2FibGVcbiAgICAvLyBJbiBXZWJLaXQsIEJsaW5rIGFuZCBHZWNrbyBpZnJhbWVzIG1heSBiZSB0YWJiYWJsZSBkZXBlbmRpbmcgb24gY29udGVudC5cbiAgICAvLyBTaW5jZSB3ZSBjYW4ndCByZWxpYWJseSBpbnZlc3RpZ2F0ZSBpZnJhbWUgZG9jdW1lbnRzIGJlY2F1c2Ugb2YgdGhlXG4gICAgLy8gU2FtZU9yaWdpblBvbGljeSwgd2UncmUgZGVjbGFyaW5nIGV2ZXJ5dGhpbmcgb25seSBmb2N1c2FibGUuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFleGNlcHQuc2Nyb2xsYWJsZSAmJiBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuR0VDS08pIHtcbiAgICAvLyBGaXJlZm94IGNvbnNpZGVycyBzY3JvbGxhYmxlIGNvbnRhaW5lcnMga2V5Ym9hcmQgZm9jdXNhYmxlLFxuICAgIC8vIGV2ZW4gdGhvdWdoIHRoZWlyIHRhYkluZGV4IHByb3BlcnR5IGlzIC0xXG4gICAgdmFyIF9zdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICAgIGlmICgoMCwgX2lzLmhhc0Nzc092ZXJmbG93U2Nyb2xsKShfc3R5bGUpKSB7XG4gICAgICByZXR1cm4gaGFzVGFiYmFibGVUYWJpbmRleE9yTm9uZTtcbiAgICB9XG4gIH1cblxuICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLlRSSURFTlQgfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkVER0UpIHtcbiAgICAvLyBJRSBhbmQgRWRnZSBkZWdyYWRlIDxhcmVhPiB0byBzY3JpcHQgZm9jdXNhYmxlLCBpZiB0aGUgaW1hZ2VcbiAgICAvLyB1c2luZyB0aGUgPG1hcD4gaGFzIGJlZW4gZ2l2ZW4gdGFiaW5kZXg9XCItMVwiXG4gICAgaWYgKG5vZGVOYW1lID09PSAnYXJlYScpIHtcbiAgICAgIHZhciBpbWcgPSAoMCwgX2ltYWdlTWFwLmdldEltYWdlT2ZBcmVhKShlbGVtZW50KTtcbiAgICAgIGlmIChpbWcgJiYgKDAsIF90YWJpbmRleFZhbHVlMi5kZWZhdWx0KShpbWcpIDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9zdHlsZTIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgICBpZiAoKDAsIF9pcy5pc1VzZXJNb2RpZnlXcml0YWJsZSkoX3N0eWxlMikpIHtcbiAgICAgIC8vIHByZXZlbnQgYmVpbmcgc3dhbGxvd2VkIGJ5IHRoZSBvdmVyemVhbG91cyBpc1Njcm9sbGFibGVDb250YWluZXIoKSBiZWxvd1xuICAgICAgcmV0dXJuIGVsZW1lbnQudGFiSW5kZXggPj0gMDtcbiAgICB9XG5cbiAgICBpZiAoIWV4Y2VwdC5mbGV4Ym94ICYmICgwLCBfaXMuaGFzQ3NzRGlzcGxheUZsZXgpKF9zdHlsZTIpKSB7XG4gICAgICBpZiAoX3RhYmluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBoYXNUYWJiYWJsZVRhYmluZGV4O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNGb2N1c1JlbGV2YW50V2l0aG91dEZsZXhib3goZWxlbWVudCkgJiYgaXNUYWJiYWJsZVdpdGhvdXRGbGV4Ym94KGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIElFIGNvbnNpZGVycyBzY3JvbGxhYmxlIGNvbnRhaW5lcnMgc2NyaXB0IGZvY3VzYWJsZSBvbmx5LFxuICAgIC8vIGV2ZW4gdGhvdWdoIHRoZWlyIHRhYkluZGV4IHByb3BlcnR5IGlzIDBcbiAgICBpZiAoKDAsIF9pcy5pc1Njcm9sbGFibGVDb250YWluZXIpKGVsZW1lbnQsIG5vZGVOYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgdmFyIHBhcmVudE5vZGVOYW1lID0gcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcGFyZW50U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQsIG51bGwpO1xuICAgICAgLy8gSUUgY29uc2lkZXJzIHNjcm9sbGFibGUgYm9kaWVzIHNjcmlwdCBmb2N1c2FibGUgb25seSxcbiAgICAgIGlmICgoMCwgX2lzLmlzU2Nyb2xsYWJsZUNvbnRhaW5lcikocGFyZW50LCBub2RlTmFtZSwgcGFyZW50Tm9kZU5hbWUsIHBhcmVudFN0eWxlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIENoaWxkcmVuIG9mIGZvY3VzYWJsZSBlbGVtZW50cyB3aXRoIGRpc3BsYXk6ZmxleCBhcmUgZm9jdXNhYmxlIGluIElFMTAtMTEsXG4gICAgICAvLyBldmVuIHRob3VnaCB0aGVpciB0YWJJbmRleCBwcm9wZXJ0eSBzdWdnZXN0cyBvdGhlcndpc2VcbiAgICAgIGlmICgoMCwgX2lzLmhhc0Nzc0Rpc3BsYXlGbGV4KShwYXJlbnRTdHlsZSkpIHtcbiAgICAgICAgLy8gdmFsdWUgb2YgdGFiaW5kZXggdGFrZXMgcHJlY2VkZW5jZVxuICAgICAgICByZXR1cm4gaGFzVGFiYmFibGVUYWJpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBodHRwczovL3d3dy53My5vcmcvV0FJL1BGL2FyaWEtcHJhY3RpY2VzLyNmb2N1c190YWJpbmRleFxuICByZXR1cm4gZWxlbWVudC50YWJJbmRleCA+PSAwO1xufVxuXG4vLyBiaW5kIGV4Y2VwdGlvbnMgdG8gYW4gaXRlcmF0b3IgY2FsbGJhY2tcbmlzVGFiYmFibGVSdWxlcy5leGNlcHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBleGNlcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIHZhciBpc1RhYmJhYmxlID0gZnVuY3Rpb24gaXNUYWJiYWJsZShjb250ZXh0KSB7XG4gICAgcmV0dXJuIGlzVGFiYmFibGVSdWxlcyh7XG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgZXhjZXB0OiBleGNlcHRcbiAgICB9KTtcbiAgfTtcblxuICBpc1RhYmJhYmxlLnJ1bGVzID0gaXNUYWJiYWJsZVJ1bGVzO1xuICByZXR1cm4gaXNUYWJiYWJsZTtcbn07XG5cbnZhciBpc0ZvY3VzUmVsZXZhbnRXaXRob3V0RmxleGJveCA9IF9mb2N1c1JlbGV2YW50Mi5kZWZhdWx0LnJ1bGVzLmV4Y2VwdCh7IGZsZXhib3g6IHRydWUgfSk7XG52YXIgaXNUYWJiYWJsZVdpdGhvdXRGbGV4Ym94ID0gaXNUYWJiYWJsZVJ1bGVzLmV4Y2VwdCh7IGZsZXhib3g6IHRydWUgfSk7XG5cbi8vIHByb3ZpZGUgaXNUYWJiYWJsZShjb250ZXh0KSBhcyBkZWZhdWx0IGl0ZXJhdG9yIGNhbGxiYWNrXG52YXIgaXNUYWJiYWJsZSA9IGlzVGFiYmFibGVSdWxlcy5leGNlcHQoe30pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNUYWJiYWJsZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFiYmFibGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICBpZiAoIXN1cHBvcnRzKSB7XG4gICAgc3VwcG9ydHMgPSAoMCwgX3N1cHBvcnRzMy5kZWZhdWx0KSgpO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcbiAgICBsYWJlbDogJ2lzL3ZhbGlkLWFyZWEnLFxuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfSk7XG5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAobm9kZU5hbWUgIT09ICdhcmVhJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBoYXNUYWJpbmRleCA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICBpZiAoIXN1cHBvcnRzLmZvY3VzQXJlYVRhYmluZGV4ICYmIGhhc1RhYmluZGV4KSB7XG4gICAgLy8gQmxpbmsgYW5kIFdlYktpdCBkbyBub3QgY29uc2lkZXIgPGFyZWEgdGFiaW5kZXg9XCItMVwiIGhyZWY9XCIjdm9pZFwiPiBmb2N1c2FibGVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaW1nID0gKDAsIF9pbWFnZU1hcC5nZXRJbWFnZU9mQXJlYSkoZWxlbWVudCk7XG4gIGlmICghaW1nIHx8ICEoMCwgX3Zpc2libGUyLmRlZmF1bHQpKGltZykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBGaXJlZm94IG9ubHkgYWxsb3dzIGZ1bGx5IGxvYWRlZCBpbWFnZXMgdG8gcmVmZXJlbmNlIGltYWdlIG1hcHNcbiAgLy8gaHR0cHM6Ly9zdGVyZW9jaHJvLm1lL2lkZWFzL2RldGVjdGluZy1icm9rZW4taW1hZ2VzLWpzXG4gIGlmICghc3VwcG9ydHMuZm9jdXNCcm9rZW5JbWFnZU1hcCAmJiAoIWltZy5jb21wbGV0ZSB8fCAhaW1nLm5hdHVyYWxIZWlnaHQgfHwgaW1nLm9mZnNldFdpZHRoIDw9IDAgfHwgaW1nLm9mZnNldEhlaWdodCA8PSAwKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEZpcmVmb3ggc3VwcG9ydHMuY2FuIGZvY3VzIGFyZWEgZWxlbWVudHMgZXZlbiBpZiB0aGV5IGRvbid0IGhhdmUgYW4gaHJlZiBhdHRyaWJ1dGVcbiAgaWYgKCFzdXBwb3J0cy5mb2N1c0FyZWFXaXRob3V0SHJlZiAmJiAhZWxlbWVudC5ocmVmKSB7XG4gICAgLy8gSW50ZXJuZXQgZXhwbG9yZXIgc3VwcG9ydHMuY2FuIGZvY3VzIGFyZWEgZWxlbWVudHMgd2l0aG91dCBocmVmIGlmIGVpdGhlclxuICAgIC8vIHRoZSBhcmVhIGVsZW1lbnQgb3IgdGhlIGltYWdlIGVsZW1lbnQgaGFzIGEgdGFiaW5kZXggYXR0cmlidXRlXG4gICAgcmV0dXJuIHN1cHBvcnRzLmZvY3VzQXJlYVRhYmluZGV4ICYmIGhhc1RhYmluZGV4IHx8IHN1cHBvcnRzLmZvY3VzQXJlYUltZ1RhYmluZGV4ICYmIGltZy5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gIH1cblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXG4gIHZhciBjaGlsZE9mSW50ZXJhY3RpdmUgPSAoMCwgX3BhcmVudHMyLmRlZmF1bHQpKHsgY29udGV4dDogaW1nIH0pLnNsaWNlKDEpLnNvbWUoZnVuY3Rpb24gKF9lbGVtZW50KSB7XG4gICAgdmFyIG5hbWUgPSBfZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBuYW1lID09PSAnYnV0dG9uJyB8fCBuYW1lID09PSAnYSc7XG4gIH0pO1xuXG4gIGlmIChjaGlsZE9mSW50ZXJhY3RpdmUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcblxudmFyIF92aXNpYmxlID0gcmVxdWlyZSgnLi92aXNpYmxlJyk7XG5cbnZhciBfdmlzaWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aXNpYmxlKTtcblxudmFyIF9wYXJlbnRzID0gcmVxdWlyZSgnLi4vZ2V0L3BhcmVudHMnKTtcblxudmFyIF9wYXJlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmVudHMpO1xuXG52YXIgX2ltYWdlTWFwID0gcmVxdWlyZSgnLi4vdXRpbC9pbWFnZS1tYXAnKTtcblxudmFyIF9zdXBwb3J0czIgPSByZXF1aXJlKCcuLi9zdXBwb3J0cy9zdXBwb3J0cycpO1xuXG52YXIgX3N1cHBvcnRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1cHBvcnRzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBzdXBwb3J0cyA9IHZvaWQgMDtcblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L21hcFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLXVzZW1hcFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnktdWkvYmxvYi9tYXN0ZXIvdWkvY29yZS5qcyNMODgtTDEwN1xuXG4vLyBkZXRlcm1pbmUgaWYgYW4gPGFyZWE+IGVsZW1lbnQgaXMgYmVpbmcgcHJvcGVybHkgdXNlZCBieSBhbmQgPGltZz4gdmlhIGEgPG1hcD5cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZC1hcmVhLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgaWYgKCFzdXBwb3J0cykge1xuICAgIHN1cHBvcnRzID0gKDAsIF9zdXBwb3J0czMuZGVmYXVsdCkoKTtcbiAgfVxuXG4gIHZhciB2YWxpZEludGVnZXJQYXR0ZXJuID0gc3VwcG9ydHMuZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVycyA/IHZhbGlkSW50ZWdlclBhdHRlcm5XaXRoVHJhaWxpbmcgOiB2YWxpZEludGVnZXJQYXR0ZXJuTm9UcmFpbGluZztcblxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xuICAgIGxhYmVsOiAnaXMvdmFsaWQtdGFiaW5kZXgnLFxuICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH0pO1xuXG4gIC8vIEVkZ2UgMTQgaGFzIGEgY2FwaXRhbGl6YXRpb24gcHJvYmxlbSBvbiBTVkcgZWxlbWVudHMsXG4gIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy85MjgyMDU4L1xuICB2YXIgaGFzVGFiaW5kZXggPSBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgdmFyIGhhc1RhYkluZGV4ID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYkluZGV4Jyk7XG5cbiAgaWYgKCFoYXNUYWJpbmRleCAmJiAhaGFzVGFiSW5kZXgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBvbGRlciBGaXJlZm94IGFuZCBJbnRlcm5ldCBFeHBsb3JlciBkb24ndCBzdXBwb3J0IHRhYmluZGV4IG9uIFNWRyBlbGVtZW50c1xuICB2YXIgaXNTdmdFbGVtZW50ID0gZWxlbWVudC5vd25lclNWR0VsZW1lbnQgfHwgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJztcbiAgaWYgKGlzU3ZnRWxlbWVudCAmJiAhc3VwcG9ydHMuZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEBicm93c2VyLWlzc3VlIEdlY2tvIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMjgwNTRcbiAgaWYgKHN1cHBvcnRzLmZvY3VzSW52YWxpZFRhYmluZGV4KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBhbiBlbGVtZW50IG1hdGNoZXMgdGhlIHRhYmluZGV4IHNlbGVjdG9yIGV2ZW4gaWYgaXRzIHZhbHVlIGlzIGludmFsaWRcbiAgdmFyIHRhYmluZGV4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoaGFzVGFiaW5kZXggPyAndGFiaW5kZXgnIDogJ3RhYkluZGV4Jyk7XG4gIC8vIElFMTEgcGFyc2VzIHRhYmluZGV4PVwiXCIgYXMgdGhlIHZhbHVlIFwiLTMyNzY4XCJcbiAgLy8gQGJyb3dzZXItaXNzdWUgVHJpZGVudCBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzEwNzI5NjVcbiAgaWYgKHRhYmluZGV4ID09PSAnLTMyNzY4Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBCb29sZWFuKHRhYmluZGV4ICYmIHZhbGlkSW50ZWdlclBhdHRlcm4udGVzdCh0YWJpbmRleCkpO1xufTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xuXG52YXIgX3N1cHBvcnRzMiA9IHJlcXVpcmUoJy4uL3N1cHBvcnRzL3N1cHBvcnRzJyk7XG5cbnZhciBfc3VwcG9ydHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydHMyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gZGV0ZXJtaW5lIGlmIGFuIGVsZW1lbnQncyB0YWJpbmRleCBhdHRyaWJ1dGUgaGFzIGEgdmFsaWQgdmFsdWVcblxudmFyIHN1cHBvcnRzID0gdm9pZCAwO1xuXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNydWxlcy1mb3ItcGFyc2luZy1pbnRlZ2Vyc1xuLy8gTk9URTogYWxsIGJyb3dzZXJzIGFncmVlIHRvIGFsbG93IHRyYWlsaW5nIHNwYWNlcyBhcyB3ZWxsXG52YXIgdmFsaWRJbnRlZ2VyUGF0dGVybk5vVHJhaWxpbmcgPSAvXlxccyooLXxcXCspP1swLTldK1xccyokLztcbnZhciB2YWxpZEludGVnZXJQYXR0ZXJuV2l0aFRyYWlsaW5nID0gL15cXHMqKC18XFwrKT9bMC05XSsuKiQvO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkLXRhYmluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9hcnJheUZpbmRJbmRleCA9IHJlcXVpcmUoJy4uL3V0aWwvYXJyYXktZmluZC1pbmRleCcpO1xuXG52YXIgX2FycmF5RmluZEluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FycmF5RmluZEluZGV4KTtcblxudmFyIF9wYXJlbnRzID0gcmVxdWlyZSgnLi4vZ2V0L3BhcmVudHMnKTtcblxudmFyIF9wYXJlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmVudHMpO1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XG5cbnZhciBfZ2V0RnJhbWVFbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9nZXQtZnJhbWUtZWxlbWVudCcpO1xuXG52YXIgX2dldEZyYW1lRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRGcmFtZUVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvcmVuZGVyaW5nLmh0bWwjYmVpbmctcmVuZGVyZWRcbi8vIDxhcmVhPiBpcyBub3QgcmVuZGVyZWQsIGJ1dCB3ZSAqY29uc2lkZXIqIGl0IHZpc2libGUgdG8gc2ltcGxmaXkgdGhpcyBmdW5jdGlvbidzIHVzYWdlXG5cbi8vIGRldGVybWluZSBpZiBhbiBlbGVtZW50IGlzIHJlbmRlcmVkXG4vLyBOT1RFOiB0aGF0IGRvZXMgbm90IG1lYW4gYW4gZWxlbWVudCBpcyB2aXNpYmxlIGluIHRoZSB2aWV3cG9ydCwgc2VlIHV0aWwvdmlzaWJsZS1hcmVhXG5cbnZhciBub3RSZW5kZXJlZEVsZW1lbnRzUGF0dGVybiA9IC9eKGFyZWEpJC87XG5cbmZ1bmN0aW9uIGNvbXB1dGVkU3R5bGUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xufVxuXG5mdW5jdGlvbiBub3REaXNwbGF5ZWQoX3BhdGgpIHtcbiAgcmV0dXJuIF9wYXRoLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAvLyBkaXNwbGF5Om5vbmUgaXMgbm90IHZpc2libGUgKG9wdGltaXplZCBhd2F5IGF0IGxheW91dClcbiAgICByZXR1cm4gY29tcHV0ZWRTdHlsZShlbGVtZW50LCAnZGlzcGxheScpID09PSAnbm9uZSc7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBub3RWaXNpYmxlKF9wYXRoKSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5LXVpL2Jsb2IvbWFzdGVyL3VpL2NvcmUuanMjTDEwOS1MMTE0XG4gIC8vIE5PVEU6IGEgbmVzdGVkIGVsZW1lbnQgY2FuIHJldmVyc2UgdmlzaWJpbGl0eTpoaWRkZW58Y29sbGFwc2UgYnkgZXhwbGljaXRseSBzZXR0aW5nIHZpc2liaWxpdHk6dmlzaWJsZVxuICAvLyBOT1RFOiB2aXNpYmlsaXR5IGNhbiBiZSBbXCJcIiwgXCJ2aXNpYmxlXCIsIFwiaGlkZGVuXCIsIFwiY29sbGFwc2VcIl1cbiAgdmFyIGhpZGRlbiA9ICgwLCBfYXJyYXlGaW5kSW5kZXgyLmRlZmF1bHQpKF9wYXRoLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciB2aXNpYmlsaXR5ID0gY29tcHV0ZWRTdHlsZShlbGVtZW50LCAndmlzaWJpbGl0eScpO1xuICAgIHJldHVybiB2aXNpYmlsaXR5ID09PSAnaGlkZGVuJyB8fCB2aXNpYmlsaXR5ID09PSAnY29sbGFwc2UnO1xuICB9KTtcblxuICBpZiAoaGlkZGVuID09PSAtMSkge1xuICAgIC8vIHRoZXJlIGlzIG5vIGhpZGRlbiBlbGVtZW50XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHZpc2libGUgPSAoMCwgX2FycmF5RmluZEluZGV4Mi5kZWZhdWx0KShfcGF0aCwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gY29tcHV0ZWRTdHlsZShlbGVtZW50LCAndmlzaWJpbGl0eScpID09PSAndmlzaWJsZSc7XG4gIH0pO1xuXG4gIGlmICh2aXNpYmxlID09PSAtMSkge1xuICAgIC8vIHRoZXJlIGlzIG5vIHZpc2libGUgZWxlbWVudCAoYnV0IGEgaGlkZGVuIGVsZW1lbnQpXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaGlkZGVuIDwgdmlzaWJsZSkge1xuICAgIC8vIHRoZXJlIGlzIGEgaGlkZGVuIGVsZW1lbnQgYW5kIGl0J3MgY2xvc2VyIHRoYW4gdGhlIGZpcnN0IHZpc2libGUgZWxlbWVudFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdGhlcmUgbWF5IGJlIGEgaGlkZGVuIGVsZW1lbnQsIGJ1dCB0aGUgY2xvc2VzdCBlbGVtZW50IGlzIHZpc2libGVcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb2xsYXBzZWRQYXJlbnQoX3BhdGgpIHtcbiAgdmFyIG9mZnNldCA9IDE7XG4gIGlmIChfcGF0aFswXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3VtbWFyeScpIHtcbiAgICBvZmZzZXQgPSAyO1xuICB9XG5cbiAgcmV0dXJuIF9wYXRoLnNsaWNlKG9mZnNldCkuc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIC8vIFwiY29udGVudCBjaGlsZHJlblwiIG9mIGEgY2xvc2VkIGRldGFpbHMgZWxlbWVudCBhcmUgbm90IHZpc2libGVcbiAgICByZXR1cm4gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZGV0YWlscycgJiYgZWxlbWVudC5vcGVuID09PSBmYWxzZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzVmlzaWJsZVJ1bGVzKCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgICAgX3JlZiRleGNlcHQgPSBfcmVmLmV4Y2VwdCxcbiAgICAgIGV4Y2VwdCA9IF9yZWYkZXhjZXB0ID09PSB1bmRlZmluZWQgPyB7XG4gICAgbm90UmVuZGVyZWQ6IGZhbHNlLFxuICAgIGNzc0Rpc3BsYXk6IGZhbHNlLFxuICAgIGNzc1Zpc2liaWxpdHk6IGZhbHNlLFxuICAgIGRldGFpbHNFbGVtZW50OiBmYWxzZSxcbiAgICBicm93c2luZ0NvbnRleHQ6IGZhbHNlXG4gIH0gOiBfcmVmJGV4Y2VwdDtcblxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xuICAgIGxhYmVsOiAnaXMvdmlzaWJsZScsXG4gICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfSk7XG5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIWV4Y2VwdC5ub3RSZW5kZXJlZCAmJiBub3RSZW5kZXJlZEVsZW1lbnRzUGF0dGVybi50ZXN0KG5vZGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIF9wYXRoID0gKDAsIF9wYXJlbnRzMi5kZWZhdWx0KSh7IGNvbnRleHQ6IGVsZW1lbnQgfSk7XG5cbiAgLy8gaW4gSW50ZXJuZXQgRXhwbG9yZXIgPGF1ZGlvPiBoYXMgYSBkZWZhdWx0IGRpc3BsYXk6IG5vbmUsIHdoZXJlIG90aGVycyBoYXZlIGRpc3BsYXk6IGlubGluZVxuICAvLyBidXQgSUUgYWxsb3dzIGZvY3VzaW5nIDxhdWRpbyBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPiwgYnV0IG5vdCA8ZGl2IGRpc3BsYXk6bm9uZT48YXVkaW8+XG4gIC8vIHRoaXMgaXMgaXJyZWxldmFudCB0byBvdGhlciBicm93c2VycywgYXMgdGhlIGNvbnRyb2xzIGF0dHJpYnV0ZSBpcyByZXF1aXJlZCB0byBtYWtlIDxhdWRpbz4gZm9jdXNhYmxlXG4gIHZhciBpc0F1ZGlvV2l0aG91dENvbnRyb2xzID0gbm9kZU5hbWUgPT09ICdhdWRpbycgJiYgIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250cm9scycpO1xuICBpZiAoIWV4Y2VwdC5jc3NEaXNwbGF5ICYmIG5vdERpc3BsYXllZChpc0F1ZGlvV2l0aG91dENvbnRyb2xzID8gX3BhdGguc2xpY2UoMSkgOiBfcGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWV4Y2VwdC5jc3NWaXNpYmlsaXR5ICYmIG5vdFZpc2libGUoX3BhdGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFleGNlcHQuZGV0YWlsc0VsZW1lbnQgJiYgY29sbGFwc2VkUGFyZW50KF9wYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghZXhjZXB0LmJyb3dzaW5nQ29udGV4dCkge1xuICAgIC8vIGVsZW1lbnRzIHdpdGhpbiBhIGJyb3dzaW5nIGNvbnRleHQgYXJlIGFmZmVjdGVkIGJ5IHRoZVxuICAgIC8vIGJyb3dzaW5nIGNvbnRleHQgaG9zdCBlbGVtZW50J3MgdmlzaWJpbGl0eSBhbmQgdGFiaW5kZXhcbiAgICB2YXIgZnJhbWVFbGVtZW50ID0gKDAsIF9nZXRGcmFtZUVsZW1lbnQyLmRlZmF1bHQpKGVsZW1lbnQpO1xuICAgIHZhciBfaXNWaXNpYmxlID0gaXNWaXNpYmxlUnVsZXMuZXhjZXB0KGV4Y2VwdCk7XG4gICAgaWYgKGZyYW1lRWxlbWVudCAmJiAhX2lzVmlzaWJsZShmcmFtZUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGJpbmQgZXhjZXB0aW9ucyB0byBhbiBpdGVyYXRvciBjYWxsYmFja1xuaXNWaXNpYmxlUnVsZXMuZXhjZXB0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZXhjZXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB2YXIgaXNWaXNpYmxlID0gZnVuY3Rpb24gaXNWaXNpYmxlKGNvbnRleHQpIHtcbiAgICByZXR1cm4gaXNWaXNpYmxlUnVsZXMoe1xuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIGV4Y2VwdDogZXhjZXB0XG4gICAgfSk7XG4gIH07XG5cbiAgaXNWaXNpYmxlLnJ1bGVzID0gaXNWaXNpYmxlUnVsZXM7XG4gIHJldHVybiBpc1Zpc2libGU7XG59O1xuXG4vLyBwcm92aWRlIGlzVmlzaWJsZShjb250ZXh0KSBhcyBkZWZhdWx0IGl0ZXJhdG9yIGNhbGxiYWNrXG52YXIgaXNWaXNpYmxlID0gaXNWaXNpYmxlUnVsZXMuZXhjZXB0KHt9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVmlzaWJsZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlzaWJsZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG4vKlxuICBVdGlsaXR5IHRvIG1ha2UgYSBzdWItdHJlZSBvZiB0aGUgRE9NIGluZXJ0LiBJbmVydCBtZWFucyB0aGUgZWxlbWVudHMgY2Fubm90IGJlIGludGVyYWN0ZWRcbiAgd2l0aCBhbmQgdGhleSBjYW5ub3QgYmUgZm9jdXNlZCB2aWEgc2NyaXB0LCBwb2ludGVyIG9yIGtleWJvYXJkLlxuXG4gIGluZXJ0IGF0dHJpYnV0ZSB3YXMgW3JlbW92ZWRdKGh0dHBzOi8vaHRtbDUub3JnL3IvODUzNikgW3R3ZWV0IGJ5IHN0ZXZlXShodHRwczovL3R3aXR0ZXIuY29tL3N0ZXZlZmF1bGtuZXIvc3RhdHVzLzQ0MzA3NTkwMDIwMTI1OTAwOClcbiAgYnV0IGRlZmluaXRpb24gb2YgW2luZXJ0IHN1YnRyZWVzXShodHRwczovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvZWRpdGluZy5odG1sI2luZXJ0LXN1YnRyZWVzKSByZW1haW5zLlxuXG4gIFtpbXBsZW1lbnRhdGlvbiBpZGVhIGJ5IFZhc2lsaXNdKGh0dHBzOi8vY29kZXBlbi5pby92YXNpbGlzdmcvcGVuL3Njb3dJKVxuICBbaW5lcnQgYXR0cmlidXRlIHBvbHlmaWxsIGJ5IEdvb2dsZUNocm9tZV0oaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS9pbmVydC1wb2x5ZmlsbClcblxuICBbR2Vja28gQnVnOiBJbmVydCBBdHRyaWJ1dGVdKGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTkyMTUwNClcbiAgW0Nocm9taXVtIEJ1ZzogSW5lcnQgQXR0cmlidXRlXShodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjY5ODQ2KVxuICBbQ2hyb21pdW0gQnVnOiBJbmVydCBTdWJ0cmVlXShodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjQxNjk5KVxuICBbV2ViS2l0IEJ1ZzogSW5lcnQgU3VidHJlZV0oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTExMDk1MilcbiovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIGNvbnRleHQgPSBfcmVmMi5jb250ZXh0LFxuICAgICAgZmlsdGVyID0gX3JlZjIuZmlsdGVyO1xuXG4gIHZhciBzZXJ2aWNlID0gbmV3IEluZXJ0U3VidHJlZSh7IGNvbnRleHQ6IGNvbnRleHQsIGZpbHRlcjogZmlsdGVyIH0pO1xuICByZXR1cm4geyBkaXNlbmdhZ2U6IHNlcnZpY2UuZGlzZW5nYWdlIH07XG59O1xuXG52YXIgX25vZGVBcnJheSA9IHJlcXVpcmUoJy4uL3V0aWwvbm9kZS1hcnJheScpO1xuXG52YXIgX25vZGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub2RlQXJyYXkpO1xuXG52YXIgX2ZvY3VzYWJsZSA9IHJlcXVpcmUoJy4uL3F1ZXJ5L2ZvY3VzYWJsZScpO1xuXG52YXIgX2ZvY3VzYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c2FibGUpO1xuXG52YXIgX2Rpc2FibGVkID0gcmVxdWlyZSgnLi4vZWxlbWVudC9kaXNhYmxlZCcpO1xuXG52YXIgX2Rpc2FibGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc2FibGVkKTtcblxudmFyIF9zaGFkb3dNdXRhdGlvbnMgPSByZXF1aXJlKCcuLi9vYnNlcnZlL3NoYWRvdy1tdXRhdGlvbnMnKTtcblxudmFyIF9zaGFkb3dNdXRhdGlvbnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhZG93TXV0YXRpb25zKTtcblxudmFyIF9jb21wYXJlUG9zaXRpb24gPSByZXF1aXJlKCcuLi91dGlsL2NvbXBhcmUtcG9zaXRpb24nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gbWFrZUVsZW1lbnRJbmVydChlbGVtZW50KSB7XG4gIHJldHVybiAoMCwgX2Rpc2FibGVkMi5kZWZhdWx0KShlbGVtZW50LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gdW5kb0VsZW1lbnRJbmVydChlbGVtZW50KSB7XG4gIHJldHVybiAoMCwgX2Rpc2FibGVkMi5kZWZhdWx0KShlbGVtZW50LCBmYWxzZSk7XG59XG5cbnZhciBvYnNlcnZlckNvbmZpZyA9IHtcbiAgYXR0cmlidXRlczogdHJ1ZSxcbiAgY2hpbGRMaXN0OiB0cnVlLFxuICBzdWJ0cmVlOiB0cnVlLFxuICBhdHRyaWJ1dGVGaWx0ZXI6IFsndGFiaW5kZXgnLCAnZGlzYWJsZWQnLCAnZGF0YS1hbGx5LWRpc2FibGVkJ11cbn07XG5cbnZhciBJbmVydFN1YnRyZWUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEluZXJ0U3VidHJlZSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgICAgICBmaWx0ZXIgPSBfcmVmLmZpbHRlcjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydFN1YnRyZWUpO1xuXG4gICAgdGhpcy5fY29udGV4dCA9ICgwLCBfbm9kZUFycmF5Mi5kZWZhdWx0KShjb250ZXh0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudClbMF07XG4gICAgdGhpcy5fZmlsdGVyID0gKDAsIF9ub2RlQXJyYXkyLmRlZmF1bHQpKGZpbHRlcik7XG4gICAgdGhpcy5faW5lcnRFbGVtZW50Q2FjaGUgPSBbXTtcblxuICAgIHRoaXMuZGlzZW5nYWdlID0gdGhpcy5kaXNlbmdhZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZU11dGF0aW9uID0gdGhpcy5oYW5kbGVNdXRhdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVuZGVySW5lcnQgPSB0aGlzLnJlbmRlckluZXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5maWx0ZXJFbGVtZW50cyA9IHRoaXMuZmlsdGVyRWxlbWVudHMuYmluZCh0aGlzKTtcbiAgICB0aGlzLmZpbHRlclBhcmVudEVsZW1lbnRzID0gdGhpcy5maWx0ZXJQYXJlbnRFbGVtZW50cy5iaW5kKHRoaXMpO1xuXG4gICAgdmFyIGZvY3VzYWJsZSA9ICgwLCBfZm9jdXNhYmxlMi5kZWZhdWx0KSh7XG4gICAgICBjb250ZXh0OiB0aGlzLl9jb250ZXh0LFxuICAgICAgaW5jbHVkZUNvbnRleHQ6IHRydWUsXG4gICAgICBzdHJhdGVneTogJ2FsbCdcbiAgICB9KTtcblxuICAgIHRoaXMucmVuZGVySW5lcnQoZm9jdXNhYmxlKTtcblxuICAgIHRoaXMuc2hhZG93T2JzZXJ2ZXIgPSAoMCwgX3NoYWRvd011dGF0aW9uczIuZGVmYXVsdCkoe1xuICAgICAgY29udGV4dDogdGhpcy5fY29udGV4dCxcbiAgICAgIGNvbmZpZzogb2JzZXJ2ZXJDb25maWcsXG4gICAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2sobXV0YXRpb25zKSB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbnMuZm9yRWFjaChfdGhpcy5oYW5kbGVNdXRhdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW5lcnRTdWJ0cmVlLCBbe1xuICAgIGtleTogJ2Rpc2VuZ2FnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2VuZ2FnZSgpIHtcbiAgICAgIGlmICghdGhpcy5fY29udGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVuZG9FbGVtZW50SW5lcnQodGhpcy5fY29udGV4dCk7XG4gICAgICB0aGlzLl9pbmVydEVsZW1lbnRDYWNoZS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB1bmRvRWxlbWVudEluZXJ0KGVsZW1lbnQpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2luZXJ0RWxlbWVudENhY2hlID0gbnVsbDtcbiAgICAgIHRoaXMuX2ZpbHRlciA9IG51bGw7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICAgIHRoaXMuc2hhZG93T2JzZXJ2ZXIgJiYgdGhpcy5zaGFkb3dPYnNlcnZlci5kaXNlbmdhZ2UoKTtcbiAgICAgIHRoaXMuc2hhZG93T2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xpc3RRdWVyeUZvY3VzYWJsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RRdWVyeUZvY3VzYWJsZShsaXN0KSB7XG4gICAgICByZXR1cm4gbGlzdFxuICAgICAgLy8gZmluZCBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIHdpdGhpbiB0aGUgZ2l2ZW4gY29udGV4dHNcbiAgICAgIC5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfZm9jdXNhYmxlMi5kZWZhdWx0KSh7IGNvbnRleHQ6IGVsZW1lbnQsIGluY2x1ZGVDb250ZXh0OiB0cnVlLCBzdHJhdGVneTogJ2FsbCcgfSk7XG4gICAgICB9KVxuICAgICAgLy8gZmxhdHRlbiBuZXN0ZWQgYXJyYXlzXG4gICAgICAucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgY3VycmVudCkge1xuICAgICAgICByZXR1cm4gcHJldmlvdXMuY29uY2F0KGN1cnJlbnQpO1xuICAgICAgfSwgW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlckluZXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVySW5lcnQoZWxlbWVudHMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgbWFrZUluZXJ0ID0gZnVuY3Rpb24gbWFrZUluZXJ0KGVsZW1lbnQpIHtcbiAgICAgICAgX3RoaXMyLl9pbmVydEVsZW1lbnRDYWNoZS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBtYWtlRWxlbWVudEluZXJ0KGVsZW1lbnQpO1xuICAgICAgfTtcblxuICAgICAgZWxlbWVudHMuZmlsdGVyKHRoaXMuZmlsdGVyRWxlbWVudHMpLmZpbHRlcih0aGlzLmZpbHRlclBhcmVudEVsZW1lbnRzKVxuICAgICAgLy8gaWdub3JlIGVsZW1lbnRzIHRoYXQgYWxyZWFkeSBhcmUgZGlzYWJsZWRcbiAgICAgIC8vIHNvIHdlIGRvbid0IGVuYWJsZSB0aGVtIG9uIGRpc2VuZ2FnZSgpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiAhKDAsIF9kaXNhYmxlZDIuZGVmYXVsdCkoZWxlbWVudCk7XG4gICAgICB9KS5mb3JFYWNoKG1ha2VJbmVydCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZmlsdGVyRWxlbWVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWx0ZXJFbGVtZW50cyhlbGVtZW50KSB7XG4gICAgICAvLyBpZ25vcmUgZWxlbWVudHMgd2l0aGluIHRoZSBleGVtcHRlZCBzdWItdHJlZXNcbiAgICAgIHZhciBpc1BhcmVudE9mRWxlbWVudCA9ICgwLCBfY29tcGFyZVBvc2l0aW9uLmdldFBhcmVudENvbXBhcmF0b3IpKHsgZWxlbWVudDogZWxlbWVudCwgaW5jbHVkZVNlbGY6IHRydWUgfSk7XG4gICAgICByZXR1cm4gIXRoaXMuX2ZpbHRlci5zb21lKGlzUGFyZW50T2ZFbGVtZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmaWx0ZXJQYXJlbnRFbGVtZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlclBhcmVudEVsZW1lbnRzKGVsZW1lbnQpIHtcbiAgICAgIC8vIGlnbm9yZSBhbmNlc3RvcnMgb2YgdGhlIGV4ZW1wdGVkIHN1Yi10cmVlc1xuICAgICAgdmFyIGlzUGFyZW50T2ZFbGVtZW50ID0gKDAsIF9jb21wYXJlUG9zaXRpb24uZ2V0UGFyZW50Q29tcGFyYXRvcikoeyBwYXJlbnQ6IGVsZW1lbnQgfSk7XG4gICAgICByZXR1cm4gIXRoaXMuX2ZpbHRlci5zb21lKGlzUGFyZW50T2ZFbGVtZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVNdXRhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgdmFyIGFkZGVkRWxlbWVudHMgPSAoMCwgX25vZGVBcnJheTIuZGVmYXVsdCkobXV0YXRpb24uYWRkZWROb2RlcykuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFhZGRlZEVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhZGRlZEZvY3VzYWJsZUVsZW1lbnRzID0gdGhpcy5saXN0UXVlcnlGb2N1c2FibGUoYWRkZWRFbGVtZW50cyk7XG4gICAgICAgIHRoaXMucmVuZGVySW5lcnQoYWRkZWRGb2N1c2FibGVFbGVtZW50cyk7XG4gICAgICB9IGVsc2UgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgICB0aGlzLnJlbmRlckluZXJ0KFttdXRhdGlvbi50YXJnZXRdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW5lcnRTdWJ0cmVlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc2FibGVkLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0O1xuXG4gIGlmICghY29udGV4dCkge1xuICAgIGNvbnRleHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgdGhlIHN1cHBvcnRzIHRlc3RzIGFyZSBydW4gYmVmb3JlIGludGVyY2VwdGluZyB0aGUgVGFiIGtleSxcbiAgLy8gb3IgSUUxMCBhbmQgSUUxMSB3aWxsIGZhaWwgdG8gcHJvY2VzcyB0aGUgZmlyc3QgVGFiIGtleSBldmVudC4gTm90XG4gIC8vIGxpbWl0aW5nIHRoaXMgd2FybS11cCB0byBJRSBiZWNhdXNlIGl0IG1heSBiZSBhIHByb2JsZW0gZWxzZXdoZXJlLCB0b28uXG4gICgwLCBfdGFic2VxdWVuY2UyLmRlZmF1bHQpKCk7XG5cbiAgcmV0dXJuICgwLCBfa2V5Mi5kZWZhdWx0KSh7XG4gICAgLy8gU2FmYXJpIG9uIE9TWCBtYXkgcmVxdWlyZSBBTFQrVEFCIHRvIHJlYWNoIGxpbmtzLFxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzE0NlxuICAgICc/YWx0Kz9zaGlmdCt0YWInOiBmdW5jdGlvbiBhbHRTaGlmdFRhYihldmVudCkge1xuICAgICAgLy8gd2UncmUgY29tcGxldGVseSB0YWtpbmcgb3ZlciB0aGUgVGFiIGtleSBoYW5kbGluZ1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIHNlcXVlbmNlID0gKDAsIF90YWJzZXF1ZW5jZTIuZGVmYXVsdCkoe1xuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICB9KTtcblxuICAgICAgdmFyIGJhY2t3YXJkID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICB2YXIgZmlyc3QgPSBzZXF1ZW5jZVswXTtcbiAgICAgIHZhciBsYXN0ID0gc2VxdWVuY2Vbc2VxdWVuY2UubGVuZ3RoIC0gMV07XG5cbiAgICAgIC8vIHdyYXAgYXJvdW5kIGZpcnN0IHRvIGxhc3QsIGxhc3QgdG8gZmlyc3RcbiAgICAgIHZhciBzb3VyY2UgPSBiYWNrd2FyZCA/IGZpcnN0IDogbGFzdDtcbiAgICAgIHZhciB0YXJnZXQgPSBiYWNrd2FyZCA/IGxhc3QgOiBmaXJzdDtcbiAgICAgIGlmICgoMCwgX2FjdGl2ZUVsZW1lbnQyLmRlZmF1bHQpKHNvdXJjZSkpIHtcbiAgICAgICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZmluZCBjdXJyZW50IHBvc2l0aW9uIGluIHRhYnNlcXVlbmNlXG4gICAgICB2YXIgY3VycmVudEluZGV4ID0gdm9pZCAwO1xuICAgICAgdmFyIGZvdW5kID0gc2VxdWVuY2Uuc29tZShmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKCEoMCwgX2FjdGl2ZUVsZW1lbnQyLmRlZmF1bHQpKGVsZW1lbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgLy8gcmVkaXJlY3QgdG8gZmlyc3QgYXMgd2UncmUgbm90IGluIG91ciB0YWJzZXF1ZW5jZVxuICAgICAgICBmaXJzdC5mb2N1cygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHNoaWZ0IGZvY3VzIHRvIHByZXZpb3VzL25leHQgZWxlbWVudCBpbiB0aGUgc2VxdWVuY2VcbiAgICAgIHZhciBvZmZzZXQgPSBiYWNrd2FyZCA/IC0xIDogMTtcbiAgICAgIHNlcXVlbmNlW2N1cnJlbnRJbmRleCArIG9mZnNldF0uZm9jdXMoKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIF9hY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnLi4vaXMvYWN0aXZlLWVsZW1lbnQnKTtcblxudmFyIF9hY3RpdmVFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FjdGl2ZUVsZW1lbnQpO1xuXG52YXIgX3RhYnNlcXVlbmNlID0gcmVxdWlyZSgnLi4vcXVlcnkvdGFic2VxdWVuY2UnKTtcblxudmFyIF90YWJzZXF1ZW5jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWJzZXF1ZW5jZSk7XG5cbnZhciBfa2V5ID0gcmVxdWlyZSgnLi4vd2hlbi9rZXknKTtcblxudmFyIF9rZXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWItZm9jdXMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG4vLyBjb2RlcyBtb3N0bHkgY2xvbmVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2tlaXRoYW11cy9qd2VydHkvYmxvYi9tYXN0ZXIvandlcnR5LmpzXG4vLyBkZWxpYmVyYXRlbHkgbm90IGV4cG9zaW5nIGNoYXJhY3RlcnMgbGlrZSA8LC4tIyogYmVjYXVzZSB0aGV5IHZhcnkgKndpbGRseSpcbi8vIGFjcm9zcyBrZXlib2FyZCBsYXlvdXRzIGFuZCBtYXkgY2F1c2UgdmFyaW91cyBwcm9ibGVtc1xuLy8gKGUuZy4gXCIqXCIgaXMgXCJTaGlmdCArXCIgb24gYSBHZXJtYW4gTWFjIGtleWJvYXJkKVxuLy8gKGUuZy4gXCJAXCIgaXMgXCJBbHQgTFwiIG9uIGEgR2VybWFuIE1hYyBrZXlib2FyZClcblxudmFyIGtleWNvZGUgPSB7XG4gIC8vIEVsZW1lbnQgRm9jdXNcbiAgdGFiOiA5LFxuXG4gIC8vIE5hdmlnYXRpb25cbiAgbGVmdDogMzcsXG4gIHVwOiAzOCxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgcGFnZVVwOiAzMyxcbiAgJ3BhZ2UtdXAnOiAzMyxcbiAgcGFnZURvd246IDM0LFxuICAncGFnZS1kb3duJzogMzQsXG4gIGVuZDogMzUsXG4gIGhvbWU6IDM2LFxuXG4gIC8vIEFjdGlvblxuICBlbnRlcjogMTMsXG4gIGVzY2FwZTogMjcsXG4gIHNwYWNlOiAzMixcblxuICAvLyBNb2RpZmllclxuICBzaGlmdDogMTYsXG4gIGNhcHNMb2NrOiAyMCxcbiAgJ2NhcHMtbG9jayc6IDIwLFxuICBjdHJsOiAxNyxcbiAgYWx0OiAxOCxcbiAgbWV0YTogOTEsXG4gIC8vIGluIGZpcmVmb3g6IDIyNFxuICAvLyBvbiBtYWMgKGNocm9tZSk6IG1ldGEtbGVmdD05MSwgbWV0YS1yaWdodD05M1xuICAvLyBvbiB3aW4gKElFMTEpOiBtZXRhLWxlZnQ9OTEsIG1ldGEtcmlnaHQ9OTJcbiAgcGF1c2U6IDE5LFxuXG4gIC8vIENvbnRlbnQgTWFuaXB1bGF0aW9uXG4gIGluc2VydDogNDUsXG4gICdkZWxldGUnOiA0NixcbiAgYmFja3NwYWNlOiA4LFxuXG4gIC8vIHRoZSBzYW1lIGxvZ2ljYWwga2V5IG1heSBiZSBpZGVudGlmaWVkIHRocm91Z2ggZGlmZmVyZW50IGtleUNvZGVzXG4gIF9hbGlhczoge1xuICAgIDkxOiBbOTIsIDkzLCAyMjRdXG4gIH1cbn07XG5cbi8vIEZ1bmN0aW9uIGtleXMgKDExMiAtIDEzNylcbi8vIE5PVEU6IG5vdCBldmVyeSBrZXlib2FyZCBrbm93cyBGMTMrXG5mb3IgKHZhciBuID0gMTsgbiA8IDI2OyBuKyspIHtcbiAga2V5Y29kZVsnZicgKyBuXSA9IG4gKyAxMTE7XG59XG5cbi8vIE51bWJlciBrZXlzICg0OC01NywgbnVtcGFkIDk2LTEwNSlcbi8vIE5PVEU6IG5vdCBldmVyeSBrZXlib2FyZCBrbm93cyBudW0tMCtcbmZvciAodmFyIF9uID0gMDsgX24gPCAxMDsgX24rKykge1xuICB2YXIgY29kZSA9IF9uICsgNDg7XG4gIHZhciBudW1Db2RlID0gX24gKyA5NjtcbiAga2V5Y29kZVtfbl0gPSBjb2RlO1xuICBrZXljb2RlWydudW0tJyArIF9uXSA9IG51bUNvZGU7XG4gIGtleWNvZGUuX2FsaWFzW2NvZGVdID0gW251bUNvZGVdO1xufVxuXG4vLyBMYXRpbiBjaGFyYWN0ZXJzICg2NSAtIDkwKVxuZm9yICh2YXIgX24yID0gMDsgX24yIDwgMjY7IF9uMisrKSB7XG4gIHZhciBfY29kZSA9IF9uMiArIDY1O1xuICB2YXIgbmFtZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoX2NvZGUpLnRvTG93ZXJDYXNlKCk7XG4gIGtleWNvZGVbbmFtZV0gPSBfY29kZTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0ga2V5Y29kZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5Y29kZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgY29udGV4dCA9IF9yZWYyLmNvbnRleHQsXG4gICAgICBjYWxsYmFjayA9IF9yZWYyLmNhbGxiYWNrLFxuICAgICAgY29uZmlnID0gX3JlZjIuY29uZmlnO1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvYnNlcnZlL3NoYWRvdy1tdXRhdGlvbnMgcmVxdWlyZXMgb3B0aW9ucy5jYWxsYmFjayB0byBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAoKHR5cGVvZiBjb25maWcgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmZpZykpICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29ic2VydmUvc2hhZG93LW11dGF0aW9ucyByZXF1aXJlcyBvcHRpb25zLmNvbmZpZyB0byBiZSBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIGlmICghd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAvLyBub3Qgc3VwcG9ydGluZyBJRTEwIHZpYSBNdXRhdGlvbiBFdmVudHMsIGJlY2F1c2UgdGhleSdyZSB0b28gZXhwZW5zaXZlXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvRXZlbnRzL011dGF0aW9uX2V2ZW50c1xuICAgIHJldHVybiB7XG4gICAgICBkaXNlbmdhZ2U6IGZ1bmN0aW9uIGRpc2VuZ2FnZSgpIHt9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gKDAsIF9jb250ZXh0VG9FbGVtZW50Mi5kZWZhdWx0KSh7XG4gICAgbGFiZWw6ICdvYnNlcnZlL3NoYWRvdy1tdXRhdGlvbnMnLFxuICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcbiAgICBkZWZhdWx0VG9Eb2N1bWVudDogdHJ1ZSxcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH0pO1xuXG4gIHZhciBzZXJ2aWNlID0gbmV3IFNoYWRvd011dGF0aW9uT2JzZXJ2ZXIoe1xuICAgIGNvbnRleHQ6IGVsZW1lbnQsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIGNvbmZpZzogY29uZmlnXG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgZGlzZW5nYWdlOiBzZXJ2aWNlLmRpc2VuZ2FnZVxuICB9O1xufTtcblxudmFyIF9ub2RlQXJyYXkgPSByZXF1aXJlKCcuLi91dGlsL25vZGUtYXJyYXknKTtcblxudmFyIF9ub2RlQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbm9kZUFycmF5KTtcblxudmFyIF9zaGFkb3dIb3N0cyA9IHJlcXVpcmUoJy4uL3F1ZXJ5L3NoYWRvdy1ob3N0cycpO1xuXG52YXIgX3NoYWRvd0hvc3RzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYWRvd0hvc3RzKTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgc2hhZG93T2JzZXJ2ZXJDb25maWcgPSB7XG4gIGNoaWxkTGlzdDogdHJ1ZSxcbiAgc3VidHJlZTogdHJ1ZVxufTtcblxudmFyIFNoYWRvd011dGF0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNoYWRvd011dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dCxcbiAgICAgICAgY2FsbGJhY2sgPSBfcmVmLmNhbGxiYWNrLFxuICAgICAgICBjb25maWcgPSBfcmVmLmNvbmZpZztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaGFkb3dNdXRhdGlvbk9ic2VydmVyKTtcblxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuXG4gICAgdGhpcy5kaXNlbmdhZ2UgPSB0aGlzLmRpc2VuZ2FnZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5jbGllbnRPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKTtcbiAgICB0aGlzLmhvc3RPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcbiAgICAgIHJldHVybiBtdXRhdGlvbnMuZm9yRWFjaChfdGhpcy5oYW5kbGVIb3N0TXV0YXRpb24sIF90aGlzKTtcbiAgICB9KTtcblxuICAgIHRoaXMub2JzZXJ2ZUNvbnRleHQoY29udGV4dCk7XG4gICAgdGhpcy5vYnNlcnZlU2hhZG93SG9zdHMoY29udGV4dCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2hhZG93TXV0YXRpb25PYnNlcnZlciwgW3tcbiAgICBrZXk6ICdkaXNlbmdhZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNlbmdhZ2UoKSB7XG4gICAgICB0aGlzLmNsaWVudE9ic2VydmVyICYmIHRoaXMuY2xpZW50T2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5jbGllbnRPYnNlcnZlciA9IG51bGw7XG4gICAgICB0aGlzLmhvc3RPYnNlcnZlciAmJiB0aGlzLmhvc3RPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLmhvc3RPYnNlcnZlciA9IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb2JzZXJ2ZVNoYWRvd0hvc3RzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2JzZXJ2ZVNoYWRvd0hvc3RzKGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgaG9zdHMgPSAoMCwgX3NoYWRvd0hvc3RzMi5kZWZhdWx0KSh7XG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgIH0pO1xuXG4gICAgICBob3N0cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpczIub2JzZXJ2ZUNvbnRleHQoZWxlbWVudC5zaGFkb3dSb290KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29ic2VydmVDb250ZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2JzZXJ2ZUNvbnRleHQoY29udGV4dCkge1xuICAgICAgdGhpcy5jbGllbnRPYnNlcnZlci5vYnNlcnZlKGNvbnRleHQsIHRoaXMuY29uZmlnKTtcbiAgICAgIHRoaXMuaG9zdE9ic2VydmVyLm9ic2VydmUoY29udGV4dCwgc2hhZG93T2JzZXJ2ZXJDb25maWcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZUhvc3RNdXRhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUhvc3RNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgaWYgKG11dGF0aW9uLnR5cGUgIT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFkZGVkRWxlbWVudHMgPSAoMCwgX25vZGVBcnJheTIuZGVmYXVsdCkobXV0YXRpb24uYWRkZWROb2RlcykuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTtcbiAgICAgIH0pO1xuICAgICAgYWRkZWRFbGVtZW50cy5mb3JFYWNoKHRoaXMub2JzZXJ2ZVNoYWRvd0hvc3RzLCB0aGlzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2hhZG93TXV0YXRpb25PYnNlcnZlcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkb3ctbXV0YXRpb25zLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgICAgaW5jbHVkZUNvbnRleHQgPSBfcmVmLmluY2x1ZGVDb250ZXh0LFxuICAgICAgaW5jbHVkZU9ubHlUYWJiYWJsZSA9IF9yZWYuaW5jbHVkZU9ubHlUYWJiYWJsZSxcbiAgICAgIF9yZWYkc3RyYXRlZ3kgPSBfcmVmLnN0cmF0ZWd5LFxuICAgICAgc3RyYXRlZ3kgPSBfcmVmJHN0cmF0ZWd5ID09PSB1bmRlZmluZWQgPyAncXVpY2snIDogX3JlZiRzdHJhdGVneTtcblxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xuICAgIGxhYmVsOiAncXVlcnkvZm9jdXNhYmxlJyxcbiAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXG4gICAgZGVmYXVsdFRvRG9jdW1lbnQ6IHRydWUsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9KTtcblxuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBjb250ZXh0OiBlbGVtZW50LFxuICAgIGluY2x1ZGVDb250ZXh0OiBpbmNsdWRlQ29udGV4dCxcbiAgICBpbmNsdWRlT25seVRhYmJhYmxlOiBpbmNsdWRlT25seVRhYmJhYmxlLFxuICAgIHN0cmF0ZWd5OiBzdHJhdGVneVxuICB9O1xuXG4gIGlmIChzdHJhdGVneSA9PT0gJ3F1aWNrJykge1xuICAgIHJldHVybiAoMCwgX2ZvY3VzYWJsZTQuZGVmYXVsdCkob3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoc3RyYXRlZ3kgPT09ICdzdHJpY3QnIHx8IHN0cmF0ZWd5ID09PSAnYWxsJykge1xuICAgIHJldHVybiAoMCwgX2ZvY3VzYWJsZTIuZGVmYXVsdCkob3B0aW9ucyk7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdxdWVyeS9mb2N1c2FibGUgcmVxdWlyZXMgb3B0aW9uLnN0cmF0ZWd5IHRvIGJlIG9uZSBvZiBbXCJxdWlja1wiLCBcInN0cmljdFwiLCBcImFsbFwiXScpO1xufTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xuXG52YXIgX2ZvY3VzYWJsZSA9IHJlcXVpcmUoJy4vZm9jdXNhYmxlLnN0cmljdCcpO1xuXG52YXIgX2ZvY3VzYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c2FibGUpO1xuXG52YXIgX2ZvY3VzYWJsZTMgPSByZXF1aXJlKCcuL2ZvY3VzYWJsZS5xdWljaycpO1xuXG52YXIgX2ZvY3VzYWJsZTQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c2FibGUzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VkaXRpbmcuaHRtbCNmb2N1c2FibGVcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvUEYvYXJpYS1wcmFjdGljZXMvI2tleWJvYXJkXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXNhYmxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHF1ZXJ5Rm9jdXNhYmxlUXVpY2s7XG5cbnZhciBfZm9jdXNhYmxlID0gcmVxdWlyZSgnLi4vc2VsZWN0b3IvZm9jdXNhYmxlJyk7XG5cbnZhciBfZm9jdXNhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzYWJsZSk7XG5cbnZhciBfZm9jdXNhYmxlMyA9IHJlcXVpcmUoJy4uL2lzL2ZvY3VzYWJsZScpO1xuXG52YXIgX2ZvY3VzYWJsZTQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c2FibGUzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VkaXRpbmcuaHRtbCNmb2N1c2FibGVcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvUEYvYXJpYS1wcmFjdGljZXMvI2tleWJvYXJkXG5cbmZ1bmN0aW9uIHF1ZXJ5Rm9jdXNhYmxlUXVpY2soKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXG4gICAgICBpbmNsdWRlQ29udGV4dCA9IF9yZWYuaW5jbHVkZUNvbnRleHQsXG4gICAgICBpbmNsdWRlT25seVRhYmJhYmxlID0gX3JlZi5pbmNsdWRlT25seVRhYmJhYmxlO1xuXG4gIHZhciBfc2VsZWN0b3IgPSAoMCwgX2ZvY3VzYWJsZTIuZGVmYXVsdCkoKTtcbiAgdmFyIGVsZW1lbnRzID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKF9zZWxlY3Rvcik7XG4gIC8vIHRoZSBzZWxlY3RvciBwb3RlbnRpYWxseSBtYXRjaGVzIG1vcmUgdGhhbiByZWFsbHkgaXMgZm9jdXNhYmxlXG5cbiAgdmFyIF9pc0ZvY3VzYWJsZSA9IF9mb2N1c2FibGU0LmRlZmF1bHQucnVsZXMuZXhjZXB0KHtcbiAgICBvbmx5VGFiYmFibGU6IGluY2x1ZGVPbmx5VGFiYmFibGVcbiAgfSk7XG5cbiAgdmFyIHJlc3VsdCA9IFtdLmZpbHRlci5jYWxsKGVsZW1lbnRzLCBfaXNGb2N1c2FibGUpO1xuXG4gIC8vIGFkZCBjb250ZXh0IGlmIHJlcXVlc3RlZCBhbmQgZm9jdXNhYmxlXG4gIGlmIChpbmNsdWRlQ29udGV4dCAmJiBfaXNGb2N1c2FibGUoY29udGV4dCkpIHtcbiAgICByZXN1bHQudW5zaGlmdChjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzYWJsZS5xdWljay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBxdWVyeUZvY3VzYWJsZVN0cmljdDtcblxudmFyIF9mb2N1c2FibGUgPSByZXF1aXJlKCcuLi9pcy9mb2N1c2FibGUnKTtcblxudmFyIF9mb2N1c2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNhYmxlKTtcblxudmFyIF9mb2N1c1JlbGV2YW50ID0gcmVxdWlyZSgnLi4vaXMvZm9jdXMtcmVsZXZhbnQnKTtcblxudmFyIF9mb2N1c1JlbGV2YW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzUmVsZXZhbnQpO1xuXG52YXIgX2dldERvY3VtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9nZXQtZG9jdW1lbnQnKTtcblxudmFyIF9nZXREb2N1bWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXREb2N1bWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpbHRlcihjb25kaXRpb24pIHtcbiAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlRmlsdGVyXG4gIHZhciBmaWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIobm9kZSkge1xuICAgIGlmIChub2RlLnNoYWRvd1Jvb3QpIHtcbiAgICAgIC8vIHJldHVybiBTaGFkb3dSb290IGVsZW1lbnRzIHJlZ2FyZGxlc3Mgb2YgdGhlbSBiZWluZyBmb2N1c2FibGUsXG4gICAgICAvLyBzbyB0aGV5IGNhbiBiZSB3YWxrZWQgcmVjdXJzaXZlbHkgbGF0ZXJcbiAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XG4gICAgfVxuXG4gICAgaWYgKGNvbmRpdGlvbihub2RlKSkge1xuICAgICAgLy8gZmluZHMgZWxlbWVudHMgdGhhdCBjb3VsZCBoYXZlIGJlZW4gZm91bmQgYnkgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgpXG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICAgIH1cblxuICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICB9O1xuICAvLyBJRSByZXF1aXJlcyBhIGZ1bmN0aW9uLCBCcm93c2VycyByZXF1aXJlIHthY2NlcHROb2RlOiBmdW5jdGlvbn1cbiAgLy8gc2VlIGh0dHA6Ly93d3cuYmVubmFkZWwuY29tL2Jsb2cvMjYwNy1maW5kaW5nLWh0bWwtY29tbWVudC1ub2Rlcy1pbi10aGUtZG9tLXVzaW5nLXRyZWV3YWxrZXIuaHRtXG4gIGZpbHRlci5hY2NlcHROb2RlID0gZmlsdGVyO1xuICByZXR1cm4gZmlsdGVyO1xufVxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VkaXRpbmcuaHRtbCNmb2N1c2FibGVcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvUEYvYXJpYS1wcmFjdGljZXMvI2tleWJvYXJkXG5cbnZhciBQb3NzaWJseUZvY3VzYWJsZUZpbHRlciA9IGNyZWF0ZUZpbHRlcihfZm9jdXNSZWxldmFudDIuZGVmYXVsdCk7XG5cbmZ1bmN0aW9uIHF1ZXJ5Rm9jdXNhYmxlU3RyaWN0KCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgICAgaW5jbHVkZUNvbnRleHQgPSBfcmVmLmluY2x1ZGVDb250ZXh0LFxuICAgICAgaW5jbHVkZU9ubHlUYWJiYWJsZSA9IF9yZWYuaW5jbHVkZU9ubHlUYWJiYWJsZSxcbiAgICAgIHN0cmF0ZWd5ID0gX3JlZi5zdHJhdGVneTtcblxuICBpZiAoIWNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgdmFyIF9pc0ZvY3VzYWJsZSA9IF9mb2N1c2FibGUyLmRlZmF1bHQucnVsZXMuZXhjZXB0KHtcbiAgICBvbmx5VGFiYmFibGU6IGluY2x1ZGVPbmx5VGFiYmFibGVcbiAgfSk7XG5cbiAgdmFyIF9kb2N1bWVudCA9ICgwLCBfZ2V0RG9jdW1lbnQyLmRlZmF1bHQpKGNvbnRleHQpO1xuICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2NyZWF0ZVRyZWVXYWxrZXJcbiAgdmFyIHdhbGtlciA9IF9kb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKFxuICAvLyByb290IGVsZW1lbnQgdG8gc3RhcnQgc2VhcmNoIGluXG4gIGNvbnRleHQsXG4gIC8vIGVsZW1lbnQgdHlwZSBmaWx0ZXJcbiAgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsXG4gIC8vIGN1c3RvbSBOb2RlRmlsdGVyIGZpbHRlclxuICBzdHJhdGVneSA9PT0gJ2FsbCcgPyBQb3NzaWJseUZvY3VzYWJsZUZpbHRlciA6IGNyZWF0ZUZpbHRlcihfaXNGb2N1c2FibGUpLFxuICAvLyBkZXByZWNhdGVkLCBidXQgSUUgcmVxdWlyZXMgaXRcbiAgZmFsc2UpO1xuXG4gIHZhciBsaXN0ID0gW107XG5cbiAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgaWYgKHdhbGtlci5jdXJyZW50Tm9kZS5zaGFkb3dSb290KSB7XG4gICAgICBpZiAoX2lzRm9jdXNhYmxlKHdhbGtlci5jdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgbGlzdC5wdXNoKHdhbGtlci5jdXJyZW50Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGxpc3QgPSBsaXN0LmNvbmNhdChxdWVyeUZvY3VzYWJsZVN0cmljdCh7XG4gICAgICAgIGNvbnRleHQ6IHdhbGtlci5jdXJyZW50Tm9kZS5zaGFkb3dSb290LFxuICAgICAgICBpbmNsdWRlT25seVRhYmJhYmxlOiBpbmNsdWRlT25seVRhYmJhYmxlLFxuICAgICAgICBzdHJhdGVneTogc3RyYXRlZ3lcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5wdXNoKHdhbGtlci5jdXJyZW50Tm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIGNvbnRleHQgaWYgcmVxdWVzdGVkIGFuZCBmb2N1c2FibGVcbiAgaWYgKGluY2x1ZGVDb250ZXh0KSB7XG4gICAgaWYgKHN0cmF0ZWd5ID09PSAnYWxsJykge1xuICAgICAgaWYgKCgwLCBfZm9jdXNSZWxldmFudDIuZGVmYXVsdCkoY29udGV4dCkpIHtcbiAgICAgICAgbGlzdC51bnNoaWZ0KGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX2lzRm9jdXNhYmxlKGNvbnRleHQpKSB7XG4gICAgICBsaXN0LnVuc2hpZnQoY29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxpc3Q7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzYWJsZS5zdHJpY3QuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcXVlcnlTaGFkb3dIb3N0cztcblxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xuXG52YXIgX2dldERvY3VtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9nZXQtZG9jdW1lbnQnKTtcblxudmFyIF9nZXREb2N1bWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXREb2N1bWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZUZpbHRlclxudmFyIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihub2RlKSB7XG4gIGlmIChub2RlLnNoYWRvd1Jvb3QpIHtcbiAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICB9XG5cbiAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG59O1xuLy8gSUUgcmVxdWlyZXMgYSBmdW5jdGlvbiwgQnJvd3NlcnMgcmVxdWlyZSB7YWNjZXB0Tm9kZTogZnVuY3Rpb259XG4vLyBzZWUgaHR0cDovL3d3dy5iZW5uYWRlbC5jb20vYmxvZy8yNjA3LWZpbmRpbmctaHRtbC1jb21tZW50LW5vZGVzLWluLXRoZS1kb20tdXNpbmctdHJlZXdhbGtlci5odG1cbmZpbHRlci5hY2NlcHROb2RlID0gZmlsdGVyO1xuXG5mdW5jdGlvbiBxdWVyeVNoYWRvd0hvc3RzKCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0O1xuXG4gIHZhciBlbGVtZW50ID0gKDAsIF9jb250ZXh0VG9FbGVtZW50Mi5kZWZhdWx0KSh7XG4gICAgbGFiZWw6ICdxdWVyeS9zaGFkb3ctaG9zdHMnLFxuICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcbiAgICBkZWZhdWx0VG9Eb2N1bWVudDogdHJ1ZSxcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH0pO1xuXG4gIHZhciBfZG9jdW1lbnQgPSAoMCwgX2dldERvY3VtZW50Mi5kZWZhdWx0KShjb250ZXh0KTtcbiAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9jcmVhdGVUcmVlV2Fsa2VyXG4gIHZhciB3YWxrZXIgPSBfZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihcbiAgLy8gcm9vdCBlbGVtZW50IHRvIHN0YXJ0IHNlYXJjaCBpblxuICBlbGVtZW50LFxuICAvLyBlbGVtZW50IHR5cGUgZmlsdGVyXG4gIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULFxuICAvLyBjdXN0b20gTm9kZUZpbHRlciBmaWx0ZXJcbiAgZmlsdGVyLFxuICAvLyBkZXByZWNhdGVkLCBidXQgSUUgcmVxdWlyZXMgaXRcbiAgZmFsc2UpO1xuXG4gIHZhciBsaXN0ID0gW107XG5cbiAgaWYgKGVsZW1lbnQuc2hhZG93Um9vdCkge1xuICAgIC8vIFRyZWVXYWxrZXIgZG9lcyBub3QgcnVuIHRoZSBmaWx0ZXIgb24gdGhlIGNvbnRleHQgZWxlbWVudFxuICAgIGxpc3QucHVzaChlbGVtZW50KTtcbiAgICBsaXN0ID0gbGlzdC5jb25jYXQocXVlcnlTaGFkb3dIb3N0cyh7XG4gICAgICBjb250ZXh0OiBlbGVtZW50LnNoYWRvd1Jvb3RcbiAgICB9KSk7XG4gIH1cblxuICB3aGlsZSAod2Fsa2VyLm5leHROb2RlKCkpIHtcbiAgICBsaXN0LnB1c2god2Fsa2VyLmN1cnJlbnROb2RlKTtcbiAgICBsaXN0ID0gbGlzdC5jb25jYXQocXVlcnlTaGFkb3dIb3N0cyh7XG4gICAgICBjb250ZXh0OiB3YWxrZXIuY3VycmVudE5vZGUuc2hhZG93Um9vdFxuICAgIH0pKTtcbiAgfVxuXG4gIHJldHVybiBsaXN0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkb3ctaG9zdHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXG4gICAgICBpbmNsdWRlQ29udGV4dCA9IF9yZWYuaW5jbHVkZUNvbnRleHQsXG4gICAgICBpbmNsdWRlT25seVRhYmJhYmxlID0gX3JlZi5pbmNsdWRlT25seVRhYmJhYmxlLFxuICAgICAgc3RyYXRlZ3kgPSBfcmVmLnN0cmF0ZWd5O1xuXG4gIHZhciBfaXNUYWJiYWJsZSA9IF90YWJiYWJsZTIuZGVmYXVsdC5ydWxlcy5leGNlcHQoe1xuICAgIG9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZVxuICB9KTtcblxuICByZXR1cm4gKDAsIF9mb2N1c2FibGUyLmRlZmF1bHQpKHtcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIGluY2x1ZGVDb250ZXh0OiBpbmNsdWRlQ29udGV4dCxcbiAgICBpbmNsdWRlT25seVRhYmJhYmxlOiBpbmNsdWRlT25seVRhYmJhYmxlLFxuICAgIHN0cmF0ZWd5OiBzdHJhdGVneVxuICB9KS5maWx0ZXIoX2lzVGFiYmFibGUpO1xufTtcblxudmFyIF9mb2N1c2FibGUgPSByZXF1aXJlKCcuL2ZvY3VzYWJsZScpO1xuXG52YXIgX2ZvY3VzYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c2FibGUpO1xuXG52YXIgX3RhYmJhYmxlID0gcmVxdWlyZSgnLi4vaXMvdGFiYmFibGUnKTtcblxudmFyIF90YWJiYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWJiYWJsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VkaXRpbmcuaHRtbCNzZXF1ZW50aWFsLWZvY3VzLW5hdmlnYXRpb24tYW5kLXRoZS10YWJpbmRleC1hdHRyaWJ1dGVcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvUEYvYXJpYS1wcmFjdGljZXMvI2tleWJvYXJkXG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJiYWJsZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dCxcbiAgICAgIGluY2x1ZGVDb250ZXh0ID0gX3JlZi5pbmNsdWRlQ29udGV4dCxcbiAgICAgIGluY2x1ZGVPbmx5VGFiYmFibGUgPSBfcmVmLmluY2x1ZGVPbmx5VGFiYmFibGUsXG4gICAgICBzdHJhdGVneSA9IF9yZWYuc3RyYXRlZ3k7XG5cbiAgaWYgKCFzdXBwb3J0cykge1xuICAgIHN1cHBvcnRzID0gKDAsIF9zdXBwb3J0czMuZGVmYXVsdCkoKTtcbiAgfVxuXG4gIHZhciBfY29udGV4dCA9ICgwLCBfbm9kZUFycmF5Mi5kZWZhdWx0KShjb250ZXh0KVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBlbGVtZW50cyA9ICgwLCBfdGFiYmFibGUyLmRlZmF1bHQpKHtcbiAgICBjb250ZXh0OiBfY29udGV4dCxcbiAgICBpbmNsdWRlQ29udGV4dDogaW5jbHVkZUNvbnRleHQsXG4gICAgaW5jbHVkZU9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZSxcbiAgICBzdHJhdGVneTogc3RyYXRlZ3lcbiAgfSk7XG5cbiAgaWYgKGRvY3VtZW50LmJvZHkuY3JlYXRlU2hhZG93Um9vdCAmJiBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuQkxJTkspIHtcbiAgICAvLyBzb3J0IHRhYmluZGV4IGxvY2FsaXplZCB0byBzaGFkb3cgZG9tXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvNlxuICAgIGVsZW1lbnRzID0gKDAsIF90YWJzZXF1ZW5jZTQuZGVmYXVsdCkoZWxlbWVudHMsIF9jb250ZXh0LCBzb3J0RWxlbWVudHMpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnRzID0gc29ydEVsZW1lbnRzKGVsZW1lbnRzLCBfY29udGV4dCk7XG4gIH1cblxuICBpZiAoaW5jbHVkZUNvbnRleHQpIHtcbiAgICAvLyBpZiB3ZSBpbmNsdWRlIHRoZSBjb250ZXh0IGl0c2VsZiwgaXQgaGFzIHRvIGJlIHRoZSBmaXJzdFxuICAgIC8vIGVsZW1lbnQgb2YgdGhlIHNlcXVlbmNlXG4gICAgZWxlbWVudHMgPSBtb3ZlQ29udGV4dFRvQmVnaW5uaW5nKGVsZW1lbnRzLCBfY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudHM7XG59O1xuXG52YXIgX3RhYmJhYmxlID0gcmVxdWlyZSgnLi90YWJiYWJsZScpO1xuXG52YXIgX3RhYmJhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYmJhYmxlKTtcblxudmFyIF9ub2RlQXJyYXkgPSByZXF1aXJlKCcuLi91dGlsL25vZGUtYXJyYXknKTtcblxudmFyIF9ub2RlQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbm9kZUFycmF5KTtcblxudmFyIF9wbGF0Zm9ybSA9IHJlcXVpcmUoJy4uL3V0aWwvcGxhdGZvcm0nKTtcblxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XG5cbnZhciBfdGFic2VxdWVuY2UgPSByZXF1aXJlKCcuL3RhYnNlcXVlbmNlLnNvcnQtYXJlYScpO1xuXG52YXIgX3RhYnNlcXVlbmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYnNlcXVlbmNlKTtcblxudmFyIF90YWJzZXF1ZW5jZTMgPSByZXF1aXJlKCcuL3RhYnNlcXVlbmNlLnNvcnQtc2hhZG93ZWQnKTtcblxudmFyIF90YWJzZXF1ZW5jZTQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWJzZXF1ZW5jZTMpO1xuXG52YXIgX3RhYnNlcXVlbmNlNSA9IHJlcXVpcmUoJy4vdGFic2VxdWVuY2Uuc29ydC10YWJpbmRleCcpO1xuXG52YXIgX3RhYnNlcXVlbmNlNiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYnNlcXVlbmNlNSk7XG5cbnZhciBfc3VwcG9ydHMyID0gcmVxdWlyZSgnLi4vc3VwcG9ydHMvc3VwcG9ydHMnKTtcblxudmFyIF9zdXBwb3J0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdXBwb3J0czIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgc3VwcG9ydHMgPSB2b2lkIDA7XG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZWRpdGluZy5odG1sI3NlcXVlbnRpYWwtZm9jdXMtbmF2aWdhdGlvbi1hbmQtdGhlLXRhYmluZGV4LWF0dHJpYnV0ZVxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1dBSS9QRi9hcmlhLXByYWN0aWNlcy8ja2V5Ym9hcmRcblxuZnVuY3Rpb24gbW92ZUNvbnRleHRUb0JlZ2lubmluZyhlbGVtZW50cywgY29udGV4dCkge1xuICB2YXIgcG9zID0gZWxlbWVudHMuaW5kZXhPZihjb250ZXh0KTtcbiAgaWYgKHBvcyA+IDApIHtcbiAgICB2YXIgdG1wID0gZWxlbWVudHMuc3BsaWNlKHBvcywgMSk7XG4gICAgcmV0dXJuIHRtcC5jb25jYXQoZWxlbWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRzO1xufVxuXG5mdW5jdGlvbiBzb3J0RWxlbWVudHMoZWxlbWVudHMsIF9jb250ZXh0KSB7XG4gIGlmIChzdXBwb3J0cy50YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9uKSB7XG4gICAgLy8gU29tZSBicm93c2VycyBzb3J0IDxhcmVhPiBpbiBET00gb3JkZXIsIHNvbWUgcGxhY2UgdGhlIDxhcmVhPnNcbiAgICAvLyB3aGVyZSB0aGUgPGltZz4gcmVmZXJlY2luZyB0aGVtIHdvdWxkJ3ZlIGJlZW4gaW4gRE9NIG9yZGVyLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvNVxuICAgIGVsZW1lbnRzID0gKDAsIF90YWJzZXF1ZW5jZTIuZGVmYXVsdCkoZWxlbWVudHMsIF9jb250ZXh0KTtcbiAgfVxuXG4gIGVsZW1lbnRzID0gKDAsIF90YWJzZXF1ZW5jZTYuZGVmYXVsdCkoZWxlbWVudHMpO1xuICByZXR1cm4gZWxlbWVudHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFic2VxdWVuY2UuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuLy8gbW92ZSA8YXJlYT4gZWxlbWVudHMgdG8gdGhlIGxvY2F0aW9uIG9mIHRoZSA8aW1nPiBlbGVtZW50cyB0aGF0IHJlZmVyZW5jZSB0aGVtXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChlbGVtZW50cywgY29udGV4dCkge1xuICAvLyBpbWFnZXMgLSB1bmxlc3MgdGhleSBhcmUgZm9jdXNhYmxlIHRoZW1zZWx2ZXMsIGxpa2VseSBub3RcbiAgLy8gcGFydCBvZiB0aGUgZWxlbWVudHMgbGlzdCwgc28gd2UnbGwgaGF2ZSB0byBmaW5kIHRoZW0gYW5kXG4gIC8vIHNvcnQgdGhlbSBpbnRvIHRoZSBlbGVtZW50cyBsaXN0IG1hbnVhbGx5XG4gIHZhciB1c2VtYXBzID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCdpbWdbdXNlbWFwXScpO1xuICB2YXIgbWFwcyA9IG5ldyBNYXBzKGNvbnRleHQpO1xuXG4gIC8vIHJlbW92ZSBhbGwgPGFyZWE+IGVsZW1lbnRzIGZyb20gdGhlIGVsZW1lbnRzIGxpc3QsXG4gIC8vIGJ1dCBwdXQgdGhlbSB0aGUgbWFwIGZvciBsYXRlciByZXRyaWV2YWxcbiAgdmFyIF9lbGVtZW50cyA9IG1hcHMuZXh0cmFjdEFyZWFzRnJvbUxpc3QoZWxlbWVudHMpO1xuXG4gIGlmICghdXNlbWFwcy5sZW5ndGgpIHtcbiAgICAvLyB0aGUgY29udGV4dCBkb2VzIG5vdCBjb250YWluIGFueSA8YXJlYT5zIHNvIG5vIG5lZWRcbiAgICAvLyB0byByZXBsYWNlIGFueXRoaW5nLCBqdXN0IHJlbW92ZSBhbnkgbWFwc1xuICAgIHJldHVybiBfZWxlbWVudHM7XG4gIH1cblxuICByZXR1cm4gKDAsIF9tZXJnZURvbU9yZGVyMi5kZWZhdWx0KSh7XG4gICAgbGlzdDogX2VsZW1lbnRzLFxuICAgIGVsZW1lbnRzOiB1c2VtYXBzLFxuICAgIHJlc29sdmVFbGVtZW50OiBmdW5jdGlvbiByZXNvbHZlRWxlbWVudChpbWFnZSkge1xuICAgICAgdmFyIG5hbWUgPSBpbWFnZS5nZXRBdHRyaWJ1dGUoJ3VzZW1hcCcpLnNsaWNlKDEpO1xuICAgICAgcmV0dXJuIG1hcHMuZ2V0QXJlYXNGb3IobmFtZSk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBfdGFiYmFibGUgPSByZXF1aXJlKCcuL3RhYmJhYmxlJyk7XG5cbnZhciBfdGFiYmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiYmFibGUpO1xuXG52YXIgX21lcmdlRG9tT3JkZXIgPSByZXF1aXJlKCcuLi91dGlsL21lcmdlLWRvbS1vcmRlcicpO1xuXG52YXIgX21lcmdlRG9tT3JkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWVyZ2VEb21PcmRlcik7XG5cbnZhciBfZ2V0RG9jdW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2dldC1kb2N1bWVudCcpO1xuXG52YXIgX2dldERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldERvY3VtZW50KTtcblxudmFyIF9pbWFnZU1hcCA9IHJlcXVpcmUoJy4uL3V0aWwvaW1hZ2UtbWFwJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBNYXBzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXBzKGNvbnRleHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFwcyk7XG5cbiAgICB0aGlzLl9kb2N1bWVudCA9ICgwLCBfZ2V0RG9jdW1lbnQyLmRlZmF1bHQpKGNvbnRleHQpO1xuICAgIHRoaXMubWFwcyA9IHt9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1hcHMsIFt7XG4gICAga2V5OiAnZ2V0QXJlYXNGb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBcmVhc0ZvcihuYW1lKSB7XG4gICAgICBpZiAoIXRoaXMubWFwc1tuYW1lXSkge1xuICAgICAgICAvLyB0aGUgbWFwIGlzIG5vdCBkZWZpbmVkIHdpdGhpbiB0aGUgY29udGV4dCwgc28gd2VcbiAgICAgICAgLy8gaGF2ZSB0byBnbyBmaW5kIGl0IGVsc2V3aGVyZSBpbiB0aGUgZG9jdW1lbnRcbiAgICAgICAgdGhpcy5hZGRNYXBCeU5hbWUobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm1hcHNbbmFtZV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWRkTWFwQnlOYW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTWFwQnlOYW1lKG5hbWUpIHtcbiAgICAgIHZhciBtYXAgPSAoMCwgX2ltYWdlTWFwLmdldE1hcEJ5TmFtZSkobmFtZSwgdGhpcy5fZG9jdW1lbnQpO1xuICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gbWFwLCB0aGUgaW1nW3VzZW1hcF0gd2Fzbid0IGRvaW5nIGFueXRoaW5nIGFueXdheVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFwc1ttYXAubmFtZV0gPSAoMCwgX3RhYmJhYmxlMi5kZWZhdWx0KSh7IGNvbnRleHQ6IG1hcCB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdleHRyYWN0QXJlYXNGcm9tTGlzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RBcmVhc0Zyb21MaXN0KGVsZW1lbnRzKSB7XG4gICAgICAvLyByZW1vdmUgYWxsIDxhcmVhPiBlbGVtZW50cyBmcm9tIHRoZSBlbGVtZW50cyBsaXN0LFxuICAgICAgLy8gYnV0IHB1dCB0aGVtIHRoZSBtYXAgZm9yIGxhdGVyIHJldHJpZXZhbFxuICAgICAgcmV0dXJuIGVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChub2RlTmFtZSAhPT0gJ2FyZWEnKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFwID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoIXRoaXMubWFwc1ttYXAubmFtZV0pIHtcbiAgICAgICAgICB0aGlzLm1hcHNbbWFwLm5hbWVdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hcHNbbWFwLm5hbWVdLnB1c2goZWxlbWVudCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXBzO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYnNlcXVlbmNlLnNvcnQtYXJlYS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChlbGVtZW50cywgY29udGV4dCwgc29ydEVsZW1lbnRzKSB7XG4gIHZhciBzaGFkb3dzID0gbmV3IFNoYWRvd3MoY29udGV4dCwgc29ydEVsZW1lbnRzKTtcbiAgdmFyIF9lbGVtZW50cyA9IHNoYWRvd3MuZXh0cmFjdEVsZW1lbnRzKGVsZW1lbnRzKTtcblxuICBpZiAoX2VsZW1lbnRzLmxlbmd0aCA9PT0gZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgLy8gbm8gc2hhZG93ZWQgY29udGVudCBmb3VuZCwgbm8gbmVlZCB0byBjb250aW51ZVxuICAgIHJldHVybiBzb3J0RWxlbWVudHMoZWxlbWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIHNoYWRvd3Muc29ydChfZWxlbWVudHMpO1xufTtcblxudmFyIF9zaGFkb3dIb3N0ID0gcmVxdWlyZSgnLi4vZ2V0L3NoYWRvdy1ob3N0Jyk7XG5cbnZhciBfc2hhZG93SG9zdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGFkb3dIb3N0KTtcblxudmFyIF9tZXJnZURvbU9yZGVyID0gcmVxdWlyZSgnLi4vdXRpbC9tZXJnZS1kb20tb3JkZXInKTtcblxudmFyIF9tZXJnZURvbU9yZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lcmdlRG9tT3JkZXIpO1xuXG52YXIgX3RhYmluZGV4VmFsdWUgPSByZXF1aXJlKCcuLi91dGlsL3RhYmluZGV4LXZhbHVlJyk7XG5cbnZhciBfdGFiaW5kZXhWYWx1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWJpbmRleFZhbHVlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFNoYWRvd3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNoYWRvd3MoY29udGV4dCwgc29ydEVsZW1lbnRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNoYWRvd3MpO1xuXG4gICAgLy8gZG9jdW1lbnQgY29udGV4dCB3ZSdyZSB3b3JraW5nIHdpdGhcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIC8vIGNhbGxiYWNrIHRoYXQgc29ydHMgYW4gYXJyYXkgb2YgZWxlbWVudHNcbiAgICB0aGlzLnNvcnRFbGVtZW50cyA9IHNvcnRFbGVtZW50cztcbiAgICAvLyByZWZlcmVuY2UgdG8gY3JlYXRlIHVuaXF1ZSBJRHMgZm9yIGVhY2ggU2hhZG93SG9zdFxuICAgIHRoaXMuaG9zdENvdW50ZXIgPSAxO1xuICAgIC8vIHJlZmVyZW5jZSBtYXAgZm9yIGNoaWxkLVNoYWRvd0hvc3RzIG9mIGEgU2hhZG93SG9zdFxuICAgIHRoaXMuaW5Ib3N0ID0ge307XG4gICAgLy8gcmVmZXJlbmNlIG1hcCBmb3IgY2hpbGQtU2hhZG93SG9zdCBvZiB0aGUgZG9jdW1lbnRcbiAgICB0aGlzLmluRG9jdW1lbnQgPSBbXTtcbiAgICAvLyByZWZlcmVuY2UgbWFwIGZvciBTaGFkb3dIb3N0c1xuICAgIHRoaXMuaG9zdHMgPSB7fTtcbiAgICAvLyByZWZlcmVuY2UgbWFwIGZvciB0YWJiYWJsZSBlbGVtZW50cyBvZiBhIFNoYWRvd0hvc3RcbiAgICB0aGlzLmVsZW1lbnRzID0ge307XG4gIH1cblxuICAvLyByZW1lbWJlciB3aGljaCBob3N0cyB3ZSBoYXZlIHRvIHNvcnQgd2l0aGluIGxhdGVyXG5cblxuICBfY3JlYXRlQ2xhc3MoU2hhZG93cywgW3tcbiAgICBrZXk6ICdfcmVnaXN0ZXJIb3N0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZ2lzdGVySG9zdChob3N0KSB7XG4gICAgICBpZiAoaG9zdC5fc29ydGluZ0lkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSB0aGUgU2hhZG93SG9zdCBpZGVudGlmaWFibGUgKHNlZSBjbGVhbnVwKCkgZm9yIHVuZG8pXG4gICAgICBob3N0Ll9zb3J0aW5nSWQgPSAnc2hhZG93LScgKyB0aGlzLmhvc3RDb3VudGVyKys7XG4gICAgICB0aGlzLmhvc3RzW2hvc3QuX3NvcnRpbmdJZF0gPSBob3N0O1xuXG4gICAgICAvLyBob3N0cyBtYXkgY29udGFpbiBvdGhlciBob3N0c1xuICAgICAgdmFyIHBhcmVudEhvc3QgPSAoMCwgX3NoYWRvd0hvc3QyLmRlZmF1bHQpKHsgY29udGV4dDogaG9zdCB9KTtcbiAgICAgIGlmIChwYXJlbnRIb3N0KSB7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVySG9zdChwYXJlbnRIb3N0KTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJIb3N0UGFyZW50KGhvc3QsIHBhcmVudEhvc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbkRvY3VtZW50LnB1c2goaG9zdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtZW1iZXIgd2hpY2ggaG9zdCBpcyB0aGUgY2hpbGQgb2Ygd2hpY2ggb3RoZXIgaG9zdFxuXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVnaXN0ZXJIb3N0UGFyZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZ2lzdGVySG9zdFBhcmVudChob3N0LCBwYXJlbnQpIHtcbiAgICAgIGlmICghdGhpcy5pbkhvc3RbcGFyZW50Ll9zb3J0aW5nSWRdKSB7XG4gICAgICAgIHRoaXMuaW5Ib3N0W3BhcmVudC5fc29ydGluZ0lkXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluSG9zdFtwYXJlbnQuX3NvcnRpbmdJZF0ucHVzaChob3N0KTtcbiAgICB9XG5cbiAgICAvLyByZW1lbWJlciB3aGljaCBlbGVtZW50cyBhIGhvc3QgY29udGFpbnNcblxuICB9LCB7XG4gICAga2V5OiAnX3JlZ2lzdGVyRWxlbWVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWdpc3RlckVsZW1lbnQoZWxlbWVudCwgaG9zdCkge1xuICAgICAgaWYgKCF0aGlzLmVsZW1lbnRzW2hvc3QuX3NvcnRpbmdJZF0pIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tob3N0Ll9zb3J0aW5nSWRdID0gW107XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxlbWVudHNbaG9zdC5fc29ydGluZ0lkXS5wdXNoKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBzaGFkb3dlZCBlbGVtZW50cyBmcm9tIHRoZSBzZXF1ZW5jZSBhbmQgcmVnaXN0ZXJcbiAgICAvLyB0aGUgU2hhZG93SG9zdHMgdGhleSBiZWxvbmcgdG8gc28gd2Uga25vdyB3aGF0IHRvIHNvcnRcbiAgICAvLyBsYXRlciBvblxuXG4gIH0sIHtcbiAgICBrZXk6ICdleHRyYWN0RWxlbWVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0RWxlbWVudHMoZWxlbWVudHMpIHtcbiAgICAgIHJldHVybiBlbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGhvc3QgPSAoMCwgX3NoYWRvd0hvc3QyLmRlZmF1bHQpKHsgY29udGV4dDogZWxlbWVudCB9KTtcbiAgICAgICAgaWYgKCFob3N0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZWdpc3Rlckhvc3QoaG9zdCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRWxlbWVudChlbGVtZW50LCBob3N0KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgLy8gaW5qZWN0IGhvc3RzIGludG8gdGhlIHNlcXVlbmNlLCBzb3J0IGV2ZXJ5dGhpbmcsXG4gICAgLy8gYW5kIHJlY291cnNpdmVseSByZXBsYWNlIGhvc3RzIGJ5IGl0cyBkZXNjZW5kYW50c1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzb3J0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29ydChlbGVtZW50cykge1xuICAgICAgdmFyIF9lbGVtZW50cyA9IHRoaXMuX2luamVjdEhvc3RzKGVsZW1lbnRzKTtcbiAgICAgIF9lbGVtZW50cyA9IHRoaXMuX3JlcGxhY2VIb3N0cyhfZWxlbWVudHMpO1xuICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgcmV0dXJuIF9lbGVtZW50cztcbiAgICB9XG5cbiAgICAvLyBtZXJnZSBTaGFkb3dIb3N0cyBpbnRvIHRoZSBlbGVtZW50IGxpc3RzIG9mIG90aGVyIFNoYWRvd0hvc3RzXG4gICAgLy8gb3IgdGhlIGRvY3VtZW50LCB0aGVuIHNvcnQgdGhlIGluZGl2aWR1YWwgbGlzdHNcblxuICB9LCB7XG4gICAga2V5OiAnX2luamVjdEhvc3RzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luamVjdEhvc3RzKGVsZW1lbnRzKSB7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmhvc3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChfc29ydGluZ0lkKSB7XG4gICAgICAgIHZhciBfbGlzdCA9IHRoaXMuZWxlbWVudHNbX3NvcnRpbmdJZF07XG4gICAgICAgIHZhciBfZWxlbWVudHMgPSB0aGlzLmluSG9zdFtfc29ydGluZ0lkXTtcbiAgICAgICAgdmFyIF9jb250ZXh0ID0gdGhpcy5ob3N0c1tfc29ydGluZ0lkXS5zaGFkb3dSb290O1xuICAgICAgICB0aGlzLmVsZW1lbnRzW19zb3J0aW5nSWRdID0gdGhpcy5fbWVyZ2UoX2xpc3QsIF9lbGVtZW50cywgX2NvbnRleHQpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9tZXJnZShlbGVtZW50cywgdGhpcy5pbkRvY3VtZW50LCB0aGlzLmNvbnRleHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19tZXJnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tZXJnZShsaXN0LCBlbGVtZW50cywgY29udGV4dCkge1xuICAgICAgdmFyIG1lcmdlZCA9ICgwLCBfbWVyZ2VEb21PcmRlcjIuZGVmYXVsdCkoe1xuICAgICAgICBsaXN0OiBsaXN0LFxuICAgICAgICBlbGVtZW50czogZWxlbWVudHNcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcy5zb3J0RWxlbWVudHMobWVyZ2VkLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfcmVwbGFjZUhvc3RzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcGxhY2VIb3N0cyhlbGVtZW50cykge1xuICAgICAgcmV0dXJuICgwLCBfbWVyZ2VEb21PcmRlcjIuZGVmYXVsdCkoe1xuICAgICAgICBsaXN0OiBlbGVtZW50cyxcbiAgICAgICAgZWxlbWVudHM6IHRoaXMuaW5Eb2N1bWVudCxcbiAgICAgICAgcmVzb2x2ZUVsZW1lbnQ6IHRoaXMuX3Jlc29sdmVIb3N0RWxlbWVudC5iaW5kKHRoaXMpXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfcmVzb2x2ZUhvc3RFbGVtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc29sdmVIb3N0RWxlbWVudChob3N0KSB7XG4gICAgICB2YXIgbWVyZ2VkID0gKDAsIF9tZXJnZURvbU9yZGVyMi5kZWZhdWx0KSh7XG4gICAgICAgIGxpc3Q6IHRoaXMuZWxlbWVudHNbaG9zdC5fc29ydGluZ0lkXSxcbiAgICAgICAgZWxlbWVudHM6IHRoaXMuaW5Ib3N0W2hvc3QuX3NvcnRpbmdJZF0sXG4gICAgICAgIHJlc29sdmVFbGVtZW50OiB0aGlzLl9yZXNvbHZlSG9zdEVsZW1lbnQuYmluZCh0aGlzKVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBfdGFiaW5kZXggPSAoMCwgX3RhYmluZGV4VmFsdWUyLmRlZmF1bHQpKGhvc3QpO1xuICAgICAgaWYgKF90YWJpbmRleCAhPT0gbnVsbCAmJiBfdGFiaW5kZXggPiAtMSkge1xuICAgICAgICByZXR1cm4gW2hvc3RdLmNvbmNhdChtZXJnZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19jbGVhbnVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFudXAoKSB7XG4gICAgICAvLyByZW1vdmUgdGhvc2UgaWRlbnRpZmVycyB3ZSBwdXQgb24gdGhlIFNoYWRvd0hvc3QgdG8gYXZvaWQgdXNpbmcgTWFwKClcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuaG9zdHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBkZWxldGUgdGhpcy5ob3N0c1trZXldLl9zb3J0aW5nSWQ7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2hhZG93cztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJzZXF1ZW5jZS5zb3J0LXNoYWRvd2VkLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGVsZW1lbnRzKSB7XG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC50YWJJbmRleFxuICAvLyBlbGVtZW50cyB3aXRoIHRhYkluZGV4IFwiMFwiIChpbmNsdWRpbmcgdGFiYmFibGVFbGVtZW50cyB3aXRob3V0IHRhYkluZGV4KSBzaG91bGQgYmUgbmF2aWdhdGVkIGluIHRoZSBvcmRlciB0aGV5IGFwcGVhci5cbiAgLy8gZWxlbWVudHMgd2l0aCBhIHBvc2l0aXZlIHRhYkluZGV4OlxuICAvLyAgIEVsZW1lbnRzIHRoYXQgaGF2ZSBpZGVudGljYWwgdGFiSW5kZXhlcyBzaG91bGQgYmUgbmF2aWdhdGVkIGluIHRoZSBvcmRlciB0aGV5IGFwcGVhci5cbiAgLy8gICBOYXZpZ2F0aW9uIHByb2NlZWRzIGZyb20gdGhlIGxvd2VzdCB0YWJJbmRleCB0byB0aGUgaGlnaGVzdCB0YWJJbmRleC5cblxuICAvLyBOT1RFOiBzb3J0IGltcGxlbWVudGF0aW9uIG1heSBiZSB1bnN0YWJsZSBhbmQgdGh1cyBtZXNzIHVwIERPTSBvcmRlcixcbiAgLy8gdGhhdCdzIHdoeSB3ZSBidWlsZCBhIG1hcCB0aGF0J3MgYmVpbmcgc29ydGVkIGluc3RlYWQuIElmIHdlIHdlcmUgYWJsZSB0byByZWx5XG4gIC8vIG9uIGEgc3RhYmxlIHNvcnRpbmcgYWxnb3JpdGhtLCBzb3J0VGFiaW5kZXgoKSBjb3VsZCBiZSBhcyBzaW1wbGUgYXNcbiAgLy8gZWxlbWVudHMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDsgfSk7XG4gIC8vIGF0IHRoaXMgdGltZSBDaHJvbWUgZG9lcyBub3QgdXNlIGEgc3RhYmxlIHNvcnRpbmcgYWxnb3JpdGhtXG4gIC8vIHNlZSBodHRwOi8vYmxvZy5yb2RuZXlyZWhtLmRlL2FyY2hpdmVzLzE0LVNvcnRpbmctV2VyZS1Eb2luZy1JdC1Xcm9uZy5odG1sI3N0YWJpbGl0eVxuXG4gIC8vIE5PVEU6IGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIHNlZW1lZCBsaWtlIG1vcmUgb3ZlcmhlYWQgdGhhbiBqdXN0IHNvcnRpbmcgdGhpcyB3aXRoIGJ1Y2tldHNcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb25cblxuICB2YXIgbWFwID0ge307XG4gIHZhciBpbmRleGVzID0gW107XG4gIHZhciBub3JtYWwgPSBlbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAvLyBpbiBUcmlkZW50IGFuZCBHZWNrbyBTVkdFbGVtZW50IGRvZXMgbm90IGtub3cgYWJvdXQgdGhlIHRhYkluZGV4IHByb3BlcnR5XG4gICAgdmFyIHRhYkluZGV4ID0gZWxlbWVudC50YWJJbmRleDtcbiAgICBpZiAodGFiSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFiSW5kZXggPSAoMCwgX3RhYmluZGV4VmFsdWUyLmRlZmF1bHQpKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIGV4dHJhY3QgZWxlbWVudHMgdGhhdCBkb24ndCBuZWVkIHNvcnRpbmdcbiAgICBpZiAodGFiSW5kZXggPD0gMCB8fCB0YWJJbmRleCA9PT0gbnVsbCB8fCB0YWJJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIW1hcFt0YWJJbmRleF0pIHtcbiAgICAgIC8vIGNyZWF0ZSBzb3J0YWJsZSBidWNrZXQgZm9yIGRvbS1vcmRlci1wcmVzZXJ2YXRpb24gb2YgZWxlbWVudHMgd2l0aCB0aGUgc2FtZSB0YWJJbmRleFxuICAgICAgbWFwW3RhYkluZGV4XSA9IFtdO1xuICAgICAgLy8gbWFpbnRhaW4gYSBsaXN0IG9mIHVuaXF1ZSB0YWJJbmRleGVzXG4gICAgICBpbmRleGVzLnB1c2godGFiSW5kZXgpO1xuICAgIH1cblxuICAgIC8vIHNvcnQgZWxlbWVudCBpbnRvIHRoZSBwcm9wZXIgYnVja2V0XG4gICAgbWFwW3RhYkluZGV4XS5wdXNoKGVsZW1lbnQpO1xuICAgIC8vIGVsZW1lbnQgbW92ZWQgdG8gc29ydGluZyBtYXAsIHNvIG5vdCBcIm5vcm1hbFwiIGFueW1vcmVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuXG4gIC8vIHNvcnQgdGhlIHRhYmluZGV4IGFzY2VuZGluZyxcbiAgLy8gdGhlbiByZXNvbHZlIHRoZW0gdG8gdGhlaXIgYXBwcm9wcmlhdGUgYnVja2V0cyxcbiAgLy8gdGhlbiBmbGF0dGVuIHRoZSBhcnJheSBvZiBhcnJheXMgdG8gYW4gYXJyYXlcbiAgdmFyIF9lbGVtZW50cyA9IGluZGV4ZXMuc29ydCgpLm1hcChmdW5jdGlvbiAodGFiSW5kZXgpIHtcbiAgICByZXR1cm4gbWFwW3RhYkluZGV4XTtcbiAgfSkucmVkdWNlUmlnaHQoZnVuY3Rpb24gKHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgcmV0dXJuIGN1cnJlbnQuY29uY2F0KHByZXZpb3VzKTtcbiAgfSwgbm9ybWFsKTtcblxuICByZXR1cm4gX2VsZW1lbnRzO1xufTtcblxudmFyIF90YWJpbmRleFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbC90YWJpbmRleC12YWx1ZScpO1xuXG52YXIgX3RhYmluZGV4VmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiaW5kZXhWYWx1ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFic2VxdWVuY2Uuc29ydC10YWJpbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCFzdXBwb3J0cykge1xuICAgIHN1cHBvcnRzID0gKDAsIF9zdXBwb3J0czMuZGVmYXVsdCkoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yO1xuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VkaXRpbmcuaHRtbCNzZXF1ZW50aWFsLWZvY3VzLW5hdmlnYXRpb24tYW5kLXRoZS10YWJpbmRleC1hdHRyaWJ1dGVcbiAgc2VsZWN0b3IgPSAnJ1xuICAvLyBJRTExIHN1cHBvcnRzLmNhbiBmb2N1cyA8dGFibGU+IGFuZCA8dGQ+XG4gICsgKHN1cHBvcnRzLmZvY3VzVGFibGUgPyAndGFibGUsIHRkLCcgOiAnJylcbiAgLy8gSUUxMSBzdXBwb3J0cy5jYW4gZm9jdXMgPGZpZWxkc2V0PlxuICArIChzdXBwb3J0cy5mb2N1c0ZpZWxkc2V0ID8gJ2ZpZWxkc2V0LCcgOiAnJylcbiAgLy8gTmFtZXNwYWNlIHByb2JsZW1zIG9mIFt4bGluazpocmVmXSBleHBsYWluZWQgaW4gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIzMDQ3ODg4LzUxNTEyNFxuICAvLyBzdmcgYVsqfGhyZWZdIGRvZXMgbm90IG1hdGNoIGluIElFOSwgYnV0IHNpbmNlIHdlJ3JlIGZpbHRlcmluZ1xuICAvLyB0aHJvdWdoIGlzL2ZvY3VzYWJsZSB3ZSBjYW4gaW5jbHVkZSBhbGwgPGE+IGZyb20gU1ZHXG4gICsgJ3N2ZyBhLCdcbiAgLy8gbWF5IGJlaGF2ZSBhcyAnc3ZnLCBzdmcgKiwnIGluIGNocm9tZSBhcyAqZXZlcnkqIHN2ZyBlbGVtZW50IHdpdGggYSBmb2N1cyBldmVudCBsaXN0ZW5lciBpcyBmb2N1c2FibGVcbiAgLy8gbmF2aWdhdGlvbmFsIGVsZW1lbnRzXG4gICsgJ2FbaHJlZl0sJ1xuICAvLyB2YWxpZGl0eSBkZXRlcm1pbmVkIGJ5IGlzL3ZhbGlkLWFyZWEuanNcbiAgKyAnYXJlYVtocmVmXSwnXG4gIC8vIHZhbGlkaXR5IGRldGVybWluZWQgYnkgaXMvZGlzYWJsZWQuanNcbiAgKyAnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGJ1dHRvbiwnXG4gIC8vIGJyb3dzaW5nIGNvbnRleHQgY29udGFpbmVyc1xuICArICdpZnJhbWUsIG9iamVjdCwgZW1iZWQsJ1xuICAvLyBpbnRlcmFjdGl2ZSBjb250ZW50XG4gICsgJ2tleWdlbiwnICsgKHN1cHBvcnRzLmZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMgPyAnYXVkaW8sJyA6ICdhdWRpb1tjb250cm9sc10sJykgKyAoc3VwcG9ydHMuZm9jdXNWaWRlb1dpdGhvdXRDb250cm9scyA/ICd2aWRlbywnIDogJ3ZpZGVvW2NvbnRyb2xzXSwnKSArIChzdXBwb3J0cy5mb2N1c1N1bW1hcnkgPyAnc3VtbWFyeSwnIDogJycpXG4gIC8vIHZhbGlkaXR5IGRldGVybWluZWQgYnkgaXMvdmFsaWQtdGFiaW5kZXguanNcbiAgKyAnW3RhYmluZGV4XSwnXG4gIC8vIGVkaXRpbmcgaG9zdHNcbiAgKyAnW2NvbnRlbnRlZGl0YWJsZV0nO1xuXG4gIC8vIHdoZXJlIFNoYWRvd0RPTSBpcyBzdXBwb3J0ZWQsIHdlIGFsc28gd2FudCB0aGUgc2hhZG93ZWQgZm9jdXNhYmxlIGVsZW1lbnRzICh2aWEgXCI+Pj5cIiBvciBcIi9kZWVwL1wiKVxuICBzZWxlY3RvciA9ICgwLCBfc2VsZWN0SW5TaGFkb3dzMi5kZWZhdWx0KShzZWxlY3Rvcik7XG5cbiAgcmV0dXJuIHNlbGVjdG9yO1xufTtcblxudmFyIF9zZWxlY3RJblNoYWRvd3MgPSByZXF1aXJlKCcuLi91dGlsL3NlbGVjdC1pbi1zaGFkb3dzJyk7XG5cbnZhciBfc2VsZWN0SW5TaGFkb3dzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NlbGVjdEluU2hhZG93cyk7XG5cbnZhciBfc3VwcG9ydHMyID0gcmVxdWlyZSgnLi4vc3VwcG9ydHMvc3VwcG9ydHMnKTtcblxudmFyIF9zdXBwb3J0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdXBwb3J0czIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBOT1RFOiB0aGlzIHNlbGVjdG9yIE1VU1QgKm5ldmVyKiBiZSB1c2VkIGRpcmVjdGx5LFxuLy8gYWx3YXlzIGdvIHRocm91Z2ggcXVlcnkvZm9jdXNhYmxlIG9yIGlzL2ZvY3VzYWJsZS5qc1xuLy8gdGhlcmUgYXJlIHRvbyBtYW55IGVkZ2UgY2FzZXMgdGhhdCB0aGV5IGNvdWxkIGJlIGNvdmVyZWQgaW5cbi8vIGEgc2ltcGxlIENTUyBzZWxlY3RvcuKAplxuXG52YXIgc3VwcG9ydHMgPSB2b2lkIDA7XG5cbnZhciBzZWxlY3RvciA9IHZvaWQgMDtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1c2FibGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb21iaW5hdG9yID0gdm9pZCAwO1xuXG4gIC8vIHNlZSBodHRwczovL2Rldi53My5vcmcvY3Nzd2cvY3NzLXNjb3BpbmctMS8jZGVlcC1jb21iaW5hdG9yXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMTc1NzJcbiAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NjA1MVxuICB0cnkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2h0bWwgPj4+IDpmaXJzdC1jaGlsZCcpO1xuICAgIGNvbWJpbmF0b3IgPSAnPj4+JztcbiAgfSBjYXRjaCAobm9BcnJvd0Fycm93QXJyb3cpIHtcbiAgICB0cnkge1xuICAgICAgLy8gb2xkIHN5bnRheCBzdXBwb3J0ZWQgYXQgbGVhc3QgdXAgdG8gQ2hyb21lIDQxXG4gICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ2MDUxXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sIC9kZWVwLyA6Zmlyc3QtY2hpbGQnKTtcbiAgICAgIGNvbWJpbmF0b3IgPSAnL2RlZXAvJztcbiAgICB9IGNhdGNoIChub0RlZXApIHtcbiAgICAgIGNvbWJpbmF0b3IgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29tYmluYXRvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3NzLXNoYWRvdy1waWVyY2luZy1kZWVwLWNvbWJpbmF0b3IuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAodGVzdHMpIHtcbiAgdmFyIGRhdGEgPSBiZWZvcmUoKTtcblxuICB2YXIgcmVzdWx0cyA9IHt9O1xuICBPYmplY3Qua2V5cyh0ZXN0cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXN1bHRzW2tleV0gPSB0ZXN0KGRhdGEsIHRlc3RzW2tleV0pO1xuICB9KTtcblxuICBhZnRlcihkYXRhKTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xuXG52YXIgX3BsYXRmb3JtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BsYXRmb3JtKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gYmVmb3JlKCkge1xuICB2YXIgZGF0YSA9IHtcbiAgICAvLyByZW1lbWJlciB3aGF0IGhhZCBmb2N1cyB0byByZXN0b3JlIGFmdGVyIHRlc3RcbiAgICBhY3RpdmVFbGVtZW50OiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LFxuICAgIC8vIHJlbWVtYmVyIHNjcm9sbCBwb3NpdGlvbnMgdG8gcmVzdG9yZSBhZnRlciB0ZXN0XG4gICAgd2luZG93U2Nyb2xsVG9wOiB3aW5kb3cuc2Nyb2xsVG9wLFxuICAgIHdpbmRvd1Njcm9sbExlZnQ6IHdpbmRvdy5zY3JvbGxMZWZ0LFxuICAgIGJvZHlTY3JvbGxUb3A6IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLFxuICAgIGJvZHlTY3JvbGxMZWZ0OiBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnRcbiAgfTtcblxuICAvLyB3cmFwIHRlc3RzIGluIGFuIGVsZW1lbnQgaGlkZGVuIGZyb20gc2NyZWVuIHJlYWRlcnMgdG8gcHJldmVudCB0aGVtXG4gIC8vIGZyb20gYW5ub3VuY2luZyBmb2N1cywgd2hpY2ggY2FuIGJlIHF1aXRlIGlycml0YXRpbmcgdG8gdGhlIHVzZXJcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzdHlsZScsICdwb3NpdGlvbjphYnNvbHV0ZTsgcG9zaXRpb246Zml4ZWQ7IHRvcDowOyBsZWZ0Oi0ycHg7IHdpZHRoOjFweDsgaGVpZ2h0OjFweDsgb3ZlcmZsb3c6aGlkZGVuOycpO1xuICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnb2ZmJyk7XG4gIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtYnVzeScsICd0cnVlJyk7XG4gIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXG4gIHZhciBfd2luZG93ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gIHZhciBfZG9jdW1lbnQgPSBfd2luZG93LmRvY3VtZW50O1xuXG4gIF9kb2N1bWVudC5vcGVuKCk7XG4gIF9kb2N1bWVudC5jbG9zZSgpO1xuICB2YXIgd3JhcHBlciA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgX2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG5cbiAgZGF0YS5pZnJhbWUgPSBpZnJhbWU7XG4gIGRhdGEud3JhcHBlciA9IHdyYXBwZXI7XG4gIGRhdGEud2luZG93ID0gX3dpbmRvdztcbiAgZGF0YS5kb2N1bWVudCA9IF9kb2N1bWVudDtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLy8gb3B0aW9ucy5lbGVtZW50OlxuLy8gIHtzdHJpbmd9IGVsZW1lbnQgbmFtZVxuLy8gIHtmdW5jdGlvbn0gY2FsbGJhY2sod3JhcHBlciwgZG9jdW1lbnQpIHRvIGdlbmVyYXRlIGFuIGVsZW1lbnRcbi8vIG9wdGlvbnMubXV0YXRlOiAob3B0aW9uYWwpXG4vLyAge2Z1bmN0aW9ufSBjYWxsYmFjayhlbGVtZW50LCB3cmFwcGVyLCBkb2N1bWVudCkgdG8gbWFuaXB1bGF0ZSBlbGVtZW50IHByaW9yIHRvIGZvY3VzLXRlc3QuXG4vLyAgICAgICAgICAgICBDYW4gcmV0dXJuIERPTUVsZW1lbnQgdG8gZGVmaW5lIGZvY3VzIHRhcmdldCAoZGVmYXVsdDogZWxlbWVudClcbi8vIG9wdGlvbnMudmFsaWRhdGU6IChvcHRpb25hbClcbi8vICB7ZnVuY3Rpb259IGNhbGxiYWNrKGVsZW1lbnQsIGZvY3VzVGFyZ2V0LCBkb2N1bWVudCkgdG8gbWFuaXB1bGF0ZSB0ZXN0LXJlc3VsdFxuZnVuY3Rpb24gdGVzdChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIG1ha2Ugc3VyZSB3ZSBvcGVyYXRlIG9uIGEgY2xlYW4gc2xhdGVcbiAgZGF0YS53cmFwcGVyLmlubmVySFRNTCA9ICcnO1xuICAvLyBjcmVhdGUgZHVtbXkgZWxlbWVudCB0byB0ZXN0IGZvY3VzYWJpbGl0eSBvZlxuICB2YXIgZWxlbWVudCA9IHR5cGVvZiBvcHRpb25zLmVsZW1lbnQgPT09ICdzdHJpbmcnID8gZGF0YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KG9wdGlvbnMuZWxlbWVudCkgOiBvcHRpb25zLmVsZW1lbnQoZGF0YS53cmFwcGVyLCBkYXRhLmRvY3VtZW50KTtcbiAgLy8gYWxsb3cgY2FsbGJhY2sgdG8gZnVydGhlciBzcGVjaWZ5IGR1bW15IGVsZW1lbnRcbiAgLy8gYW5kIG9wdGlvbmFsbHkgZGVmaW5lIGVsZW1lbnQgdG8gZm9jdXNcbiAgdmFyIGZvY3VzID0gb3B0aW9ucy5tdXRhdGUgJiYgb3B0aW9ucy5tdXRhdGUoZWxlbWVudCwgZGF0YS53cmFwcGVyLCBkYXRhLmRvY3VtZW50KTtcbiAgaWYgKCFmb2N1cyAmJiBmb2N1cyAhPT0gZmFsc2UpIHtcbiAgICBmb2N1cyA9IGVsZW1lbnQ7XG4gIH1cbiAgLy8gZWxlbWVudCBuZWVkcyB0byBiZSBwYXJ0IG9mIHRoZSBET00gdG8gYmUgZm9jdXNhYmxlXG4gICFlbGVtZW50LnBhcmVudE5vZGUgJiYgZGF0YS53cmFwcGVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAvLyB0ZXN0IGlmIHRoZSBlbGVtZW50IHdpdGggaW52YWxpZCB0YWJpbmRleCBjYW4gYmUgZm9jdXNlZFxuICBmb2N1cyAmJiBmb2N1cy5mb2N1cyAmJiBmb2N1cy5mb2N1cygpO1xuICAvLyB2YWxpZGF0ZSB0ZXN0J3MgcmVzdWx0XG4gIHJldHVybiBvcHRpb25zLnZhbGlkYXRlID8gb3B0aW9ucy52YWxpZGF0ZShlbGVtZW50LCBmb2N1cywgZGF0YS5kb2N1bWVudCkgOiBkYXRhLmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZvY3VzO1xufVxuXG5mdW5jdGlvbiBhZnRlcihkYXRhKSB7XG4gIC8vIHJlc3RvcmUgZm9jdXMgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHRlc3QgYW5kIGNsZWFudXBcbiAgaWYgKGRhdGEuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuSUUxMCkge1xuICAgICAgLy8gSUUxMCBkb2VzIG5vdCByZWRpcmVjdCBmb2N1cyB0byA8Ym9keT4gd2hlbiB0aGUgYWN0aXZlRWxlbWVudCBpcyByZW1vdmVkXG4gICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRhdGEuYWN0aXZlRWxlbWVudCAmJiBkYXRhLmFjdGl2ZUVsZW1lbnQuZm9jdXMgJiYgZGF0YS5hY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gIH1cblxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRhdGEuaWZyYW1lKTtcblxuICAvLyByZXN0b3JlIHNjcm9sbCBwb3NpdGlvblxuICB3aW5kb3cuc2Nyb2xsVG9wID0gZGF0YS53aW5kb3dTY3JvbGxUb3A7XG4gIHdpbmRvdy5zY3JvbGxMZWZ0ID0gZGF0YS53aW5kb3dTY3JvbGxMZWZ0O1xuICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA9IGRhdGEuYm9keVNjcm9sbFRvcDtcbiAgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0ID0gZGF0YS5ib2R5U2Nyb2xsTGVmdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3QtZm9jdXMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dpZiA9IHJlcXVpcmUoJy4vbWVkaWEvZ2lmJyk7XG5cbnZhciBfZ2lmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dpZik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbWcjYXR0ci11c2VtYXBcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2RpdicsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiPicgKyAnPGFyZWEgc2hhcGU9XCJyZWN0XCIgY29vcmRzPVwiNjMsMTksMTQ0LDQ1XCI+PC9tYXA+JyArICc8aW1nIHVzZW1hcD1cIiNpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiIHRhYmluZGV4PVwiLTFcIiBhbHQ9XCJcIiBzcmM9XCInICsgX2dpZjIuZGVmYXVsdCArICdcIj4nO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcignYXJlYScpO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1hcmVhLWltZy10YWJpbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2lmID0gcmVxdWlyZSgnLi9tZWRpYS9naWYnKTtcblxudmFyIF9naWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2lmKTtcblxudmFyIF9wbGF0Zm9ybSA9IHJlcXVpcmUoJy4uL3V0aWwvcGxhdGZvcm0nKTtcblxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbWcjYXR0ci11c2VtYXBcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2RpdicsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiPicgKyAnPGFyZWEgaHJlZj1cIiN2b2lkXCIgdGFiaW5kZXg9XCItMVwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIiBhbHQ9XCJcIiBzcmM9XCInICsgX2dpZjIuZGVmYXVsdCArICdcIj4nO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xuICAgIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuR0VDS08pIHtcbiAgICAgIC8vIGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMzVcbiAgICAgIC8vIEZpcmVmb3ggbG9hZHMgdGhlIERhdGFVUkkgYXN5bmNocm9ub3VzbHksIGNhdXNpbmcgYSBmYWxzZS1uZWdhdGl2ZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGZvY3VzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhcmVhJyk7XG4gICAgZm9jdXMuZm9jdXMoKTtcbiAgICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZvY3VzO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1hcmVhLXRhYmluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9naWYgPSByZXF1aXJlKCcuL21lZGlhL2dpZicpO1xuXG52YXIgX2dpZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9naWYpO1xuXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xuXG52YXIgX3BsYXRmb3JtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BsYXRmb3JtKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLXVzZW1hcFxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBlbGVtZW50OiAnZGl2JyxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxtYXAgbmFtZT1cImltYWdlLW1hcC1hcmVhLWhyZWYtdGVzdFwiPicgKyAnPGFyZWEgc2hhcGU9XCJyZWN0XCIgY29vcmRzPVwiNjMsMTksMTQ0LDQ1XCI+PC9tYXA+JyArICc8aW1nIHVzZW1hcD1cIiNpbWFnZS1tYXAtYXJlYS1ocmVmLXRlc3RcIiBhbHQ9XCJcIiBzcmM9XCInICsgX2dpZjIuZGVmYXVsdCArICdcIj4nO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcignYXJlYScpO1xuICB9LFxuICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xuICAgIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuR0VDS08pIHtcbiAgICAgIC8vIGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMzVcbiAgICAgIC8vIEZpcmVmb3ggbG9hZHMgdGhlIERhdGFVUkkgYXN5bmNocm9ub3VzbHksIGNhdXNpbmcgYSBmYWxzZS1uZWdhdGl2ZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmb2N1c1RhcmdldDtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtYXJlYS13aXRob3V0LWhyZWYuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21wID0gcmVxdWlyZSgnLi9tZWRpYS9tcDMnKTtcblxudmFyIF9tcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tcCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ2Nhbi1mb2N1cy1hdWRpby13aXRob3V0LWNvbnRyb2xzJyxcbiAgZWxlbWVudDogJ2F1ZGlvJyxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBpbnZhbGlkIG1lZGlhIGZpbGUgY2FuIHRyaWdnZXIgd2FybmluZyBpbiBjb25zb2xlLCBkYXRhLXVyaSB0byBwcmV2ZW50IEhUVFAgcmVxdWVzdFxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NyYycsIF9tcDIuZGVmYXVsdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSUU5IG1heSB0aHJvdyBcIkVycm9yOiBOb3QgaW1wbGVtZW50ZWRcIlxuICAgIH1cbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtYXVkaW8td2l0aG91dC1jb250cm9scy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2lmID0gcmVxdWlyZSgnLi9tZWRpYS9naWYuaW52YWxpZCcpO1xuXG52YXIgX2dpZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9naWYpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBOT1RFOiBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzM1XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdkaXYnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPG1hcCBuYW1lPVwiYnJva2VuLWltYWdlLW1hcC10ZXN0XCI+PGFyZWEgaHJlZj1cIiN2b2lkXCIgc2hhcGU9XCJyZWN0XCIgY29vcmRzPVwiNjMsMTksMTQ0LDQ1XCI+PC9tYXA+JyArICc8aW1nIHVzZW1hcD1cIiNicm9rZW4taW1hZ2UtbWFwLXRlc3RcIiBhbHQ9XCJcIiBzcmM9XCInICsgX2dpZjIuZGVmYXVsdCArICdcIj4nO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcignYXJlYScpO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1icm9rZW4taW1hZ2UtbWFwLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuLy8gQ2hpbGRyZW4gb2YgZm9jdXNhYmxlIGVsZW1lbnRzIHdpdGggZGlzcGxheTpmbGV4IGFyZSBmb2N1c2FibGUgaW4gSUUxMC0xMVxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBlbGVtZW50OiAnZGl2JyxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiAtd2Via2l0LWZsZXg7IGRpc3BsYXk6IC1tcy1mbGV4Ym94OyBkaXNwbGF5OiBmbGV4OycpO1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxzcGFuIHN0eWxlPVwiZGlzcGxheTogYmxvY2s7XCI+aGVsbG88L3NwYW4+JztcbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWNoaWxkcmVuLW9mLWZvY3VzYWJsZS1mbGV4Ym94LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuLy8gZmllbGRzZXRbdGFiaW5kZXg9MF1bZGlzYWJsZWRdIHNob3VsZCBub3QgYmUgZm9jdXNhYmxlLCBidXQgQmxpbmsgYW5kIFdlYktpdCBkaXNhZ3JlZVxuLy8gQHNwZWNpZmljYXRpb24gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Rpc2FibGVkLWVsZW1lbnRzLmh0bWwjY29uY2VwdC1lbGVtZW50LWRpc2FibGVkXG4vLyBAYnJvd3Nlci1pc3N1ZSBDaHJvbWl1bSBodHRwczovL2NyYnVnLmNvbS80NTM4NDdcbi8vIEBicm93c2VyLWlzc3VlIFdlYktpdCBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQxMDg2XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdmaWVsZHNldCcsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtZmllbGRzZXQtZGlzYWJsZWQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBlbGVtZW50OiAnZmllbGRzZXQnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPGxlZ2VuZD5sZWdlbmQ8L2xlZ2VuZD48cD5jb250ZW50PC9wPic7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWZpZWxkc2V0LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuLy8gZWxlbWVudHMgd2l0aCBkaXNwbGF5OmZsZXggYXJlIGZvY3VzYWJsZSBpbiBJRTEwLTExXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdzcGFuJyxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiAtd2Via2l0LWZsZXg7IGRpc3BsYXk6IC1tcy1mbGV4Ym94OyBkaXNwbGF5OiBmbGV4OycpO1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxzcGFuIHN0eWxlPVwiZGlzcGxheTogYmxvY2s7XCI+aGVsbG88L3NwYW4+JztcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtZmxleGJveC1jb250YWluZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG4vLyBmb3JtW3RhYmluZGV4PTBdW2Rpc2FibGVkXSBzaG91bGQgYmUgZm9jdXNhYmxlIGFzIHRoZVxuLy8gc3BlY2lmaWNhdGlvbiBkb2Vzbid0IGtub3cgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZSBvbiB0aGUgZm9ybSBlbGVtZW50XG4vLyBAc3BlY2lmaWNhdGlvbiBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCN0aGUtZm9ybS1lbGVtZW50XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdmb3JtJyxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1mb3JtLWRpc2FibGVkLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9naWYgPSByZXF1aXJlKCcuL21lZGlhL2dpZicpO1xuXG52YXIgX2dpZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9naWYpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBOT1RFOiBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzM1XG4vLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIwXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItaXNtYXBcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2EnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5ocmVmID0gJyN2b2lkJztcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8aW1nIGlzbWFwIHNyYz1cIicgKyBfZ2lmMi5kZWZhdWx0ICsgJ1wiIGFsdD1cIlwiPic7XG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcignaW1nJyk7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWltZy1pc21hcC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2lmID0gcmVxdWlyZSgnLi9tZWRpYS9naWYnKTtcblxudmFyIF9naWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2lmKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gTk9URTogaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8zNVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLXVzZW1hcFxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBlbGVtZW50OiAnZGl2JyxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxtYXAgbmFtZT1cImltYWdlLW1hcC10YWJpbmRleC10ZXN0XCI+PGFyZWEgaHJlZj1cIiN2b2lkXCIgc2hhcGU9XCJyZWN0XCIgY29vcmRzPVwiNjMsMTksMTQ0LDQ1XCI+PC9tYXA+JyArICc8aW1nIHVzZW1hcD1cIiNpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiIHRhYmluZGV4PVwiLTFcIiBhbHQ9XCJcIiAnICsgJ3NyYz1cIicgKyBfZ2lmMi5kZWZhdWx0ICsgJ1wiPic7XG5cbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtaW1nLXVzZW1hcC10YWJpbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6IGZ1bmN0aW9uIGVsZW1lbnQod3JhcHBlciwgX2RvY3VtZW50KSB7XG4gICAgdmFyIGlmcmFtZSA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblxuICAgIC8vIGlmcmFtZSBtdXN0IGJlIHBhcnQgb2YgdGhlIERPTSBiZWZvcmUgYWNjZXNzaW5nIHRoZSBjb250ZW50V2luZG93IGlzIHBvc3NpYmxlXG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBpZnJhbWUncyBkZWZhdWx0IGRvY3VtZW50ICg8aHRtbD48aGVhZD48L2hlYWQ+PGJvZHk+PC9ib2R5PjwvaHRtbD4pXG4gICAgdmFyIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICAgIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gICAgcmV0dXJuIGlmcmFtZTtcbiAgfSxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoaWZyYW1lKSB7XG4gICAgaWZyYW1lLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuICAgIHZhciBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICAgIHZhciBpbnB1dCA9IGlmcmFtZURvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgaWZyYW1lRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9LFxuICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoaWZyYW1lKSB7XG4gICAgdmFyIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgdmFyIGZvY3VzID0gaWZyYW1lRG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZm9jdXM7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWluLWhpZGRlbi1pZnJhbWUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xuXG52YXIgX3BsYXRmb3JtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BsYXRmb3JtKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHJlc3VsdCA9ICFfcGxhdGZvcm0yLmRlZmF1bHQuaXMuV0VCS0lUO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWluLXplcm8tZGltZW5zaW9uLW9iamVjdC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbi8vIEZpcmVmb3ggYWxsb3dzICphbnkqIHZhbHVlIGFuZCB0cmVhdHMgaW52YWxpZCB2YWx1ZXMgbGlrZSB0YWJpbmRleD1cIi0xXCJcbi8vIEBicm93c2VyLWlzc3VlIEdlY2tvIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMjgwNTRcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2RpdicsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnaW52YWxpZC12YWx1ZScpO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1pbnZhbGlkLXRhYmluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2xhYmVsJyxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICB9LFxuICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xuICAgIC8vIGZvcmNlIGxheW91dCBpbiBDaHJvbWUgNDksIG90aGVyd2lzZSB0aGUgZWxlbWVudCB3b24ndCBiZSBmb2N1c2FibGVcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgIHZhciB2YXJpYWJsZVRvUHJldmVudERlYWRDb2RlRWxpbWluYXRpb24gPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgZWxlbWVudC5mb2N1cygpO1xuICAgIHJldHVybiBfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWxlbWVudDtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtbGFiZWwtdGFiaW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3N2ZyA9IHJlcXVpcmUoJy4vbWVkaWEvc3ZnJyk7XG5cbnZhciBfc3ZnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N2Zyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIE5vdGU6IElFMTAgb24gQnJvd3NlclN0YWNrIGRvZXMgbm90IGxpa2UgdGhpcyB0ZXN0XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ29iamVjdCcsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndHlwZScsICdpbWFnZS9zdmcreG1sJyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEnLCBfc3ZnMi5kZWZhdWx0KTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMjAwJyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICc1MCcpO1xuICAgIGVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1vYmplY3Qtc3ZnLWhpZGRlbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc3ZnID0gcmVxdWlyZSgnLi9tZWRpYS9zdmcnKTtcblxudmFyIF9zdmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ZnKTtcblxudmFyIF9wbGF0Zm9ybSA9IHJlcXVpcmUoJy4uL3V0aWwvcGxhdGZvcm0nKTtcblxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIE5vdGU6IElFMTAgb24gQnJvd3NlclN0YWNrIGRvZXMgbm90IGxpa2UgdGhpcyB0ZXN0XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ2Nhbi1mb2N1cy1vYmplY3Qtc3ZnJyxcbiAgZWxlbWVudDogJ29iamVjdCcsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndHlwZScsICdpbWFnZS9zdmcreG1sJyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEnLCBfc3ZnMi5kZWZhdWx0KTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMjAwJyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICc1MCcpO1xuICB9LFxuICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xuICAgIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuR0VDS08pIHtcbiAgICAgIC8vIEZpcmVmb3ggc2VlbXMgdG8gYmUgaGFuZGxpbmcgdGhlIG9iamVjdCBjcmVhdGlvbiBhc3luY2hyb25vdXNseSBhbmQgdGhlcmVieSBwcm9kdWNlcyBhIGZhbHNlIG5lZ2F0aXZlIHRlc3QgcmVzdWx0LlxuICAgICAgLy8gQmVjYXVzZSB3ZSBrbm93IEZpcmVmb3ggaXMgYWJsZSB0byBmb2N1cyBvYmplY3QgZWxlbWVudHMgcmVmZXJlbmNpbmcgU1ZHcywgd2Ugc2ltcGx5IGNoZWF0IGJ5IHNuaWZmaW5nIHRoZSB1c2VyIGFnZW50IHN0cmluZ1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbGVtZW50O1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1vYmplY3Qtc3ZnLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIF9wbGF0Zm9ybSA9IHJlcXVpcmUoJy4uL3V0aWwvcGxhdGZvcm0nKTtcblxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIEV2ZXJ5IEVudmlyb25tZW50IGV4Y2VwdCBJRTkgY29uc2lkZXJzIFNXRiBvYmplY3RzIGZvY3VzYWJsZVxudmFyIHJlc3VsdCA9ICFfcGxhdGZvcm0yLmRlZmF1bHQuaXMuSUU5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLW9iamVjdC1zd2YuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dpZiA9IHJlcXVpcmUoJy4vbWVkaWEvZ2lmJyk7XG5cbnZhciBfZ2lmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dpZik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2RpdicsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8bWFwIG5hbWU9XCJmb2N1cy1yZWRpcmVjdC1pbWctdXNlbWFwXCI+PGFyZWEgaHJlZj1cIiN2b2lkXCIgc2hhcGU9XCJyZWN0XCIgY29vcmRzPVwiNjMsMTksMTQ0LDQ1XCI+PC9tYXA+JyArICc8aW1nIHVzZW1hcD1cIiNmb2N1cy1yZWRpcmVjdC1pbWctdXNlbWFwXCIgYWx0PVwiXCIgJyArICdzcmM9XCInICsgX2dpZjIuZGVmYXVsdCArICdcIj4nO1xuXG4gICAgLy8gZm9jdXMgdGhlIDxpbWc+LCBub3QgdGhlIDxkaXY+XG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcignaW1nJyk7XG4gIH0sXG4gIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShlbGVtZW50LCBmb2N1c1RhcmdldCwgX2RvY3VtZW50KSB7XG4gICAgdmFyIHRhcmdldCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignYXJlYScpO1xuICAgIHJldHVybiBfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGFyZ2V0O1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1yZWRpcmVjdC1pbWctdXNlbWFwLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuLy8gc2VlIGh0dHBzOi8vanNiaW4uY29tL25lbmlyaXNhZ2UvZWRpdD9odG1sLGpzLGNvbnNvbGUsb3V0cHV0XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2ZpZWxkc2V0JyxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxsZWdlbmQ+bGVnZW5kPC9sZWdlbmQ+PGlucHV0IHRhYmluZGV4PVwiLTFcIj48aW5wdXQgdGFiaW5kZXg9XCIwXCI+JztcbiAgICAvLyB0YWtlIGNhcmUgb2YgZm9jdXMgaW4gdmFsaWRhdGUoKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShlbGVtZW50LCBmb2N1c1RhcmdldCwgX2RvY3VtZW50KSB7XG4gICAgdmFyIGZvY3VzYWJsZSA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbdGFiaW5kZXg9XCItMVwiXScpO1xuICAgIHZhciB0YWJiYWJsZSA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbdGFiaW5kZXg9XCIwXCJdJyk7XG5cbiAgICAvLyBGaXJlZm94IHJlcXVpcmVzIHRoaXMgdGVzdCB0byBmb2N1cyB0aGUgPGZpZWxkc2V0PiBmaXJzdCwgd2hpbGUgdGhpcyBpcyBub3QgbmVjZXNzYXJ5IGluXG4gICAgLy8gaHR0cHM6Ly9qc2Jpbi5jb20vbmVuaXJpc2FnZS9lZGl0P2h0bWwsanMsY29uc29sZSxvdXRwdXRcbiAgICBlbGVtZW50LmZvY3VzKCk7XG5cbiAgICBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xlZ2VuZCcpLmZvY3VzKCk7XG4gICAgcmV0dXJuIF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmb2N1c2FibGUgJiYgJ2ZvY3VzYWJsZScgfHwgX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRhYmJhYmxlICYmICd0YWJiYWJsZScgfHwgJyc7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXJlZGlyZWN0LWxlZ2VuZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMjFcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2RpdicsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnd2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7IG92ZXJmbG93OiBhdXRvOycpO1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxkaXYgc3R5bGU9XCJ3aWR0aDogNTAwcHg7IGhlaWdodDogNDBweDtcIj5zY3JvbGxhYmxlIGNvbnRlbnQ8L2Rpdj4nO1xuICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1zY3JvbGwtYm9keS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMjFcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2RpdicsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnd2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7Jyk7XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPGRpdiBzdHlsZT1cIndpZHRoOiA1MDBweDsgaGVpZ2h0OiA0MHB4O1wiPnNjcm9sbGFibGUgY29udGVudDwvZGl2Pic7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXNjcm9sbC1jb250YWluZXItd2l0aG91dC1vdmVyZmxvdy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMjFcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2RpdicsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnd2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7IG92ZXJmbG93OiBhdXRvOycpO1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxkaXYgc3R5bGU9XCJ3aWR0aDogNTAwcHg7IGhlaWdodDogNDBweDtcIj5zY3JvbGxhYmxlIGNvbnRlbnQ8L2Rpdj4nO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1zY3JvbGwtY29udGFpbmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2RldGFpbHMnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPHN1bW1hcnk+Zm9vPC9zdW1tYXJ5PjxwPmNvbnRlbnQ8L3A+JztcbiAgICByZXR1cm4gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc3VtbWFyeS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc3ZnID0gcmVxdWlyZSgnLi9oZWxwZXIvc3ZnJyk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2RpdicsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICgwLCBfc3ZnLmdlbmVyYXRlKSgnPHRleHQgZm9jdXNhYmxlPVwidHJ1ZVwiPmE8L3RleHQ+Jyk7XG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGV4dCcpO1xuICB9LFxuICB2YWxpZGF0ZTogX3N2Zy52YWxpZGF0ZVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc3ZnLWZvY3VzYWJsZS1hdHRyaWJ1dGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3N2ZyA9IHJlcXVpcmUoJy4vaGVscGVyL3N2ZycpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdkaXYnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAoMCwgX3N2Zy5nZW5lcmF0ZSkoJzxmb3JlaWduT2JqZWN0IHRhYmluZGV4PVwiLTFcIj48aW5wdXQgdHlwZT1cInRleHRcIiAvPjwvZm9yZWlnbk9iamVjdD4nKTtcbiAgICAvLyBTYWZhcmkgOCdzIHF1ZXJzU2VsZWN0b3IoKSBjYW4ndCBpZGVudGlmeSBmb3JlaWduT2JqZWN0LCBidXQgZ2V0RWxlbWVudHlCeVRhZ05hbWUoKSBjYW5cbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdmb3JlaWduT2JqZWN0JykgfHwgZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZm9yZWlnbk9iamVjdCcpWzBdO1xuICB9LFxuICB2YWxpZGF0ZTogX3N2Zy52YWxpZGF0ZVxuXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1zdmctZm9yZWlnbm9iamVjdC10YWJpbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBfcGxhdGZvcm0gPSByZXF1aXJlKCcuLi91dGlsL3BsYXRmb3JtJyk7XG5cbnZhciBfcGxhdGZvcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxhdGZvcm0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBGaXJlZm94IHNlZW1zIHRvIGJlIGhhbmRsaW5nIHRoZSBTVkctZG9jdW1lbnQtaW4taWZyYW1lIGNyZWF0aW9uIGFzeW5jaHJvbm91c2x5XG4vLyBhbmQgdGhlcmVieSBwcm9kdWNlcyBhIGZhbHNlIG5lZ2F0aXZlIHRlc3QgcmVzdWx0LiBUaHVzIHRoZSB0ZXN0IGlzIHBvaW50bGVzc1xuLy8gYW5kIHdlIHJlc29ydCB0byBVQSBzbmlmZmluZyBvbmNlIGFnYWluLlxuLy8gc2VlIGh0dHA6Ly9qc2Jpbi5jb20vdnVuYWRvaG9rby8xL2VkaXQ/anMsY29uc29sZSxvdXRwdXRcblxudmFyIHJlc3VsdCA9IEJvb2xlYW4oX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkdFQ0tPICYmIHR5cGVvZiBTVkdFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBTVkdFbGVtZW50LnByb3RvdHlwZS5mb2N1cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc3ZnLWluLWlmcmFtZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc3ZnID0gcmVxdWlyZSgnLi9oZWxwZXIvc3ZnJyk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2RpdicsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICgwLCBfc3ZnLmdlbmVyYXRlKSgnPHRleHQgdGFiaW5kZXg9XCItMVwiPmE8L3RleHQ+Jyk7XG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGV4dCcpO1xuICB9LFxuICB2YWxpZGF0ZTogX3N2Zy52YWxpZGF0ZVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc3ZnLW5lZ2F0aXZlLXRhYmluZGV4LWF0dHJpYnV0ZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc3ZnID0gcmVxdWlyZSgnLi9oZWxwZXIvc3ZnJyk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2RpdicsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICgwLCBfc3ZnLmdlbmVyYXRlKSgnPHRleHQgdGFiaW5kZXg9XCIwXCI+YTwvdGV4dD4nKTtcbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0ZXh0Jyk7XG4gIH0sXG4gIHZhbGlkYXRlOiBfc3ZnLnZhbGlkYXRlXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1zdmctdGFiaW5kZXgtYXR0cmlidXRlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9zdmcgPSByZXF1aXJlKCcuL2hlbHBlci9zdmcnKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBlbGVtZW50OiAnZGl2JyxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gKDAsIF9zdmcuZ2VuZXJhdGUpKFsnPGcgaWQ9XCJhbGx5LXRlc3QtdGFyZ2V0XCI+PGEgeGxpbms6aHJlZj1cIiN2b2lkXCI+PHRleHQ+bGluazwvdGV4dD48L2E+PC9nPicsICc8dXNlIHhsaW5rOmhyZWY9XCIjYWxseS10ZXN0LXRhcmdldFwiIHg9XCIwXCIgeT1cIjBcIiB0YWJpbmRleD1cIi0xXCIgLz4nXS5qb2luKCcnKSk7XG5cbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCd1c2UnKTtcbiAgfSxcbiAgdmFsaWRhdGU6IF9zdmcudmFsaWRhdGVcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXN2Zy11c2UtdGFiaW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3N2ZyA9IHJlcXVpcmUoJy4vaGVscGVyL3N2ZycpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdkaXYnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAoMCwgX3N2Zy5nZW5lcmF0ZSkoJycpO1xuICAgIHJldHVybiBlbGVtZW50LmZpcnN0Q2hpbGQ7XG4gIH0sXG4gIHZhbGlkYXRlOiBfc3ZnLnZhbGlkYXRlXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1zdmcuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG4vLyBGaXJlZm94IGFsbG93cyAqYW55KiB2YWx1ZSBhbmQgdHJlYXRzIGludmFsaWQgdmFsdWVzIGxpa2UgdGFiaW5kZXg9XCItMVwiXG4vLyBAYnJvd3Nlci1pc3N1ZSBHZWNrbyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTI4MDU0XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdkaXYnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzN4Jyk7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXRhYmluZGV4LXRyYWlsaW5nLWNoYXJhY3RlcnMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBlbGVtZW50OiAndGFibGUnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50LCB3cmFwcGVyLCBfZG9jdW1lbnQpIHtcbiAgICAvLyBJRTkgaGFzIGEgcHJvYmxlbSByZXBsYWNpbmcgVEJPRFkgY29udGVudHMgd2l0aCBpbm5lckhUTUwuXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzgwOTcwNTUvNTE1MTI0XG4gICAgLy8gZWxlbWVudC5pbm5lckhUTUwgPSAnPHRyPjx0ZD5jZWxsPC90ZD48L3RyPic7XG4gICAgdmFyIGZyYWdtZW50ID0gX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBmcmFnbWVudC5pbm5lckhUTUwgPSAnPHRyPjx0ZD5jZWxsPC90ZD48L3RyPic7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXRhYmxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tcCA9IHJlcXVpcmUoJy4vbWVkaWEvbXA0Jyk7XG5cbnZhciBfbXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbXApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICd2aWRlbycsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgLy8gaW52YWxpZCBtZWRpYSBmaWxlIGNhbiB0cmlnZ2VyIHdhcm5pbmcgaW4gY29uc29sZSwgZGF0YS11cmkgdG8gcHJldmVudCBIVFRQIHJlcXVlc3RcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcmMnLCBfbXAyLmRlZmF1bHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFOSBtYXkgdGhyb3cgXCJFcnJvcjogTm90IGltcGxlbWVudGVkXCJcbiAgICB9XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXZpZGVvLXdpdGhvdXQtY29udHJvbHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlO1xuZXhwb3J0cy5mb2N1cyA9IGZvY3VzO1xuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuXG52YXIgX2ZvY3VzID0gcmVxdWlyZSgnLi4vLi4vZWxlbWVudC9mb2N1cy5zdmctZm9yZWlnbi1vYmplY3QtaGFjaycpO1xuXG52YXIgX2ZvY3VzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2VuZXJhdGUoZWxlbWVudCkge1xuICByZXR1cm4gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiPicgKyBlbGVtZW50ICsgJzwvc3ZnPic7XG59XG5cbmZ1bmN0aW9uIGZvY3VzKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQuZm9jdXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cnkge1xuICAgIEhUTUxFbGVtZW50LnByb3RvdHlwZS5mb2N1cy5jYWxsKGVsZW1lbnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgKDAsIF9mb2N1czIuZGVmYXVsdCkoZWxlbWVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xuICBmb2N1cyhmb2N1c1RhcmdldCk7XG4gIHJldHVybiBfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZm9jdXNUYXJnZXQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdmcuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8vWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWic7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdpZi5pbnZhbGlkLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFBQUFBUC8vL3lINUJBRUFBQUFBTEFBQUFBQUJBQUVBQUFJQlJBQTcnO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1naWYuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dpZiA9IHJlcXVpcmUoJy4vZ2lmJyk7XG5cbnZhciBfZ2lmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dpZik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9naWYyLmRlZmF1bHQ7XG4vLyBleHBvcnQgZGVmYXVsdCAnZGF0YTphdWRpby9tcDM7YmFzZTY0LGF1ZGlvLWZvY3VzLXRlc3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1wMy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2lmID0gcmVxdWlyZSgnLi9naWYnKTtcblxudmFyIF9naWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2lmKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX2dpZjIuZGVmYXVsdDtcbi8vIGV4cG9ydCBkZWZhdWx0ICdkYXRhOnZpZGVvL21wNDtiYXNlNjQsdmlkZW8tZm9jdXMtdGVzdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXA0LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9ICdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGh0YicgKyAnRzV6T25oc2FXNXJQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUwzaHNhVzVySWlCcFpEMGljM1puSWo0OGRHVjRkQ0I0UFNJeE1DSWdlVDBpTWpBaUlHbGtQU0onICsgJ3pkbWN0YkdsdWF5MTBaWGgwSWo1MFpYaDBQQzkwWlhoMFBqd3ZjM1puUGc9PSc7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN2Zy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdmVyc2lvbiA9IHJlcXVpcmUoJy4uL3ZlcnNpb24nKTtcblxudmFyIF92ZXJzaW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZlcnNpb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiByZWFkTG9jYWxTdG9yYWdlKGtleSkge1xuICAvLyBhbGxvdyByZWFkaW5nIGZyb20gc3RvcmFnZSB0byByZXRyaWV2ZSBwcmV2aW91cyBzdXBwb3J0IHJlc3VsdHNcbiAgLy8gZXZlbiB3aGlsZSB0aGUgZG9jdW1lbnQgZG9lcyBub3QgaGF2ZSBmb2N1c1xuICB2YXIgZGF0YSA9IHZvaWQgMDtcblxuICB0cnkge1xuICAgIGRhdGEgPSB3aW5kb3cubG9jYWxTdG9yYWdlICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIGRhdGEgPSBkYXRhID8gSlNPTi5wYXJzZShkYXRhKSA6IHt9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGF0YSA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59IC8qXG4gICAgICBGYWNpbGl0eSB0byBjYWNoZSB0ZXN0IHJlc3VsdHMgaW4gbG9jYWxTdG9yYWdlLlxuICBcbiAgICAgIFVTQUdFOlxuICAgICAgICBjYWNoZS5nZXQoJ2tleScpO1xuICAgICAgICBjYWNoZS5zZXQoJ2tleScsICd2YWx1ZScpO1xuICAgKi9cblxuZnVuY3Rpb24gd3JpdGVMb2NhbFN0b3JhZ2Uoa2V5LCB2YWx1ZSkge1xuICBpZiAoIWRvY3VtZW50Lmhhc0ZvY3VzKCkpIHtcbiAgICAvLyBpZiB0aGUgZG9jdW1lbnQgZG9lcyBub3QgaGF2ZSBmb2N1cyB3aGVuIHRlc3RzIGFyZSBleGVjdXRlZCwgZm9jdXMoKSBtYXlcbiAgICAvLyBub3QgYmUgaGFuZGxlZCBwcm9wZXJseSBhbmQgZXZlbnRzIG1heSBub3QgYmUgZGlzcGF0Y2hlZCBpbW1lZGlhdGVseS5cbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGRvY3VtZW50IGlzIHJlbG9hZGVkIHdoaWxlIERldmVsb3BlciBUb29scyBoYXZlIGZvY3VzLlxuICAgIHRyeSB7XG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlnbm9yZVxuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgd2luZG93LmxvY2FsU3RvcmFnZSAmJiB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaWdub3JlXG4gIH1cbn1cblxudmFyIHVzZXJBZ2VudCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xudmFyIGNhY2hlS2V5ID0gJ2FsbHktc3VwcG9ydHMtY2FjaGUnO1xudmFyIGNhY2hlID0gcmVhZExvY2FsU3RvcmFnZShjYWNoZUtleSk7XG5cbi8vIHVwZGF0ZSB0aGUgY2FjaGUgaWYgYWxseSBvciB0aGUgdXNlciBhZ2VudCBjaGFuZ2VkIChuZXdlciB2ZXJzaW9uLCBldGMpXG5pZiAoY2FjaGUudXNlckFnZW50ICE9PSB1c2VyQWdlbnQgfHwgY2FjaGUudmVyc2lvbiAhPT0gX3ZlcnNpb24yLmRlZmF1bHQpIHtcbiAgY2FjaGUgPSB7fTtcbn1cblxuY2FjaGUudXNlckFnZW50ID0gdXNlckFnZW50O1xuY2FjaGUudmVyc2lvbiA9IF92ZXJzaW9uMi5kZWZhdWx0O1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBjYWNoZTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWVzKSB7XG4gICAgT2JqZWN0LmtleXModmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGNhY2hlW2tleV0gPSB2YWx1ZXNba2V5XTtcbiAgICB9KTtcblxuICAgIGNhY2hlLnRpbWUgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgd3JpdGVMb2NhbFN0b3JhZ2UoY2FjaGVLZXksIGNhY2hlKTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3VwcG9ydHMtY2FjaGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChzdXBwb3J0c0NhY2hlKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRzQ2FjaGU7XG4gIH1cblxuICBzdXBwb3J0c0NhY2hlID0gX3N1cHBvcnRzQ2FjaGUyLmRlZmF1bHQuZ2V0KCk7XG4gIGlmICghc3VwcG9ydHNDYWNoZS50aW1lKSB7XG4gICAgX3N1cHBvcnRzQ2FjaGUyLmRlZmF1bHQuc2V0KGV4ZWN1dGVUZXN0cygpKTtcbiAgICBzdXBwb3J0c0NhY2hlID0gX3N1cHBvcnRzQ2FjaGUyLmRlZmF1bHQuZ2V0KCk7XG4gIH1cblxuICByZXR1cm4gc3VwcG9ydHNDYWNoZTtcbn07XG5cbnZhciBfZGV0ZWN0Rm9jdXMgPSByZXF1aXJlKCcuL2RldGVjdC1mb2N1cycpO1xuXG52YXIgX2RldGVjdEZvY3VzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RldGVjdEZvY3VzKTtcblxudmFyIF9zdXBwb3J0c0NhY2hlID0gcmVxdWlyZSgnLi9zdXBwb3J0cy1jYWNoZScpO1xuXG52YXIgX3N1cHBvcnRzQ2FjaGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydHNDYWNoZSk7XG5cbnZhciBfY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvciA9IHJlcXVpcmUoJy4vY3NzLXNoYWRvdy1waWVyY2luZy1kZWVwLWNvbWJpbmF0b3InKTtcblxudmFyIF9jc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IpO1xuXG52YXIgX2ZvY3VzQXJlYUltZ1RhYmluZGV4ID0gcmVxdWlyZSgnLi9mb2N1cy1hcmVhLWltZy10YWJpbmRleCcpO1xuXG52YXIgX2ZvY3VzQXJlYUltZ1RhYmluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzQXJlYUltZ1RhYmluZGV4KTtcblxudmFyIF9mb2N1c0FyZWFUYWJpbmRleCA9IHJlcXVpcmUoJy4vZm9jdXMtYXJlYS10YWJpbmRleCcpO1xuXG52YXIgX2ZvY3VzQXJlYVRhYmluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzQXJlYVRhYmluZGV4KTtcblxudmFyIF9mb2N1c0FyZWFXaXRob3V0SHJlZiA9IHJlcXVpcmUoJy4vZm9jdXMtYXJlYS13aXRob3V0LWhyZWYnKTtcblxudmFyIF9mb2N1c0FyZWFXaXRob3V0SHJlZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0FyZWFXaXRob3V0SHJlZik7XG5cbnZhciBfZm9jdXNBdWRpb1dpdGhvdXRDb250cm9scyA9IHJlcXVpcmUoJy4vZm9jdXMtYXVkaW8td2l0aG91dC1jb250cm9scycpO1xuXG52YXIgX2ZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNBdWRpb1dpdGhvdXRDb250cm9scyk7XG5cbnZhciBfZm9jdXNCcm9rZW5JbWFnZU1hcCA9IHJlcXVpcmUoJy4vZm9jdXMtYnJva2VuLWltYWdlLW1hcCcpO1xuXG52YXIgX2ZvY3VzQnJva2VuSW1hZ2VNYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNCcm9rZW5JbWFnZU1hcCk7XG5cbnZhciBfZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveCA9IHJlcXVpcmUoJy4vZm9jdXMtY2hpbGRyZW4tb2YtZm9jdXNhYmxlLWZsZXhib3gnKTtcblxudmFyIF9mb2N1c0NoaWxkcmVuT2ZGb2N1c2FibGVGbGV4Ym94MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzQ2hpbGRyZW5PZkZvY3VzYWJsZUZsZXhib3gpO1xuXG52YXIgX2ZvY3VzRmllbGRzZXREaXNhYmxlZCA9IHJlcXVpcmUoJy4vZm9jdXMtZmllbGRzZXQtZGlzYWJsZWQnKTtcblxudmFyIF9mb2N1c0ZpZWxkc2V0RGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNGaWVsZHNldERpc2FibGVkKTtcblxudmFyIF9mb2N1c0ZpZWxkc2V0ID0gcmVxdWlyZSgnLi9mb2N1cy1maWVsZHNldCcpO1xuXG52YXIgX2ZvY3VzRmllbGRzZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNGaWVsZHNldCk7XG5cbnZhciBfZm9jdXNGbGV4Ym94Q29udGFpbmVyID0gcmVxdWlyZSgnLi9mb2N1cy1mbGV4Ym94LWNvbnRhaW5lcicpO1xuXG52YXIgX2ZvY3VzRmxleGJveENvbnRhaW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0ZsZXhib3hDb250YWluZXIpO1xuXG52YXIgX2ZvY3VzRm9ybURpc2FibGVkID0gcmVxdWlyZSgnLi9mb2N1cy1mb3JtLWRpc2FibGVkJyk7XG5cbnZhciBfZm9jdXNGb3JtRGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNGb3JtRGlzYWJsZWQpO1xuXG52YXIgX2ZvY3VzSW1nSXNtYXAgPSByZXF1aXJlKCcuL2ZvY3VzLWltZy1pc21hcCcpO1xuXG52YXIgX2ZvY3VzSW1nSXNtYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNJbWdJc21hcCk7XG5cbnZhciBfZm9jdXNJbWdVc2VtYXBUYWJpbmRleCA9IHJlcXVpcmUoJy4vZm9jdXMtaW1nLXVzZW1hcC10YWJpbmRleCcpO1xuXG52YXIgX2ZvY3VzSW1nVXNlbWFwVGFiaW5kZXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNJbWdVc2VtYXBUYWJpbmRleCk7XG5cbnZhciBfZm9jdXNJbkhpZGRlbklmcmFtZSA9IHJlcXVpcmUoJy4vZm9jdXMtaW4taGlkZGVuLWlmcmFtZScpO1xuXG52YXIgX2ZvY3VzSW5IaWRkZW5JZnJhbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNJbkhpZGRlbklmcmFtZSk7XG5cbnZhciBfZm9jdXNJblplcm9EaW1lbnNpb25PYmplY3QgPSByZXF1aXJlKCcuL2ZvY3VzLWluLXplcm8tZGltZW5zaW9uLW9iamVjdCcpO1xuXG52YXIgX2ZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0KTtcblxudmFyIF9mb2N1c0ludmFsaWRUYWJpbmRleCA9IHJlcXVpcmUoJy4vZm9jdXMtaW52YWxpZC10YWJpbmRleCcpO1xuXG52YXIgX2ZvY3VzSW52YWxpZFRhYmluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzSW52YWxpZFRhYmluZGV4KTtcblxudmFyIF9mb2N1c0xhYmVsVGFiaW5kZXggPSByZXF1aXJlKCcuL2ZvY3VzLWxhYmVsLXRhYmluZGV4Jyk7XG5cbnZhciBfZm9jdXNMYWJlbFRhYmluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzTGFiZWxUYWJpbmRleCk7XG5cbnZhciBfZm9jdXNPYmplY3RTdmdIaWRkZW4gPSByZXF1aXJlKCcuL2ZvY3VzLW9iamVjdC1zdmctaGlkZGVuJyk7XG5cbnZhciBfZm9jdXNPYmplY3RTdmdIaWRkZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNPYmplY3RTdmdIaWRkZW4pO1xuXG52YXIgX2ZvY3VzT2JqZWN0U3ZnID0gcmVxdWlyZSgnLi9mb2N1cy1vYmplY3Qtc3ZnJyk7XG5cbnZhciBfZm9jdXNPYmplY3RTdmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNPYmplY3RTdmcpO1xuXG52YXIgX2ZvY3VzT2JqZWN0U3dmID0gcmVxdWlyZSgnLi9mb2N1cy1vYmplY3Qtc3dmJyk7XG5cbnZhciBfZm9jdXNPYmplY3RTd2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNPYmplY3RTd2YpO1xuXG52YXIgX2ZvY3VzUmVkaXJlY3RJbWdVc2VtYXAgPSByZXF1aXJlKCcuL2ZvY3VzLXJlZGlyZWN0LWltZy11c2VtYXAnKTtcblxudmFyIF9mb2N1c1JlZGlyZWN0SW1nVXNlbWFwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzUmVkaXJlY3RJbWdVc2VtYXApO1xuXG52YXIgX2ZvY3VzUmVkaXJlY3RMZWdlbmQgPSByZXF1aXJlKCcuL2ZvY3VzLXJlZGlyZWN0LWxlZ2VuZCcpO1xuXG52YXIgX2ZvY3VzUmVkaXJlY3RMZWdlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNSZWRpcmVjdExlZ2VuZCk7XG5cbnZhciBfZm9jdXNTY3JvbGxCb2R5ID0gcmVxdWlyZSgnLi9mb2N1cy1zY3JvbGwtYm9keScpO1xuXG52YXIgX2ZvY3VzU2Nyb2xsQm9keTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1Njcm9sbEJvZHkpO1xuXG52YXIgX2ZvY3VzU2Nyb2xsQ29udGFpbmVyV2l0aG91dE92ZXJmbG93ID0gcmVxdWlyZSgnLi9mb2N1cy1zY3JvbGwtY29udGFpbmVyLXdpdGhvdXQtb3ZlcmZsb3cnKTtcblxudmFyIF9mb2N1c1Njcm9sbENvbnRhaW5lcldpdGhvdXRPdmVyZmxvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1Njcm9sbENvbnRhaW5lcldpdGhvdXRPdmVyZmxvdyk7XG5cbnZhciBfZm9jdXNTY3JvbGxDb250YWluZXIgPSByZXF1aXJlKCcuL2ZvY3VzLXNjcm9sbC1jb250YWluZXInKTtcblxudmFyIF9mb2N1c1Njcm9sbENvbnRhaW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1Njcm9sbENvbnRhaW5lcik7XG5cbnZhciBfZm9jdXNTdW1tYXJ5ID0gcmVxdWlyZSgnLi9mb2N1cy1zdW1tYXJ5Jyk7XG5cbnZhciBfZm9jdXNTdW1tYXJ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzU3VtbWFyeSk7XG5cbnZhciBfZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL2ZvY3VzLXN2Zy1mb2N1c2FibGUtYXR0cmlidXRlJyk7XG5cbnZhciBfZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUpO1xuXG52YXIgX2ZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL2ZvY3VzLXN2Zy10YWJpbmRleC1hdHRyaWJ1dGUnKTtcblxudmFyIF9mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUpO1xuXG52YXIgX2ZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vZm9jdXMtc3ZnLW5lZ2F0aXZlLXRhYmluZGV4LWF0dHJpYnV0ZScpO1xuXG52YXIgX2ZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N2Z05lZ2F0aXZlVGFiaW5kZXhBdHRyaWJ1dGUpO1xuXG52YXIgX2ZvY3VzU3ZnVXNlVGFiaW5kZXggPSByZXF1aXJlKCcuL2ZvY3VzLXN2Zy11c2UtdGFiaW5kZXgnKTtcblxudmFyIF9mb2N1c1N2Z1VzZVRhYmluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzU3ZnVXNlVGFiaW5kZXgpO1xuXG52YXIgX2ZvY3VzU3ZnRm9yZWlnbm9iamVjdFRhYmluZGV4ID0gcmVxdWlyZSgnLi9mb2N1cy1zdmctZm9yZWlnbm9iamVjdC10YWJpbmRleCcpO1xuXG52YXIgX2ZvY3VzU3ZnRm9yZWlnbm9iamVjdFRhYmluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzU3ZnRm9yZWlnbm9iamVjdFRhYmluZGV4KTtcblxudmFyIF9mb2N1c1N2Z0luSWZyYW1lID0gcmVxdWlyZSgnLi9mb2N1cy1zdmctaW4taWZyYW1lJyk7XG5cbnZhciBfZm9jdXNTdmdJbklmcmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N2Z0luSWZyYW1lKTtcblxudmFyIF9mb2N1c1N2ZyA9IHJlcXVpcmUoJy4vZm9jdXMtc3ZnJyk7XG5cbnZhciBfZm9jdXNTdmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNTdmcpO1xuXG52YXIgX2ZvY3VzVGFiaW5kZXhUcmFpbGluZ0NoYXJhY3RlcnMgPSByZXF1aXJlKCcuL2ZvY3VzLXRhYmluZGV4LXRyYWlsaW5nLWNoYXJhY3RlcnMnKTtcblxudmFyIF9mb2N1c1RhYmluZGV4VHJhaWxpbmdDaGFyYWN0ZXJzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzVGFiaW5kZXhUcmFpbGluZ0NoYXJhY3RlcnMpO1xuXG52YXIgX2ZvY3VzVGFibGUgPSByZXF1aXJlKCcuL2ZvY3VzLXRhYmxlJyk7XG5cbnZhciBfZm9jdXNUYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1RhYmxlKTtcblxudmFyIF9mb2N1c1ZpZGVvV2l0aG91dENvbnRyb2xzID0gcmVxdWlyZSgnLi9mb2N1cy12aWRlby13aXRob3V0LWNvbnRyb2xzJyk7XG5cbnZhciBfZm9jdXNWaWRlb1dpdGhvdXRDb250cm9sczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1ZpZGVvV2l0aG91dENvbnRyb2xzKTtcblxudmFyIF90YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9uID0gcmVxdWlyZSgnLi90YWJzZXF1ZW5jZS1hcmVhLWF0LWltZy1wb3NpdGlvbicpO1xuXG52YXIgX3RhYnNlcXVlbmNlQXJlYUF0SW1nUG9zaXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB0ZXN0Q2FsbGJhY2tzID0ge1xuICBjc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yOiBfY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvcjIuZGVmYXVsdCxcbiAgZm9jdXNJblplcm9EaW1lbnNpb25PYmplY3Q6IF9mb2N1c0luWmVyb0RpbWVuc2lvbk9iamVjdDIuZGVmYXVsdCxcbiAgZm9jdXNPYmplY3RTd2Y6IF9mb2N1c09iamVjdFN3ZjIuZGVmYXVsdCxcbiAgZm9jdXNTdmdJbklmcmFtZTogX2ZvY3VzU3ZnSW5JZnJhbWUyLmRlZmF1bHQsXG4gIHRhYnNlcXVlbmNlQXJlYUF0SW1nUG9zaXRpb246IF90YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9uMi5kZWZhdWx0XG59O1xuXG52YXIgdGVzdERlc2NyaXB0aW9ucyA9IHtcbiAgZm9jdXNBcmVhSW1nVGFiaW5kZXg6IF9mb2N1c0FyZWFJbWdUYWJpbmRleDIuZGVmYXVsdCxcbiAgZm9jdXNBcmVhVGFiaW5kZXg6IF9mb2N1c0FyZWFUYWJpbmRleDIuZGVmYXVsdCxcbiAgZm9jdXNBcmVhV2l0aG91dEhyZWY6IF9mb2N1c0FyZWFXaXRob3V0SHJlZjIuZGVmYXVsdCxcbiAgZm9jdXNBdWRpb1dpdGhvdXRDb250cm9sczogX2ZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMyLmRlZmF1bHQsXG4gIGZvY3VzQnJva2VuSW1hZ2VNYXA6IF9mb2N1c0Jyb2tlbkltYWdlTWFwMi5kZWZhdWx0LFxuICBmb2N1c0NoaWxkcmVuT2ZGb2N1c2FibGVGbGV4Ym94OiBfZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveDIuZGVmYXVsdCxcbiAgZm9jdXNGaWVsZHNldERpc2FibGVkOiBfZm9jdXNGaWVsZHNldERpc2FibGVkMi5kZWZhdWx0LFxuICBmb2N1c0ZpZWxkc2V0OiBfZm9jdXNGaWVsZHNldDIuZGVmYXVsdCxcbiAgZm9jdXNGbGV4Ym94Q29udGFpbmVyOiBfZm9jdXNGbGV4Ym94Q29udGFpbmVyMi5kZWZhdWx0LFxuICBmb2N1c0Zvcm1EaXNhYmxlZDogX2ZvY3VzRm9ybURpc2FibGVkMi5kZWZhdWx0LFxuICBmb2N1c0ltZ0lzbWFwOiBfZm9jdXNJbWdJc21hcDIuZGVmYXVsdCxcbiAgZm9jdXNJbWdVc2VtYXBUYWJpbmRleDogX2ZvY3VzSW1nVXNlbWFwVGFiaW5kZXgyLmRlZmF1bHQsXG4gIGZvY3VzSW5IaWRkZW5JZnJhbWU6IF9mb2N1c0luSGlkZGVuSWZyYW1lMi5kZWZhdWx0LFxuICBmb2N1c0ludmFsaWRUYWJpbmRleDogX2ZvY3VzSW52YWxpZFRhYmluZGV4Mi5kZWZhdWx0LFxuICBmb2N1c0xhYmVsVGFiaW5kZXg6IF9mb2N1c0xhYmVsVGFiaW5kZXgyLmRlZmF1bHQsXG4gIGZvY3VzT2JqZWN0U3ZnOiBfZm9jdXNPYmplY3RTdmcyLmRlZmF1bHQsXG4gIGZvY3VzT2JqZWN0U3ZnSGlkZGVuOiBfZm9jdXNPYmplY3RTdmdIaWRkZW4yLmRlZmF1bHQsXG4gIGZvY3VzUmVkaXJlY3RJbWdVc2VtYXA6IF9mb2N1c1JlZGlyZWN0SW1nVXNlbWFwMi5kZWZhdWx0LFxuICBmb2N1c1JlZGlyZWN0TGVnZW5kOiBfZm9jdXNSZWRpcmVjdExlZ2VuZDIuZGVmYXVsdCxcbiAgZm9jdXNTY3JvbGxCb2R5OiBfZm9jdXNTY3JvbGxCb2R5Mi5kZWZhdWx0LFxuICBmb2N1c1Njcm9sbENvbnRhaW5lcldpdGhvdXRPdmVyZmxvdzogX2ZvY3VzU2Nyb2xsQ29udGFpbmVyV2l0aG91dE92ZXJmbG93Mi5kZWZhdWx0LFxuICBmb2N1c1Njcm9sbENvbnRhaW5lcjogX2ZvY3VzU2Nyb2xsQ29udGFpbmVyMi5kZWZhdWx0LFxuICBmb2N1c1N1bW1hcnk6IF9mb2N1c1N1bW1hcnkyLmRlZmF1bHQsXG4gIGZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlOiBfZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUyLmRlZmF1bHQsXG4gIGZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGU6IF9mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlMi5kZWZhdWx0LFxuICBmb2N1c1N2Z05lZ2F0aXZlVGFiaW5kZXhBdHRyaWJ1dGU6IF9mb2N1c1N2Z05lZ2F0aXZlVGFiaW5kZXhBdHRyaWJ1dGUyLmRlZmF1bHQsXG4gIGZvY3VzU3ZnVXNlVGFiaW5kZXg6IF9mb2N1c1N2Z1VzZVRhYmluZGV4Mi5kZWZhdWx0LFxuICBmb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleDogX2ZvY3VzU3ZnRm9yZWlnbm9iamVjdFRhYmluZGV4Mi5kZWZhdWx0LFxuICBmb2N1c1N2ZzogX2ZvY3VzU3ZnMi5kZWZhdWx0LFxuICBmb2N1c1RhYmluZGV4VHJhaWxpbmdDaGFyYWN0ZXJzOiBfZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVyczIuZGVmYXVsdCxcbiAgZm9jdXNUYWJsZTogX2ZvY3VzVGFibGUyLmRlZmF1bHQsXG4gIGZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHM6IF9mb2N1c1ZpZGVvV2l0aG91dENvbnRyb2xzMi5kZWZhdWx0XG59O1xuXG5mdW5jdGlvbiBleGVjdXRlVGVzdHMoKSB7XG4gIHZhciByZXN1bHRzID0gKDAsIF9kZXRlY3RGb2N1czIuZGVmYXVsdCkodGVzdERlc2NyaXB0aW9ucyk7XG4gIE9iamVjdC5rZXlzKHRlc3RDYWxsYmFja3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJlc3VsdHNba2V5XSA9IHRlc3RDYWxsYmFja3Nba2V5XSgpO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxudmFyIHN1cHBvcnRzQ2FjaGUgPSBudWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1cHBvcnRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIF9wbGF0Zm9ybSA9IHJlcXVpcmUoJy4uL3V0aWwvcGxhdGZvcm0nKTtcblxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIGh0dHBzOi8vanNiaW4uY29tL3ZhZmFiYS8zL2VkaXQ/aHRtbCxqcyxjb25zb2xlLG91dHB1dFxudmFyIHJlc3VsdCA9IF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5HRUNLTyB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuVFJJREVOVCB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuRURHRTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJzZXF1ZW5jZS1hcmVhLWF0LWltZy1wb3NpdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZpbmRJbmRleDtcbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgY2FsbGJhY2spIHtcbiAgLy8gYXR0ZW1wdCB0byB1c2UgbmF0aXZlIG9yIHBvbHlmaWxsZWQgQXJyYXkjZmluZEluZGV4IGZpcnN0XG4gIGlmIChhcnJheS5maW5kSW5kZXgpIHtcbiAgICByZXR1cm4gYXJyYXkuZmluZEluZGV4KGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgLy8gc2hvcnRjdXQgaWYgdGhlIGFycmF5IGlzIGVtcHR5XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvLyBvdGhlcndpc2UgbG9vcCBvdmVyIGFycmF5XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY2FsbGJhY2soYXJyYXlbaV0sIGksIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5LWZpbmQtaW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRQYXJlbnRDb21wYXJhdG9yID0gZ2V0UGFyZW50Q29tcGFyYXRvcjtcblxuLy8gTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiBpcyBhdmFpbGFibGUgc2luY2UgSUU5XG4vLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb25cblxuLy8gY2FsbGJhY2sgcmV0dXJucyB0cnVlIHdoZW4gZWxlbWVudCBpcyBjb250YWluZWQgYnkgcGFyZW50IG9yIGlzIHRoZSBwYXJlbnQgc3VpdGVkIGZvciB1c2Ugd2l0aCBBcnJheS5zb21lKClcbi8qXG4gIFVTQUdFOlxuICAgIHZhciBpc0NoaWxkT2YgPSBnZXRQYXJlbnRDb21wYXJhdG9yKHtwYXJlbnQ6IHNvbWVOb2RlfSk7XG4gICAgbGlzdE9mRWxlbWVudHMuc29tZShpc0NoaWxkT2YpXG4qL1xuXG5mdW5jdGlvbiBnZXRQYXJlbnRDb21wYXJhdG9yKCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBwYXJlbnQgPSBfcmVmLnBhcmVudCxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBpbmNsdWRlU2VsZiA9IF9yZWYuaW5jbHVkZVNlbGY7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc0NoaWxkT2Yobm9kZSkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4oaW5jbHVkZVNlbGYgJiYgbm9kZSA9PT0gcGFyZW50IHx8IHBhcmVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2RlKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNQYXJlbnRPZihub2RlKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihpbmNsdWRlU2VsZiAmJiBlbGVtZW50ID09PSBub2RlIHx8IG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudCkgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSk7XG4gICAgfTtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3V0aWwvY29tcGFyZS1wb3NpdGlvbiNnZXRQYXJlbnRDb21wYXJhdG9yIHJlcXVpcmVkIGVpdGhlciBvcHRpb25zLnBhcmVudCBvciBvcHRpb25zLmVsZW1lbnQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBhcmUtcG9zaXRpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgY29udGV4dCA9IF9yZWYuY29udGV4dCxcbiAgICAgIF9yZWYkbGFiZWwgPSBfcmVmLmxhYmVsLFxuICAgICAgbGFiZWwgPSBfcmVmJGxhYmVsID09PSB1bmRlZmluZWQgPyAnY29udGV4dC10by1lbGVtZW50JyA6IF9yZWYkbGFiZWwsXG4gICAgICByZXNvbHZlRG9jdW1lbnQgPSBfcmVmLnJlc29sdmVEb2N1bWVudCxcbiAgICAgIGRlZmF1bHRUb0RvY3VtZW50ID0gX3JlZi5kZWZhdWx0VG9Eb2N1bWVudDtcblxuICB2YXIgZWxlbWVudCA9ICgwLCBfbm9kZUFycmF5Mi5kZWZhdWx0KShjb250ZXh0KVswXTtcblxuICBpZiAocmVzb2x2ZURvY3VtZW50ICYmIGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgZWxlbWVudCA9IGVsZW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgaWYgKCFlbGVtZW50ICYmIGRlZmF1bHRUb0RvY3VtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIGlmICghZWxlbWVudCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IobGFiZWwgKyAnIHJlcXVpcmVzIHZhbGlkIG9wdGlvbnMuY29udGV4dCcpO1xuICB9XG5cbiAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGVsZW1lbnQubm9kZVR5cGUgIT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IobGFiZWwgKyAnIHJlcXVpcmVzIG9wdGlvbnMuY29udGV4dCB0byBiZSBhbiBFbGVtZW50Jyk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbnZhciBfbm9kZUFycmF5ID0gcmVxdWlyZSgnLi4vdXRpbC9ub2RlLWFycmF5Jyk7XG5cbnZhciBfbm9kZUFycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX25vZGVBcnJheSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGV4dC10by1lbGVtZW50LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGVsZW1lbnRNYXRjaGVzO1xuXG4vLyBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIG1heSBiZSBhdmFpbGFibGUgYXQgYSBkaWZmZXJlbnQgbmFtZVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0VsZW1lbnQvbWF0Y2hlc1xuXG52YXIgbmFtZXMgPSBbJ21hdGNoZXMnLCAnd2Via2l0TWF0Y2hlc1NlbGVjdG9yJywgJ21vek1hdGNoZXNTZWxlY3RvcicsICdtc01hdGNoZXNTZWxlY3RvciddO1xudmFyIG5hbWUgPSBudWxsO1xuXG5mdW5jdGlvbiBmaW5kTWV0aG9kTmFtZShlbGVtZW50KSB7XG4gIG5hbWVzLnNvbWUoZnVuY3Rpb24gKF9uYW1lKSB7XG4gICAgaWYgKCFlbGVtZW50W19uYW1lXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG5hbWUgPSBfbmFtZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gIGlmICghbmFtZSkge1xuICAgIGZpbmRNZXRob2ROYW1lKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRbbmFtZV0oc2VsZWN0b3IpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGVtZW50LW1hdGNoZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRyeSB7XG4gICAgLy8gd29ya3Mgb24gPG9iamVjdD4gYW5kIDxpZnJhbWU+XG4gICAgcmV0dXJuIG5vZGUuY29udGVudERvY3VtZW50XG4gICAgLy8gd29ya3Mgb24gPG9iamVjdD4gYW5kIDxpZnJhbWU+XG4gICAgfHwgbm9kZS5jb250ZW50V2luZG93ICYmIG5vZGUuY29udGVudFdpbmRvdy5kb2N1bWVudFxuICAgIC8vIHdvcmtzIG9uIDxvYmplY3Q+IGFuZCA8aWZyYW1lPiB0aGF0IGNvbnRhaW4gU1ZHXG4gICAgfHwgbm9kZS5nZXRTVkdEb2N1bWVudCAmJiBub2RlLmdldFNWR0RvY3VtZW50KCkgfHwgbnVsbDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFNlY3VyaXR5RXJyb3I6IEZhaWxlZCB0byByZWFkIHRoZSAnY29udGVudERvY3VtZW50JyBwcm9wZXJ0eSBmcm9tICdIVE1MT2JqZWN0RWxlbWVudCdcbiAgICAvLyBhbHNvIElFIG1heSB0aHJvdyBtZW1iZXIgbm90IGZvdW5kIGV4Y2VwdGlvbiBlLmcuIG9uIDxvYmplY3QgdHlwZT1cImltYWdlL3BuZ1wiPlxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWNvbnRlbnQtZG9jdW1lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBkb2N1bWVudDtcbiAgfVxuXG4gIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWRvY3VtZW50LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGdldEZyYW1lRWxlbWVudDtcblxudmFyIF9nZXRDb250ZW50RG9jdW1lbnQgPSByZXF1aXJlKCcuL2dldC1jb250ZW50LWRvY3VtZW50Jyk7XG5cbnZhciBfZ2V0Q29udGVudERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldENvbnRlbnREb2N1bWVudCk7XG5cbnZhciBfZ2V0V2luZG93ID0gcmVxdWlyZSgnLi9nZXQtd2luZG93Jyk7XG5cbnZhciBfZ2V0V2luZG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFdpbmRvdyk7XG5cbnZhciBfc2VsZWN0SW5TaGFkb3dzID0gcmVxdWlyZSgnLi9zZWxlY3QtaW4tc2hhZG93cycpO1xuXG52YXIgX3NlbGVjdEluU2hhZG93czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZWxlY3RJblNoYWRvd3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgc2VsZWN0b3IgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIGZpbmREb2N1bWVudEhvc3RFbGVtZW50KF93aW5kb3cpIHtcbiAgaWYgKCFzZWxlY3Rvcikge1xuICAgIHNlbGVjdG9yID0gKDAsIF9zZWxlY3RJblNoYWRvd3MyLmRlZmF1bHQpKCdvYmplY3QsIGlmcmFtZScpO1xuICB9XG5cbiAgaWYgKF93aW5kb3cuX2ZyYW1lRWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIF93aW5kb3cuX2ZyYW1lRWxlbWVudDtcbiAgfVxuXG4gIF93aW5kb3cuX2ZyYW1lRWxlbWVudCA9IG51bGw7XG5cbiAgdmFyIHBvdGVudGlhbEhvc3RzID0gX3dpbmRvdy5wYXJlbnQuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIFtdLnNvbWUuY2FsbChwb3RlbnRpYWxIb3N0cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB2YXIgX2RvY3VtZW50ID0gKDAsIF9nZXRDb250ZW50RG9jdW1lbnQyLmRlZmF1bHQpKGVsZW1lbnQpO1xuICAgIGlmIChfZG9jdW1lbnQgIT09IF93aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBfd2luZG93Ll9mcmFtZUVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gX3dpbmRvdy5fZnJhbWVFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRGcmFtZUVsZW1lbnQoZWxlbWVudCkge1xuICB2YXIgX3dpbmRvdyA9ICgwLCBfZ2V0V2luZG93Mi5kZWZhdWx0KShlbGVtZW50KTtcbiAgaWYgKCFfd2luZG93LnBhcmVudCB8fCBfd2luZG93LnBhcmVudCA9PT0gX3dpbmRvdykge1xuICAgIC8vIGlmIHRoZXJlIGlzIG5vIHBhcmVudCBicm93c2luZyBjb250ZXh0LFxuICAgIC8vIHdlJ3JlIG5vdCBnb2luZyB0byBnZXQgYSBmcmFtZUVsZW1lbnQgZWl0aGVyIHdheVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9mcmFtZUVsZW1lbnRcbiAgICAvLyBkb2VzIG5vdCB3b3JrIHdpdGhpbiA8ZW1iZWQ+IGFueXdoZXJlLCBhbmQgbm90IHdpdGhpbiBpbiA8b2JqZWN0PiBpbiBJRVxuICAgIHJldHVybiBfd2luZG93LmZyYW1lRWxlbWVudCB8fCBmaW5kRG9jdW1lbnRIb3N0RWxlbWVudChfd2luZG93KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1mcmFtZS1lbGVtZW50LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIF9kb2N1bWVudCA9ICgwLCBfZ2V0RG9jdW1lbnQyLmRlZmF1bHQpKG5vZGUpO1xuICByZXR1cm4gX2RvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbn07XG5cbnZhciBfZ2V0RG9jdW1lbnQgPSByZXF1aXJlKCcuL2dldC1kb2N1bWVudCcpO1xuXG52YXIgX2dldERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldERvY3VtZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtd2luZG93LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0TWFwQnlOYW1lID0gZ2V0TWFwQnlOYW1lO1xuZXhwb3J0cy5nZXRNYXBPZkltYWdlID0gZ2V0TWFwT2ZJbWFnZTtcbmV4cG9ydHMuZ2V0SW1hZ2VPZkFyZWEgPSBnZXRJbWFnZU9mQXJlYTtcblxudmFyIF9jc3MgPSByZXF1aXJlKCdjc3MuZXNjYXBlJyk7XG5cbnZhciBfY3NzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nzcyk7XG5cbnZhciBfZ2V0RG9jdW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2dldC1kb2N1bWVudCcpO1xuXG52YXIgX2dldERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldERvY3VtZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0TWFwQnlOYW1lKG5hbWUsIF9kb2N1bWVudCkge1xuICAvLyBhcHBhcmVudGx5IGdldEVsZW1lbnRzQnlOYW1lKCkgYWxzbyBjb25zaWRlcnMgaWQgYXR0cmlidXRlIGluIElFICYgb3BlcmFcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2dldEVsZW1lbnRzQnlOYW1lXG4gIHZhciBtYXAgPSBfZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWFwW25hbWU9XCInICsgKDAsIF9jc3MyLmRlZmF1bHQpKG5hbWUpICsgJ1wiXScpO1xuICByZXR1cm4gbWFwIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldE1hcE9mSW1hZ2UoZWxlbWVudCkge1xuICB2YXIgdXNlbWFwID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3VzZW1hcCcpO1xuICBpZiAoIXVzZW1hcCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIF9kb2N1bWVudCA9ICgwLCBfZ2V0RG9jdW1lbnQyLmRlZmF1bHQpKGVsZW1lbnQpO1xuICByZXR1cm4gZ2V0TWFwQnlOYW1lKHVzZW1hcC5zbGljZSgxKSwgX2RvY3VtZW50KTtcbn1cblxuZnVuY3Rpb24gZ2V0SW1hZ2VPZkFyZWEoZWxlbWVudCkge1xuICB2YXIgbWFwID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXG4gIGlmICghbWFwLm5hbWUgfHwgbWFwLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdtYXAnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOT1RFOiBpbWFnZSBtYXBzIGNhbiBhbHNvIGJlIGFwcGxpZWQgdG8gPG9iamVjdD4gd2l0aCBpbWFnZSBjb250ZW50LFxuICAvLyBidXQgbm8gYnJvd3NlciBzdXBwb3J0cyB0aGlzIGF0IHRoZSBtb21lbnRcblxuICAvLyBIVE1MNSBzcGVjaWZpZXMgSFRNTE1hcEVsZW1lbnQuaW1hZ2VzIHRvIGJlIGFuIEhUTUxDb2xsZWN0aW9uIG9mIGFsbFxuICAvLyA8aW1nPiBhbmQgPG9iamVjdD4gcmVmZXJlbmNpbmcgdGhlIDxtYXA+IGVsZW1lbnQsIGJ1dCBubyBicm93c2VyIGltcGxlbWVudHMgdGhpc1xuICAvLyAgIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCN0aGUtbWFwLWVsZW1lbnRcbiAgLy8gICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1hcEVsZW1lbnRcbiAgLy8gdGhlIGltYWdlIG11c3QgYmUgdmFsaWQgYW5kIGxvYWRlZCBmb3IgdGhlIG1hcCB0byB0YWtlIGVmZmVjdFxuICB2YXIgX2RvY3VtZW50ID0gKDAsIF9nZXREb2N1bWVudDIuZGVmYXVsdCkoZWxlbWVudCk7XG4gIHJldHVybiBfZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW1nW3VzZW1hcD1cIiMnICsgKDAsIF9jc3MyLmRlZmF1bHQpKG1hcC5uYW1lKSArICdcIl0nKSB8fCBudWxsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtbWFwLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG52YXIgX2NvbnNvbGUgPSB7XG4gIGxvZzogbm9vcCxcbiAgZGVidWc6IG5vb3AsXG4gIGluZm86IG5vb3AsXG4gIHdhcm46IG5vb3AsXG4gIGVycm9yOiBub29wXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgPyBjb25zb2xlIDogX2NvbnNvbGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgbGlzdCA9IF9yZWYubGlzdCxcbiAgICAgIGVsZW1lbnRzID0gX3JlZi5lbGVtZW50cyxcbiAgICAgIHJlc29sdmVFbGVtZW50ID0gX3JlZi5yZXNvbHZlRWxlbWVudDtcblxuICAvLyBvcGVyYXRlIG9uIGEgY29weSBzbyB3ZSBkb24ndCBtdXRhdGUgdGhlIG9yaWdpbmFsIGFycmF5XG4gIHZhciBfbGlzdCA9IGxpc3Quc2xpY2UoMCk7XG4gIC8vIG1ha2Ugc3VyZSB0aGUgZWxlbWVudHMgd2UncmUgaW5qZWN0aW5nIGFyZSBwcm92aWRlZCBpbiBET00gb3JkZXJcbiAgdmFyIF9lbGVtZW50cyA9ICgwLCBfbm9kZUFycmF5Mi5kZWZhdWx0KShlbGVtZW50cykuc2xpY2UoMCk7XG4gICgwLCBfc29ydERvbU9yZGVyMi5kZWZhdWx0KShfZWxlbWVudHMpO1xuICAvLyBmaW5kIHRoZSBvZmZzZXRzIHdpdGhpbiB0aGUgdGFyZ2V0IGFycmF5IChsaXN0KSBhdCB3aGljaCB0byBpbmplY3RcbiAgLy8gZWFjaCBpbmRpdmlkdWFsIGVsZW1lbnQgKGZyb20gZWxlbWVudHMpXG4gIHZhciBpbnNlcnRpb25zID0gZmluZEluc2VydGlvbk9mZnNldHMoX2xpc3QsIF9lbGVtZW50cywgcmVzb2x2ZUVsZW1lbnQpO1xuICAvLyBhY3R1YWxseSBpbmplY3QgdGhlIGVsZW1lbnRzIGludG8gdGhlIHRhcmdldCBhcnJheSBhdCB0aGUgaWRlbnRpZmllZCBwb3NpdGlvbnNcbiAgaW5zZXJ0RWxlbWVudHNBdE9mZnNldHMoX2xpc3QsIGluc2VydGlvbnMpO1xuICByZXR1cm4gX2xpc3Q7XG59O1xuXG52YXIgX2FycmF5RmluZEluZGV4ID0gcmVxdWlyZSgnLi4vdXRpbC9hcnJheS1maW5kLWluZGV4Jyk7XG5cbnZhciBfYXJyYXlGaW5kSW5kZXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXJyYXlGaW5kSW5kZXgpO1xuXG52YXIgX25vZGVBcnJheSA9IHJlcXVpcmUoJy4vbm9kZS1hcnJheScpO1xuXG52YXIgX25vZGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub2RlQXJyYXkpO1xuXG52YXIgX3NvcnREb21PcmRlciA9IHJlcXVpcmUoJy4vc29ydC1kb20tb3JkZXInKTtcblxudmFyIF9zb3J0RG9tT3JkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc29ydERvbU9yZGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0Rmlyc3RTdWNjZXNzb3JPZmZzZXQobGlzdCwgdGFyZ2V0KSB7XG4gIC8vIGZpbmQgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBjb21lcyBBRlRFUiB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgcmV0dXJuICgwLCBfYXJyYXlGaW5kSW5kZXgyLmRlZmF1bHQpKGxpc3QsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRhcmdldC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50KSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICB9KTtcbn1cbi8vIHNvcnQgYSBsaXN0IG9mIGVsZW1lbnRzIGludG8gYW5vdGhlciBsaXN0IG9mIGVsZW1lbnRzIGluIERPTSBvcmRlclxuXG4vKlxuICBVU0FHRTpcbiAgICBtZXJnZURvbU9yZGVyKHtcbiAgICAgIC8vIERPTSBvcmRlcmVkIGFycmF5IG9mIGVsZW1lbnRzIHRvIHVzZSBhcyBiYXNlIG9mIG1lcmdlXG4gICAgICBsaXN0OiBbXSxcbiAgICAgIC8vIHVub3JkZXJlZCBhcnJheSBvZiBlbGVtZW50cyB0byBtZXJnZSBpbnRvIGJhc2UgbGlzdFxuICAgICAgZWxlbWVudHM6IFtdLFxuICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb24gdG8gcmVzb2x2ZSBhbiBlbGVtZW50XG4gICAgICByZXNvbHZlRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAvLyByZXR1cm4gbnVsbCB0byBza2lwXG4gICAgICAgIC8vIHJldHVybiBlbGVtZW50IHRvIHJlcGxhY2UgaW5zZXJ0aW9uXG4gICAgICAgIC8vIHJldHVybiBbZWxlbWVudDEsIGVsZW1lbnQyLCDigKZdIHRvIHJlcGxhY2UgaW5zZXJ0aW9uIHdpdGggbXVsdGlwbGUgZWxlbWVudHNcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9LFxuICAgIH0pXG4qL1xuXG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uT2Zmc2V0cyhsaXN0LCBlbGVtZW50cywgcmVzb2x2ZUVsZW1lbnQpIHtcbiAgLy8gaW5zdGVhZCBvZiBtdXRhdGluZyB0aGUgZWxlbWVudHMgbGlzdCBkaXJlY3RseSwgcmVtZW1iZXIgcG9zaXRpb24gYW5kIG1hcFxuICAvLyB0byBpbmplY3QgbGF0ZXIsIHdoZW4gd2UgY2FuIGRvIHRoaXMgbW9yZSBlZmZpY2llbnRseVxuICB2YXIgaW5zZXJ0aW9ucyA9IFtdO1xuICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIHJlcGxhY2UgPSB0cnVlO1xuICAgIHZhciBvZmZzZXQgPSBsaXN0LmluZGV4T2YoZWxlbWVudCk7XG5cbiAgICBpZiAob2Zmc2V0ID09PSAtMSkge1xuICAgICAgLy8gZWxlbWVudCBpcyBub3QgaW4gdGFyZ2V0IGxpc3RcbiAgICAgIG9mZnNldCA9IGdldEZpcnN0U3VjY2Vzc29yT2Zmc2V0KGxpc3QsIGVsZW1lbnQpO1xuICAgICAgcmVwbGFjZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPT09IC0xKSB7XG4gICAgICAvLyB0aGVyZSBpcyBubyBzdWNjZXNzb3IgaW4gdGhlIHRhYnNlcXVlbmNlLFxuICAgICAgLy8gbWVhbmluZyB0aGUgaW1hZ2UgbXVzdCBiZSB0aGUgbGFzdCBlbGVtZW50XG4gICAgICBvZmZzZXQgPSBsaXN0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyB0aGUgY29uc3VtZXIgdG8gcmVwbGFjZSB0aGUgaW5qZWN0ZWQgZWxlbWVudFxuICAgIHZhciBpbmplY3Rpb25zID0gKDAsIF9ub2RlQXJyYXkyLmRlZmF1bHQpKHJlc29sdmVFbGVtZW50ID8gcmVzb2x2ZUVsZW1lbnQoZWxlbWVudCkgOiBlbGVtZW50KTtcbiAgICBpZiAoIWluamVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAvLyB3ZSBjYW4ndCBpbmplY3QgemVybyBlbGVtZW50c1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluc2VydGlvbnMucHVzaCh7XG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgICBlbGVtZW50czogaW5qZWN0aW9uc1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gaW5zZXJ0aW9ucztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0RWxlbWVudHNBdE9mZnNldHMobGlzdCwgaW5zZXJ0aW9ucykge1xuICAvLyByZW1lbWJlciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHdlIGhhdmUgYWxyZWFkeSBpbmplY3RlZFxuICAvLyBzbyB3ZSBhY2NvdW50IGZvciB0aGUgY2F1c2VkIGluZGV4IG9mZnNldFxuICB2YXIgaW5zZXJ0ZWQgPSAwO1xuICAvLyBtYWtlIHN1cmUgdGhhdCB3ZSBpbnNlcnQgdGhlIGVsZW1lbnRzIGluIHNlcXVlbmNlLFxuICAvLyBvdGhlcndpc2UgdGhlIG9mZnNldCBjb21wZW5zYXRpb24gd29uJ3Qgd29ya1xuICBpbnNlcnRpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5vZmZzZXQgLSBiLm9mZnNldDtcbiAgfSk7XG4gIGluc2VydGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW5zZXJ0aW9uKSB7XG4gICAgLy8gYXJyYXkuc3BsaWNlIGhhcyBhbiBhbm5veWluZyBmdW5jdGlvbiBzaWduYXR1cmUgOihcbiAgICB2YXIgcmVtb3ZlID0gaW5zZXJ0aW9uLnJlcGxhY2UgPyAxIDogMDtcbiAgICB2YXIgYXJncyA9IFtpbnNlcnRpb24ub2Zmc2V0ICsgaW5zZXJ0ZWQsIHJlbW92ZV0uY29uY2F0KGluc2VydGlvbi5lbGVtZW50cyk7XG4gICAgbGlzdC5zcGxpY2UuYXBwbHkobGlzdCwgYXJncyk7XG4gICAgaW5zZXJ0ZWQgKz0gaW5zZXJ0aW9uLmVsZW1lbnRzLmxlbmd0aCAtIHJlbW92ZTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2UtZG9tLW9yZGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIGlmICghaW5wdXQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICAvLyBpbnN0YW5jZW9mIE5vZGUgLSBkb2VzIG5vdCB3b3JrIHdpdGggaWZyYW1lc1xuICBpZiAoaW5wdXQubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbaW5wdXRdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICBpbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoaW5wdXQpO1xuICB9XG5cbiAgaWYgKGlucHV0Lmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoaW5wdXQsIDApO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5leHBlY3RlZCBpbnB1dCAnICsgU3RyaW5nKGlucHV0KSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIGlucHV0IG1heSBiZSB1bmRlZmluZWQsIHNlbGVjdG9yLXRyaW5nLCBOb2RlLCBOb2RlTGlzdCwgSFRNTENvbGxlY3Rpb24sIGFycmF5IG9mIE5vZGVzXG4vLyB5ZXMsIHRvIHNvbWUgZXh0ZW50IHRoaXMgaXMgYSBiYWQgcmVwbGljYSBvZiBqUXVlcnkncyBjb25zdHJ1Y3RvciBmdW5jdGlvblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9kZS1hcnJheS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcGxhdGZvcm0yID0gcmVxdWlyZSgncGxhdGZvcm0nKTtcblxudmFyIF9wbGF0Zm9ybTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBkZWVwIGNsb25lIG9mIG9yaWdpbmFsIHBsYXRmb3JtXG52YXIgcGxhdGZvcm0gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KF9wbGF0Zm9ybTMuZGVmYXVsdCkpO1xuXG4vLyBvcGVyYXRpbmcgc3lzdGVtXG5cbi8vIHN1Z2FyIGZvciBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvcGxhdGZvcm0uanNcbi8vIG1ha2Ugc3VyZSB0byBBTFdBWVMgcmVmZXJlbmNlIHRoZSBsYXlvdXQgZW5naW5lLFxuLy8gZXZlbiBpZiBpdCBpcyBub3QgbmVjZXNzYXJ5IGZvciB0aGUgY29uZGl0aW9uLFxuLy8gYXMgdGhpcyBtYWtlcyBncmVwcGluZyBmb3IgdGhpcyBzdHVmZiBzaW1wbGVyXG5cbnZhciBvcyA9IHBsYXRmb3JtLm9zLmZhbWlseSB8fCAnJztcbnZhciBBTkRST0lEID0gb3MgPT09ICdBbmRyb2lkJztcbnZhciBXSU5ET1dTID0gb3Muc2xpY2UoMCwgNykgPT09ICdXaW5kb3dzJztcbnZhciBPU1ggPSBvcyA9PT0gJ09TIFgnO1xudmFyIElPUyA9IG9zID09PSAnaU9TJztcblxuLy8gbGF5b3V0XG52YXIgQkxJTksgPSBwbGF0Zm9ybS5sYXlvdXQgPT09ICdCbGluayc7XG52YXIgR0VDS08gPSBwbGF0Zm9ybS5sYXlvdXQgPT09ICdHZWNrbyc7XG52YXIgVFJJREVOVCA9IHBsYXRmb3JtLmxheW91dCA9PT0gJ1RyaWRlbnQnO1xudmFyIEVER0UgPSBwbGF0Zm9ybS5sYXlvdXQgPT09ICdFZGdlSFRNTCc7XG52YXIgV0VCS0lUID0gcGxhdGZvcm0ubGF5b3V0ID09PSAnV2ViS2l0JztcblxuLy8gYnJvd3NlciB2ZXJzaW9uIChub3QgbGF5b3V0IGVuZ2luZSB2ZXJzaW9uISlcbnZhciB2ZXJzaW9uID0gcGFyc2VGbG9hdChwbGF0Zm9ybS52ZXJzaW9uKTtcbnZhciBtYWpvclZlcnNpb24gPSBNYXRoLmZsb29yKHZlcnNpb24pO1xucGxhdGZvcm0ubWFqb3JWZXJzaW9uID0gbWFqb3JWZXJzaW9uO1xuXG5wbGF0Zm9ybS5pcyA9IHtcbiAgLy8gb3BlcmF0aW5nIHN5c3RlbVxuICBBTkRST0lEOiBBTkRST0lELFxuICBXSU5ET1dTOiBXSU5ET1dTLFxuICBPU1g6IE9TWCxcbiAgSU9TOiBJT1MsXG4gIC8vIGxheW91dFxuICBCTElOSzogQkxJTkssIC8vIFwiQ2hyb21lXCIsIFwiQ2hyb21lIE1vYmlsZVwiLCBcIk9wZXJhXCJcbiAgR0VDS086IEdFQ0tPLCAvLyBcIkZpcmVmb3hcIlxuICBUUklERU5UOiBUUklERU5ULCAvLyBcIkludGVybmV0IEV4cGxvcmVyXCJcbiAgRURHRTogRURHRSwgLy8gXCJNaWNyb3NvZnQgRWRnZVwiXG4gIFdFQktJVDogV0VCS0lULCAvLyBcIlNhZmFyaVwiXG4gIC8vIElOVEVSTkVUIEVYUExPUkVSU1xuICBJRTk6IFRSSURFTlQgJiYgbWFqb3JWZXJzaW9uID09PSA5LFxuICBJRTEwOiBUUklERU5UICYmIG1ham9yVmVyc2lvbiA9PT0gMTAsXG4gIElFMTE6IFRSSURFTlQgJiYgbWFqb3JWZXJzaW9uID09PSAxMVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gcGxhdGZvcm07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsYXRmb3JtLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIGlmICh0eXBlb2Ygc2hhZG93UHJlZml4ICE9PSAnc3RyaW5nJykge1xuICAgIHZhciBvcGVyYXRvciA9ICgwLCBfY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvcjIuZGVmYXVsdCkoKTtcbiAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgIHNoYWRvd1ByZWZpeCA9ICcsIGh0bWwgJyArIG9wZXJhdG9yICsgJyAnO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2hhZG93UHJlZml4KSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdG9yICsgc2hhZG93UHJlZml4ICsgc2VsZWN0b3IucmVwbGFjZSgvXFxzKixcXHMqL2csICcsJykuc3BsaXQoJywnKS5qb2luKHNoYWRvd1ByZWZpeCk7XG59O1xuXG52YXIgX2Nzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IgPSByZXF1aXJlKCcuLi9zdXBwb3J0cy9jc3Mtc2hhZG93LXBpZXJjaW5nLWRlZXAtY29tYmluYXRvcicpO1xuXG52YXIgX2Nzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBzaGFkb3dQcmVmaXggPSB2b2lkIDA7XG4vLyBjb252ZXJ0IGEgQ1NTIHNlbGVjdG9yIHNvIHRoYXQgaXQgYWxzbyBwaWVyY2VzIFNoYWRvd0RPTVxuLy8gdGFrZXMgXCIuYSwgI2JcIiBhbmQgdHVybnMgaXQgaW50byBcIi5hLCAjYiwgaHRtbCA+Pj4gLmEsIGh0bWwgPj4+ICNiXCJcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3QtaW4tc2hhZG93cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGVsZW1lbnRzKSB7XG4gIHJldHVybiBlbGVtZW50cy5zb3J0KGNvbXBhcmVEb21Qb3NpdGlvbik7XG59O1xuXG4vLyBzb3J0cyBhIGxpc3Qgb2YgZWxlbWVudHMgYWNjb3JkaW5nIHRvIHRoZWlyIG9yZGVyIGluIHRoZSBET01cblxuZnVuY3Rpb24gY29tcGFyZURvbVBvc2l0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyA/IC0xIDogMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnQtZG9tLW9yZGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgaWYgKCEoMCwgX3ZhbGlkVGFiaW5kZXgyLmRlZmF1bHQpKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBFZGdlIDE0IGhhcyBhIGNhcGl0YWxpemF0aW9uIHByb2JsZW0gb24gU1ZHIGVsZW1lbnRzLFxuICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvOTI4MjA1OC9cbiAgdmFyIGhhc1RhYmluZGV4ID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gIHZhciBhdHRyaWJ1dGVOYW1lID0gaGFzVGFiaW5kZXggPyAndGFiaW5kZXgnIDogJ3RhYkluZGV4JztcblxuICAvLyBAYnJvd3Nlci1pc3N1ZSBHZWNrbyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTI4MDU0XG4gIHZhciB0YWJpbmRleCA9IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpLCAxMCk7XG4gIHJldHVybiBpc05hTih0YWJpbmRleCkgPyAtMSA6IHRhYmluZGV4O1xufTtcblxudmFyIF92YWxpZFRhYmluZGV4ID0gcmVxdWlyZSgnLi4vaXMvdmFsaWQtdGFiaW5kZXgnKTtcblxudmFyIF92YWxpZFRhYmluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZhbGlkVGFiaW5kZXgpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYmluZGV4LXZhbHVlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBhdHRyaWJ1dGUgPSBfcmVmLmF0dHJpYnV0ZSxcbiAgICAgIHRlbXBvcmFyeVZhbHVlID0gX3JlZi50ZW1wb3JhcnlWYWx1ZSxcbiAgICAgIHNhdmVWYWx1ZSA9IF9yZWYuc2F2ZVZhbHVlO1xuXG4gIHZhciB0ZW1wb3JhcnlBdHRyaWJ1dGUgPSAnZGF0YS1jYWNoZWQtJyArIGF0dHJpYnV0ZTtcblxuICBpZiAodGVtcG9yYXJ5VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBfdmFsdWUgPSBzYXZlVmFsdWUgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSh0ZW1wb3JhcnlBdHRyaWJ1dGUsIF92YWx1ZSB8fCAnJyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB0ZW1wb3JhcnlWYWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF92YWx1ZTIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSh0ZW1wb3JhcnlBdHRyaWJ1dGUpO1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHRlbXBvcmFyeUF0dHJpYnV0ZSk7XG4gICAgaWYgKF92YWx1ZTIgPT09ICcnKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIF92YWx1ZTIpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyBoZWxwZXIgdG8gdHVyblxuLy8gIDxkaXYgc29tZS1hdHRyaWJ1dGU9XCJvcmlnaW5hbFwiPlxuLy8gaW50b1xuLy8gIDxkaXYgc29tZS1hdHRyaWJ1dGU9XCJuZXdcIiBkYXRhLWNhY2hlZC1zb21lLWF0dHJpYnV0ZT1cIm9yaWdpbmFsXCI+XG4vLyBhbmQgYmFja1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9nZ2xlLWF0dHJpYnV0ZS12YWx1ZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxuICAgICAgYXR0cmlidXRlID0gX3JlZi5hdHRyaWJ1dGU7XG5cbiAgdmFyIHRlbXBvcmFyeUF0dHJpYnV0ZSA9ICdkYXRhLWNhY2hlZC0nICsgYXR0cmlidXRlO1xuICB2YXIgdGVtcG9yYXJ5QXR0cmlidXRlVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSh0ZW1wb3JhcnlBdHRyaWJ1dGUpO1xuXG4gIGlmICh0ZW1wb3JhcnlBdHRyaWJ1dGVWYWx1ZSA9PT0gbnVsbCkge1xuICAgIHZhciBfdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgIGlmIChfdmFsdWUgPT09IG51bGwpIHtcbiAgICAgIC8vIGNhbid0IHJlbW92ZSB3aGF0J3Mgbm90IHRoZXJlXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUodGVtcG9yYXJ5QXR0cmlidXRlLCBfdmFsdWUgfHwgJycpO1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF92YWx1ZTIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSh0ZW1wb3JhcnlBdHRyaWJ1dGUpO1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHRlbXBvcmFyeUF0dHJpYnV0ZSk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBfdmFsdWUyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyBoZWxwZXIgdG8gdHVyblxuLy8gIDxkaXYgc29tZS1hdHRyaWJ1dGU9XCJvcmlnaW5hbFwiPlxuLy8gaW50b1xuLy8gIDxkaXYgZGF0YS1jYWNoZWQtc29tZS1hdHRyaWJ1dGU9XCJvcmlnaW5hbFwiPlxuLy8gYW5kIGJhY2tcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvZ2dsZS1hdHRyaWJ1dGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG4vLyB0aGlzIGZpbGUgaXMgb3ZlcndyaXR0ZW4gYnkgYG5wbSBydW4gYnVpbGQ6cHJlYFxudmFyIHZlcnNpb24gPSAnMS40LjEnO1xuZXhwb3J0cy5kZWZhdWx0ID0gdmVyc2lvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uIChfdGV4dCkge1xuICAgIHZhciB0b2tlbnMgPSBfdGV4dC5zcGxpdCgnKycpO1xuICAgIHZhciBfbW9kaWZpZXJzID0gcmVzb2x2ZU1vZGlmaWVycyh0b2tlbnMuc2xpY2UoMCwgLTEpKTtcbiAgICB2YXIgX2tleUNvZGVzID0gcmVzb2x2ZUtleSh0b2tlbnMuc2xpY2UoLTEpKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5Q29kZXM6IF9rZXlDb2RlcyxcbiAgICAgIG1vZGlmaWVyczogX21vZGlmaWVycyxcbiAgICAgIG1hdGNoTW9kaWZpZXJzOiBtYXRjaE1vZGlmaWVycy5iaW5kKG51bGwsIF9tb2RpZmllcnMpXG4gICAgfTtcbiAgfSk7XG59O1xuXG52YXIgX2tleWNvZGUgPSByZXF1aXJlKCcuLi9tYXAva2V5Y29kZScpO1xuXG52YXIgX2tleWNvZGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5Y29kZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBtb2RpZmllciA9IHtcbiAgYWx0OiAnYWx0S2V5JyxcbiAgY3RybDogJ2N0cmxLZXknLFxuICBtZXRhOiAnbWV0YUtleScsXG4gIHNoaWZ0OiAnc2hpZnRLZXknXG59O1xuLypcbiAgZGVjb2RlcyBhIGtleSBiaW5kaW5nIHRva2VuIHRvIGEgSmF2YVNjcmlwdCBzdHJ1Y3R1cmVcblxuICByZXR1cm5zIGFuIGFycmF5IG9mIG9iamVjdHM6XG4gICAge1xuICAgICAgLy8ga2V5IG5hbWUgdHJhbnNsYXRlZCB0byBrZXlDb2RlIChwb3NzaWJseSBtb3JlIHRoYW4gb25lKVxuICAgICAga2V5Q29kZXM6IFs8bnVtYmVyPl0sXG4gICAgICAvLyB0cmFuc2xhdGVkIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgIGFsdEtleTogbnVsbCwgICAvLyBpZ25vcmVcbiAgICAgICAgY3RyS2V5OiBmYWxzZSwgIC8vIGV4cGVjdCBub3QgcHJlc3NlZFxuICAgICAgICBtZXRhS2V5OiB0cnVlLCAgLy8gZXhwZWN0IHByZXNzZWRcbiAgICAgICAgc2hpZnRLZXk6IHRydWUsIC8vIGV4cGVjdCBwcmVzc2VkXG4gICAgICB9LFxuICAgICAgLy8gY2FsbGJhY2sgdGhhdCByZXR1cm5zIHRydWUgaWYgZXZlbnQnc1xuICAgICAgLy8gbW9kaWZpZXIga2V5cyBtYXRjaCB0aGUgZXhwZWN0ZWQgc3RhdGVcbiAgICAgIG1hdGNoTW9kaWZpZXJzOiBmdW5jdGlvbihldmVudCl7fSxcbiAgICB9XG4qL1xuXG52YXIgbW9kaWZpZXJTZXF1ZW5jZSA9IE9iamVjdC5rZXlzKG1vZGlmaWVyKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG1vZGlmaWVyW25hbWVdO1xufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUV4cGVjdGVkTW9kaWZpZXJzKGlnbm9yZU1vZGlmaWVycykge1xuICB2YXIgdmFsdWUgPSBpZ25vcmVNb2RpZmllcnMgPyBudWxsIDogZmFsc2U7XG4gIHJldHVybiB7XG4gICAgYWx0S2V5OiB2YWx1ZSxcbiAgICBjdHJsS2V5OiB2YWx1ZSxcbiAgICBtZXRhS2V5OiB2YWx1ZSxcbiAgICBzaGlmdEtleTogdmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgdmFyIGlnbm9yZU1vZGlmaWVycyA9IG1vZGlmaWVycy5pbmRleE9mKCcqJykgIT09IC0xO1xuICB2YXIgZXhwZWN0ZWQgPSBjcmVhdGVFeHBlY3RlZE1vZGlmaWVycyhpZ25vcmVNb2RpZmllcnMpO1xuXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGlmICh0b2tlbiA9PT0gJyonKSB7XG4gICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGNvdmVyZWQgdGhlIGFsbC1pbiBvcGVyYXRvclxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHdlIHdhbnQgdGhlIG1vZGlmaWVyIHByZXNzZWRcbiAgICB2YXIgdmFsdWUgPSB0cnVlO1xuICAgIHZhciBvcGVyYXRvciA9IHRva2VuLnNsaWNlKDAsIDEpO1xuICAgIGlmIChvcGVyYXRvciA9PT0gJz8nKSB7XG4gICAgICAvLyB3ZSBkb24ndCBjYXJlIGlmIHRoZSBtb2RpZmllciBpcyBwcmVzc2VkXG4gICAgICB2YWx1ZSA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChvcGVyYXRvciA9PT0gJyEnKSB7XG4gICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0aGUgbW9kaWZpZXIgcHJlc3NlZFxuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgIC8vIGNvbXBlbnNhdGUgZm9yIHRoZSBtb2RpZmllcidzIG9wZXJhdG9yXG4gICAgICB0b2tlbiA9IHRva2VuLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBtb2RpZmllclt0b2tlbl07XG4gICAgaWYgKCFwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gbW9kaWZpZXIgXCInICsgdG9rZW4gKyAnXCInKTtcbiAgICB9XG5cbiAgICBleHBlY3RlZFtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gIH0pO1xuXG4gIHJldHVybiBleHBlY3RlZDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUtleShrZXkpIHtcbiAgdmFyIGNvZGUgPSBfa2V5Y29kZTIuZGVmYXVsdFtrZXldIHx8IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoIWNvZGUgfHwgdHlwZW9mIGNvZGUgIT09ICdudW1iZXInIHx8IGlzTmFOKGNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBrZXkgXCInICsga2V5ICsgJ1wiJyk7XG4gIH1cblxuICByZXR1cm4gW2NvZGVdLmNvbmNhdChfa2V5Y29kZTIuZGVmYXVsdC5fYWxpYXNbY29kZV0gfHwgW10pO1xufVxuXG5mdW5jdGlvbiBtYXRjaE1vZGlmaWVycyhleHBlY3RlZCwgZXZlbnQpIHtcbiAgLy8gcmV0dXJucyB0cnVlIG9uIG1hdGNoXG4gIHJldHVybiAhbW9kaWZpZXJTZXF1ZW5jZS5zb21lKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgLy8gcmV0dXJucyB0cnVlIG9uIG1pc21hdGNoXG4gICAgcmV0dXJuIHR5cGVvZiBleHBlY3RlZFtwcm9wXSA9PT0gJ2Jvb2xlYW4nICYmIEJvb2xlYW4oZXZlbnRbcHJvcF0pICE9PSBleHBlY3RlZFtwcm9wXTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5LmJpbmRpbmcuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtYXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIHZhciBiaW5kaW5ncyA9IHt9O1xuXG4gIHZhciBjb250ZXh0ID0gKDAsIF9ub2RlQXJyYXkyLmRlZmF1bHQpKG1hcC5jb250ZXh0KVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGRlbGV0ZSBtYXAuY29udGV4dDtcbiAgdmFyIGZpbHRlciA9ICgwLCBfbm9kZUFycmF5Mi5kZWZhdWx0KShtYXAuZmlsdGVyKTtcbiAgZGVsZXRlIG1hcC5maWx0ZXI7XG5cbiAgdmFyIG1hcEtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuICBpZiAoIW1hcEtleXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignd2hlbi9rZXkgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIG9wdGlvbiBrZXknKTtcbiAgfVxuXG4gIHZhciByZWdpc3RlckJpbmRpbmcgPSBmdW5jdGlvbiByZWdpc3RlckJpbmRpbmcoZXZlbnQpIHtcbiAgICBldmVudC5rZXlDb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICBpZiAoIWJpbmRpbmdzW2NvZGVdKSB7XG4gICAgICAgIGJpbmRpbmdzW2NvZGVdID0gW107XG4gICAgICB9XG5cbiAgICAgIGJpbmRpbmdzW2NvZGVdLnB1c2goZXZlbnQpO1xuICAgIH0pO1xuICB9O1xuXG4gIG1hcEtleXMuZm9yRWFjaChmdW5jdGlvbiAodGV4dCkge1xuICAgIGlmICh0eXBlb2YgbWFwW3RleHRdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd3aGVuL2tleSByZXF1aXJlcyBvcHRpb25bXCInICsgdGV4dCArICdcIl0gdG8gYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHZhciBhZGRDYWxsYmFjayA9IGZ1bmN0aW9uIGFkZENhbGxiYWNrKGV2ZW50KSB7XG4gICAgICBldmVudC5jYWxsYmFjayA9IG1hcFt0ZXh0XTtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuXG4gICAgKDAsIF9rZXkyLmRlZmF1bHQpKHRleHQpLm1hcChhZGRDYWxsYmFjaykuZm9yRWFjaChyZWdpc3RlckJpbmRpbmcpO1xuICB9KTtcblxuICB2YXIgaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmaWx0ZXIubGVuZ3RoKSB7XG4gICAgICAvLyBpZ25vcmUgZWxlbWVudHMgd2l0aGluIHRoZSBleGVtcHRlZCBzdWItdHJlZXNcbiAgICAgIHZhciBpc1BhcmVudE9mRWxlbWVudCA9ICgwLCBfY29tcGFyZVBvc2l0aW9uLmdldFBhcmVudENvbXBhcmF0b3IpKHsgZWxlbWVudDogZXZlbnQudGFyZ2V0LCBpbmNsdWRlU2VsZjogdHJ1ZSB9KTtcbiAgICAgIGlmIChmaWx0ZXIuc29tZShpc1BhcmVudE9mRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXkgPSBldmVudC5rZXlDb2RlIHx8IGV2ZW50LndoaWNoO1xuICAgIGlmICghYmluZGluZ3Nba2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJpbmRpbmdzW2tleV0uZm9yRWFjaChmdW5jdGlvbiAoX2V2ZW50KSB7XG4gICAgICBpZiAoIV9ldmVudC5tYXRjaE1vZGlmaWVycyhldmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfZXZlbnQuY2FsbGJhY2suY2FsbChjb250ZXh0LCBldmVudCwgZGlzZW5nYWdlKTtcbiAgICB9KTtcbiAgfTtcblxuICBjb250ZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duLCBmYWxzZSk7XG5cbiAgdmFyIGRpc2VuZ2FnZSA9IGZ1bmN0aW9uIGRpc2VuZ2FnZSgpIHtcbiAgICBjb250ZXh0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duLCBmYWxzZSk7XG4gIH07XG5cbiAgcmV0dXJuIHsgZGlzZW5nYWdlOiBkaXNlbmdhZ2UgfTtcbn07XG5cbnZhciBfa2V5ID0gcmVxdWlyZSgnLi9rZXkuYmluZGluZycpO1xuXG52YXIgX2tleTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXkpO1xuXG52YXIgX25vZGVBcnJheSA9IHJlcXVpcmUoJy4uL3V0aWwvbm9kZS1hcnJheScpO1xuXG52YXIgX25vZGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub2RlQXJyYXkpO1xuXG52YXIgX2NvbXBhcmVQb3NpdGlvbiA9IHJlcXVpcmUoJy4uL3V0aWwvY29tcGFyZS1wb3NpdGlvbicpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLy8gQnVnIDI4NjkzMyAtIEtleSBldmVudHMgaW4gdGhlIGF1dG9jb21wbGV0ZSBwb3B1cCBzaG91bGQgYmUgaGlkZGVuIGZyb20gcGFnZSBzY3JpcHRzXG4vLyBAYnJvd3Nlci1pc3N1ZSBHZWNrbyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yODY5MzNcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gVGhpcyBmaWxlIHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gYnkgQGRydWRydSAoaHR0cHM6Ly9naXRodWIuY29tL2RydWRydS9hbnNpX3VwKSwgTUlULCAyMDExXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBBTlNJX0NPTE9SUyA9IFtbeyBjb2xvcjogXCIwLCAwLCAwXCIsIFwiY2xhc3NcIjogXCJhbnNpLWJsYWNrXCIgfSwgeyBjb2xvcjogXCIxODcsIDAsIDBcIiwgXCJjbGFzc1wiOiBcImFuc2ktcmVkXCIgfSwgeyBjb2xvcjogXCIwLCAxODcsIDBcIiwgXCJjbGFzc1wiOiBcImFuc2ktZ3JlZW5cIiB9LCB7IGNvbG9yOiBcIjE4NywgMTg3LCAwXCIsIFwiY2xhc3NcIjogXCJhbnNpLXllbGxvd1wiIH0sIHsgY29sb3I6IFwiMCwgMCwgMTg3XCIsIFwiY2xhc3NcIjogXCJhbnNpLWJsdWVcIiB9LCB7IGNvbG9yOiBcIjE4NywgMCwgMTg3XCIsIFwiY2xhc3NcIjogXCJhbnNpLW1hZ2VudGFcIiB9LCB7IGNvbG9yOiBcIjAsIDE4NywgMTg3XCIsIFwiY2xhc3NcIjogXCJhbnNpLWN5YW5cIiB9LCB7IGNvbG9yOiBcIjI1NSwyNTUsMjU1XCIsIFwiY2xhc3NcIjogXCJhbnNpLXdoaXRlXCIgfV0sIFt7IGNvbG9yOiBcIjg1LCA4NSwgODVcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LWJsYWNrXCIgfSwgeyBjb2xvcjogXCIyNTUsIDg1LCA4NVwiLCBcImNsYXNzXCI6IFwiYW5zaS1icmlnaHQtcmVkXCIgfSwgeyBjb2xvcjogXCIwLCAyNTUsIDBcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LWdyZWVuXCIgfSwgeyBjb2xvcjogXCIyNTUsIDI1NSwgODVcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LXllbGxvd1wiIH0sIHsgY29sb3I6IFwiODUsIDg1LCAyNTVcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LWJsdWVcIiB9LCB7IGNvbG9yOiBcIjI1NSwgODUsIDI1NVwiLCBcImNsYXNzXCI6IFwiYW5zaS1icmlnaHQtbWFnZW50YVwiIH0sIHsgY29sb3I6IFwiODUsIDI1NSwgMjU1XCIsIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC1jeWFuXCIgfSwgeyBjb2xvcjogXCIyNTUsIDI1NSwgMjU1XCIsIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC13aGl0ZVwiIH1dXTtcblxudmFyIEFuc2VyID0gZnVuY3Rpb24gKCkge1xuICAgIF9jcmVhdGVDbGFzcyhBbnNlciwgbnVsbCwgW3tcbiAgICAgICAga2V5OiBcImVzY2FwZUZvckh0bWxcIixcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbnNlci5lc2NhcGVGb3JIdG1sXG4gICAgICAgICAqIEVzY2FwZSB0aGUgaW5wdXQgSFRNTC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBkb2VzIHRoZSBtaW5pbXVtIGVzY2FwaW5nIG9mIHRleHQgdG8gbWFrZSBpdCBjb21wbGlhbnQgd2l0aCBIVE1MLlxuICAgICAgICAgKiBJbiBwYXJ0aWN1bGFyLCB0aGUgJyYnLCc8JywgYW5kICc+JyBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUaGlzIHNob3VsZFxuICAgICAgICAgKiBiZSBydW4gcHJpb3IgdG8gYGFuc2lUb0h0bWxgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBBbnNlci5lc2NhcGVGb3JIdG1sXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0IChjb250YWluaW5nIHRoZSBBTlNJIHNuaXBwZXRzKS5cbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGVzY2FwZWQgaHRtbC5cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlc2NhcGVGb3JIdG1sKHR4dCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbnNlcigpLmVzY2FwZUZvckh0bWwodHh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbnNlci5saW5raWZ5XG4gICAgICAgICAqIEFkZHMgdGhlIGxpbmtzIGluIHRoZSBIVE1MLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHJlcGxhY2VzIGFueSBsaW5rcyBpbiB0aGUgdGV4dCB3aXRoIGFuY2hvciB0YWdzIHRoYXQgZGlzcGxheSB0aGVcbiAgICAgICAgICogbGluay4gVGhlIGxpbmtzIHNob3VsZCBoYXZlIGF0IGxlYXN0IG9uZSB3aGl0ZXNwYWNlIGNoYXJhY3RlclxuICAgICAgICAgKiBzdXJyb3VuZGluZyBpdC4gQWxzbywgeW91IHNob3VsZCBhcHBseSB0aGlzIGFmdGVyIHlvdSBoYXZlIHJ1blxuICAgICAgICAgKiBgYW5zaVRvSHRtbGAgb24gdGhlIHRleHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIEFuc2VyLmxpbmtpZnlcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBIVE1MIGNvbnRhaW5pbmcgdGhlIDxhPiB0YWdzICh1bmVzY2FwZWQpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImxpbmtpZnlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmtpZnkodHh0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuc2VyKCkubGlua2lmeSh0eHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuc2VyLmFuc2lUb0h0bWxcbiAgICAgICAgICogVGhpcyByZXBsYWNlcyBBTlNJIHRlcm1pbmFsIGVzY2FwZSBjb2RlcyB3aXRoIFNQQU4gdGFncyB0aGF0IHdyYXAgdGhlXG4gICAgICAgICAqIGNvbnRlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gb25seSBpbnRlcnByZXRzIEFOU0kgU0dSIChTZWxlY3QgR3JhcGhpYyBSZW5kaXRpb24pIGNvZGVzXG4gICAgICAgICAqIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGluIEhUTUwuXG4gICAgICAgICAqIEZvciBleGFtcGxlLCBjdXJzb3IgbW92ZW1lbnQgY29kZXMgYXJlIGlnbm9yZWQgYW5kIGhpZGRlbiBmcm9tIG91dHB1dC5cbiAgICAgICAgICogVGhlIGRlZmF1bHQgc3R5bGUgdXNlcyBjb2xvcnMgdGhhdCBhcmUgdmVyeSBjbG9zZSB0byB0aGUgcHJlc2NyaWJlZFxuICAgICAgICAgKiBzdGFuZGFyZC4gVGhlIHN0YW5kYXJkIGFzc3VtZXMgdGhhdCB0aGUgdGV4dCB3aWxsIGhhdmUgYSBibGFja1xuICAgICAgICAgKiBiYWNrZ3JvdW5kLiBUaGVzZSBjb2xvcnMgYXJlIHNldCBhcyBpbmxpbmUgc3R5bGVzIG9uIHRoZSBTUEFOIHRhZ3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFub3RoZXIgb3B0aW9uIGlzIHRvIHNldCBgdXNlX2NsYXNzZXM6IHRydWVgIGluIHRoZSBvcHRpb25zIGFyZ3VtZW50LlxuICAgICAgICAgKiBUaGlzIHdpbGwgaW5zdGVhZCBzZXQgY2xhc3NlcyBvbiB0aGUgc3BhbnMgc28gdGhlIGNvbG9ycyBjYW4gYmUgc2V0IHZpYVxuICAgICAgICAgKiBDU1MuIFRoZSBjbGFzcyBuYW1lcyB1c2VkIGFyZSBvZiB0aGUgZm9ybWF0IGBhbnNpLSotZmcvYmdgIGFuZFxuICAgICAgICAgKiBgYW5zaS1icmlnaHQtKi1mZy9iZ2Agd2hlcmUgYCpgIGlzIHRoZSBjb2xvciBuYW1lLFxuICAgICAgICAgKiBpLmUgYmxhY2svcmVkL2dyZWVuL3llbGxvdy9ibHVlL21hZ2VudGEvY3lhbi93aGl0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgQW5zZXIuYW5zaVRvSHRtbFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBhbnNpVG9IVE1MIG1ldGhvZC5cbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIEhUTUwgb3V0cHV0LlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFuc2lUb0h0bWxcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuc2lUb0h0bWwodHh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuc2VyKCkuYW5zaVRvSHRtbCh0eHQsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuc2VyLmFuc2lUb0pzb25cbiAgICAgICAgICogQ29udmVydHMgQU5TSSBpbnB1dCBpbnRvIEpTT04gb3V0cHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBBbnNlci5hbnNpVG9Kc29uXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIGFuc2lUb0hUTUwgbWV0aG9kLlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSFRNTCBvdXRwdXQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYW5zaVRvSnNvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5zaVRvSnNvbih0eHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5zZXIoKS5hbnNpVG9Kc29uKHR4dCwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQW5zZXIuYW5zaVRvVGV4dFxuICAgICAgICAgKiBDb252ZXJ0cyBBTlNJIGlucHV0IGludG8gdGV4dCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIEFuc2VyLmFuc2lUb1RleHRcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB0ZXh0IG91dHB1dC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhbnNpVG9UZXh0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbnNpVG9UZXh0KHR4dCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbnNlcigpLmFuc2lUb1RleHQodHh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbnNlclxuICAgICAgICAgKiBUaGUgYEFuc2VyYCBjbGFzcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgQW5zZXJcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtBbnNlcn1cbiAgICAgICAgICovXG5cbiAgICB9XSk7XG5cbiAgICBmdW5jdGlvbiBBbnNlcigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFuc2VyKTtcblxuICAgICAgICB0aGlzLmZnID0gdGhpcy5iZyA9IHRoaXMuZmdfdHJ1ZWNvbG9yID0gdGhpcy5iZ190cnVlY29sb3IgPSBudWxsO1xuICAgICAgICB0aGlzLmJyaWdodCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0dXBQYWxldHRlXG4gICAgICogU2V0cyB1cCB0aGUgcGFsZXR0ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHNldHVwUGFsZXR0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQW5zZXIsIFt7XG4gICAgICAgIGtleTogXCJzZXR1cFBhbGV0dGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwUGFsZXR0ZSgpIHtcbiAgICAgICAgICAgIHRoaXMuUEFMRVRURV9DT0xPUlMgPSBbXTtcblxuICAgICAgICAgICAgLy8gSW5kZXggMC4uMTUgOiBTeXN0ZW0gY29sb3JcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5QQUxFVFRFX0NPTE9SUy5wdXNoKEFOU0lfQ09MT1JTW2ldW2pdLmNvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluZGV4IDE2Li4yMzEgOiBSR0IgNng2eDZcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2phc29ubTIzLzI4Njg5ODEjZmlsZS14dGVybS0yNTZjb2xvci15YW1sXG4gICAgICAgICAgICB2YXIgbGV2ZWxzID0gWzAsIDk1LCAxMzUsIDE3NSwgMjE1LCAyNTVdO1xuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChyLCBnLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxldmVsc1tyXSArIFwiLCBcIiArIGxldmVsc1tnXSArIFwiLCBcIiArIGxldmVsc1tiXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgciA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBnID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGIgPSB2b2lkIDA7XG4gICAgICAgICAgICBmb3IgKHZhciBfciA9IDA7IF9yIDwgNjsgKytfcikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9nID0gMDsgX2cgPCA2OyArK19nKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMDsgX2IgPCA2OyArK19iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLlBBTEVUVEVfQ09MT1JTLnB1c2goZm9ybWF0KF9yLCBfZywgX2IpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5kZXggMjMyLi4yNTUgOiBHcmF5c2NhbGVcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IDg7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgMjQ7ICsrX2ksIGxldmVsICs9IDEwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5QQUxFVFRFX0NPTE9SUy5wdXNoKGZvcm1hdChsZXZlbCwgbGV2ZWwsIGxldmVsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZXNjYXBlRm9ySHRtbFxuICAgICAgICAgKiBFc2NhcGVzIHRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBlc2NhcGVGb3JIdG1sXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgZXNjcGFlZCBIVE1MIG91dHB1dC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJlc2NhcGVGb3JIdG1sXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlc2NhcGVGb3JIdG1sKHR4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHR4dC5yZXBsYWNlKC9bJjw+XS9nbSwgZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHIgPT0gXCImXCIgPyBcIiZhbXA7XCIgOiBzdHIgPT0gXCI8XCIgPyBcIiZsdDtcIiA6IHN0ciA9PSBcIj5cIiA/IFwiJmd0O1wiIDogXCJcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGxpbmtpZnlcbiAgICAgICAgICogQWRkcyBIVE1MIGxpbmsgZWxlbWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIGxpbmtpZnlcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBIVE1MIG91dHB1dCBjb250YWluaW5nIGxpbmsgZWxlbWVudHMuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwibGlua2lmeVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGlua2lmeSh0eHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0eHQucmVwbGFjZSgvKGh0dHBzPzpcXC9cXC9bXlxcc10rKS9nbSwgZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIjxhIGhyZWY9XFxcIlwiICsgc3RyICsgXCJcXFwiPlwiICsgc3RyICsgXCI8L2E+XCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhbnNpVG9IdG1sXG4gICAgICAgICAqIENvbnZlcnRzIEFOU0kgaW5wdXQgaW50byBIVE1MIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgYW5zaVRvSHRtbFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIG90IHRoZSBgcHJvY2Vzc2AgbWV0aG9kLlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSFRNTCBvdXRwdXQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYW5zaVRvSHRtbFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5zaVRvSHRtbCh0eHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3ModHh0LCBvcHRpb25zLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhbnNpVG9Kc29uXG4gICAgICAgICAqIENvbnZlcnRzIEFOU0kgaW5wdXQgaW50byBIVE1MIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgYW5zaVRvSnNvblxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIG90IHRoZSBgcHJvY2Vzc2AgbWV0aG9kLlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSlNPTiBvdXRwdXQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYW5zaVRvSnNvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5zaVRvSnNvbih0eHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgb3B0aW9ucy5qc29uID0gdHJ1ZTtcbiAgICAgICAgICAgIG9wdGlvbnMuY2xlYXJMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzKHR4dCwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogYW5zaVRvVGV4dFxuICAgICAgICAgKiBDb252ZXJ0cyBBTlNJIGlucHV0IGludG8gSFRNTCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIGFuc2lUb1RleHRcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB0ZXh0IG91dHB1dC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhbnNpVG9UZXh0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbnNpVG9UZXh0KHR4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzcyh0eHQsIHt9LCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2Vzc1xuICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGlucHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBwcm9jZXNzXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgcGFzc2VkIHRvIGBwcm9jZXNzQ2h1bmtgIG1ldGhvZCwgZXh0ZW5kZWQgd2l0aDpcbiAgICAgICAgICpcbiAgICAgICAgICogIC0gYGpzb25gIChCb29sZWFuKTogSWYgYHRydWVgLCB0aGUgcmVzdWx0IHdpbGwgYmUgYW4gb2JqZWN0LlxuICAgICAgICAgKiAgLSBgdXNlX2NsYXNzZXNgIChCb29sZWFuKTogSWYgYHRydWVgLCBIVE1MIGNsYXNzZXMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgSFRNTCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFya3VwXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwicHJvY2Vzc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzcyh0eHQsIG9wdGlvbnMsIG1hcmt1cCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHJhd190ZXh0X2NodW5rcyA9IHR4dC5zcGxpdCgvXFwwMzNcXFsvKTtcbiAgICAgICAgICAgIHZhciBmaXJzdF9jaHVuayA9IHJhd190ZXh0X2NodW5rcy5zaGlmdCgpOyAvLyB0aGUgZmlyc3QgY2h1bmsgaXMgbm90IHRoZSByZXN1bHQgb2YgdGhlIHNwbGl0XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMuY2xlYXJMaW5lID0gL1xcci8udGVzdCh0eHQpOyAvLyBjaGVjayBmb3IgQ2FycmlhZ2UgUmV0dXJuXG4gICAgICAgICAgICB2YXIgY29sb3JfY2h1bmtzID0gcmF3X3RleHRfY2h1bmtzLm1hcChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvY2Vzc0NodW5rKGNodW5rLCBvcHRpb25zLCBtYXJrdXApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuanNvbikge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IHNlbGYucHJvY2Vzc0NodW5rSnNvbihcIlwiKTtcbiAgICAgICAgICAgICAgICBmaXJzdC5jb250ZW50ID0gZmlyc3RfY2h1bms7XG4gICAgICAgICAgICAgICAgZmlyc3QuY2xlYXJMaW5lID0gb3B0aW9ucy5jbGVhckxpbmU7XG4gICAgICAgICAgICAgICAgY29sb3JfY2h1bmtzLnVuc2hpZnQoZmlyc3QpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlbW92ZV9lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcl9jaHVua3MgPSBjb2xvcl9jaHVua3MuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWMuaXNFbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yX2NodW5rcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sb3JfY2h1bmtzLnVuc2hpZnQoZmlyc3RfY2h1bmspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29sb3JfY2h1bmtzLmpvaW4oXCJcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2Vzc0NodW5rSnNvblxuICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGN1cnJlbnQgY2h1bmsgaW50byBqc29uIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgcHJvY2Vzc0NodW5rSnNvblxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgLSBganNvbmAgKEJvb2xlYW4pOiBJZiBgdHJ1ZWAsIHRoZSByZXN1bHQgd2lsbCBiZSBhbiBvYmplY3QuXG4gICAgICAgICAqICAtIGB1c2VfY2xhc3Nlc2AgKEJvb2xlYW4pOiBJZiBgdHJ1ZWAsIEhUTUwgY2xhc3NlcyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBIVE1MIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBtYXJrdXAgSWYgZmFsc2UsIHRoZSBjb2xvcnMgd2lsbCBub3QgYmUgcGFyc2VkLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHQgb2JqZWN0OlxuICAgICAgICAgKlxuICAgICAgICAgKiAgLSBgY29udGVudGAgKFN0cmluZyk6IFRoZSB0ZXh0LlxuICAgICAgICAgKiAgLSBgZmdgIChTdHJpbmd8bnVsbCk6IFRoZSBmb3JlZ3JvdW5kIGNvbG9yLlxuICAgICAgICAgKiAgLSBgYmdgIChTdHJpbmd8bnVsbCk6IFRoZSBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgICAgICAgKiAgLSBgZmdfdHJ1ZWNvbG9yYCAoU3RyaW5nfG51bGwpOiBUaGUgZm9yZWdyb3VuZCB0cnVlIGNvbG9yIChpZiAxNm0gY29sb3IgaXMgZW5hYmxlZCkuXG4gICAgICAgICAqICAtIGBiZ190cnVlY29sb3JgIChTdHJpbmd8bnVsbCk6IFRoZSBiYWNrZ3JvdW5kIHRydWUgY29sb3IgKGlmIDE2bSBjb2xvciBpcyBlbmFibGVkKS5cbiAgICAgICAgICogIC0gYGNsZWFyTGluZWAgKEJvb2xlYW4pOiBgdHJ1ZWAgaWYgYSBjYXJyaWFnZVJldHVybiBcXHIgd2FzIGZvdW50IGF0IGVuZCBvZiBsaW5lLlxuICAgICAgICAgKiAgLSBgd2FzX3Byb2Nlc3NlZGAgKEJvbGVhbik6IGB0cnVlYCBpZiB0aGUgY29sb3JzIHdlcmUgcHJvY2Vzc2VkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgICAgICogIC0gYGlzRW1wdHlgIChGdW5jdGlvbik6IEEgZnVuY3Rpb24gcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgY29udGVudCBpcyBlbXB0eSwgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwicHJvY2Vzc0NodW5rSnNvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0NodW5rSnNvbih0ZXh0LCBvcHRpb25zLCBtYXJrdXApIHtcblxuICAgICAgICAgICAgLy8gQXJlIHdlIHVzaW5nIGNsYXNzZXMgb3Igc3R5bGVzP1xuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09IFwidW5kZWZpbmVkXCIgPyB7fSA6IG9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgdXNlX2NsYXNzZXMgPSBvcHRpb25zLnVzZV9jbGFzc2VzID0gdHlwZW9mIG9wdGlvbnMudXNlX2NsYXNzZXMgIT0gXCJ1bmRlZmluZWRcIiAmJiBvcHRpb25zLnVzZV9jbGFzc2VzO1xuICAgICAgICAgICAgdmFyIGtleSA9IG9wdGlvbnMua2V5ID0gdXNlX2NsYXNzZXMgPyBcImNsYXNzXCIgOiBcImNvbG9yXCI7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgY29udGVudDogdGV4dCxcbiAgICAgICAgICAgICAgICBmZzogbnVsbCxcbiAgICAgICAgICAgICAgICBiZzogbnVsbCxcbiAgICAgICAgICAgICAgICBmZ190cnVlY29sb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgYmdfdHJ1ZWNvbG9yOiBudWxsLFxuICAgICAgICAgICAgICAgIGNsZWFyTGluZTogb3B0aW9ucy5jbGVhckxpbmUsXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICB3YXNfcHJvY2Vzc2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXJlc3VsdC5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEVhY2ggXCJjaHVua1wiIGlzIHRoZSB0ZXh0IGFmdGVyIHRoZSBDU0kgKEVTQyArIFwiW1wiKSBhbmQgYmVmb3JlIHRoZSBuZXh0IENTSS9FT0YuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhpcyByZWdleCBtYXRjaGVzIGZvdXIgZ3JvdXBzIHdpdGhpbiBhIGNodW5rLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBhbmQgdGhpcmQgZ3JvdXBzIG1hdGNoIGNvZGUgdHlwZS5cbiAgICAgICAgICAgIC8vIFdlIHN1cHBvcnRlZCBvbmx5IFNHUiBjb21tYW5kLiBJdCBoYXMgZW1wdHkgZmlyc3QgZ3JvdXAgYW5kIFwibVwiIGluIHRoaXJkLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBzZWNvbmQgZ3JvdXAgbWF0Y2hlcyBhbGwgb2YgdGhlIG51bWJlcitzZW1pY29sb24gY29tbWFuZCBzZXF1ZW5jZXNcbiAgICAgICAgICAgIC8vIGJlZm9yZSB0aGUgXCJtXCIgKG9yIG90aGVyIHRyYWlsaW5nKSBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIGdyYXBoaWNzIG9yIFNHUiBjb21tYW5kcy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgbGFzdCBncm91cCBpcyB0aGUgdGV4dCAoaW5jbHVkaW5nIG5ld2xpbmVzKSB0aGF0IGlzIGNvbG9yZWQgYnlcbiAgICAgICAgICAgIC8vIHRoZSBvdGhlciBncm91cFwicyBjb21tYW5kcy5cbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gdGV4dC5tYXRjaCgvXihbIVxceDNjLVxceDNmXSopKFtcXGQ7XSopKFtcXHgyMC1cXHgyY10qW1xceDQwLVxceDdlXSkoW1xcc1xcU10qKS9tKTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaGVzKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgICAgICB2YXIgb3JpZ190eHQgPSByZXN1bHQuY29udGVudCA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgICB2YXIgbnVtcyA9IG1hdGNoZXNbMl0uc3BsaXQoXCI7XCIpO1xuXG4gICAgICAgICAgICAvLyBXZSBjdXJyZW50bHkgc3VwcG9ydCBvbmx5IFwiU0dSXCIgKFNlbGVjdCBHcmFwaGljIFJlbmRpdGlvbilcbiAgICAgICAgICAgIC8vIFNpbXBseSBpZ25vcmUgaWYgbm90IGEgU0dSIGNvbW1hbmQuXG4gICAgICAgICAgICBpZiAobWF0Y2hlc1sxXSAhPT0gXCJcIiB8fCBtYXRjaGVzWzNdICE9PSBcIm1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbWFya3VwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBzZWxmLmRlY29yYXRpb24gPSBudWxsO1xuXG4gICAgICAgICAgICB3aGlsZSAobnVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG51bV9zdHIgPSBudW1zLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdmFyIG51bSA9IHBhcnNlSW50KG51bV9zdHIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKG51bSkgfHwgbnVtID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBzZWxmLmJnID0gc2VsZi5kZWNvcmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb24gPSBcImJvbGRcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb24gPSBcImRpbVwiO1xuICAgICAgICAgICAgICAgICAgICAvLyBFbmFibGUgY29kZSAyIHRvIGdldCBzdHJpbmdcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbiA9IFwiaXRhbGljXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb24gPSBcInVuZGVybGluZVwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9uID0gXCJibGlua1wiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSA3KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbiA9IFwicmV2ZXJzZVwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbiA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuYWJsZSBjb2RlIDkgdG8gZ2V0IHN0cmlrZXRocm91Z2hcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb24gPSBcInN0cmlrZXRocm91Z2hcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PSAzOSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmZnID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PSA0OSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmJnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yZWdyb3VuZCBjb2xvclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID49IDMwICYmIG51bSA8IDM4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBBTlNJX0NPTE9SU1swXVtudW0gJSAxMF1ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yZWdyb3VuZCBicmlnaHQgY29sb3JcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA+PSA5MCAmJiBudW0gPCA5OCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmZnID0gQU5TSV9DT0xPUlNbMV1bbnVtICUgMTBdW2tleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIEJhY2tncm91bmQgY29sb3JcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA+PSA0MCAmJiBudW0gPCA0OCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmJnID0gQU5TSV9DT0xPUlNbMF1bbnVtICUgMTBdW2tleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIEJhY2tncm91bmQgYnJpZ2h0IGNvbG9yXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPj0gMTAwICYmIG51bSA8IDEwOCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmJnID0gQU5TSV9DT0xPUlNbMV1bbnVtICUgMTBdW2tleV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDM4IHx8IG51bSA9PT0gNDgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXh0ZW5kIGNvbG9yICgzOD1mZywgNDg9YmcpXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc19mb3JlZ3JvdW5kID0gbnVtID09PSAzODtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bXMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RlID0gbnVtcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwiNVwiICYmIG51bXMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYWxldHRlIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhbGV0dGVfaW5kZXggPSBwYXJzZUludChudW1zLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWxldHRlX2luZGV4ID49IDAgJiYgcGFsZXR0ZV9pbmRleCA8PSAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VfY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLlBBTEVUVEVfQ09MT1JTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXR1cFBhbGV0dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19mb3JlZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mZyA9IHRoaXMuUEFMRVRURV9DT0xPUlNbcGFsZXR0ZV9pbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSB0aGlzLlBBTEVUVEVfQ09MT1JTW3BhbGV0dGVfaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtsYXNzID0gcGFsZXR0ZV9pbmRleCA+PSAxNiA/IFwiYW5zaS1wYWxldHRlLVwiICsgcGFsZXR0ZV9pbmRleCA6IEFOU0lfQ09MT1JTW3BhbGV0dGVfaW5kZXggPiA3ID8gMSA6IDBdW3BhbGV0dGVfaW5kZXggJSA4XVtcImNsYXNzXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2ZvcmVncm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZnID0ga2xhc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSBrbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gXCIyXCIgJiYgbnVtcy5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHBhcnNlSW50KG51bXMuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSBwYXJzZUludChudW1zLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gcGFyc2VJbnQobnVtcy5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAociA+PSAwICYmIHIgPD0gMjU1ICYmIGcgPj0gMCAmJiBnIDw9IDI1NSAmJiBiID49IDAgJiYgYiA8PSAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gciArIFwiLCBcIiArIGcgKyBcIiwgXCIgKyBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZV9jbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZm9yZWdyb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5iZyA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2ZvcmVncm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZnID0gXCJhbnNpLXRydWVjb2xvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmdfdHJ1ZWNvbG9yID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSBcImFuc2ktdHJ1ZWNvbG9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5iZ190cnVlY29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYuZmcgPT09IG51bGwgJiYgc2VsZi5iZyA9PT0gbnVsbCAmJiBzZWxmLmRlY29yYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0LmZnID0gc2VsZi5mZztcbiAgICAgICAgICAgICAgICByZXN1bHQuYmcgPSBzZWxmLmJnO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5mZ190cnVlY29sb3IgPSBzZWxmLmZnX3RydWVjb2xvcjtcbiAgICAgICAgICAgICAgICByZXN1bHQuYmdfdHJ1ZWNvbG9yID0gc2VsZi5iZ190cnVlY29sb3I7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRlY29yYXRpb24gPSBzZWxmLmRlY29yYXRpb247XG4gICAgICAgICAgICAgICAgcmVzdWx0Lndhc19wcm9jZXNzZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm9jZXNzQ2h1bmtcbiAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBjdXJyZW50IGNodW5rIG9mIHRleHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIHByb2Nlc3NDaHVua1xuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgLSBganNvbmAgKEJvb2xlYW4pOiBJZiBgdHJ1ZWAsIHRoZSByZXN1bHQgd2lsbCBiZSBhbiBvYmplY3QuXG4gICAgICAgICAqICAtIGB1c2VfY2xhc3Nlc2AgKEJvb2xlYW4pOiBJZiBgdHJ1ZWAsIEhUTUwgY2xhc3NlcyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBIVE1MIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBtYXJrdXAgSWYgZmFsc2UsIHRoZSBjb2xvcnMgd2lsbCBub3QgYmUgcGFyc2VkLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R8U3RyaW5nfSBUaGUgcmVzdWx0IChvYmplY3QgaWYgYGpzb25gIGlzIHdhbnRlZCBiYWNrIG9yIHN0cmluZyBvdGhlcndpc2UpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInByb2Nlc3NDaHVua1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0NodW5rKHRleHQsIG9wdGlvbnMsIG1hcmt1cCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGpzb25DaHVuayA9IHRoaXMucHJvY2Vzc0NodW5rSnNvbih0ZXh0LCBvcHRpb25zLCBtYXJrdXApO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5qc29uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25DaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc29uQ2h1bmsuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWpzb25DaHVuay53YXNfcHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25DaHVuay5jb250ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdXNlX2NsYXNzZXMgPSBvcHRpb25zLnVzZV9jbGFzc2VzO1xuXG4gICAgICAgICAgICB2YXIgc3R5bGVzID0gW107XG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgICAgIHZhciByZW5kZXJfZGF0YSA9IGZ1bmN0aW9uIHJlbmRlcl9kYXRhKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnRzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKFwiZGF0YS1cIiArIGtleSArIFwiPVxcXCJcIiArIF90aGlzMi5lc2NhcGVGb3JIdG1sKGRhdGFba2V5XSkgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cy5sZW5ndGggPiAwID8gXCIgXCIgKyBmcmFnbWVudHMuam9pbihcIiBcIikgOiBcIlwiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGpzb25DaHVuay5mZykge1xuICAgICAgICAgICAgICAgIGlmICh1c2VfY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goanNvbkNodW5rLmZnICsgXCItZmdcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uQ2h1bmsuZmdfdHJ1ZWNvbG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW1wiYW5zaS10cnVlY29sb3ItZmdcIl0gPSBqc29uQ2h1bmsuZmdfdHJ1ZWNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbkNodW5rLmZnX3RydWVjb2xvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChcImNvbG9yOnJnYihcIiArIGpzb25DaHVuay5mZyArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqc29uQ2h1bmsuYmcpIHtcbiAgICAgICAgICAgICAgICBpZiAodXNlX2NsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGpzb25DaHVuay5iZyArIFwiLWJnXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbkNodW5rLmJnX3RydWVjb2xvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtcImFuc2ktdHJ1ZWNvbG9yLWJnXCJdID0ganNvbkNodW5rLmJnX3RydWVjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25DaHVuay5iZ190cnVlY29sb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goXCJiYWNrZ3JvdW5kLWNvbG9yOnJnYihcIiArIGpzb25DaHVuay5iZyArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqc29uQ2h1bmsuZGVjb3JhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICh1c2VfY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goXCJhbnNpLVwiICsganNvbkNodW5rLmRlY29yYXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoanNvbkNodW5rLmRlY29yYXRpb24gPT09IFwiYm9sZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwiZm9udC13ZWlnaHQ6Ym9sZFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpzb25DaHVuay5kZWNvcmF0aW9uID09PSBcImRpbVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwib3BhY2l0eTowLjVcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqc29uQ2h1bmsuZGVjb3JhdGlvbiA9PT0gXCJpdGFsaWNcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChcImZvbnQtc3R5bGU6aXRhbGljXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyB1bmRlcmxpbmUgYW5kIGJsaW5rIGFyZSB0cmVhdGVkIGJlbGxvd1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoanNvbkNodW5rLmRlY29yYXRpb24gPT09IFwicmV2ZXJzZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwiZmlsdGVyOmludmVydCgxMDAlKVwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpzb25DaHVuay5kZWNvcmF0aW9uID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwidmlzaWJpbGl0eTpoaWRkZW5cIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqc29uQ2h1bmsuZGVjb3JhdGlvbiA9PT0gXCJzdHJpa2V0aHJvdWdoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goXCJ0ZXh0LWRlY29yYXRpb246bGluZS10aHJvdWdoXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwidGV4dC1kZWNvcmF0aW9uOlwiICsganNvbkNodW5rLmRlY29yYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHVzZV9jbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiPHNwYW4gY2xhc3M9XFxcIlwiICsgY2xhc3Nlcy5qb2luKFwiIFwiKSArIFwiXFxcIlwiICsgcmVuZGVyX2RhdGEoZGF0YSkgKyBcIj5cIiArIGpzb25DaHVuay5jb250ZW50ICsgXCI8L3NwYW4+XCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIjxzcGFuIHN0eWxlPVxcXCJcIiArIHN0eWxlcy5qb2luKFwiO1wiKSArIFwiXFxcIlwiICsgcmVuZGVyX2RhdGEoZGF0YSkgKyBcIj5cIiArIGpzb25DaHVuay5jb250ZW50ICsgXCI8L3NwYW4+XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQW5zZXI7XG59KCk7XG5cbjtcblxubW9kdWxlLmV4cG9ydHMgPSBBbnNlcjsiLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL2Nzc2VzY2FwZSB2MS41LjEgYnkgQG1hdGhpYXMgfCBNSVQgbGljZW5zZSAqL1xuOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvcmV0dXJuRXhwb3J0cy5qc1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcpIHtcblx0XHQvLyBGb3IgTm9kZS5qcy5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnkocm9vdCk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBGb3IgQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZShbXSwgZmFjdG9yeS5iaW5kKHJvb3QsIHJvb3QpKTtcblx0fSBlbHNlIHtcblx0XHQvLyBGb3IgYnJvd3NlciBnbG9iYWxzIChub3QgZXhwb3NpbmcgdGhlIGZ1bmN0aW9uIHNlcGFyYXRlbHkpLlxuXHRcdGZhY3Rvcnkocm9vdCk7XG5cdH1cbn0odHlwZW9mIGdsb2JhbCAhPSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHRoaXMsIGZ1bmN0aW9uKHJvb3QpIHtcblxuXHRpZiAocm9vdC5DU1MgJiYgcm9vdC5DU1MuZXNjYXBlKSB7XG5cdFx0cmV0dXJuIHJvb3QuQ1NTLmVzY2FwZTtcblx0fVxuXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jc2VyaWFsaXplLWFuLWlkZW50aWZpZXJcblx0dmFyIGNzc0VzY2FwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYENTUy5lc2NhcGVgIHJlcXVpcmVzIGFuIGFyZ3VtZW50LicpO1xuXHRcdH1cblx0XHR2YXIgc3RyaW5nID0gU3RyaW5nKHZhbHVlKTtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgY29kZVVuaXQ7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdHZhciBmaXJzdENvZGVVbml0ID0gc3RyaW5nLmNoYXJDb2RlQXQoMCk7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGNvZGVVbml0ID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xuXHRcdFx0Ly8gTm90ZTogdGhlcmXigJlzIG5vIG5lZWQgdG8gc3BlY2lhbC1jYXNlIGFzdHJhbCBzeW1ib2xzLCBzdXJyb2dhdGVcblx0XHRcdC8vIHBhaXJzLCBvciBsb25lIHN1cnJvZ2F0ZXMuXG5cblx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgTlVMTCAoVSswMDAwKSwgdGhlbiB0aGUgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHQvLyAoVStGRkZEKS5cblx0XHRcdGlmIChjb2RlVW5pdCA9PSAweDAwMDApIHtcblx0XHRcdFx0cmVzdWx0ICs9ICdcXHVGRkZEJztcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyBpbiB0aGUgcmFuZ2UgW1xcMS1cXDFGXSAoVSswMDAxIHRvIFUrMDAxRikgb3IgaXNcblx0XHRcdFx0Ly8gVSswMDdGLCBb4oCmXVxuXHRcdFx0XHQoY29kZVVuaXQgPj0gMHgwMDAxICYmIGNvZGVVbml0IDw9IDB4MDAxRikgfHwgY29kZVVuaXQgPT0gMHgwMDdGIHx8XG5cdFx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXMgaW4gdGhlIHJhbmdlIFswLTldXG5cdFx0XHRcdC8vIChVKzAwMzAgdG8gVSswMDM5KSwgW+KApl1cblx0XHRcdFx0KGluZGV4ID09IDAgJiYgY29kZVVuaXQgPj0gMHgwMDMwICYmIGNvZGVVbml0IDw9IDB4MDAzOSkgfHxcblx0XHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyB0aGUgc2Vjb25kIGNoYXJhY3RlciBhbmQgaXMgaW4gdGhlIHJhbmdlIFswLTldXG5cdFx0XHRcdC8vIChVKzAwMzAgdG8gVSswMDM5KSBhbmQgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBhIGAtYCAoVSswMDJEKSwgW+KApl1cblx0XHRcdFx0KFxuXHRcdFx0XHRcdGluZGV4ID09IDEgJiZcblx0XHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwMzAgJiYgY29kZVVuaXQgPD0gMHgwMDM5ICYmXG5cdFx0XHRcdFx0Zmlyc3RDb2RlVW5pdCA9PSAweDAwMkRcblx0XHRcdFx0KVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jZXNjYXBlLWEtY2hhcmFjdGVyLWFzLWNvZGUtcG9pbnRcblx0XHRcdFx0cmVzdWx0ICs9ICdcXFxcJyArIGNvZGVVbml0LnRvU3RyaW5nKDE2KSArICcgJztcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpcyBhIGAtYCAoVSswMDJEKSwgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIG5vIHNlY29uZCBjaGFyYWN0ZXIsIFvigKZdXG5cdFx0XHRcdGluZGV4ID09IDAgJiZcblx0XHRcdFx0bGVuZ3RoID09IDEgJiZcblx0XHRcdFx0Y29kZVVuaXQgPT0gMHgwMDJEXG5cdFx0XHQpIHtcblx0XHRcdFx0cmVzdWx0ICs9ICdcXFxcJyArIHN0cmluZy5jaGFyQXQoaW5kZXgpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyBub3QgaGFuZGxlZCBieSBvbmUgb2YgdGhlIGFib3ZlIHJ1bGVzIGFuZCBpc1xuXHRcdFx0Ly8gZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIFUrMDA4MCwgaXMgYC1gIChVKzAwMkQpIG9yIGBfYCAoVSswMDVGKSwgb3Jcblx0XHRcdC8vIGlzIGluIG9uZSBvZiB0aGUgcmFuZ2VzIFswLTldIChVKzAwMzAgdG8gVSswMDM5KSwgW0EtWl0gKFUrMDA0MSB0b1xuXHRcdFx0Ly8gVSswMDVBKSwgb3IgW2Etel0gKFUrMDA2MSB0byBVKzAwN0EpLCBb4oCmXVxuXHRcdFx0aWYgKFxuXHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwODAgfHxcblx0XHRcdFx0Y29kZVVuaXQgPT0gMHgwMDJEIHx8XG5cdFx0XHRcdGNvZGVVbml0ID09IDB4MDA1RiB8fFxuXHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwMzAgJiYgY29kZVVuaXQgPD0gMHgwMDM5IHx8XG5cdFx0XHRcdGNvZGVVbml0ID49IDB4MDA0MSAmJiBjb2RlVW5pdCA8PSAweDAwNUEgfHxcblx0XHRcdFx0Y29kZVVuaXQgPj0gMHgwMDYxICYmIGNvZGVVbml0IDw9IDB4MDA3QVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIHRoZSBjaGFyYWN0ZXIgaXRzZWxmXG5cdFx0XHRcdHJlc3VsdCArPSBzdHJpbmcuY2hhckF0KGluZGV4KTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSwgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuXHRcdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNlc2NhcGUtYS1jaGFyYWN0ZXJcblx0XHRcdHJlc3VsdCArPSAnXFxcXCcgKyBzdHJpbmcuY2hhckF0KGluZGV4KTtcblxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGlmICghcm9vdC5DU1MpIHtcblx0XHRyb290LkNTUyA9IHt9O1xuXHR9XG5cblx0cm9vdC5DU1MuZXNjYXBlID0gY3NzRXNjYXBlO1xuXHRyZXR1cm4gY3NzRXNjYXBlO1xuXG59KSk7XG4iLCJ2YXIgZSx0PShlPXJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKSkmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZcImRlZmF1bHRcImluIGU/ZS5kZWZhdWx0OmUscj0vaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS87ZnVuY3Rpb24gbyhlKXtcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9ZyhlKSk7dmFyIG89ZnVuY3Rpb24oZSx0LHIpe3ZhciBvPWUuYXV0aCxhPWUuaG9zdG5hbWUscz1lLnByb3RvY29sfHxcIlwiLGM9ZS5wYXRobmFtZXx8XCJcIixoPWUuaGFzaHx8XCJcIixwPWUucXVlcnl8fFwiXCIsbj0hMTtvPW8/ZW5jb2RlVVJJQ29tcG9uZW50KG8pLnJlcGxhY2UoLyUzQS9pLFwiOlwiKStcIkBcIjpcIlwiLGUuaG9zdD9uPW8rZS5ob3N0OmEmJihuPW8rKH5hLmluZGV4T2YoXCI6XCIpP1wiW1wiK2ErXCJdXCI6YSksZS5wb3J0JiYobis9XCI6XCIrZS5wb3J0KSkscCYmXCJvYmplY3RcIj09dHlwZW9mIHAmJihwPXQuZW5jb2RlKHApKTt2YXIgbD1lLnNlYXJjaHx8cCYmXCI/XCIrcHx8XCJcIjtyZXR1cm4gcyYmXCI6XCIhPT1zLnN1YnN0cigtMSkmJihzKz1cIjpcIiksZS5zbGFzaGVzfHwoIXN8fHIudGVzdChzKSkmJiExIT09bj8obj1cIi8vXCIrKG58fFwiXCIpLGMmJlwiL1wiIT09Y1swXSYmKGM9XCIvXCIrYykpOm58fChuPVwiXCIpLGgmJlwiI1wiIT09aFswXSYmKGg9XCIjXCIraCksbCYmXCI/XCIhPT1sWzBdJiYobD1cIj9cIitsKSx7cHJvdG9jb2w6cyxob3N0Om4scGF0aG5hbWU6Yz1jLnJlcGxhY2UoL1s/I10vZyxlbmNvZGVVUklDb21wb25lbnQpLHNlYXJjaDpsPWwucmVwbGFjZShcIiNcIixcIiUyM1wiKSxoYXNoOmh9fShlLHQscik7cmV0dXJuXCJcIitvLnByb3RvY29sK28uaG9zdCtvLnBhdGhuYW1lK28uc2VhcmNoK28uaGFzaH12YXIgYT1cImh0dHA6Ly9cIixzPVwidy53XCIsYz1hK3MsaD0vXihbYS16MC05ListXSo6XFwvXFwvXFwvKShbYS16MC05ListXTpcXC8qKT8vaSxwPS9odHRwcz98ZnRwfGdvcGhlcnxmaWxlLztmdW5jdGlvbiBuKGUsdCl7dmFyIHI9XCJzdHJpbmdcIj09dHlwZW9mIGU/ZyhlKTplO2U9XCJvYmplY3RcIj09dHlwZW9mIGU/byhlKTplO3ZhciBzPWcodCksbj1cIlwiO3IucHJvdG9jb2wmJiFyLnNsYXNoZXMmJihuPXIucHJvdG9jb2wsZT1lLnJlcGxhY2Uoci5wcm90b2NvbCxcIlwiKSxuKz1cIi9cIj09PXRbMF18fFwiL1wiPT09ZVswXT9cIi9cIjpcIlwiKSxuJiZzLnByb3RvY29sJiYobj1cIlwiLHMuc2xhc2hlc3x8KG49cy5wcm90b2NvbCx0PXQucmVwbGFjZShzLnByb3RvY29sLFwiXCIpKSk7dmFyIGw9ZS5tYXRjaChoKTtsJiYhcy5wcm90b2NvbCYmKGU9ZS5zdWJzdHIoKG49bFsxXSsobFsyXXx8XCJcIikpLmxlbmd0aCksL15cXC9cXC9bXi9dLy50ZXN0KHQpJiYobj1uLnNsaWNlKDAsLTEpKSk7dmFyIGk9bmV3IFVSTChlLGMrXCIvXCIpLGY9bmV3IFVSTCh0LGkpLnRvU3RyaW5nKCkucmVwbGFjZShjLFwiXCIpLHU9cy5wcm90b2NvbHx8ci5wcm90b2NvbDtyZXR1cm4gdSs9ci5zbGFzaGVzfHxzLnNsYXNoZXM/XCIvL1wiOlwiXCIsIW4mJnU/Zj1mLnJlcGxhY2UoYSx1KTpuJiYoZj1mLnJlcGxhY2UoYSxcIlwiKSkscC50ZXN0KGYpfHx+dC5pbmRleE9mKFwiLlwiKXx8XCIvXCI9PT1lLnNsaWNlKC0xKXx8XCIvXCI9PT10LnNsaWNlKC0xKXx8XCIvXCIhPT1mLnNsaWNlKC0xKXx8KGY9Zi5zbGljZSgwLC0xKSksbiYmKGY9bisoXCIvXCI9PT1mWzBdP2Yuc3Vic3RyKDEpOmYpKSxmfWZ1bmN0aW9uIGwoKXt9bC5wYXJzZT1nLGwuZm9ybWF0PW8sbC5yZXNvbHZlPW4sbC5yZXNvbHZlT2JqZWN0PW47dmFyIGk9L15odHRwcz98ZnRwfGdvcGhlcnxmaWxlLyxmPS9eKC4qPykoWyM/XS4qKS8sdT0vXihbYS16MC05ListXSo6KShcXC97MCwzfSkoLiopL2ksbT0vXihbYS16MC05ListXSo6KT9cXC9cXC9cXC8qL2ksdj0vXihbYS16MC05ListXSo6KShcXC97MCwyfSlcXFsoLiopXFxdJC9pO2Z1bmN0aW9uIGQoZSl7dHJ5e3JldHVybiBkZWNvZGVVUkkoZSl9Y2F0Y2godCl7cmV0dXJuIGV9fWZ1bmN0aW9uIGcoZSxyLGEpe2lmKHZvaWQgMD09PXImJihyPSExKSx2b2lkIDA9PT1hJiYoYT0hMSksZSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJmUgaW5zdGFuY2VvZiBsKXJldHVybiBlO3ZhciBoPShlPWUudHJpbSgpKS5tYXRjaChmKTtlPWg/ZChoWzFdKS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpK2hbMl06ZChlKS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpLHYudGVzdChlKSYmXCIvXCIhPT1lLnNsaWNlKC0xKSYmKGUrPVwiL1wiKTt2YXIgcD0hLyheamF2YXNjcmlwdCkvLnRlc3QoZSkmJmUubWF0Y2godSksbj1tLnRlc3QoZSksZz1cIlwiO3AmJihpLnRlc3QocFsxXSl8fChnPXBbMV0udG9Mb3dlckNhc2UoKSxlPVwiXCIrcFsyXStwWzNdKSxwWzJdfHwobj0hMSxpLnRlc3QocFsxXSk/KGc9cFsxXSxlPVwiXCIrcFszXSk6ZT1cIi8vXCIrcFszXSksMyE9PXBbMl0ubGVuZ3RoJiYxIT09cFsyXS5sZW5ndGh8fChnPXBbMV0sZT1cIi9cIitwWzNdKSk7dmFyIGIseT0oaD9oWzFdOmUpLm1hdGNoKC8oOlswLTldKykvKSxqPVwiXCI7eSYmeVsxXSYmMz09PXlbMV0ubGVuZ3RoJiYoZT1lLnJlcGxhY2Uoaj15WzFdLGorXCIwMFwiKSk7dmFyIHc9bmV3IGwseD1cIlwiLFU9XCJcIjt0cnl7Yj1uZXcgVVJMKGUpfWNhdGNoKHQpe3g9dCxnfHxhfHwhL15cXC9cXC8vLnRlc3QoZSl8fC9eXFwvXFwvLitbQC5dLy50ZXN0KGUpfHwoVT1cIi9cIixlPWUuc3Vic3RyKDEpKTt0cnl7Yj1uZXcgVVJMKGUsYyl9Y2F0Y2goZSl7cmV0dXJuIHcucHJvdG9jb2w9Zyx3LmhyZWY9Zyx3fX13LnNsYXNoZXM9biYmIVUsdy5ob3N0PWIuaG9zdD09PXM/XCJcIjpiLmhvc3Qsdy5ob3N0bmFtZT1iLmhvc3RuYW1lPT09cz9cIlwiOmIuaG9zdG5hbWUucmVwbGFjZSgvKFxcW3xcXF0pL2csXCJcIiksdy5wcm90b2NvbD14P2d8fG51bGw6Yi5wcm90b2NvbCx3LnNlYXJjaD1iLnNlYXJjaC5yZXBsYWNlKC9cXFxcL2csXCIlNUNcIiksdy5oYXNoPWIuaGFzaC5yZXBsYWNlKC9cXFxcL2csXCIlNUNcIik7dmFyIFI9ZS5zcGxpdChcIiNcIik7IXcuc2VhcmNoJiZ+UlswXS5pbmRleE9mKFwiP1wiKSYmKHcuc2VhcmNoPVwiP1wiKSx3Lmhhc2h8fFwiXCIhPT1SWzFdfHwody5oYXNoPVwiI1wiKSx3LnF1ZXJ5PXI/dC5kZWNvZGUoYi5zZWFyY2guc3Vic3RyKDEpKTp3LnNlYXJjaC5zdWJzdHIoMSksdy5wYXRobmFtZT1VK2QoYi5wYXRobmFtZSkucmVwbGFjZSgvXCIvZyxcIiUyMlwiKSxcImFib3V0OlwiPT09dy5wcm90b2NvbCYmXCJibGFua1wiPT09dy5wYXRobmFtZSYmKHcucHJvdG9jb2w9XCJcIix3LnBhdGhuYW1lPVwiXCIpLHgmJlwiL1wiIT09ZVswXSYmKHcucGF0aG5hbWU9dy5wYXRobmFtZS5zdWJzdHIoMSkpLGcmJiFpLnRlc3QoZykmJlwiL1wiIT09ZS5zbGljZSgtMSkmJlwiL1wiPT09dy5wYXRobmFtZSYmKHcucGF0aG5hbWU9XCJcIiksdy5wYXRoPXcucGF0aG5hbWUrdy5zZWFyY2gsdy5hdXRoPVtiLnVzZXJuYW1lLGIucGFzc3dvcmRdLm1hcChkZWNvZGVVUklDb21wb25lbnQpLmZpbHRlcihCb29sZWFuKS5qb2luKFwiOlwiKSx3LnBvcnQ9Yi5wb3J0LGomJih3Lmhvc3Q9dy5ob3N0LnJlcGxhY2UoaitcIjAwXCIsaiksdy5wb3J0PXcucG9ydC5zbGljZSgwLC0yKSksdy5ocmVmPVU/XCJcIit3LnBhdGhuYW1lK3cuc2VhcmNoK3cuaGFzaDpvKHcpO3ZhciBPPS9eKGZpbGUpLy50ZXN0KHcuaHJlZik/W1wiaG9zdFwiLFwiaG9zdG5hbWVcIl06W107cmV0dXJuIE9iamVjdC5rZXlzKHcpLmZvckVhY2goZnVuY3Rpb24oZSl7fk8uaW5kZXhPZihlKXx8KHdbZV09d1tlXXx8bnVsbCl9KSx3fWV4cG9ydHMucGFyc2U9ZyxleHBvcnRzLmZvcm1hdD1vLGV4cG9ydHMucmVzb2x2ZT1uLGV4cG9ydHMucmVzb2x2ZU9iamVjdD1mdW5jdGlvbihlLHQpe3JldHVybiBnKG4oZSx0KSl9LGV4cG9ydHMuVXJsPWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsImltcG9ydCB7IFdvcmtib3ggfSBmcm9tICd3b3JrYm94LXdpbmRvdydcclxuXHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yKSB7XHJcbiAgd2luZG93Lndvcmtib3ggPSBuZXcgV29ya2JveChfX1BXQV9TV19fLCB7IHNjb3BlOiBfX1BXQV9TQ09QRV9fIH0pXHJcbiAgaWYoX19QV0FfRU5BQkxFX1JFR0lTVEVSX18pIHdpbmRvdy53b3JrYm94LnJlZ2lzdGVyKClcclxufVxyXG4iLCJQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5PWZ1bmN0aW9uKG4pe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIG4pcmV0dXJuIHRoaXMudGhlbihuLG4pO3ZhciB0PXRoaXMuY29uc3RydWN0b3J8fFByb21pc2U7cmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbihyKXtyZXR1cm4gdC5yZXNvbHZlKG4oKSkudGhlbihmdW5jdGlvbigpe3JldHVybiByfSl9LGZ1bmN0aW9uKHIpe3JldHVybiB0LnJlc29sdmUobigpKS50aGVuKGZ1bmN0aW9uKCl7dGhyb3cgcn0pfSl9OyIsIm1vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGUsbil7cmV0dXJuIG49bnx8e30sbmV3IFByb21pc2UoZnVuY3Rpb24odCxyKXt2YXIgcz1uZXcgWE1MSHR0cFJlcXVlc3Qsbz1bXSx1PVtdLGk9e30sYT1mdW5jdGlvbigpe3JldHVybntvazoyPT0ocy5zdGF0dXMvMTAwfDApLHN0YXR1c1RleHQ6cy5zdGF0dXNUZXh0LHN0YXR1czpzLnN0YXR1cyx1cmw6cy5yZXNwb25zZVVSTCx0ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShzLnJlc3BvbnNlVGV4dCl9LGpzb246ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2Uocy5yZXNwb25zZVRleHQpKX0sYmxvYjpmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3MucmVzcG9uc2VdKSl9LGNsb25lOmEsaGVhZGVyczp7a2V5czpmdW5jdGlvbigpe3JldHVybiBvfSxlbnRyaWVzOmZ1bmN0aW9uKCl7cmV0dXJuIHV9LGdldDpmdW5jdGlvbihlKXtyZXR1cm4gaVtlLnRvTG93ZXJDYXNlKCldfSxoYXM6ZnVuY3Rpb24oZSl7cmV0dXJuIGUudG9Mb3dlckNhc2UoKWluIGl9fX19O2Zvcih2YXIgbCBpbiBzLm9wZW4obi5tZXRob2R8fFwiZ2V0XCIsZSwhMCkscy5vbmxvYWQ9ZnVuY3Rpb24oKXtzLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnJlcGxhY2UoL14oLio/KTpbXlxcU1xcbl0qKFtcXHNcXFNdKj8pJC9nbSxmdW5jdGlvbihlLG4sdCl7by5wdXNoKG49bi50b0xvd2VyQ2FzZSgpKSx1LnB1c2goW24sdF0pLGlbbl09aVtuXT9pW25dK1wiLFwiK3Q6dH0pLHQoYSgpKX0scy5vbmVycm9yPXIscy53aXRoQ3JlZGVudGlhbHM9XCJpbmNsdWRlXCI9PW4uY3JlZGVudGlhbHMsbi5oZWFkZXJzKXMuc2V0UmVxdWVzdEhlYWRlcihsLG4uaGVhZGVyc1tsXSk7cy5zZW5kKG4uYm9keXx8bnVsbCl9KX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmZldGNoLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0cy5kZWZhdWx0PWluaXRpYWxpemVCdWlsZFdhdGNoZXI7dmFyIF9ldmVudHNvdXJjZT1yZXF1aXJlKFwiLi9lcnJvci1vdmVybGF5L2V2ZW50c291cmNlXCIpO2Z1bmN0aW9uIGluaXRpYWxpemVCdWlsZFdhdGNoZXIoKXt2YXIgc2hhZG93SG9zdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtzaGFkb3dIb3N0LmlkPSdfX25leHQtYnVpbGQtd2F0Y2hlcic7Ly8gTWFrZSBzdXJlIGNvbnRhaW5lciBpcyBmaXhlZCBhbmQgb24gYSBoaWdoIHpJbmRleCBzbyBpdCBzaG93c1xuc2hhZG93SG9zdC5zdHlsZS5wb3NpdGlvbj0nZml4ZWQnO3NoYWRvd0hvc3Quc3R5bGUuYm90dG9tPScxMHB4JztzaGFkb3dIb3N0LnN0eWxlLnJpZ2h0PScyMHB4JztzaGFkb3dIb3N0LnN0eWxlLndpZHRoPTA7c2hhZG93SG9zdC5zdHlsZS5oZWlnaHQ9MDtzaGFkb3dIb3N0LnN0eWxlLnpJbmRleD05OTk5OTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNoYWRvd0hvc3QpO3ZhciBzaGFkb3dSb290O3ZhciBwcmVmaXg9Jyc7aWYoc2hhZG93SG9zdC5hdHRhY2hTaGFkb3cpe3NoYWRvd1Jvb3Q9c2hhZG93SG9zdC5hdHRhY2hTaGFkb3coe21vZGU6J29wZW4nfSk7fWVsc2V7Ly8gSWYgYXR0YWNoU2hhZG93IGlzIHVuZGVmaW5lZCB0aGVuIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnRcbi8vIHRoZSBTaGFkb3cgRE9NLCB3ZSBuZWVkIHRvIHByZWZpeCBhbGwgdGhlIG5hbWVzIHNvIHRoZXJlXG4vLyB3aWxsIGJlIG5vIGNvbmZsaWN0c1xuc2hhZG93Um9vdD1zaGFkb3dIb3N0O3ByZWZpeD0nX19uZXh0LWJ1aWxkLXdhdGNoZXItJzt9Ly8gQ29udGFpbmVyXG52YXIgY29udGFpbmVyPWNyZWF0ZUNvbnRhaW5lcihwcmVmaXgpO3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTsvLyBDU1NcbnZhciBjc3M9Y3JlYXRlQ3NzKHByZWZpeCk7c2hhZG93Um9vdC5hcHBlbmRDaGlsZChjc3MpOy8vIFN0YXRlXG52YXIgaXNWaXNpYmxlPWZhbHNlO3ZhciBpc0J1aWxkaW5nPWZhbHNlO3ZhciB0aW1lb3V0SWQ9bnVsbDsvLyBIYW5kbGUgZXZlbnRzXG52YXIgZXZ0U291cmNlPSgwLF9ldmVudHNvdXJjZS5nZXRFdmVudFNvdXJjZVdyYXBwZXIpKHtwYXRoOicvX25leHQvd2VicGFjay1obXInfSk7ZXZ0U291cmNlLmFkZE1lc3NhZ2VMaXN0ZW5lcihldmVudD0+ey8vIFRoaXMgaXMgdGhlIGhlYXJ0YmVhdCBldmVudFxuaWYoZXZlbnQuZGF0YT09PSdcXHVEODNEXFx1REM5Mycpe3JldHVybjt9dHJ5e2hhbmRsZU1lc3NhZ2UoZXZlbnQpO31jYXRjaChfdW51c2VkKXt9fSk7ZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldmVudCl7dmFyIG9iaj1KU09OLnBhcnNlKGV2ZW50LmRhdGEpOy8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcbnN3aXRjaChvYmouYWN0aW9uKXtjYXNlJ2J1aWxkaW5nJzp0aW1lb3V0SWQmJmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO2lzVmlzaWJsZT10cnVlO2lzQnVpbGRpbmc9dHJ1ZTt1cGRhdGVDb250YWluZXIoKTticmVhaztjYXNlJ2J1aWx0JzpjYXNlJ3N5bmMnOmlzQnVpbGRpbmc9ZmFsc2U7Ly8gV2FpdCBmb3IgdGhlIGZhZGUgb3V0IHRyYW5zdGlvbiB0byBjb21wbGV0ZVxudGltZW91dElkPXNldFRpbWVvdXQoKCk9Pntpc1Zpc2libGU9ZmFsc2U7dXBkYXRlQ29udGFpbmVyKCk7fSwxMDApO3VwZGF0ZUNvbnRhaW5lcigpO2JyZWFrO319ZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKCl7aWYoaXNCdWlsZGluZyl7Y29udGFpbmVyLmNsYXNzTGlzdC5hZGQocHJlZml4K1wiYnVpbGRpbmdcIik7fWVsc2V7Y29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUocHJlZml4K1wiYnVpbGRpbmdcIik7fWlmKGlzVmlzaWJsZSl7Y29udGFpbmVyLmNsYXNzTGlzdC5hZGQocHJlZml4K1widmlzaWJsZVwiKTt9ZWxzZXtjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShwcmVmaXgrXCJ2aXNpYmxlXCIpO319fWZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcihwcmVmaXgpe3ZhciBjb250YWluZXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7Y29udGFpbmVyLmlkPXByZWZpeCtcImNvbnRhaW5lclwiO2NvbnRhaW5lci5pbm5lckhUTUw9XCJcXG4gICAgPGRpdiBpZD1cXFwiXCIrcHJlZml4K1wiaWNvbi13cmFwcGVyXFxcIj5cXG4gICAgICA8c3ZnIHZpZXdCb3g9XFxcIjAgMCAyMjYgMjAwXFxcIj5cXG4gICAgICAgIDxkZWZzPlxcbiAgICAgICAgICA8bGluZWFyR3JhZGllbnRcXG4gICAgICAgICAgICB4MT1cXFwiMTE0LjcyMDc3NSVcXFwiXFxuICAgICAgICAgICAgeTE9XFxcIjE4MS4yODMyNDUlXFxcIlxcbiAgICAgICAgICAgIHgyPVxcXCIzOS41Mzk5MzA2JVxcXCJcXG4gICAgICAgICAgICB5Mj1cXFwiMTAwJVxcXCJcXG4gICAgICAgICAgICBpZD1cXFwiXCIrcHJlZml4K1wibGluZWFyLWdyYWRpZW50XFxcIlxcbiAgICAgICAgICA+XFxuICAgICAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cXFwiI0ZGRkZGRlxcXCIgb2Zmc2V0PVxcXCIwJVxcXCIgLz5cXG4gICAgICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVxcXCIjMDAwMDAwXFxcIiBvZmZzZXQ9XFxcIjEwMCVcXFwiIC8+XFxuICAgICAgICAgIDwvbGluZWFyR3JhZGllbnQ+XFxuICAgICAgICA8L2RlZnM+XFxuICAgICAgICA8ZyBpZD1cXFwiXCIrcHJlZml4K1wiaWNvbi1ncm91cFxcXCIgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCJ1cmwoI1wiK3ByZWZpeCtcImxpbmVhci1ncmFkaWVudClcXFwiIHN0cm9rZS13aWR0aD1cXFwiMThcXFwiPlxcbiAgICAgICAgICA8cGF0aCBkPVxcXCJNMTEzLDUuMDgyMTkxMTcgTDQuMjgzOTM4MDEsMTk3LjUgTDIyMS43MTYwNjIsMTk3LjUgTDExMyw1LjA4MjE5MTE3IFpcXFwiIC8+XFxuICAgICAgICA8L2c+XFxuICAgICAgPC9zdmc+XFxuICAgIDwvZGl2PlxcbiAgXCI7cmV0dXJuIGNvbnRhaW5lcjt9ZnVuY3Rpb24gY3JlYXRlQ3NzKHByZWZpeCl7dmFyIGNzcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO2Nzcy50ZXh0Q29udGVudD1cIlxcbiAgICAjXCIrcHJlZml4K1wiY29udGFpbmVyIHtcXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgYm90dG9tOiAxMHB4O1xcbiAgICAgIHJpZ2h0OiAzMHB4O1xcblxcbiAgICAgIGJhY2tncm91bmQ6ICNmZmY7XFxuICAgICAgY29sb3I6ICMwMDA7XFxuICAgICAgZm9udDogaW5pdGlhbDtcXG4gICAgICBjdXJzb3I6IGluaXRpYWw7XFxuICAgICAgbGV0dGVyLXNwYWNpbmc6IGluaXRpYWw7XFxuICAgICAgdGV4dC1zaGFkb3c6IGluaXRpYWw7XFxuICAgICAgdGV4dC10cmFuc2Zvcm06IGluaXRpYWw7XFxuICAgICAgdmlzaWJpbGl0eTogaW5pdGlhbDtcXG5cXG4gICAgICBwYWRkaW5nOiA4cHggMTBweDtcXG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgIGJveC1zaGFkb3c6IDAgMTFweCA0MHB4IDAgcmdiYSgwLCAwLCAwLCAwLjI1KSwgMCAycHggMTBweCAwIHJnYmEoMCwgMCwgMCwgMC4xMik7XFxuXFxuICAgICAgZGlzcGxheTogbm9uZTtcXG4gICAgICBvcGFjaXR5OiAwO1xcbiAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBlYXNlLCBib3R0b20gMC4xcyBlYXNlO1xcbiAgICAgIGFuaW1hdGlvbjogXCIrcHJlZml4K1wiZmFkZS1pbiAwLjFzIGVhc2UtaW4tb3V0O1xcbiAgICB9XFxuXFxuICAgICNcIitwcmVmaXgrXCJjb250YWluZXIuXCIrcHJlZml4K1widmlzaWJsZSB7XFxuICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgfVxcblxcbiAgICAjXCIrcHJlZml4K1wiY29udGFpbmVyLlwiK3ByZWZpeCtcImJ1aWxkaW5nIHtcXG4gICAgICBib3R0b206IDIwcHg7XFxuICAgICAgb3BhY2l0eTogMTtcXG4gICAgfVxcblxcbiAgICAjXCIrcHJlZml4K1wiaWNvbi13cmFwcGVyIHtcXG4gICAgICB3aWR0aDogMTZweDtcXG4gICAgICBoZWlnaHQ6IDE2cHg7XFxuICAgIH1cXG5cXG4gICAgI1wiK3ByZWZpeCtcImljb24td3JhcHBlciA+IHN2ZyB7XFxuICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB9XFxuXFxuICAgICNcIitwcmVmaXgrXCJpY29uLWdyb3VwIHtcXG4gICAgICBhbmltYXRpb246IFwiK3ByZWZpeCtcInN0cm9rZWRhc2ggMXMgZWFzZS1pbi1vdXQgYm90aCBpbmZpbml0ZTtcXG4gICAgfVxcblxcbiAgICBAa2V5ZnJhbWVzIFwiK3ByZWZpeCtcImZhZGUtaW4ge1xcbiAgICAgIGZyb20ge1xcbiAgICAgICAgYm90dG9tOiAxMHB4O1xcbiAgICAgICAgb3BhY2l0eTogMDtcXG4gICAgICB9XFxuICAgICAgdG8ge1xcbiAgICAgICAgYm90dG9tOiAyMHB4O1xcbiAgICAgICAgb3BhY2l0eTogMTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgQGtleWZyYW1lcyBcIitwcmVmaXgrXCJzdHJva2VkYXNoIHtcXG4gICAgICAwJSB7XFxuICAgICAgICBzdHJva2UtZGFzaGFycmF5OiAwIDIyNjtcXG4gICAgICB9XFxuICAgICAgODAlLFxcbiAgICAgIDEwMCUge1xcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogNjU5IDIyNjtcXG4gICAgICB9XFxuICAgIH1cXG4gIFwiO3JldHVybiBjc3M7fSIsIlwidXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMuZ2V0RXZlbnRTb3VyY2VXcmFwcGVyPWdldEV2ZW50U291cmNlV3JhcHBlcjt2YXIgZXZlbnRDYWxsYmFja3M9W107ZnVuY3Rpb24gRXZlbnRTb3VyY2VXcmFwcGVyKG9wdGlvbnMpe3ZhciBzb3VyY2U7dmFyIGxhc3RBY3Rpdml0eT1uZXcgRGF0ZSgpO3ZhciBsaXN0ZW5lcnM9W107aWYoIW9wdGlvbnMudGltZW91dCl7b3B0aW9ucy50aW1lb3V0PTIwKjEwMDA7fWluaXQoKTt2YXIgdGltZXI9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtpZihuZXcgRGF0ZSgpLWxhc3RBY3Rpdml0eT5vcHRpb25zLnRpbWVvdXQpe2hhbmRsZURpc2Nvbm5lY3QoKTt9fSxvcHRpb25zLnRpbWVvdXQvMik7ZnVuY3Rpb24gaW5pdCgpe3NvdXJjZT1uZXcgd2luZG93LkV2ZW50U291cmNlKG9wdGlvbnMucGF0aCk7c291cmNlLm9ub3Blbj1oYW5kbGVPbmxpbmU7c291cmNlLm9uZXJyb3I9aGFuZGxlRGlzY29ubmVjdDtzb3VyY2Uub25tZXNzYWdlPWhhbmRsZU1lc3NhZ2U7fWZ1bmN0aW9uIGhhbmRsZU9ubGluZSgpe2lmKG9wdGlvbnMubG9nKWNvbnNvbGUubG9nKCdbSE1SXSBjb25uZWN0ZWQnKTtsYXN0QWN0aXZpdHk9bmV3IERhdGUoKTt9ZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldmVudCl7bGFzdEFjdGl2aXR5PW5ldyBEYXRlKCk7Zm9yKHZhciBpPTA7aTxsaXN0ZW5lcnMubGVuZ3RoO2krKyl7bGlzdGVuZXJzW2ldKGV2ZW50KTt9aWYoZXZlbnQuZGF0YS5pbmRleE9mKCdhY3Rpb24nKSE9PS0xKXtldmVudENhbGxiYWNrcy5mb3JFYWNoKGNiPT5jYihldmVudCkpO319ZnVuY3Rpb24gaGFuZGxlRGlzY29ubmVjdCgpe2NsZWFySW50ZXJ2YWwodGltZXIpO3NvdXJjZS5jbG9zZSgpO3NldFRpbWVvdXQoaW5pdCxvcHRpb25zLnRpbWVvdXQpO31yZXR1cm57Y2xvc2U6KCk9PntjbGVhckludGVydmFsKHRpbWVyKTtzb3VyY2UuY2xvc2UoKTt9LGFkZE1lc3NhZ2VMaXN0ZW5lcjpmdW5jdGlvbiBhZGRNZXNzYWdlTGlzdGVuZXIoZm4pe2xpc3RlbmVycy5wdXNoKGZuKTt9fTt9ZnVuY3Rpb24gZ2V0RXZlbnRTb3VyY2VXcmFwcGVyKG9wdGlvbnMpe2lmKCFvcHRpb25zLm9uZGVtYW5kKXtyZXR1cm57YWRkTWVzc2FnZUxpc3RlbmVyOmNiPT57ZXZlbnRDYWxsYmFja3MucHVzaChjYik7fX07fXJldHVybiBFdmVudFNvdXJjZVdyYXBwZXIob3B0aW9ucyk7fSIsIlwidXNlIHN0cmljdFwiOy8qKlxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5TT0ZUV0FSRS5cbiovIC8vIFRoaXMgZmlsZSBpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9ibG9iLzdiMWEzMmJlNmVjOWY5OWE2YzlhM2M2NjgxM2YzYWMwOWM0NzM2YjkvcGFja2FnZXMvcmVhY3QtZGV2LXV0aWxzL2Zvcm1hdFdlYnBhY2tNZXNzYWdlcy5qc1xuLy8gSXQncyBiZWVuIGVkaXRlZCB0byByZW1vdmUgY2hhbGsgYW5kIENSQS1zcGVjaWZpYyBsb2dpY1xudmFyIGZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbD0nU3ludGF4IGVycm9yOic7ZnVuY3Rpb24gaXNMaWtlbHlBU3ludGF4RXJyb3IobWVzc2FnZSl7cmV0dXJuIG1lc3NhZ2UuaW5kZXhPZihmcmllbmRseVN5bnRheEVycm9yTGFiZWwpIT09LTE7fS8vIENsZWFucyB1cCB3ZWJwYWNrIGVycm9yIG1lc3NhZ2VzLlxuZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShtZXNzYWdlKXt2YXIgbGluZXM9bWVzc2FnZS5zcGxpdCgnXFxuJyk7Ly8gU3RyaXAgV2VicGFjay1hZGRlZCBoZWFkZXJzIG9mZiBlcnJvcnMvd2FybmluZ3Ncbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2svYmxvYi9tYXN0ZXIvbGliL01vZHVsZUVycm9yLmpzXG5saW5lcz1saW5lcy5maWx0ZXIobGluZT0+IS9Nb2R1bGUgW0EteiBdK1xcKGZyb20vLnRlc3QobGluZSkpOy8vIFRyYW5zZm9ybSBwYXJzaW5nIGVycm9yIGludG8gc3ludGF4IGVycm9yXG4vLyBUT0RPOiBtb3ZlIHRoaXMgdG8gb3VyIEVTTGludCBmb3JtYXR0ZXI/XG5saW5lcz1saW5lcy5tYXAobGluZT0+e3ZhciBwYXJzaW5nRXJyb3I9L0xpbmUgKFxcZCspOig/OihcXGQrKTopP1xccypQYXJzaW5nIGVycm9yOiAoLispJC8uZXhlYyhsaW5lKTtpZighcGFyc2luZ0Vycm9yKXtyZXR1cm4gbGluZTt9dmFyWyxlcnJvckxpbmUsZXJyb3JDb2x1bW4sZXJyb3JNZXNzYWdlXT1wYXJzaW5nRXJyb3I7cmV0dXJuIGZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbCtcIiBcIitlcnJvck1lc3NhZ2UrXCIgKFwiK2Vycm9yTGluZStcIjpcIitlcnJvckNvbHVtbitcIilcIjt9KTttZXNzYWdlPWxpbmVzLmpvaW4oJ1xcbicpOy8vIFNtb29zaCBzeW50YXggZXJyb3JzIChjb21tb25seSBmb3VuZCBpbiBDU1MpXG5tZXNzYWdlPW1lc3NhZ2UucmVwbGFjZSgvU3ludGF4RXJyb3JcXHMrXFwoKFxcZCspOihcXGQrKVxcKVxccyooLis/KVxcbi9nLGZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbCtcIiAkMyAoJDE6JDIpXFxuXCIpOy8vIENsZWFuIHVwIGV4cG9ydCBlcnJvcnNcbm1lc3NhZ2U9bWVzc2FnZS5yZXBsYWNlKC9eLipleHBvcnQgJyguKz8pJyB3YXMgbm90IGZvdW5kIGluICcoLis/KScuKiQvZ20sXCJBdHRlbXB0ZWQgaW1wb3J0IGVycm9yOiAnJDEnIGlzIG5vdCBleHBvcnRlZCBmcm9tICckMicuXCIpO21lc3NhZ2U9bWVzc2FnZS5yZXBsYWNlKC9eLipleHBvcnQgJ2RlZmF1bHQnIFxcKGltcG9ydGVkIGFzICcoLis/KSdcXCkgd2FzIG5vdCBmb3VuZCBpbiAnKC4rPyknLiokL2dtLFwiQXR0ZW1wdGVkIGltcG9ydCBlcnJvcjogJyQyJyBkb2VzIG5vdCBjb250YWluIGEgZGVmYXVsdCBleHBvcnQgKGltcG9ydGVkIGFzICckMScpLlwiKTttZXNzYWdlPW1lc3NhZ2UucmVwbGFjZSgvXi4qZXhwb3J0ICcoLis/KScgXFwoaW1wb3J0ZWQgYXMgJyguKz8pJ1xcKSB3YXMgbm90IGZvdW5kIGluICcoLis/KScuKiQvZ20sXCJBdHRlbXB0ZWQgaW1wb3J0IGVycm9yOiAnJDEnIGlzIG5vdCBleHBvcnRlZCBmcm9tICckMycgKGltcG9ydGVkIGFzICckMicpLlwiKTtsaW5lcz1tZXNzYWdlLnNwbGl0KCdcXG4nKTsvLyBSZW1vdmUgbGVhZGluZyBuZXdsaW5lXG5pZihsaW5lcy5sZW5ndGg+MiYmbGluZXNbMV0udHJpbSgpPT09Jycpe2xpbmVzLnNwbGljZSgxLDEpO30vLyBDbGVhbiB1cCBmaWxlIG5hbWVcbmxpbmVzWzBdPWxpbmVzWzBdLnJlcGxhY2UoL14oLiopIFxcZCs6XFxkKy1cXGQrJC8sJyQxJyk7Ly8gQ2xlYW5zIHVwIHZlcmJvc2UgXCJtb2R1bGUgbm90IGZvdW5kXCIgbWVzc2FnZXMgZm9yIGZpbGVzIGFuZCBwYWNrYWdlcy5cbmlmKGxpbmVzWzFdJiZsaW5lc1sxXS5pbmRleE9mKCdNb2R1bGUgbm90IGZvdW5kOiAnKT09PTApe2xpbmVzPVtsaW5lc1swXSxsaW5lc1sxXS5yZXBsYWNlKCdFcnJvcjogJywnJykucmVwbGFjZSgnTW9kdWxlIG5vdCBmb3VuZDogQ2Fubm90IGZpbmQgZmlsZTonLCdDYW5ub3QgZmluZCBmaWxlOicpXTt9Ly8gQWRkIGhlbHBmdWwgbWVzc2FnZSBmb3IgdXNlcnMgdHJ5aW5nIHRvIHVzZSBTYXNzIGZvciB0aGUgZmlyc3QgdGltZVxuaWYobGluZXNbMV0mJmxpbmVzWzFdLm1hdGNoKC9DYW5ub3QgZmluZCBtb2R1bGUuK25vZGUtc2Fzcy8pKXsvLyAuL2ZpbGUubW9kdWxlLnNjc3MgKDw8bG9hZGVyIGluZm8+PikgPT4gLi9maWxlLm1vZHVsZS5zY3NzXG5saW5lc1swXT1saW5lc1swXS5yZXBsYWNlKC8oLispIFxcKC4rPyg/PVxcP1xcPykuKz9cXCkvLCckMScpO2xpbmVzWzFdPVwiVG8gdXNlIE5leHQuanMnIGJ1aWx0LWluIFNhc3Mgc3VwcG9ydCwgeW91IGZpcnN0IG5lZWQgdG8gaW5zdGFsbCBgc2Fzc2AuXFxuXCI7bGluZXNbMV0rPSdSdW4gYG5wbSBpIHNhc3NgIG9yIGB5YXJuIGFkZCBzYXNzYCBpbnNpZGUgeW91ciB3b3Jrc3BhY2UuXFxuJztsaW5lc1sxXSs9J1xcbkxlYXJuIG1vcmU6IGh0dHBzOi8vZXJyLnNoL25leHQuanMvaW5zdGFsbC1zYXNzJzt9bWVzc2FnZT1saW5lcy5qb2luKCdcXG4nKTsvLyBJbnRlcm5hbCBzdGFja3MgYXJlIGdlbmVyYWxseSB1c2VsZXNzIHNvIHdlIHN0cmlwIHRoZW0uLi4gd2l0aCB0aGVcbi8vIGV4Y2VwdGlvbiBvZiBzdGFja3MgY29udGFpbmluZyBgd2VicGFjazpgIGJlY2F1c2UgdGhleSdyZSBub3JtYWxseVxuLy8gZnJvbSB1c2VyIGNvZGUgZ2VuZXJhdGVkIGJ5IFdlYnBhY2suIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2NyZWF0ZS1yZWFjdC1hcHAvcHVsbC8xMDUwXG5tZXNzYWdlPW1lc3NhZ2UucmVwbGFjZSgvXlxccyphdFxccygoPyF3ZWJwYWNrOikuKSo6XFxkKzpcXGQrW1xccyldKihcXG58JCkvZ20sJycpOy8vIGF0IC4uLiAuLi46eDp5XG5tZXNzYWdlPW1lc3NhZ2UucmVwbGFjZSgvXlxccyphdFxcczxhbm9ueW1vdXM+KFxcbnwkKS9nbSwnJyk7Ly8gYXQgPGFub255bW91cz5cbmxpbmVzPW1lc3NhZ2Uuc3BsaXQoJ1xcbicpOy8vIFJlbW92ZSBkdXBsaWNhdGVkIG5ld2xpbmVzXG5saW5lcz1saW5lcy5maWx0ZXIoKGxpbmUsaW5kZXgsYXJyKT0+aW5kZXg9PT0wfHxsaW5lLnRyaW0oKSE9PScnfHxsaW5lLnRyaW0oKSE9PWFycltpbmRleC0xXS50cmltKCkpOy8vIFJlYXNzZW1ibGUgdGhlIG1lc3NhZ2Vcbm1lc3NhZ2U9bGluZXMuam9pbignXFxuJyk7cmV0dXJuIG1lc3NhZ2UudHJpbSgpO31mdW5jdGlvbiBmb3JtYXRXZWJwYWNrTWVzc2FnZXMoanNvbil7dmFyIGZvcm1hdHRlZEVycm9ycz1qc29uLmVycm9ycy5tYXAoZnVuY3Rpb24obWVzc2FnZSl7cmV0dXJuIGZvcm1hdE1lc3NhZ2UobWVzc2FnZSx0cnVlKTt9KTt2YXIgZm9ybWF0dGVkV2FybmluZ3M9anNvbi53YXJuaW5ncy5tYXAoZnVuY3Rpb24obWVzc2FnZSl7cmV0dXJuIGZvcm1hdE1lc3NhZ2UobWVzc2FnZSxmYWxzZSk7fSk7dmFyIHJlc3VsdD17ZXJyb3JzOmZvcm1hdHRlZEVycm9ycyx3YXJuaW5nczpmb3JtYXR0ZWRXYXJuaW5nc307aWYocmVzdWx0LmVycm9ycy5zb21lKGlzTGlrZWx5QVN5bnRheEVycm9yKSl7Ly8gSWYgdGhlcmUgYXJlIGFueSBzeW50YXggZXJyb3JzLCBzaG93IGp1c3QgdGhlbS5cbnJlc3VsdC5lcnJvcnM9cmVzdWx0LmVycm9ycy5maWx0ZXIoaXNMaWtlbHlBU3ludGF4RXJyb3IpO31yZXR1cm4gcmVzdWx0O31tb2R1bGUuZXhwb3J0cz1mb3JtYXRXZWJwYWNrTWVzc2FnZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ9cmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO3ZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZD1yZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkXCIpO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMuZGVmYXVsdD1jb25uZWN0O3ZhciBEZXZPdmVybGF5PV9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJAbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvY2xpZW50XCIpKTt2YXIgX3N0cmlwQW5zaT1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvc3RyaXAtYW5zaVwiKSk7dmFyIF9ldmVudHNvdXJjZT1yZXF1aXJlKFwiLi9ldmVudHNvdXJjZVwiKTt2YXIgX2Zvcm1hdFdlYnBhY2tNZXNzYWdlcz1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Zvcm1hdC13ZWJwYWNrLW1lc3NhZ2VzXCIpKTsvKipcbiAqIE1JVCBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqLyAvLyBUaGlzIGZpbGUgaXMgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSBDcmVhdGUgUmVhY3QgQXBwIEhNUiBkZXYgY2xpZW50IHRoYXRcbi8vIGNhbiBiZSBmb3VuZCBoZXJlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2NyZWF0ZS1yZWFjdC1hcHAvYmxvYi92My40LjEvcGFja2FnZXMvcmVhY3QtZGV2LXV0aWxzL3dlYnBhY2tIb3REZXZDbGllbnQuanNcbi8vIFRoaXMgYWx0ZXJuYXRpdmUgV2VicGFja0RldlNlcnZlciBjb21iaW5lcyB0aGUgZnVuY3Rpb25hbGl0eSBvZjpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2stZGV2LXNlcnZlci9ibG9iL3dlYnBhY2stMS9jbGllbnQvaW5kZXguanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2svYmxvYi93ZWJwYWNrLTEvaG90L2Rldi1zZXJ2ZXIuanNcbi8vIEl0IG9ubHkgc3VwcG9ydHMgdGhlaXIgc2ltcGxlc3QgY29uZmlndXJhdGlvbiAoaG90IHVwZGF0ZXMgb24gc2FtZSBzZXJ2ZXIpLlxuLy8gSXQgbWFrZXMgc29tZSBvcGluaW9uYXRlZCBjaG9pY2VzIG9uIHRvcCwgbGlrZSBhZGRpbmcgYSBzeW50YXggZXJyb3Igb3ZlcmxheVxuLy8gdGhhdCBsb29rcyBzaW1pbGFyIHRvIG91ciBjb25zb2xlIG91dHB1dC4gVGhlIGVycm9yIG92ZXJsYXkgaXMgaW5zcGlyZWQgYnk6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ2xlbmphbWluL3dlYnBhY2staG90LW1pZGRsZXdhcmVcbnZhciBoYWRSdW50aW1lRXJyb3I9ZmFsc2U7dmFyIGN1c3RvbUhtckV2ZW50SGFuZGxlcjtmdW5jdGlvbiBjb25uZWN0KG9wdGlvbnMpe0Rldk92ZXJsYXkucmVnaXN0ZXIoKTsoMCxfZXZlbnRzb3VyY2UuZ2V0RXZlbnRTb3VyY2VXcmFwcGVyKShvcHRpb25zKS5hZGRNZXNzYWdlTGlzdGVuZXIoZXZlbnQ9PnsvLyBUaGlzIGlzIHRoZSBoZWFydGJlYXQgZXZlbnRcbmlmKGV2ZW50LmRhdGE9PT0nXFx1RDgzRFxcdURDOTMnKXtyZXR1cm47fXRyeXtwcm9jZXNzTWVzc2FnZShldmVudCk7fWNhdGNoKGV4KXtjb25zb2xlLndhcm4oJ0ludmFsaWQgSE1SIG1lc3NhZ2U6ICcrZXZlbnQuZGF0YSsnXFxuJytleCk7fX0pO3JldHVybntzdWJzY3JpYmVUb0htckV2ZW50KGhhbmRsZXIpe2N1c3RvbUhtckV2ZW50SGFuZGxlcj1oYW5kbGVyO30sb25VbnJlY292ZXJhYmxlRXJyb3IoKXtoYWRSdW50aW1lRXJyb3I9dHJ1ZTt9fTt9Ly8gUmVtZW1iZXIgc29tZSBzdGF0ZSByZWxhdGVkIHRvIGhvdCBtb2R1bGUgcmVwbGFjZW1lbnQuXG52YXIgaXNGaXJzdENvbXBpbGF0aW9uPXRydWU7dmFyIG1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2g9bnVsbDt2YXIgaGFzQ29tcGlsZUVycm9ycz1mYWxzZTtmdW5jdGlvbiBjbGVhck91dGRhdGVkRXJyb3JzKCl7Ly8gQ2xlYW4gdXAgb3V0ZGF0ZWQgY29tcGlsZSBlcnJvcnMsIGlmIGFueS5cbmlmKHR5cGVvZiBjb25zb2xlIT09J3VuZGVmaW5lZCcmJnR5cGVvZiBjb25zb2xlLmNsZWFyPT09J2Z1bmN0aW9uJyl7aWYoaGFzQ29tcGlsZUVycm9ycyl7Y29uc29sZS5jbGVhcigpO319fS8vIFN1Y2Nlc3NmdWwgY29tcGlsYXRpb24uXG5mdW5jdGlvbiBoYW5kbGVTdWNjZXNzKCl7Y2xlYXJPdXRkYXRlZEVycm9ycygpO3ZhciBpc0hvdFVwZGF0ZT0haXNGaXJzdENvbXBpbGF0aW9uO2lzRmlyc3RDb21waWxhdGlvbj1mYWxzZTtoYXNDb21waWxlRXJyb3JzPWZhbHNlOy8vIEF0dGVtcHQgdG8gYXBwbHkgaG90IHVwZGF0ZXMgb3IgcmVsb2FkLlxuaWYoaXNIb3RVcGRhdGUpe3RyeUFwcGx5VXBkYXRlcyhmdW5jdGlvbiBvblN1Y2Nlc3NmdWxIb3RVcGRhdGUoaGFzVXBkYXRlcyl7Ly8gT25seSBkaXNtaXNzIGl0IHdoZW4gd2UncmUgc3VyZSBpdCdzIGEgaG90IHVwZGF0ZS5cbi8vIE90aGVyd2lzZSBpdCB3b3VsZCBmbGlja2VyIHJpZ2h0IGJlZm9yZSB0aGUgcmVsb2FkLlxub25GYXN0UmVmcmVzaChoYXNVcGRhdGVzKTt9KTt9fS8vIENvbXBpbGF0aW9uIHdpdGggd2FybmluZ3MgKGUuZy4gRVNMaW50KS5cbmZ1bmN0aW9uIGhhbmRsZVdhcm5pbmdzKHdhcm5pbmdzKXtjbGVhck91dGRhdGVkRXJyb3JzKCk7dmFyIGlzSG90VXBkYXRlPSFpc0ZpcnN0Q29tcGlsYXRpb247aXNGaXJzdENvbXBpbGF0aW9uPWZhbHNlO2hhc0NvbXBpbGVFcnJvcnM9ZmFsc2U7ZnVuY3Rpb24gcHJpbnRXYXJuaW5ncygpey8vIFByaW50IHdhcm5pbmdzIHRvIHRoZSBjb25zb2xlLlxudmFyIGZvcm1hdHRlZD0oMCxfZm9ybWF0V2VicGFja01lc3NhZ2VzLmRlZmF1bHQpKHt3YXJuaW5nczp3YXJuaW5ncyxlcnJvcnM6W119KTtpZih0eXBlb2YgY29uc29sZSE9PSd1bmRlZmluZWQnJiZ0eXBlb2YgY29uc29sZS53YXJuPT09J2Z1bmN0aW9uJyl7Zm9yKHZhciBpPTA7aTxmb3JtYXR0ZWQud2FybmluZ3MubGVuZ3RoO2krKyl7aWYoaT09PTUpe2NvbnNvbGUud2FybignVGhlcmUgd2VyZSBtb3JlIHdhcm5pbmdzIGluIG90aGVyIGZpbGVzLlxcbicrJ1lvdSBjYW4gZmluZCBhIGNvbXBsZXRlIGxvZyBpbiB0aGUgdGVybWluYWwuJyk7YnJlYWs7fWNvbnNvbGUud2FybigoMCxfc3RyaXBBbnNpLmRlZmF1bHQpKGZvcm1hdHRlZC53YXJuaW5nc1tpXSkpO319fXByaW50V2FybmluZ3MoKTsvLyBBdHRlbXB0IHRvIGFwcGx5IGhvdCB1cGRhdGVzIG9yIHJlbG9hZC5cbmlmKGlzSG90VXBkYXRlKXt0cnlBcHBseVVwZGF0ZXMoZnVuY3Rpb24gb25TdWNjZXNzZnVsSG90VXBkYXRlKGhhc1VwZGF0ZXMpey8vIE9ubHkgZGlzbWlzcyBpdCB3aGVuIHdlJ3JlIHN1cmUgaXQncyBhIGhvdCB1cGRhdGUuXG4vLyBPdGhlcndpc2UgaXQgd291bGQgZmxpY2tlciByaWdodCBiZWZvcmUgdGhlIHJlbG9hZC5cbm9uRmFzdFJlZnJlc2goaGFzVXBkYXRlcyk7fSk7fX0vLyBDb21waWxhdGlvbiB3aXRoIGVycm9ycyAoZS5nLiBzeW50YXggZXJyb3Igb3IgbWlzc2luZyBtb2R1bGVzKS5cbmZ1bmN0aW9uIGhhbmRsZUVycm9ycyhlcnJvcnMpe2NsZWFyT3V0ZGF0ZWRFcnJvcnMoKTtpc0ZpcnN0Q29tcGlsYXRpb249ZmFsc2U7aGFzQ29tcGlsZUVycm9ycz10cnVlOy8vIFwiTWFzc2FnZVwiIHdlYnBhY2sgbWVzc2FnZXMuXG52YXIgZm9ybWF0dGVkPSgwLF9mb3JtYXRXZWJwYWNrTWVzc2FnZXMuZGVmYXVsdCkoe2Vycm9yczplcnJvcnMsd2FybmluZ3M6W119KTsvLyBPbmx5IHNob3cgdGhlIGZpcnN0IGVycm9yLlxuRGV2T3ZlcmxheS5vbkJ1aWxkRXJyb3IoZm9ybWF0dGVkLmVycm9yc1swXSk7Ly8gQWxzbyBsb2cgdGhlbSB0byB0aGUgY29uc29sZS5cbmlmKHR5cGVvZiBjb25zb2xlIT09J3VuZGVmaW5lZCcmJnR5cGVvZiBjb25zb2xlLmVycm9yPT09J2Z1bmN0aW9uJyl7Zm9yKHZhciBpPTA7aTxmb3JtYXR0ZWQuZXJyb3JzLmxlbmd0aDtpKyspe2NvbnNvbGUuZXJyb3IoKDAsX3N0cmlwQW5zaS5kZWZhdWx0KShmb3JtYXR0ZWQuZXJyb3JzW2ldKSk7fX0vLyBEbyBub3QgYXR0ZW1wdCB0byByZWxvYWQgbm93LlxuLy8gV2Ugd2lsbCByZWxvYWQgb24gbmV4dCBzdWNjZXNzIGluc3RlYWQuXG5pZihwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKXtpZihzZWxmLl9fTkVYVF9ITVJfQ0Ipe3NlbGYuX19ORVhUX0hNUl9DQihmb3JtYXR0ZWQuZXJyb3JzWzBdKTtzZWxmLl9fTkVYVF9ITVJfQ0I9bnVsbDt9fX1mdW5jdGlvbiBvbkZhc3RSZWZyZXNoKGhhc1VwZGF0ZXMpe0Rldk92ZXJsYXkub25CdWlsZE9rKCk7aWYoaGFzVXBkYXRlcyl7RGV2T3ZlcmxheS5vblJlZnJlc2goKTt9Y29uc29sZS5sb2coJ1tGYXN0IFJlZnJlc2hdIGRvbmUnKTt9Ly8gVGhlcmUgaXMgYSBuZXdlciB2ZXJzaW9uIG9mIHRoZSBjb2RlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIGhhbmRsZUF2YWlsYWJsZUhhc2goaGFzaCl7Ly8gVXBkYXRlIGxhc3Qga25vd24gY29tcGlsYXRpb24gaGFzaC5cbm1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2g9aGFzaDt9Ly8gSGFuZGxlIG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlci5cbmZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlKGUpe3ZhciBvYmo9SlNPTi5wYXJzZShlLmRhdGEpO3N3aXRjaChvYmouYWN0aW9uKXtjYXNlJ2J1aWxkaW5nJzp7Y29uc29sZS5sb2coJ1tGYXN0IFJlZnJlc2hdIHJlYnVpbGRpbmcnKTticmVhazt9Y2FzZSdidWlsdCc6Y2FzZSdzeW5jJzp7aWYob2JqLmhhc2gpe2hhbmRsZUF2YWlsYWJsZUhhc2gob2JqLmhhc2gpO312YXJ7ZXJyb3JzLHdhcm5pbmdzfT1vYmo7dmFyIGhhc0Vycm9ycz1Cb29sZWFuKGVycm9ycyYmZXJyb3JzLmxlbmd0aCk7aWYoaGFzRXJyb3JzKXtyZXR1cm4gaGFuZGxlRXJyb3JzKGVycm9ycyk7fXZhciBoYXNXYXJuaW5ncz1Cb29sZWFuKHdhcm5pbmdzJiZ3YXJuaW5ncy5sZW5ndGgpO2lmKGhhc1dhcm5pbmdzKXtyZXR1cm4gaGFuZGxlV2FybmluZ3Mod2FybmluZ3MpO31yZXR1cm4gaGFuZGxlU3VjY2VzcygpO31kZWZhdWx0OntpZihjdXN0b21IbXJFdmVudEhhbmRsZXIpe2N1c3RvbUhtckV2ZW50SGFuZGxlcihvYmopO2JyZWFrO31icmVhazt9fX0vLyBJcyB0aGVyZSBhIG5ld2VyIHZlcnNpb24gb2YgdGhpcyBjb2RlIGF2YWlsYWJsZT9cbmZ1bmN0aW9uIGlzVXBkYXRlQXZhaWxhYmxlKCl7LyogZ2xvYmFscyBfX3dlYnBhY2tfaGFzaF9fICovIC8vIF9fd2VicGFja19oYXNoX18gaXMgdGhlIGhhc2ggb2YgdGhlIGN1cnJlbnQgY29tcGlsYXRpb24uXG4vLyBJdCdzIGEgZ2xvYmFsIHZhcmlhYmxlIGluamVjdGVkIGJ5IFdlYnBhY2suXG5yZXR1cm4gbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCE9PV9fd2VicGFja19oYXNoX187fS8vIFdlYnBhY2sgZGlzYWxsb3dzIHVwZGF0ZXMgaW4gb3RoZXIgc3RhdGVzLlxuZnVuY3Rpb24gY2FuQXBwbHlVcGRhdGVzKCl7cmV0dXJuIG1vZHVsZS5ob3Quc3RhdHVzKCk9PT0naWRsZSc7fWZ1bmN0aW9uIGFmdGVyQXBwbHlVcGRhdGVzKGZuKXtpZihjYW5BcHBseVVwZGF0ZXMoKSl7Zm4oKTt9ZWxzZXtmdW5jdGlvbiBoYW5kbGVyKHN0YXR1cyl7aWYoc3RhdHVzPT09J2lkbGUnKXttb2R1bGUuaG90LnJlbW92ZVN0YXR1c0hhbmRsZXIoaGFuZGxlcik7Zm4oKTt9fW1vZHVsZS5ob3QuYWRkU3RhdHVzSGFuZGxlcihoYW5kbGVyKTt9fS8vIEF0dGVtcHQgdG8gdXBkYXRlIGNvZGUgb24gdGhlIGZseSwgZmFsbCBiYWNrIHRvIGEgaGFyZCByZWxvYWQuXG5mdW5jdGlvbiB0cnlBcHBseVVwZGF0ZXMob25Ib3RVcGRhdGVTdWNjZXNzKXtpZighbW9kdWxlLmhvdCl7Ly8gSG90TW9kdWxlUmVwbGFjZW1lbnRQbHVnaW4gaXMgbm90IGluIFdlYnBhY2sgY29uZmlndXJhdGlvbi5cbmNvbnNvbGUuZXJyb3IoJ0hvdE1vZHVsZVJlcGxhY2VtZW50UGx1Z2luIGlzIG5vdCBpbiBXZWJwYWNrIGNvbmZpZ3VyYXRpb24uJyk7Ly8gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xucmV0dXJuO31pZighaXNVcGRhdGVBdmFpbGFibGUoKXx8IWNhbkFwcGx5VXBkYXRlcygpKXtyZXR1cm47fWZ1bmN0aW9uIGhhbmRsZUFwcGx5VXBkYXRlcyhlcnIsdXBkYXRlZE1vZHVsZXMpe2lmKGVycnx8aGFkUnVudGltZUVycm9yfHwhdXBkYXRlZE1vZHVsZXMpe2lmKGVycil7Y29uc29sZS53YXJuKCdbRmFzdCBSZWZyZXNoXSBwZXJmb3JtaW5nIGZ1bGwgcmVsb2FkXFxuXFxuJytcIkZhc3QgUmVmcmVzaCB3aWxsIHBlcmZvcm0gYSBmdWxsIHJlbG9hZCB3aGVuIHlvdSBlZGl0IGEgZmlsZSB0aGF0J3MgaW1wb3J0ZWQgYnkgbW9kdWxlcyBvdXRzaWRlIG9mIHRoZSBSZWFjdCB0cmVlLlxcblwiKydZb3UgbWlnaHQgaGF2ZSBhIGZpbGUgd2hpY2ggcmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBidXQgYWxzbyBleHBvcnRzIGEgdmFsdWUgdGhhdCBpcyBpbXBvcnRlZCBieSBhIG5vbi1SZWFjdCBjb21wb25lbnQuXFxuJysnQ29uc2lkZXIgbWlncmF0aW5nIHRoZSBub24tUmVhY3QgY29tcG9uZW50IGV4cG9ydCB0byBhIHNlcGFyYXRlIGZpbGUgYW5kIGltcG9ydGluZyBpdCBpbnRvIGJvdGggZmlsZXMuXFxuXFxuJysnSXQgaXMgYWxzbyBwb3NzaWJsZSB5b3UgYXJlIHVzaW5nIGNsYXNzIGNvbXBvbmVudHMgYXQgdGhlIHRvcC1sZXZlbCBvZiB5b3VyIGFwcGxpY2F0aW9uLCB3aGljaCBkaXNhYmxlcyBGYXN0IFJlZnJlc2guXFxuJysnRmFzdCBSZWZyZXNoIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBmdW5jdGlvbiBjb21wb25lbnQgaW4geW91ciBSZWFjdCB0cmVlLicpO31lbHNlIGlmKGhhZFJ1bnRpbWVFcnJvcil7Y29uc29sZS53YXJuKCdbRmFzdCBSZWZyZXNoXSBwZXJmb3JtaW5nIGZ1bGwgcmVsb2FkIGJlY2F1c2UgeW91ciBhcHBsaWNhdGlvbiBoYWQgYW4gdW5yZWNvdmVyYWJsZSBlcnJvcicpO313aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7cmV0dXJuO312YXIgaGFzVXBkYXRlcz1Cb29sZWFuKHVwZGF0ZWRNb2R1bGVzLmxlbmd0aCk7aWYodHlwZW9mIG9uSG90VXBkYXRlU3VjY2Vzcz09PSdmdW5jdGlvbicpey8vIE1heWJlIHdlIHdhbnQgdG8gZG8gc29tZXRoaW5nLlxub25Ib3RVcGRhdGVTdWNjZXNzKGhhc1VwZGF0ZXMpO31pZihpc1VwZGF0ZUF2YWlsYWJsZSgpKXsvLyBXaGlsZSB3ZSB3ZXJlIHVwZGF0aW5nLCB0aGVyZSB3YXMgYSBuZXcgdXBkYXRlISBEbyBpdCBhZ2Fpbi5cbnRyeUFwcGx5VXBkYXRlcyhoYXNVcGRhdGVzP3VuZGVmaW5lZDpvbkhvdFVwZGF0ZVN1Y2Nlc3MpO31lbHNle2lmKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpe2FmdGVyQXBwbHlVcGRhdGVzKCgpPT57aWYoc2VsZi5fX05FWFRfSE1SX0NCKXtzZWxmLl9fTkVYVF9ITVJfQ0IoKTtzZWxmLl9fTkVYVF9ITVJfQ0I9bnVsbDt9fSk7fX19Ly8gaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9hcGkvaG90LW1vZHVsZS1yZXBsYWNlbWVudC8jY2hlY2tcbm1vZHVsZS5ob3QuY2hlY2soLyogYXV0b0FwcGx5ICovdHJ1ZSkudGhlbih1cGRhdGVkTW9kdWxlcz0+e2hhbmRsZUFwcGx5VXBkYXRlcyhudWxsLHVwZGF0ZWRNb2R1bGVzKTt9LGVycj0+e2hhbmRsZUFwcGx5VXBkYXRlcyhlcnIsbnVsbCk7fSk7fSIsIlwidXNlIHN0cmljdFwiO3ZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0PXJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLmRlZmF1bHQ9dm9pZCAwO3ZhciBfdW5mZXRjaD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJuZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3VuZmV0Y2hcIikpOy8qIGVzbGludC1kaXNhYmxlICovIC8vIEltcHJvdmVkIHZlcnNpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL1lhZmZsZS9FdmVudFNvdXJjZS9cbi8vIEF2YWlsYWJsZSB1bmRlciBNSVQgTGljZW5zZSAoTUlUKVxuLy8gT25seSB0cmllcyB0byBzdXBwb3J0IElFMTEgYW5kIG5vdGhpbmcgYmVsb3dcbnZhciBkb2N1bWVudD13aW5kb3cuZG9jdW1lbnQ7dmFyIFJlc3BvbnNlPXdpbmRvdy5SZXNwb25zZTt2YXIgVGV4dERlY29kZXI9d2luZG93LlRleHREZWNvZGVyO3ZhciBUZXh0RW5jb2Rlcj13aW5kb3cuVGV4dEVuY29kZXI7dmFyIEFib3J0Q29udHJvbGxlcj13aW5kb3cuQWJvcnRDb250cm9sbGVyO2lmKEFib3J0Q29udHJvbGxlcj09dW5kZWZpbmVkKXtBYm9ydENvbnRyb2xsZXI9ZnVuY3Rpb24gQWJvcnRDb250cm9sbGVyKCl7dGhpcy5zaWduYWw9bnVsbDt0aGlzLmFib3J0PWZ1bmN0aW9uKCl7fTt9O31mdW5jdGlvbiBUZXh0RGVjb2RlclBvbHlmaWxsKCl7dGhpcy5iaXRzTmVlZGVkPTA7dGhpcy5jb2RlUG9pbnQ9MDt9VGV4dERlY29kZXJQb2x5ZmlsbC5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKG9jdGV0cyl7ZnVuY3Rpb24gdmFsaWQoY29kZVBvaW50LHNoaWZ0LG9jdGV0c0NvdW50KXtpZihvY3RldHNDb3VudD09PTEpe3JldHVybiBjb2RlUG9pbnQ+PTB4MDA4MD4+c2hpZnQmJmNvZGVQb2ludDw8c2hpZnQ8PTB4MDdmZjt9aWYob2N0ZXRzQ291bnQ9PT0yKXtyZXR1cm4gY29kZVBvaW50Pj0weDA4MDA+PnNoaWZ0JiZjb2RlUG9pbnQ8PHNoaWZ0PD0weGQ3ZmZ8fGNvZGVQb2ludD49MHhlMDAwPj5zaGlmdCYmY29kZVBvaW50PDxzaGlmdDw9MHhmZmZmO31pZihvY3RldHNDb3VudD09PTMpe3JldHVybiBjb2RlUG9pbnQ+PTB4MDEwMDAwPj5zaGlmdCYmY29kZVBvaW50PDxzaGlmdDw9MHgxMGZmZmY7fXRocm93IG5ldyBFcnJvcigpO31mdW5jdGlvbiBvY3RldHNDb3VudChiaXRzTmVlZGVkLGNvZGVQb2ludCl7aWYoYml0c05lZWRlZD09PTYqMSl7cmV0dXJuIGNvZGVQb2ludD4+Nj4xNT8zOmNvZGVQb2ludD4zMT8yOjE7fWlmKGJpdHNOZWVkZWQ9PT02KjIpe3JldHVybiBjb2RlUG9pbnQ+MTU/MzoyO31pZihiaXRzTmVlZGVkPT09NiozKXtyZXR1cm4gMzt9dGhyb3cgbmV3IEVycm9yKCk7fXZhciBSRVBMQUNFUj0weGZmZmQ7dmFyIHN0cmluZz0nJzt2YXIgYml0c05lZWRlZD10aGlzLmJpdHNOZWVkZWQ7dmFyIGNvZGVQb2ludD10aGlzLmNvZGVQb2ludDtmb3IodmFyIGk9MDtpPG9jdGV0cy5sZW5ndGg7aSs9MSl7dmFyIG9jdGV0PW9jdGV0c1tpXTtpZihiaXRzTmVlZGVkIT09MCl7aWYob2N0ZXQ8MTI4fHxvY3RldD4xOTF8fCF2YWxpZChjb2RlUG9pbnQ8PDZ8b2N0ZXQmNjMsYml0c05lZWRlZC02LG9jdGV0c0NvdW50KGJpdHNOZWVkZWQsY29kZVBvaW50KSkpe2JpdHNOZWVkZWQ9MDtjb2RlUG9pbnQ9UkVQTEFDRVI7c3RyaW5nKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7fX1pZihiaXRzTmVlZGVkPT09MCl7aWYob2N0ZXQ+PTAmJm9jdGV0PD0xMjcpe2JpdHNOZWVkZWQ9MDtjb2RlUG9pbnQ9b2N0ZXQ7fWVsc2UgaWYob2N0ZXQ+PTE5MiYmb2N0ZXQ8PTIyMyl7Yml0c05lZWRlZD02KjE7Y29kZVBvaW50PW9jdGV0JjMxO31lbHNlIGlmKG9jdGV0Pj0yMjQmJm9jdGV0PD0yMzkpe2JpdHNOZWVkZWQ9NioyO2NvZGVQb2ludD1vY3RldCYxNTt9ZWxzZSBpZihvY3RldD49MjQwJiZvY3RldDw9MjQ3KXtiaXRzTmVlZGVkPTYqMztjb2RlUG9pbnQ9b2N0ZXQmNzt9ZWxzZXtiaXRzTmVlZGVkPTA7Y29kZVBvaW50PVJFUExBQ0VSO31pZihiaXRzTmVlZGVkIT09MCYmIXZhbGlkKGNvZGVQb2ludCxiaXRzTmVlZGVkLG9jdGV0c0NvdW50KGJpdHNOZWVkZWQsY29kZVBvaW50KSkpe2JpdHNOZWVkZWQ9MDtjb2RlUG9pbnQ9UkVQTEFDRVI7fX1lbHNle2JpdHNOZWVkZWQtPTY7Y29kZVBvaW50PWNvZGVQb2ludDw8NnxvY3RldCY2Mzt9aWYoYml0c05lZWRlZD09PTApe2lmKGNvZGVQb2ludDw9MHhmZmZmKXtzdHJpbmcrPVN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTt9ZWxzZXtzdHJpbmcrPVN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODAwKyhjb2RlUG9pbnQtMHhmZmZmLTE+PjEwKSk7c3RyaW5nKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZGMwMCsoY29kZVBvaW50LTB4ZmZmZi0xJjB4M2ZmKSk7fX19dGhpcy5iaXRzTmVlZGVkPWJpdHNOZWVkZWQ7dGhpcy5jb2RlUG9pbnQ9Y29kZVBvaW50O3JldHVybiBzdHJpbmc7fTsvLyBGaXJlZm94IDwgMzggdGhyb3dzIGFuIGVycm9yIHdpdGggc3RyZWFtIG9wdGlvblxudmFyIHN1cHBvcnRzU3RyZWFtT3B0aW9uPWZ1bmN0aW9uIHN1cHBvcnRzU3RyZWFtT3B0aW9uKCl7dHJ5e3JldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCd0ZXN0Jykse3N0cmVhbTp0cnVlfSk9PT0ndGVzdCc7fWNhdGNoKGVycm9yKXtjb25zb2xlLmxvZyhlcnJvcik7fXJldHVybiBmYWxzZTt9Oy8vIElFLCBFZGdlXG5pZihUZXh0RGVjb2Rlcj09dW5kZWZpbmVkfHxUZXh0RW5jb2Rlcj09dW5kZWZpbmVkfHwhc3VwcG9ydHNTdHJlYW1PcHRpb24oKSl7VGV4dERlY29kZXI9VGV4dERlY29kZXJQb2x5ZmlsbDt9dmFyIGs9ZnVuY3Rpb24gaygpe307ZnVuY3Rpb24gWEhSV3JhcHBlcih4aHIpe3RoaXMud2l0aENyZWRlbnRpYWxzPWZhbHNlO3RoaXMucmVzcG9uc2VUeXBlPScnO3RoaXMucmVhZHlTdGF0ZT0wO3RoaXMuc3RhdHVzPTA7dGhpcy5zdGF0dXNUZXh0PScnO3RoaXMucmVzcG9uc2VUZXh0PScnO3RoaXMub25wcm9ncmVzcz1rO3RoaXMub25yZWFkeXN0YXRlY2hhbmdlPWs7dGhpcy5fY29udGVudFR5cGU9Jyc7dGhpcy5feGhyPXhocjt0aGlzLl9zZW5kVGltZW91dD0wO3RoaXMuX2Fib3J0PWs7fVhIUldyYXBwZXIucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24obWV0aG9kLHVybCl7dGhpcy5fYWJvcnQodHJ1ZSk7dmFyIHRoYXQ9dGhpczt2YXIgeGhyPXRoaXMuX3hocjt2YXIgc3RhdGU9MTt2YXIgdGltZW91dD0wO3RoaXMuX2Fib3J0PWZ1bmN0aW9uKHNpbGVudCl7aWYodGhhdC5fc2VuZFRpbWVvdXQhPT0wKXtjbGVhclRpbWVvdXQodGhhdC5fc2VuZFRpbWVvdXQpO3RoYXQuX3NlbmRUaW1lb3V0PTA7fWlmKHN0YXRlPT09MXx8c3RhdGU9PT0yfHxzdGF0ZT09PTMpe3N0YXRlPTQ7eGhyLm9ubG9hZD1rO3hoci5vbmVycm9yPWs7eGhyLm9uYWJvcnQ9azt4aHIub25wcm9ncmVzcz1rO3hoci5vbnJlYWR5c3RhdGVjaGFuZ2U9azsvLyBJRSA4IC0gOTogWERvbWFpblJlcXVlc3QjYWJvcnQoKSBkb2VzIG5vdCBmaXJlIGFueSBldmVudFxuLy8gT3BlcmEgPCAxMDogWE1MSHR0cFJlcXVlc3QjYWJvcnQoKSBkb2VzIG5vdCBmaXJlIGFueSBldmVudFxueGhyLmFib3J0KCk7aWYodGltZW91dCE9PTApe2NsZWFyVGltZW91dCh0aW1lb3V0KTt0aW1lb3V0PTA7fWlmKCFzaWxlbnQpe3RoYXQucmVhZHlTdGF0ZT00O3RoYXQub25yZWFkeXN0YXRlY2hhbmdlKCk7fX1zdGF0ZT0wO307dmFyIG9uU3RhcnQ9ZnVuY3Rpb24gb25TdGFydCgpe2lmKHN0YXRlPT09MSl7Ly8gc3RhdGUgPSAyO1xudmFyIHN0YXR1cz0wO3ZhciBzdGF0dXNUZXh0PScnO3ZhciBjb250ZW50VHlwZT11bmRlZmluZWQ7aWYoISgnY29udGVudFR5cGUnaW4geGhyKSl7dHJ5e3N0YXR1cz14aHIuc3RhdHVzO3N0YXR1c1RleHQ9eGhyLnN0YXR1c1RleHQ7Y29udGVudFR5cGU9eGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTt9Y2F0Y2goZXJyb3Ipey8vIElFIDwgMTAgdGhyb3dzIGV4Y2VwdGlvbiBmb3IgYHhoci5zdGF0dXNgIHdoZW4geGhyLnJlYWR5U3RhdGUgPT09IDIgfHwgeGhyLnJlYWR5U3RhdGUgPT09IDNcbi8vIE9wZXJhIDwgMTEgdGhyb3dzIGV4Y2VwdGlvbiBmb3IgYHhoci5zdGF0dXNgIHdoZW4geGhyLnJlYWR5U3RhdGUgPT09IDJcbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTEyMVxuc3RhdHVzPTA7c3RhdHVzVGV4dD0nJztjb250ZW50VHlwZT11bmRlZmluZWQ7Ly8gRmlyZWZveCA8IDE0LCBDaHJvbWUgPywgU2FmYXJpID9cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTY1OFxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTc3ODU0XG59fWVsc2V7c3RhdHVzPTIwMDtzdGF0dXNUZXh0PSdPSyc7Y29udGVudFR5cGU9eGhyLmNvbnRlbnRUeXBlO31pZihzdGF0dXMhPT0wKXtzdGF0ZT0yO3RoYXQucmVhZHlTdGF0ZT0yO3RoYXQuc3RhdHVzPXN0YXR1czt0aGF0LnN0YXR1c1RleHQ9c3RhdHVzVGV4dDt0aGF0Ll9jb250ZW50VHlwZT1jb250ZW50VHlwZTt0aGF0Lm9ucmVhZHlzdGF0ZWNoYW5nZSgpO319fTt2YXIgb25Qcm9ncmVzcz1mdW5jdGlvbiBvblByb2dyZXNzKCl7b25TdGFydCgpO2lmKHN0YXRlPT09Mnx8c3RhdGU9PT0zKXtzdGF0ZT0zO3ZhciByZXNwb25zZVRleHQ9Jyc7dHJ5e3Jlc3BvbnNlVGV4dD14aHIucmVzcG9uc2VUZXh0O31jYXRjaChlcnJvcil7Ly8gSUUgOCAtIDkgd2l0aCBYTUxIdHRwUmVxdWVzdFxufXRoYXQucmVhZHlTdGF0ZT0zO3RoYXQucmVzcG9uc2VUZXh0PXJlc3BvbnNlVGV4dDt0aGF0Lm9ucHJvZ3Jlc3MoKTt9fTt2YXIgb25GaW5pc2g9ZnVuY3Rpb24gb25GaW5pc2goKXsvLyBGaXJlZm94IDUyIGZpcmVzIFwicmVhZHlzdGF0ZWNoYW5nZVwiICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkgd2l0aG91dCBmaW5hbCBcInJlYWR5c3RhdGVjaGFuZ2VcIiAoeGhyLnJlYWR5U3RhdGUgPT09IDMpXG4vLyBJRSA4IGZpcmVzIFwib25sb2FkXCIgd2l0aG91dCBcIm9ucHJvZ3Jlc3NcIlxub25Qcm9ncmVzcygpO2lmKHN0YXRlPT09MXx8c3RhdGU9PT0yfHxzdGF0ZT09PTMpe3N0YXRlPTQ7aWYodGltZW91dCE9PTApe2NsZWFyVGltZW91dCh0aW1lb3V0KTt0aW1lb3V0PTA7fXRoYXQucmVhZHlTdGF0ZT00O3RoYXQub25yZWFkeXN0YXRlY2hhbmdlKCk7fX07dmFyIG9uUmVhZHlTdGF0ZUNoYW5nZT1mdW5jdGlvbiBvblJlYWR5U3RhdGVDaGFuZ2UoKXtpZih4aHIhPXVuZGVmaW5lZCl7Ly8gT3BlcmEgMTJcbmlmKHhoci5yZWFkeVN0YXRlPT09NCl7b25GaW5pc2goKTt9ZWxzZSBpZih4aHIucmVhZHlTdGF0ZT09PTMpe29uUHJvZ3Jlc3MoKTt9ZWxzZSBpZih4aHIucmVhZHlTdGF0ZT09PTIpe29uU3RhcnQoKTt9fX07dmFyIG9uVGltZW91dD1mdW5jdGlvbiBvblRpbWVvdXQoKXt0aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtvblRpbWVvdXQoKTt9LDUwMCk7aWYoeGhyLnJlYWR5U3RhdGU9PT0zKXtvblByb2dyZXNzKCk7fX07Ly8gWERvbWFpblJlcXVlc3QjYWJvcnQgcmVtb3ZlcyBvbnByb2dyZXNzLCBvbmVycm9yLCBvbmxvYWRcbnhoci5vbmxvYWQ9b25GaW5pc2g7eGhyLm9uZXJyb3I9b25GaW5pc2g7Ly8gaW1wcm9wZXIgZml4IHRvIG1hdGNoIEZpcmVmb3ggYmVoYXZpb3VyLCBidXQgaXQgaXMgYmV0dGVyIHRoYW4ganVzdCBpZ25vcmUgYWJvcnRcbi8vIHNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03Njg1OTZcbi8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4MDIwMFxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTE1MzU3MFxuLy8gSUUgOCBmaXJlcyBcIm9ubG9hZFwiIHdpdGhvdXQgXCJvbnByb2dyZXNzXG54aHIub25hYm9ydD1vbkZpbmlzaDsvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03MzY3MjNcbmlmKCEoJ3NlbmRBc0JpbmFyeSdpbiBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUpJiYhKCdtb3pBbm9uJ2luIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZSkpe3hoci5vbnByb2dyZXNzPW9uUHJvZ3Jlc3M7fS8vIElFIDggLSA5IChYTUxIVFRQUmVxdWVzdClcbi8vIE9wZXJhIDwgMTJcbi8vIEZpcmVmb3ggPCAzLjVcbi8vIEZpcmVmb3ggMy41IC0gMy42IC0gPyA8IDkuMFxuLy8gb25wcm9ncmVzcyBpcyBub3QgZmlyZWQgc29tZXRpbWVzIG9yIGRlbGF5ZWRcbi8vIHNlZSBhbHNvICM2NFxueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZT1vblJlYWR5U3RhdGVDaGFuZ2U7aWYoJ2NvbnRlbnRUeXBlJ2luIHhocil7dXJsKz0odXJsLmluZGV4T2YoJz8nKT09PS0xPyc/JzonJicpKydwYWRkaW5nPXRydWUnO314aHIub3BlbihtZXRob2QsdXJsLHRydWUpO2lmKCdyZWFkeVN0YXRlJ2luIHhocil7Ly8gd29ya2Fyb3VuZCBmb3IgT3BlcmEgMTIgaXNzdWUgd2l0aCBcInByb2dyZXNzXCIgZXZlbnRzXG4vLyAjOTFcbnRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe29uVGltZW91dCgpO30sMCk7fX07WEhSV3JhcHBlci5wcm90b3R5cGUuYWJvcnQ9ZnVuY3Rpb24oKXt0aGlzLl9hYm9ydChmYWxzZSk7fTtYSFJXcmFwcGVyLnByb3RvdHlwZS5nZXRSZXNwb25zZUhlYWRlcj1mdW5jdGlvbihuYW1lKXtyZXR1cm4gdGhpcy5fY29udGVudFR5cGU7fTtYSFJXcmFwcGVyLnByb3RvdHlwZS5zZXRSZXF1ZXN0SGVhZGVyPWZ1bmN0aW9uKG5hbWUsdmFsdWUpe3ZhciB4aHI9dGhpcy5feGhyO2lmKCdzZXRSZXF1ZXN0SGVhZGVyJ2luIHhocil7eGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSx2YWx1ZSk7fX07WEhSV3JhcHBlci5wcm90b3R5cGUuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3hoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMhPXVuZGVmaW5lZD90aGlzLl94aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk6Jyc7fTtYSFJXcmFwcGVyLnByb3RvdHlwZS5zZW5kPWZ1bmN0aW9uKCl7Ly8gbG9hZGluZyBpbmRpY2F0b3IgaW4gU2FmYXJpIDwgPyAoNiksIENocm9tZSA8IDE0LCBGaXJlZm94XG5pZighKCdvbnRpbWVvdXQnaW4gWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlKSYmZG9jdW1lbnQhPXVuZGVmaW5lZCYmZG9jdW1lbnQucmVhZHlTdGF0ZSE9dW5kZWZpbmVkJiZkb2N1bWVudC5yZWFkeVN0YXRlIT09J2NvbXBsZXRlJyl7dmFyIHRoYXQ9dGhpczt0aGF0Ll9zZW5kVGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhhdC5fc2VuZFRpbWVvdXQ9MDt0aGF0LnNlbmQoKTt9LDQpO3JldHVybjt9dmFyIHhocj10aGlzLl94aHI7Ly8gd2l0aENyZWRlbnRpYWxzIHNob3VsZCBiZSBzZXQgYWZ0ZXIgXCJvcGVuXCIgZm9yIFNhZmFyaSBhbmQgQ2hyb21lICg8IDE5ID8pXG54aHIud2l0aENyZWRlbnRpYWxzPXRoaXMud2l0aENyZWRlbnRpYWxzO3hoci5yZXNwb25zZVR5cGU9dGhpcy5yZXNwb25zZVR5cGU7dHJ5ey8vIHhoci5zZW5kKCk7IHRocm93cyBcIk5vdCBlbm91Z2ggYXJndW1lbnRzXCIgaW4gRmlyZWZveCAzLjBcbnhoci5zZW5kKHVuZGVmaW5lZCk7fWNhdGNoKGVycm9yMSl7Ly8gU2FmYXJpIDUuMS43LCBPcGVyYSAxMlxudGhyb3cgZXJyb3IxO319O2Z1bmN0aW9uIHRvTG93ZXJDYXNlKG5hbWUpe3JldHVybiBuYW1lLnJlcGxhY2UoL1tBLVpdL2csZnVuY3Rpb24oYyl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYy5jaGFyQ29kZUF0KDApKzB4MjApO30pO31mdW5jdGlvbiBIZWFkZXJzUG9seWZpbGwoYWxsKXsvLyBHZXQgaGVhZGVyczogaW1wbGVtZW50ZWQgYWNjb3JkaW5nIHRvIG1vemlsbGEncyBleGFtcGxlIGNvZGU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9nZXRBbGxSZXNwb25zZUhlYWRlcnMjRXhhbXBsZVxudmFyIG1hcD1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhcnJheT1hbGwuc3BsaXQoJ1xcclxcbicpO2Zvcih2YXIgaT0wO2k8YXJyYXkubGVuZ3RoO2krPTEpe3ZhciBsaW5lPWFycmF5W2ldO3ZhciBwYXJ0cz1saW5lLnNwbGl0KCc6ICcpO3ZhciBuYW1lPXBhcnRzLnNoaWZ0KCk7dmFyIHZhbHVlPXBhcnRzLmpvaW4oJzogJyk7bWFwW3RvTG93ZXJDYXNlKG5hbWUpXT12YWx1ZTt9dGhpcy5fbWFwPW1hcDt9SGVhZGVyc1BvbHlmaWxsLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24obmFtZSl7cmV0dXJuIHRoaXMuX21hcFt0b0xvd2VyQ2FzZShuYW1lKV07fTtmdW5jdGlvbiBYSFJUcmFuc3BvcnQoKXt9WEhSVHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKHhocixvblN0YXJ0Q2FsbGJhY2ssb25Qcm9ncmVzc0NhbGxiYWNrLG9uRmluaXNoQ2FsbGJhY2ssdXJsLHdpdGhDcmVkZW50aWFscyxoZWFkZXJzKXt4aHIub3BlbignR0VUJyx1cmwpO3ZhciBvZmZzZXQ9MDt4aHIub25wcm9ncmVzcz1mdW5jdGlvbigpe3ZhciByZXNwb25zZVRleHQ9eGhyLnJlc3BvbnNlVGV4dDt2YXIgY2h1bms9cmVzcG9uc2VUZXh0LnNsaWNlKG9mZnNldCk7b2Zmc2V0Kz1jaHVuay5sZW5ndGg7b25Qcm9ncmVzc0NhbGxiYWNrKGNodW5rKTt9O3hoci5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZih4aHIucmVhZHlTdGF0ZT09PTIpe3ZhciBzdGF0dXM9eGhyLnN0YXR1czt2YXIgc3RhdHVzVGV4dD14aHIuc3RhdHVzVGV4dDt2YXIgY29udGVudFR5cGU9eGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTt2YXIgaGVhZGVycz14aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7b25TdGFydENhbGxiYWNrKHN0YXR1cyxzdGF0dXNUZXh0LGNvbnRlbnRUeXBlLG5ldyBIZWFkZXJzUG9seWZpbGwoaGVhZGVycyksZnVuY3Rpb24oKXt4aHIuYWJvcnQoKTt9KTt9ZWxzZSBpZih4aHIucmVhZHlTdGF0ZT09PTQpe29uRmluaXNoQ2FsbGJhY2soKTt9fTt4aHIud2l0aENyZWRlbnRpYWxzPXdpdGhDcmVkZW50aWFsczt4aHIucmVzcG9uc2VUeXBlPSd0ZXh0Jztmb3IodmFyIG5hbWUgaW4gaGVhZGVycyl7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsbmFtZSkpe3hoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsaGVhZGVyc1tuYW1lXSk7fX14aHIuc2VuZCgpO307ZnVuY3Rpb24gSGVhZGVyc1dyYXBwZXIoaGVhZGVycyl7dGhpcy5faGVhZGVycz1oZWFkZXJzO31IZWFkZXJzV3JhcHBlci5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKG5hbWUpe3JldHVybiB0aGlzLl9oZWFkZXJzLmdldChuYW1lKTt9O2Z1bmN0aW9uIEZldGNoVHJhbnNwb3J0KCl7fUZldGNoVHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKHhocixvblN0YXJ0Q2FsbGJhY2ssb25Qcm9ncmVzc0NhbGxiYWNrLG9uRmluaXNoQ2FsbGJhY2ssdXJsLHdpdGhDcmVkZW50aWFscyxoZWFkZXJzKXt2YXIgY29udHJvbGxlcj1uZXcgQWJvcnRDb250cm9sbGVyKCk7dmFyIHNpZ25hbD1jb250cm9sbGVyLnNpZ25hbDsvLyBzZWUgIzEyMFxudmFyIHRleHREZWNvZGVyPW5ldyBUZXh0RGVjb2RlcigpOygwLF91bmZldGNoLmRlZmF1bHQpKHVybCx7aGVhZGVyczpoZWFkZXJzLGNyZWRlbnRpYWxzOndpdGhDcmVkZW50aWFscz8naW5jbHVkZSc6J3NhbWUtb3JpZ2luJyxzaWduYWw6c2lnbmFsLGNhY2hlOiduby1zdG9yZSd9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXt2YXIgcmVhZGVyPXJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7b25TdGFydENhbGxiYWNrKHJlc3BvbnNlLnN0YXR1cyxyZXNwb25zZS5zdGF0dXNUZXh0LHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSxuZXcgSGVhZGVyc1dyYXBwZXIocmVzcG9uc2UuaGVhZGVycyksZnVuY3Rpb24oKXtjb250cm9sbGVyLmFib3J0KCk7cmVhZGVyLmNhbmNlbCgpO30pO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7dmFyIHJlYWROZXh0Q2h1bms9ZnVuY3Rpb24gcmVhZE5leHRDaHVuaygpe3JlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbihyZXN1bHQpe2lmKHJlc3VsdC5kb25lKXsvLyBOb3RlOiBieXRlcyBpbiB0ZXh0RGVjb2RlciBhcmUgaWdub3JlZFxucmVzb2x2ZSh1bmRlZmluZWQpO31lbHNle3ZhciBjaHVuaz10ZXh0RGVjb2Rlci5kZWNvZGUocmVzdWx0LnZhbHVlLHtzdHJlYW06dHJ1ZX0pO29uUHJvZ3Jlc3NDYWxsYmFjayhjaHVuayk7cmVhZE5leHRDaHVuaygpO319KVsnY2F0Y2gnXShmdW5jdGlvbihlcnJvcil7cmVqZWN0KGVycm9yKTt9KTt9O3JlYWROZXh0Q2h1bmsoKTt9KTt9KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7b25GaW5pc2hDYWxsYmFjaygpO3JldHVybiByZXN1bHQ7fSxmdW5jdGlvbihlcnJvcil7b25GaW5pc2hDYWxsYmFjaygpO3JldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7fSk7fTtmdW5jdGlvbiBFdmVudFRhcmdldCgpe3RoaXMuX2xpc3RlbmVycz1PYmplY3QuY3JlYXRlKG51bGwpO31mdW5jdGlvbiB0aHJvd0Vycm9yKGUpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBlO30sMCk7fUV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50PWZ1bmN0aW9uKGV2ZW50KXtldmVudC50YXJnZXQ9dGhpczt2YXIgdHlwZUxpc3RlbmVycz10aGlzLl9saXN0ZW5lcnNbZXZlbnQudHlwZV07aWYodHlwZUxpc3RlbmVycyE9dW5kZWZpbmVkKXt2YXIgbGVuZ3RoPXR5cGVMaXN0ZW5lcnMubGVuZ3RoO2Zvcih2YXIgaT0wO2k8bGVuZ3RoO2krPTEpe3ZhciBsaXN0ZW5lcj10eXBlTGlzdGVuZXJzW2ldO3RyeXtpZih0eXBlb2YgbGlzdGVuZXIuaGFuZGxlRXZlbnQ9PT0nZnVuY3Rpb24nKXtsaXN0ZW5lci5oYW5kbGVFdmVudChldmVudCk7fWVsc2V7bGlzdGVuZXIuY2FsbCh0aGlzLGV2ZW50KTt9fWNhdGNoKGUpe3Rocm93RXJyb3IoZSk7fX19fTtFdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbih0eXBlLGxpc3RlbmVyKXt0eXBlPVN0cmluZyh0eXBlKTt2YXIgbGlzdGVuZXJzPXRoaXMuX2xpc3RlbmVyczt2YXIgdHlwZUxpc3RlbmVycz1saXN0ZW5lcnNbdHlwZV07aWYodHlwZUxpc3RlbmVycz09dW5kZWZpbmVkKXt0eXBlTGlzdGVuZXJzPVtdO2xpc3RlbmVyc1t0eXBlXT10eXBlTGlzdGVuZXJzO312YXIgZm91bmQ9ZmFsc2U7Zm9yKHZhciBpPTA7aTx0eXBlTGlzdGVuZXJzLmxlbmd0aDtpKz0xKXtpZih0eXBlTGlzdGVuZXJzW2ldPT09bGlzdGVuZXIpe2ZvdW5kPXRydWU7fX1pZighZm91bmQpe3R5cGVMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7fX07RXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24odHlwZSxsaXN0ZW5lcil7dHlwZT1TdHJpbmcodHlwZSk7dmFyIGxpc3RlbmVycz10aGlzLl9saXN0ZW5lcnM7dmFyIHR5cGVMaXN0ZW5lcnM9bGlzdGVuZXJzW3R5cGVdO2lmKHR5cGVMaXN0ZW5lcnMhPXVuZGVmaW5lZCl7dmFyIGZpbHRlcmVkPVtdO2Zvcih2YXIgaT0wO2k8dHlwZUxpc3RlbmVycy5sZW5ndGg7aSs9MSl7aWYodHlwZUxpc3RlbmVyc1tpXSE9PWxpc3RlbmVyKXtmaWx0ZXJlZC5wdXNoKHR5cGVMaXN0ZW5lcnNbaV0pO319aWYoZmlsdGVyZWQubGVuZ3RoPT09MCl7ZGVsZXRlIGxpc3RlbmVyc1t0eXBlXTt9ZWxzZXtsaXN0ZW5lcnNbdHlwZV09ZmlsdGVyZWQ7fX19O2Z1bmN0aW9uIEV2ZW50KHR5cGUpe3RoaXMudHlwZT10eXBlO3RoaXMudGFyZ2V0PXVuZGVmaW5lZDt9ZnVuY3Rpb24gTWVzc2FnZUV2ZW50KHR5cGUsb3B0aW9ucyl7RXZlbnQuY2FsbCh0aGlzLHR5cGUpO3RoaXMuZGF0YT1vcHRpb25zLmRhdGE7dGhpcy5sYXN0RXZlbnRJZD1vcHRpb25zLmxhc3RFdmVudElkO31NZXNzYWdlRXZlbnQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtmdW5jdGlvbiBDb25uZWN0aW9uRXZlbnQodHlwZSxvcHRpb25zKXtFdmVudC5jYWxsKHRoaXMsdHlwZSk7dGhpcy5zdGF0dXM9b3B0aW9ucy5zdGF0dXM7dGhpcy5zdGF0dXNUZXh0PW9wdGlvbnMuc3RhdHVzVGV4dDt0aGlzLmhlYWRlcnM9b3B0aW9ucy5oZWFkZXJzO31Db25uZWN0aW9uRXZlbnQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTt2YXIgV0FJVElORz0tMTt2YXIgQ09OTkVDVElORz0wO3ZhciBPUEVOPTE7dmFyIENMT1NFRD0yO3ZhciBBRlRFUl9DUj0tMTt2YXIgRklFTERfU1RBUlQ9MDt2YXIgRklFTEQ9MTt2YXIgVkFMVUVfU1RBUlQ9Mjt2YXIgVkFMVUU9Mzt2YXIgY29udGVudFR5cGVSZWdFeHA9L150ZXh0XFwvZXZlbnRcXC1zdHJlYW07PyhcXHMqY2hhcnNldFxcPXV0ZlxcLTgpPyQvaTt2YXIgTUlOSU1VTV9EVVJBVElPTj0xMDAwO3ZhciBNQVhJTVVNX0RVUkFUSU9OPTE4MDAwMDAwO3ZhciBwYXJzZUR1cmF0aW9uPWZ1bmN0aW9uIHBhcnNlRHVyYXRpb24odmFsdWUsZGVmKXt2YXIgbj1wYXJzZUludCh2YWx1ZSwxMCk7aWYobiE9PW4pe249ZGVmO31yZXR1cm4gY2xhbXBEdXJhdGlvbihuKTt9O3ZhciBjbGFtcER1cmF0aW9uPWZ1bmN0aW9uIGNsYW1wRHVyYXRpb24obil7cmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sTUlOSU1VTV9EVVJBVElPTiksTUFYSU1VTV9EVVJBVElPTik7fTt2YXIgZmlyZT1mdW5jdGlvbiBmaXJlKHRoYXQsZixldmVudCl7dHJ5e2lmKHR5cGVvZiBmPT09J2Z1bmN0aW9uJyl7Zi5jYWxsKHRoYXQsZXZlbnQpO319Y2F0Y2goZSl7dGhyb3dFcnJvcihlKTt9fTtmdW5jdGlvbiBFdmVudFNvdXJjZVBvbHlmaWxsKHVybCxvcHRpb25zKXtFdmVudFRhcmdldC5jYWxsKHRoaXMpO3RoaXMub25vcGVuPXVuZGVmaW5lZDt0aGlzLm9ubWVzc2FnZT11bmRlZmluZWQ7dGhpcy5vbmVycm9yPXVuZGVmaW5lZDt0aGlzLnVybD11bmRlZmluZWQ7dGhpcy5yZWFkeVN0YXRlPXVuZGVmaW5lZDt0aGlzLndpdGhDcmVkZW50aWFscz11bmRlZmluZWQ7dGhpcy5fY2xvc2U9dW5kZWZpbmVkO3N0YXJ0KHRoaXMsdXJsLG9wdGlvbnMpO312YXIgaXNGZXRjaFN1cHBvcnRlZD1fdW5mZXRjaC5kZWZhdWx0IT11bmRlZmluZWQmJlJlc3BvbnNlIT11bmRlZmluZWQmJidib2R5J2luIFJlc3BvbnNlLnByb3RvdHlwZTtmdW5jdGlvbiBzdGFydChlcyx1cmwsb3B0aW9ucyl7dXJsPVN0cmluZyh1cmwpO3ZhciB3aXRoQ3JlZGVudGlhbHM9b3B0aW9ucyE9dW5kZWZpbmVkJiZCb29sZWFuKG9wdGlvbnMud2l0aENyZWRlbnRpYWxzKTt2YXIgaW5pdGlhbFJldHJ5PWNsYW1wRHVyYXRpb24oMTAwMCk7dmFyIGhlYXJ0YmVhdFRpbWVvdXQ9b3B0aW9ucyE9dW5kZWZpbmVkJiZvcHRpb25zLmhlYXJ0YmVhdFRpbWVvdXQhPXVuZGVmaW5lZD9wYXJzZUR1cmF0aW9uKG9wdGlvbnMuaGVhcnRiZWF0VGltZW91dCw0NTAwMCk6Y2xhbXBEdXJhdGlvbig0NTAwMCk7dmFyIGxhc3RFdmVudElkPScnO3ZhciByZXRyeT1pbml0aWFsUmV0cnk7dmFyIHdhc0FjdGl2aXR5PWZhbHNlO3ZhciBoZWFkZXJzPW9wdGlvbnMhPXVuZGVmaW5lZCYmb3B0aW9ucy5oZWFkZXJzIT11bmRlZmluZWQ/SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvcHRpb25zLmhlYWRlcnMpKTp1bmRlZmluZWQ7dmFyIEN1cnJlbnRUcmFuc3BvcnQ9b3B0aW9ucyE9dW5kZWZpbmVkJiZvcHRpb25zLlRyYW5zcG9ydCE9dW5kZWZpbmVkP29wdGlvbnMuVHJhbnNwb3J0OlhNTEh0dHBSZXF1ZXN0O3ZhciB4aHI9aXNGZXRjaFN1cHBvcnRlZCYmIShvcHRpb25zIT11bmRlZmluZWQmJm9wdGlvbnMuVHJhbnNwb3J0IT11bmRlZmluZWQpP3VuZGVmaW5lZDpuZXcgWEhSV3JhcHBlcihuZXcgQ3VycmVudFRyYW5zcG9ydCgpKTt2YXIgdHJhbnNwb3J0PXhocj09dW5kZWZpbmVkP25ldyBGZXRjaFRyYW5zcG9ydCgpOm5ldyBYSFJUcmFuc3BvcnQoKTt2YXIgY2FuY2VsRnVuY3Rpb249dW5kZWZpbmVkO3ZhciB0aW1lb3V0PTA7dmFyIGN1cnJlbnRTdGF0ZT1XQUlUSU5HO3ZhciBkYXRhQnVmZmVyPScnO3ZhciBsYXN0RXZlbnRJZEJ1ZmZlcj0nJzt2YXIgZXZlbnRUeXBlQnVmZmVyPScnO3ZhciB0ZXh0QnVmZmVyPScnO3ZhciBzdGF0ZT1GSUVMRF9TVEFSVDt2YXIgZmllbGRTdGFydD0wO3ZhciB2YWx1ZVN0YXJ0PTA7dmFyIG9uU3RhcnQ9ZnVuY3Rpb24gb25TdGFydChzdGF0dXMsc3RhdHVzVGV4dCxjb250ZW50VHlwZSxoZWFkZXJzLGNhbmNlbCl7aWYoY3VycmVudFN0YXRlPT09Q09OTkVDVElORyl7Y2FuY2VsRnVuY3Rpb249Y2FuY2VsO2lmKHN0YXR1cz09PTIwMCYmY29udGVudFR5cGUhPXVuZGVmaW5lZCYmY29udGVudFR5cGVSZWdFeHAudGVzdChjb250ZW50VHlwZSkpe2N1cnJlbnRTdGF0ZT1PUEVOO3dhc0FjdGl2aXR5PXRydWU7cmV0cnk9aW5pdGlhbFJldHJ5O2VzLnJlYWR5U3RhdGU9T1BFTjt2YXIgZXZlbnQ9bmV3IENvbm5lY3Rpb25FdmVudCgnb3Blbicse3N0YXR1czpzdGF0dXMsc3RhdHVzVGV4dDpzdGF0dXNUZXh0LGhlYWRlcnM6aGVhZGVyc30pO2VzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO2ZpcmUoZXMsZXMub25vcGVuLGV2ZW50KTt9ZWxzZXt2YXIgbWVzc2FnZT0nJztpZihzdGF0dXMhPT0yMDApe2lmKHN0YXR1c1RleHQpe3N0YXR1c1RleHQ9c3RhdHVzVGV4dC5yZXBsYWNlKC9cXHMrL2csJyAnKTt9bWVzc2FnZT1cIkV2ZW50U291cmNlJ3MgcmVzcG9uc2UgaGFzIGEgc3RhdHVzIFwiK3N0YXR1cysnICcrc3RhdHVzVGV4dCsnIHRoYXQgaXMgbm90IDIwMC4gQWJvcnRpbmcgdGhlIGNvbm5lY3Rpb24uJzt9ZWxzZXttZXNzYWdlPVwiRXZlbnRTb3VyY2UncyByZXNwb25zZSBoYXMgYSBDb250ZW50LVR5cGUgc3BlY2lmeWluZyBhbiB1bnN1cHBvcnRlZCB0eXBlOiBcIisoY29udGVudFR5cGU9PXVuZGVmaW5lZD8nLSc6Y29udGVudFR5cGUucmVwbGFjZSgvXFxzKy9nLCcgJykpKycuIEFib3J0aW5nIHRoZSBjb25uZWN0aW9uLic7fXRocm93RXJyb3IobmV3IEVycm9yKG1lc3NhZ2UpKTtjbG9zZSgpO3ZhciBldmVudD1uZXcgQ29ubmVjdGlvbkV2ZW50KCdlcnJvcicse3N0YXR1czpzdGF0dXMsc3RhdHVzVGV4dDpzdGF0dXNUZXh0LGhlYWRlcnM6aGVhZGVyc30pO2VzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO2ZpcmUoZXMsZXMub25lcnJvcixldmVudCk7fX19O3ZhciBvblByb2dyZXNzPWZ1bmN0aW9uIG9uUHJvZ3Jlc3ModGV4dENodW5rKXtpZihjdXJyZW50U3RhdGU9PT1PUEVOKXt2YXIgbj0tMTtmb3IodmFyIGk9MDtpPHRleHRDaHVuay5sZW5ndGg7aSs9MSl7dmFyIGM9dGV4dENodW5rLmNoYXJDb2RlQXQoaSk7aWYoYz09PSdcXG4nLmNoYXJDb2RlQXQoMCl8fGM9PT0nXFxyJy5jaGFyQ29kZUF0KDApKXtuPWk7fX12YXIgY2h1bms9KG4hPT0tMT90ZXh0QnVmZmVyOicnKSt0ZXh0Q2h1bmsuc2xpY2UoMCxuKzEpO3RleHRCdWZmZXI9KG49PT0tMT90ZXh0QnVmZmVyOicnKSt0ZXh0Q2h1bmsuc2xpY2UobisxKTtpZihjaHVuayE9PScnKXt3YXNBY3Rpdml0eT10cnVlO31mb3IodmFyIHBvc2l0aW9uPTA7cG9zaXRpb248Y2h1bmsubGVuZ3RoO3Bvc2l0aW9uKz0xKXt2YXIgYz1jaHVuay5jaGFyQ29kZUF0KHBvc2l0aW9uKTtpZihzdGF0ZT09PUFGVEVSX0NSJiZjPT09J1xcbicuY2hhckNvZGVBdCgwKSl7c3RhdGU9RklFTERfU1RBUlQ7fWVsc2V7aWYoc3RhdGU9PT1BRlRFUl9DUil7c3RhdGU9RklFTERfU1RBUlQ7fWlmKGM9PT0nXFxyJy5jaGFyQ29kZUF0KDApfHxjPT09J1xcbicuY2hhckNvZGVBdCgwKSl7aWYoc3RhdGUhPT1GSUVMRF9TVEFSVCl7aWYoc3RhdGU9PT1GSUVMRCl7dmFsdWVTdGFydD1wb3NpdGlvbisxO312YXIgZmllbGQ9Y2h1bmsuc2xpY2UoZmllbGRTdGFydCx2YWx1ZVN0YXJ0LTEpO3ZhciB2YWx1ZT1jaHVuay5zbGljZSh2YWx1ZVN0YXJ0Kyh2YWx1ZVN0YXJ0PHBvc2l0aW9uJiZjaHVuay5jaGFyQ29kZUF0KHZhbHVlU3RhcnQpPT09JyAnLmNoYXJDb2RlQXQoMCk/MTowKSxwb3NpdGlvbik7aWYoZmllbGQ9PT0nZGF0YScpe2RhdGFCdWZmZXIrPSdcXG4nO2RhdGFCdWZmZXIrPXZhbHVlO31lbHNlIGlmKGZpZWxkPT09J2lkJyl7bGFzdEV2ZW50SWRCdWZmZXI9dmFsdWU7fWVsc2UgaWYoZmllbGQ9PT0nZXZlbnQnKXtldmVudFR5cGVCdWZmZXI9dmFsdWU7fWVsc2UgaWYoZmllbGQ9PT0ncmV0cnknKXtpbml0aWFsUmV0cnk9cGFyc2VEdXJhdGlvbih2YWx1ZSxpbml0aWFsUmV0cnkpO3JldHJ5PWluaXRpYWxSZXRyeTt9ZWxzZSBpZihmaWVsZD09PSdoZWFydGJlYXRUaW1lb3V0Jyl7aGVhcnRiZWF0VGltZW91dD1wYXJzZUR1cmF0aW9uKHZhbHVlLGhlYXJ0YmVhdFRpbWVvdXQpO2lmKHRpbWVvdXQhPT0wKXtjbGVhclRpbWVvdXQodGltZW91dCk7dGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b25UaW1lb3V0KCk7fSxoZWFydGJlYXRUaW1lb3V0KTt9fX1pZihzdGF0ZT09PUZJRUxEX1NUQVJUKXtpZihkYXRhQnVmZmVyIT09Jycpe2xhc3RFdmVudElkPWxhc3RFdmVudElkQnVmZmVyO2lmKGV2ZW50VHlwZUJ1ZmZlcj09PScnKXtldmVudFR5cGVCdWZmZXI9J21lc3NhZ2UnO312YXIgZXZlbnQ9bmV3IE1lc3NhZ2VFdmVudChldmVudFR5cGVCdWZmZXIse2RhdGE6ZGF0YUJ1ZmZlci5zbGljZSgxKSxsYXN0RXZlbnRJZDpsYXN0RXZlbnRJZEJ1ZmZlcn0pO2VzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO2lmKGV2ZW50VHlwZUJ1ZmZlcj09PSdtZXNzYWdlJyl7ZmlyZShlcyxlcy5vbm1lc3NhZ2UsZXZlbnQpO31pZihjdXJyZW50U3RhdGU9PT1DTE9TRUQpe3JldHVybjt9fWRhdGFCdWZmZXI9Jyc7ZXZlbnRUeXBlQnVmZmVyPScnO31zdGF0ZT1jPT09J1xccicuY2hhckNvZGVBdCgwKT9BRlRFUl9DUjpGSUVMRF9TVEFSVDt9ZWxzZXtpZihzdGF0ZT09PUZJRUxEX1NUQVJUKXtmaWVsZFN0YXJ0PXBvc2l0aW9uO3N0YXRlPUZJRUxEO31pZihzdGF0ZT09PUZJRUxEKXtpZihjPT09JzonLmNoYXJDb2RlQXQoMCkpe3ZhbHVlU3RhcnQ9cG9zaXRpb24rMTtzdGF0ZT1WQUxVRV9TVEFSVDt9fWVsc2UgaWYoc3RhdGU9PT1WQUxVRV9TVEFSVCl7c3RhdGU9VkFMVUU7fX19fX19O3ZhciBvbkZpbmlzaD1mdW5jdGlvbiBvbkZpbmlzaCgpe2lmKGN1cnJlbnRTdGF0ZT09PU9QRU58fGN1cnJlbnRTdGF0ZT09PUNPTk5FQ1RJTkcpe2N1cnJlbnRTdGF0ZT1XQUlUSU5HO2lmKHRpbWVvdXQhPT0wKXtjbGVhclRpbWVvdXQodGltZW91dCk7dGltZW91dD0wO310aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtvblRpbWVvdXQoKTt9LHJldHJ5KTtyZXRyeT1jbGFtcER1cmF0aW9uKE1hdGgubWluKGluaXRpYWxSZXRyeSoxNixyZXRyeSoyKSk7ZXMucmVhZHlTdGF0ZT1DT05ORUNUSU5HO3ZhciBldmVudD1uZXcgRXZlbnQoJ2Vycm9yJyk7ZXMuZGlzcGF0Y2hFdmVudChldmVudCk7ZmlyZShlcyxlcy5vbmVycm9yLGV2ZW50KTt9fTt2YXIgY2xvc2U9ZnVuY3Rpb24gY2xvc2UoKXtjdXJyZW50U3RhdGU9Q0xPU0VEO2lmKGNhbmNlbEZ1bmN0aW9uIT11bmRlZmluZWQpe2NhbmNlbEZ1bmN0aW9uKCk7Y2FuY2VsRnVuY3Rpb249dW5kZWZpbmVkO31pZih0aW1lb3V0IT09MCl7Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO3RpbWVvdXQ9MDt9ZXMucmVhZHlTdGF0ZT1DTE9TRUQ7fTt2YXIgb25UaW1lb3V0PWZ1bmN0aW9uIG9uVGltZW91dCgpe3RpbWVvdXQ9MDtpZihjdXJyZW50U3RhdGUhPT1XQUlUSU5HKXtpZighd2FzQWN0aXZpdHkmJmNhbmNlbEZ1bmN0aW9uIT11bmRlZmluZWQpe3Rocm93RXJyb3IobmV3IEVycm9yKCdObyBhY3Rpdml0eSB3aXRoaW4gJytoZWFydGJlYXRUaW1lb3V0KycgbWlsbGlzZWNvbmRzLiBSZWNvbm5lY3RpbmcuJykpO2NhbmNlbEZ1bmN0aW9uKCk7Y2FuY2VsRnVuY3Rpb249dW5kZWZpbmVkO31lbHNle3dhc0FjdGl2aXR5PWZhbHNlO3RpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe29uVGltZW91dCgpO30saGVhcnRiZWF0VGltZW91dCk7fXJldHVybjt9d2FzQWN0aXZpdHk9ZmFsc2U7dGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b25UaW1lb3V0KCk7fSxoZWFydGJlYXRUaW1lb3V0KTtjdXJyZW50U3RhdGU9Q09OTkVDVElORztkYXRhQnVmZmVyPScnO2V2ZW50VHlwZUJ1ZmZlcj0nJztsYXN0RXZlbnRJZEJ1ZmZlcj1sYXN0RXZlbnRJZDt0ZXh0QnVmZmVyPScnO2ZpZWxkU3RhcnQ9MDt2YWx1ZVN0YXJ0PTA7c3RhdGU9RklFTERfU1RBUlQ7Ly8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDI4OTE2XG4vLyBSZXF1ZXN0IGhlYWRlciBmaWVsZCBMYXN0LUV2ZW50LUlEIGlzIG5vdCBhbGxvd2VkIGJ5IEFjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnMuXG52YXIgcmVxdWVzdFVSTD11cmw7aWYodXJsLnNsaWNlKDAsNSkhPT0nZGF0YTonJiZ1cmwuc2xpY2UoMCw1KSE9PSdibG9iOicpe2lmKGxhc3RFdmVudElkIT09Jycpe3JlcXVlc3RVUkwrPSh1cmwuaW5kZXhPZignPycpPT09LTE/Jz8nOicmJykrJ2xhc3RFdmVudElkPScrZW5jb2RlVVJJQ29tcG9uZW50KGxhc3RFdmVudElkKTt9fXZhciByZXF1ZXN0SGVhZGVycz17fTtyZXF1ZXN0SGVhZGVyc1snQWNjZXB0J109J3RleHQvZXZlbnQtc3RyZWFtJztpZihoZWFkZXJzIT11bmRlZmluZWQpe2Zvcih2YXIgbmFtZSBpbiBoZWFkZXJzKXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGVhZGVycyxuYW1lKSl7cmVxdWVzdEhlYWRlcnNbbmFtZV09aGVhZGVyc1tuYW1lXTt9fX10cnl7dHJhbnNwb3J0Lm9wZW4oeGhyLG9uU3RhcnQsb25Qcm9ncmVzcyxvbkZpbmlzaCxyZXF1ZXN0VVJMLHdpdGhDcmVkZW50aWFscyxyZXF1ZXN0SGVhZGVycyk7fWNhdGNoKGVycm9yKXtjbG9zZSgpO3Rocm93IGVycm9yO319O2VzLnVybD11cmw7ZXMucmVhZHlTdGF0ZT1DT05ORUNUSU5HO2VzLndpdGhDcmVkZW50aWFscz13aXRoQ3JlZGVudGlhbHM7ZXMuX2Nsb3NlPWNsb3NlO29uVGltZW91dCgpO31FdmVudFNvdXJjZVBvbHlmaWxsLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEV2ZW50VGFyZ2V0LnByb3RvdHlwZSk7RXZlbnRTb3VyY2VQb2x5ZmlsbC5wcm90b3R5cGUuQ09OTkVDVElORz1DT05ORUNUSU5HO0V2ZW50U291cmNlUG9seWZpbGwucHJvdG90eXBlLk9QRU49T1BFTjtFdmVudFNvdXJjZVBvbHlmaWxsLnByb3RvdHlwZS5DTE9TRUQ9Q0xPU0VEO0V2ZW50U291cmNlUG9seWZpbGwucHJvdG90eXBlLmNsb3NlPWZ1bmN0aW9uKCl7dGhpcy5fY2xvc2UoKTt9O0V2ZW50U291cmNlUG9seWZpbGwuQ09OTkVDVElORz1DT05ORUNUSU5HO0V2ZW50U291cmNlUG9seWZpbGwuT1BFTj1PUEVOO0V2ZW50U291cmNlUG9seWZpbGwuQ0xPU0VEPUNMT1NFRDtFdmVudFNvdXJjZVBvbHlmaWxsLnByb3RvdHlwZS53aXRoQ3JlZGVudGlhbHM9dW5kZWZpbmVkO3ZhciBfZGVmYXVsdD1FdmVudFNvdXJjZVBvbHlmaWxsO2V4cG9ydHMuZGVmYXVsdD1fZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLmRpc3BsYXlDb250ZW50PWRpc3BsYXlDb250ZW50O2Z1bmN0aW9uIGRpc3BsYXlDb250ZW50KGNhbGxiYWNrKXsvLyBUaGlzIGlzIHRoZSBmYWxsYmFjayBoZWxwZXIgdGhhdCByZW1vdmVzIE5leHQuanMnIG5vLUZPVUMgc3R5bGVzIHdoZW5cbi8vIENTUyBtb2RlIGlzIGVuYWJsZWQuIFRoaXMgb25seSByZWFsbHkgYWN0aXZhdGVzIGlmIHlvdSBoYXZlbid0IGNyZWF0ZWRcbi8vIF9hbnlfIHN0eWxlcyBpbiB5b3VyIGFwcGxpY2F0aW9uIHlldC5cbjsod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8c2V0VGltZW91dCkoZnVuY3Rpb24oKXtmb3IodmFyIHg9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbmV4dC1oaWRlLWZvdWNdJyksaT14Lmxlbmd0aDtpLS07KXt4W2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoeFtpXSk7fWlmKGNhbGxiYWNrKXtjYWxsYmFjaygpO319KTt9IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ9cmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMuZGVmYXVsdD12b2lkIDA7dmFyIF9yb3V0ZXI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibmV4dC9yb3V0ZXJcIikpO3ZhciBfb25EZW1hbmRFbnRyaWVzVXRpbHM9cmVxdWlyZShcIi4vb24tZGVtYW5kLWVudHJpZXMtdXRpbHNcIik7dmFyIF9kZWZhdWx0PWFzeW5jKF9yZWYpPT57dmFye2Fzc2V0UHJlZml4fT1fcmVmO19yb3V0ZXIuZGVmYXVsdC5yZWFkeSgoKT0+e19yb3V0ZXIuZGVmYXVsdC5ldmVudHMub24oJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLF9vbkRlbWFuZEVudHJpZXNVdGlscy5zZXR1cFBpbmcuYmluZCh2b2lkIDAsYXNzZXRQcmVmaXgsKCk9Pl9yb3V0ZXIuZGVmYXVsdC5wYXRobmFtZSkpO30pOygwLF9vbkRlbWFuZEVudHJpZXNVdGlscy5zZXR1cFBpbmcpKGFzc2V0UHJlZml4LCgpPT5fcm91dGVyLmRlZmF1bHQucGF0aG5hbWUsX29uRGVtYW5kRW50cmllc1V0aWxzLmN1cnJlbnRQYWdlKTsvLyBwcmV2ZW50IEhNUiBjb25uZWN0aW9uIGZyb20gYmVpbmcgY2xvc2VkIHdoZW4gcnVubmluZyB0ZXN0c1xuaWYoIXByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpe2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLGV2ZW50PT57dmFyIHN0YXRlPWRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZTtpZihzdGF0ZT09PSd2aXNpYmxlJyl7KDAsX29uRGVtYW5kRW50cmllc1V0aWxzLnNldHVwUGluZykoYXNzZXRQcmVmaXgsKCk9Pl9yb3V0ZXIuZGVmYXVsdC5wYXRobmFtZSx0cnVlKTt9ZWxzZXsoMCxfb25EZW1hbmRFbnRyaWVzVXRpbHMuY2xvc2VQaW5nKSgpO319KTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywoKT0+eygwLF9vbkRlbWFuZEVudHJpZXNVdGlscy5jbG9zZVBpbmcpKCk7fSk7fX07ZXhwb3J0cy5kZWZhdWx0PV9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO3ZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0PXJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLmNsb3NlUGluZz1jbG9zZVBpbmc7ZXhwb3J0cy5zZXR1cFBpbmc9c2V0dXBQaW5nO2V4cG9ydHMuY3VycmVudFBhZ2U9dm9pZCAwO3ZhciBfdW5mZXRjaD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJuZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3VuZmV0Y2hcIikpO3ZhciBfZXZlbnRzb3VyY2U9cmVxdWlyZShcIi4vZXJyb3Itb3ZlcmxheS9ldmVudHNvdXJjZVwiKTsvKiBnbG9iYWwgbG9jYXRpb24gKi92YXIgZXZ0U291cmNlO3ZhciBjdXJyZW50UGFnZTtleHBvcnRzLmN1cnJlbnRQYWdlPWN1cnJlbnRQYWdlO2Z1bmN0aW9uIGNsb3NlUGluZygpe2lmKGV2dFNvdXJjZSlldnRTb3VyY2UuY2xvc2UoKTtldnRTb3VyY2U9bnVsbDt9ZnVuY3Rpb24gc2V0dXBQaW5nKGFzc2V0UHJlZml4LHBhdGhuYW1lRm4scmV0cnkpe3ZhciBwYXRobmFtZT1wYXRobmFtZUZuKCk7Ly8gTWFrZSBzdXJlIHRvIG9ubHkgY3JlYXRlIG5ldyBFdmVudFNvdXJjZSByZXF1ZXN0IGlmIHBhZ2UgaGFzIGNoYW5nZWRcbmlmKHBhdGhuYW1lPT09Y3VycmVudFBhZ2UmJiFyZXRyeSlyZXR1cm47ZXhwb3J0cy5jdXJyZW50UGFnZT1jdXJyZW50UGFnZT1wYXRobmFtZTsvLyBjbG9zZSBjdXJyZW50IEV2ZW50U291cmNlIGNvbm5lY3Rpb25cbmNsb3NlUGluZygpO3ZhciB1cmw9YXNzZXRQcmVmaXgrXCIvX25leHQvd2VicGFjay1obXI/cGFnZT1cIitjdXJyZW50UGFnZTtldnRTb3VyY2U9KDAsX2V2ZW50c291cmNlLmdldEV2ZW50U291cmNlV3JhcHBlcikoe3BhdGg6dXJsLHRpbWVvdXQ6NTAwMCxvbmRlbWFuZDoxfSk7ZXZ0U291cmNlLmFkZE1lc3NhZ2VMaXN0ZW5lcihldmVudD0+e2lmKGV2ZW50LmRhdGEuaW5kZXhPZigneycpPT09LTEpcmV0dXJuO3RyeXt2YXIgcGF5bG9hZD1KU09OLnBhcnNlKGV2ZW50LmRhdGEpO2lmKHBheWxvYWQuaW52YWxpZCl7Ly8gUGF5bG9hZCBjYW4gYmUgaW52YWxpZCBldmVuIGlmIHRoZSBwYWdlIGRvZXMgbm90IGV4aXN0LlxuLy8gU28sIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGl0IGV4aXN0cyBiZWZvcmUgcmVsb2FkaW5nLlxuKDAsX3VuZmV0Y2guZGVmYXVsdCkobG9jYXRpb24uaHJlZix7Y3JlZGVudGlhbHM6J3NhbWUtb3JpZ2luJ30pLnRoZW4ocGFnZVJlcz0+e2lmKHBhZ2VSZXMuc3RhdHVzPT09MjAwKXtsb2NhdGlvbi5yZWxvYWQoKTt9fSk7fX1jYXRjaChlcnIpe2NvbnNvbGUuZXJyb3IoJ29uLWRlbWFuZC1lbnRyaWVzIGZhaWxlZCB0byBwYXJzZSByZXNwb25zZScsZXJyKTt9fSk7fSIsIlwidXNlIHN0cmljdFwiO3ZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0PXJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLmRlZmF1bHQ9aW5pdGlhbGl6ZUJ1aWxkV2F0Y2hlcjt2YXIgX3JvdXRlcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9yb3V0ZXJcIikpO2Z1bmN0aW9uIGluaXRpYWxpemVCdWlsZFdhdGNoZXIoKXt2YXIgc2hhZG93SG9zdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtzaGFkb3dIb3N0LmlkPSdfX25leHQtcHJlcmVuZGVyLWluZGljYXRvcic7Ly8gTWFrZSBzdXJlIGNvbnRhaW5lciBpcyBmaXhlZCBhbmQgb24gYSBoaWdoIHpJbmRleCBzbyBpdCBzaG93c1xuc2hhZG93SG9zdC5zdHlsZS5wb3NpdGlvbj0nZml4ZWQnO3NoYWRvd0hvc3Quc3R5bGUuYm90dG9tPScyMHB4JztzaGFkb3dIb3N0LnN0eWxlLnJpZ2h0PScxMHB4JztzaGFkb3dIb3N0LnN0eWxlLndpZHRoPTA7c2hhZG93SG9zdC5zdHlsZS5oZWlnaHQ9MDtzaGFkb3dIb3N0LnN0eWxlLnpJbmRleD05OTk5ODtzaGFkb3dIb3N0LnN0eWxlLnRyYW5zaXRpb249J2FsbCAxMDBtcyBlYXNlJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNoYWRvd0hvc3QpO3ZhciBzaGFkb3dSb290O3ZhciBwcmVmaXg9Jyc7aWYoc2hhZG93SG9zdC5hdHRhY2hTaGFkb3cpe3NoYWRvd1Jvb3Q9c2hhZG93SG9zdC5hdHRhY2hTaGFkb3coe21vZGU6J29wZW4nfSk7fWVsc2V7Ly8gSWYgYXR0YWNoU2hhZG93IGlzIHVuZGVmaW5lZCB0aGVuIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnRcbi8vIHRoZSBTaGFkb3cgRE9NLCB3ZSBuZWVkIHRvIHByZWZpeCBhbGwgdGhlIG5hbWVzIHNvIHRoZXJlXG4vLyB3aWxsIGJlIG5vIGNvbmZsaWN0c1xuc2hhZG93Um9vdD1zaGFkb3dIb3N0O3ByZWZpeD0nX19uZXh0LXByZXJlbmRlci1pbmRpY2F0b3ItJzt9Ly8gQ29udGFpbmVyXG52YXIgY29udGFpbmVyPWNyZWF0ZUNvbnRhaW5lcihwcmVmaXgpO3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTsvLyBDU1NcbnZhciBjc3M9Y3JlYXRlQ3NzKHByZWZpeCk7c2hhZG93Um9vdC5hcHBlbmRDaGlsZChjc3MpO3ZhciBleHBhbmRFbD1jb250YWluZXIucXVlcnlTZWxlY3RvcignYScpO3ZhciBjbG9zZUVsPWNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiI1wiK3ByZWZpeCtcImNsb3NlXCIpOy8vIFN0YXRlXG52YXIgZGlzbWlzc0tleT0nX19ORVhUX0RJU01JU1NfUFJFUkVOREVSX0lORElDQVRPUic7dmFyIGRpc21pc3NVbnRpbD1wYXJzZUludCh3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oZGlzbWlzc0tleSksMTApO3ZhciBkaXNtaXNzZWQ9ZGlzbWlzc1VudGlsPm5ldyBEYXRlKCkuZ2V0VGltZSgpO3ZhciBpc1Zpc2libGU9IWRpc21pc3NlZCYmd2luZG93Ll9fTkVYVF9EQVRBX18ubmV4dEV4cG9ydDtmdW5jdGlvbiB1cGRhdGVDb250YWluZXIoKXtpZihpc1Zpc2libGUpe2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHByZWZpeCtcInZpc2libGVcIik7fWVsc2V7Y29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUocHJlZml4K1widmlzaWJsZVwiKTt9fXZhciBleHBhbmRlZENsYXNzPXByZWZpeCtcImV4cGFuZGVkXCI7dmFyIHRvZ2dsZVRpbWVvdXQ7dmFyIHRvZ2dsZUV4cGFuZD1mdW5jdGlvbiB0b2dnbGVFeHBhbmQoZXhwYW5kKXtpZihleHBhbmQ9PT12b2lkIDApe2V4cGFuZD10cnVlO31jbGVhclRpbWVvdXQodG9nZ2xlVGltZW91dCk7dG9nZ2xlVGltZW91dD1zZXRUaW1lb3V0KCgpPT57aWYoZXhwYW5kKXtleHBhbmRFbC5jbGFzc0xpc3QuYWRkKGV4cGFuZGVkQ2xhc3MpO2Nsb3NlRWwuc3R5bGUuZGlzcGxheT0nZmxleCc7fWVsc2V7ZXhwYW5kRWwuY2xhc3NMaXN0LnJlbW92ZShleHBhbmRlZENsYXNzKTtjbG9zZUVsLnN0eWxlLmRpc3BsYXk9J25vbmUnO319LDUwKTt9O2Nsb3NlRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCgpPT57dmFyIG9uZUhvdXJBd2F5PW5ldyBEYXRlKCkuZ2V0VGltZSgpKzEqNjAqNjAqMTAwMDt3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oZGlzbWlzc0tleSxvbmVIb3VyQXdheSsnJyk7aXNWaXNpYmxlPWZhbHNlO3VwZGF0ZUNvbnRhaW5lcigpO30pO2Nsb3NlRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsKCk9PnRvZ2dsZUV4cGFuZCgpKTtjbG9zZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCgpPT50b2dnbGVFeHBhbmQoZmFsc2UpKTtleHBhbmRFbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywoKT0+dG9nZ2xlRXhwYW5kKCkpO2V4cGFuZEVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCgpPT50b2dnbGVFeHBhbmQoZmFsc2UpKTtfcm91dGVyLmRlZmF1bHQuZXZlbnRzLm9uKCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywoKT0+e2lzVmlzaWJsZT13aW5kb3cubmV4dC5pc1ByZXJlbmRlcmVkO3VwZGF0ZUNvbnRhaW5lcigpO30pO3VwZGF0ZUNvbnRhaW5lcigpO31mdW5jdGlvbiBjcmVhdGVDb250YWluZXIocHJlZml4KXt2YXIgY29udGFpbmVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO2NvbnRhaW5lci5pZD1wcmVmaXgrXCJjb250YWluZXJcIjtjb250YWluZXIuaW5uZXJIVE1MPVwiXFxuICAgIDxidXR0b24gaWQ9XFxcIlwiK3ByZWZpeCtcImNsb3NlXFxcIiB0aXRsZT1cXFwiSGlkZSBpbmRpY2F0b3IgZm9yIHNlc3Npb25cXFwiPlxcbiAgICAgIDxzcGFuPlxceEQ3PC9zcGFuPlxcbiAgICA8L2J1dHRvbj5cXG4gICAgPGEgaHJlZj1cXFwiaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MjYXV0b21hdGljLXN0YXRpYy1vcHRpbWl6YXRpb24taW5kaWNhdG9yXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgcmVsPVxcXCJub3JlZmVycmVyXFxcIj5cXG4gICAgICA8ZGl2IGlkPVxcXCJcIitwcmVmaXgrXCJpY29uLXdyYXBwZXJcXFwiPlxcbiAgICAgICAgICA8c3ZnIHdpZHRoPVxcXCIxNVxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDYwIDgwXFxcIiBmaWxsPVxcXCJub25lXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPlxcbiAgICAgICAgICA8cGF0aCBkPVxcXCJNMzYgM0wzMC43NCA0MUg4TDM2IDNaXFxcIiBmaWxsPVxcXCJibGFja1xcXCIvPlxcbiAgICAgICAgICA8cGF0aCBkPVxcXCJNMjUgNzdMMzAuMjYgMzlINTNMMjUgNzdaXFxcIiBmaWxsPVxcXCJibGFja1xcXCIvPlxcbiAgICAgICAgICA8cGF0aCBkPVxcXCJNMTMuNSAzMy41TDUzIDM5TDQ3LjUgNDYuNUw3IDQxLjI1TDEzLjUgMzMuNVpcXFwiIGZpbGw9XFxcImJsYWNrXFxcIi8+XFxuICAgICAgICAgIDwvc3ZnPlxcbiAgICAgICAgICBQcmVyZW5kZXJlZCBQYWdlXFxuICAgICAgPC9kaXY+XFxuICAgIDwvYT5cXG4gIFwiO3JldHVybiBjb250YWluZXI7fWZ1bmN0aW9uIGNyZWF0ZUNzcyhwcmVmaXgpe3ZhciBjc3M9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtjc3MudGV4dENvbnRlbnQ9XCJcXG4gICAgI1wiK3ByZWZpeCtcImNvbnRhaW5lciB7XFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgICAgYm90dG9tOiAxMHB4O1xcbiAgICAgIHJpZ2h0OiAxNXB4O1xcbiAgICB9XFxuXFxuICAgICNcIitwcmVmaXgrXCJjbG9zZSB7XFxuICAgICAgdG9wOiAtMTBweDtcXG4gICAgICByaWdodDogLTEwcHg7XFxuICAgICAgYm9yZGVyOiBub25lO1xcbiAgICAgIHdpZHRoOiAxOHB4O1xcbiAgICAgIGhlaWdodDogMThweDtcXG4gICAgICBjb2xvcjogIzMzMzMzMztcXG4gICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgIGJhY2tncm91bmQ6ICNmZmZmZmY7XFxuICAgICAgYm9yZGVyLXJhZGl1czogMTAwJTtcXG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIH1cXG5cXG4gICAgI1wiK3ByZWZpeCtcImNvbnRhaW5lciBhIHtcXG4gICAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgd2lkdGg6IDE1cHg7XFxuICAgICAgaGVpZ2h0OiAyM3B4O1xcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuXFxuICAgICAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgICAgIGJhY2tncm91bmQ6ICNmZmY7XFxuICAgICAgY29sb3I6ICMwMDA7XFxuICAgICAgZm9udDogaW5pdGlhbDtcXG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgbGV0dGVyLXNwYWNpbmc6IGluaXRpYWw7XFxuICAgICAgdGV4dC1zaGFkb3c6IGluaXRpYWw7XFxuICAgICAgdGV4dC10cmFuc2Zvcm06IGluaXRpYWw7XFxuICAgICAgdmlzaWJpbGl0eTogaW5pdGlhbDtcXG4gICAgICBmb250LXNpemU6IDE0cHg7XFxuICAgICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NlZ29lIFVJJywgUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLCAnT3BlbiBTYW5zJywgJ0hlbHZldGljYSBOZXVlJywgc2Fucy1zZXJpZjtcXG5cXG4gICAgICBwYWRkaW5nOiA0cHggMnB4O1xcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgYm94LXNoYWRvdzogMCAxMXB4IDQwcHggMCByZ2JhKDAsIDAsIDAsIDAuMjUpLCAwIDJweCAxMHB4IDAgcmdiYSgwLCAwLCAwLCAwLjEyKTtcXG5cXG4gICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBlYXNlLCBib3R0b20gMC4xcyBlYXNlLCB3aWR0aCAwLjNzIGVhc2U7XFxuICAgICAgYW5pbWF0aW9uOiBcIitwcmVmaXgrXCJmYWRlLWluIDAuMXMgZWFzZS1pbi1vdXQ7XFxuICAgIH1cXG5cXG4gICAgI1wiK3ByZWZpeCtcImljb24td3JhcHBlciB7XFxuICAgICAgd2lkdGg6IDE0MHB4O1xcbiAgICAgIGhlaWdodDogMjBweDtcXG4gICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgIGZsZXgtc2hyaW5rOiAwO1xcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICB9XFxuXFxuICAgICNcIitwcmVmaXgrXCJpY29uLXdyYXBwZXIgc3ZnIHtcXG4gICAgICBmbGV4LXNocmluazogMDtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDNweDtcXG4gICAgfVxcblxcbiAgICAjXCIrcHJlZml4K1wiY29udGFpbmVyIGEuXCIrcHJlZml4K1wiZXhwYW5kZWQge1xcbiAgICAgIHdpZHRoOiAxMzVweDtcXG4gICAgfVxcblxcbiAgICAjXCIrcHJlZml4K1wiY29udGFpbmVyLlwiK3ByZWZpeCtcInZpc2libGUge1xcbiAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgYm90dG9tOiAxMHB4O1xcbiAgICAgIG9wYWNpdHk6IDE7XFxuICAgIH1cXG5cXG4gICAgQGtleWZyYW1lcyBcIitwcmVmaXgrXCJmYWRlLWluIHtcXG4gICAgICBmcm9tIHtcXG4gICAgICAgIGJvdHRvbTogMHB4O1xcbiAgICAgICAgb3BhY2l0eTogMDtcXG4gICAgICB9XFxuICAgICAgdG8ge1xcbiAgICAgICAgYm90dG9tOiAxMHB4O1xcbiAgICAgICAgb3BhY2l0eTogMTtcXG4gICAgICB9XFxuICAgIH1cXG4gIFwiO3JldHVybiBjc3M7fSIsIlwidXNlIHN0cmljdFwiO3ZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0PXJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLmRlZmF1bHQ9dm9pZCAwO3ZhciBfaG90RGV2Q2xpZW50PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZXJyb3Itb3ZlcmxheS9ob3QtZGV2LWNsaWVudFwiKSk7dmFyIF9kZWZhdWx0PShfcmVmKT0+e3Zhcnthc3NldFByZWZpeH09X3JlZjt2YXIgb3B0aW9ucz17cGF0aDphc3NldFByZWZpeCtcIi9fbmV4dC93ZWJwYWNrLWhtclwifTt2YXIgZGV2Q2xpZW50PSgwLF9ob3REZXZDbGllbnQuZGVmYXVsdCkob3B0aW9ucyk7ZGV2Q2xpZW50LnN1YnNjcmliZVRvSG1yRXZlbnQob2JqPT57aWYob2JqLmFjdGlvbj09PSdyZWxvYWRQYWdlJyl7cmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTt9aWYob2JqLmFjdGlvbj09PSdyZW1vdmVkUGFnZScpe3ZhcltwYWdlXT1vYmouZGF0YTtpZihwYWdlPT09d2luZG93Lm5leHQucm91dGVyLnBhdGhuYW1lKXtyZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO31yZXR1cm47fWlmKG9iai5hY3Rpb249PT0nYWRkZWRQYWdlJyl7dmFyW19wYWdlXT1vYmouZGF0YTtpZihfcGFnZT09PXdpbmRvdy5uZXh0LnJvdXRlci5wYXRobmFtZSYmdHlwZW9mIHdpbmRvdy5uZXh0LnJvdXRlci5jb21wb25lbnRzW19wYWdlXT09PSd1bmRlZmluZWQnKXtyZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO31yZXR1cm47fXRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBhY3Rpb24gJytvYmouYWN0aW9uKTt9KTtyZXR1cm4gZGV2Q2xpZW50O307ZXhwb3J0cy5kZWZhdWx0PV9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMuZGVmYXVsdD1pbml0SGVhZE1hbmFnZXI7dmFyIERPTUF0dHJpYnV0ZU5hbWVzPXthY2NlcHRDaGFyc2V0OidhY2NlcHQtY2hhcnNldCcsY2xhc3NOYW1lOidjbGFzcycsaHRtbEZvcjonZm9yJyxodHRwRXF1aXY6J2h0dHAtZXF1aXYnfTtmdW5jdGlvbiByZWFjdEVsZW1lbnRUb0RPTShfcmVmKXt2YXJ7dHlwZSxwcm9wc309X3JlZjt2YXIgZWw9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtmb3IodmFyIHAgaW4gcHJvcHMpe2lmKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwKSljb250aW51ZTtpZihwPT09J2NoaWxkcmVuJ3x8cD09PSdkYW5nZXJvdXNseVNldElubmVySFRNTCcpY29udGludWU7Ly8gd2UgZG9uJ3QgcmVuZGVyIHVuZGVmaW5lZCBwcm9wcyB0byB0aGUgRE9NXG5pZihwcm9wc1twXT09PXVuZGVmaW5lZCljb250aW51ZTt2YXIgYXR0cj1ET01BdHRyaWJ1dGVOYW1lc1twXXx8cC50b0xvd2VyQ2FzZSgpO2VsLnNldEF0dHJpYnV0ZShhdHRyLHByb3BzW3BdKTt9dmFye2NoaWxkcmVuLGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MfT1wcm9wcztpZihkYW5nZXJvdXNseVNldElubmVySFRNTCl7ZWwuaW5uZXJIVE1MPWRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbHx8Jyc7fWVsc2UgaWYoY2hpbGRyZW4pe2VsLnRleHRDb250ZW50PXR5cGVvZiBjaGlsZHJlbj09PSdzdHJpbmcnP2NoaWxkcmVuOmNoaWxkcmVuLmpvaW4oJycpO31yZXR1cm4gZWw7fWZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnRzKHR5cGUsY29tcG9uZW50cyl7dmFyIGhlYWRFbD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO3ZhciBoZWFkQ291bnRFbD1oZWFkRWwucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPW5leHQtaGVhZC1jb3VudF0nKTtpZihwcm9jZXNzLmVudi5OT0RFX0VOViE9PSdwcm9kdWN0aW9uJyl7aWYoIWhlYWRDb3VudEVsKXtjb25zb2xlLmVycm9yKCdXYXJuaW5nOiBuZXh0LWhlYWQtY291bnQgaXMgbWlzc2luZy4gaHR0cHM6Ly9lcnIuc2gvbmV4dC5qcy9uZXh0LWhlYWQtY291bnQtbWlzc2luZycpO3JldHVybjt9fXZhciBoZWFkQ291bnQ9TnVtYmVyKGhlYWRDb3VudEVsLmNvbnRlbnQpO3ZhciBvbGRUYWdzPVtdO2Zvcih2YXIgaT0wLGo9aGVhZENvdW50RWwucHJldmlvdXNFbGVtZW50U2libGluZztpPGhlYWRDb3VudDtpKyssaj1qLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpe2lmKGoudGFnTmFtZS50b0xvd2VyQ2FzZSgpPT09dHlwZSl7b2xkVGFncy5wdXNoKGopO319dmFyIG5ld1RhZ3M9Y29tcG9uZW50cy5tYXAocmVhY3RFbGVtZW50VG9ET00pLmZpbHRlcihuZXdUYWc9Pntmb3IodmFyIGs9MCxsZW49b2xkVGFncy5sZW5ndGg7azxsZW47aysrKXt2YXIgb2xkVGFnPW9sZFRhZ3Nba107aWYob2xkVGFnLmlzRXF1YWxOb2RlKG5ld1RhZykpe29sZFRhZ3Muc3BsaWNlKGssMSk7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fSk7b2xkVGFncy5mb3JFYWNoKHQ9PnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KSk7bmV3VGFncy5mb3JFYWNoKHQ9PmhlYWRFbC5pbnNlcnRCZWZvcmUodCxoZWFkQ291bnRFbCkpO2hlYWRDb3VudEVsLmNvbnRlbnQ9KGhlYWRDb3VudC1vbGRUYWdzLmxlbmd0aCtuZXdUYWdzLmxlbmd0aCkudG9TdHJpbmcoKTt9ZnVuY3Rpb24gaW5pdEhlYWRNYW5hZ2VyKCl7dmFyIHVwZGF0ZVByb21pc2U9bnVsbDtyZXR1cm4gaGVhZD0+e3ZhciBwcm9taXNlPXVwZGF0ZVByb21pc2U9UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+e2lmKHByb21pc2UhPT11cGRhdGVQcm9taXNlKXJldHVybjt1cGRhdGVQcm9taXNlPW51bGw7dmFyIHRhZ3M9e307aGVhZC5mb3JFYWNoKGg9Pnt2YXIgY29tcG9uZW50cz10YWdzW2gudHlwZV18fFtdO2NvbXBvbmVudHMucHVzaChoKTt0YWdzW2gudHlwZV09Y29tcG9uZW50czt9KTt2YXIgdGl0bGVDb21wb25lbnQ9dGFncy50aXRsZT90YWdzLnRpdGxlWzBdOm51bGw7dmFyIHRpdGxlPScnO2lmKHRpdGxlQ29tcG9uZW50KXt2YXJ7Y2hpbGRyZW59PXRpdGxlQ29tcG9uZW50LnByb3BzO3RpdGxlPXR5cGVvZiBjaGlsZHJlbj09PSdzdHJpbmcnP2NoaWxkcmVuOmNoaWxkcmVuLmpvaW4oJycpO31pZih0aXRsZSE9PWRvY3VtZW50LnRpdGxlKWRvY3VtZW50LnRpdGxlPXRpdGxlO1snbWV0YScsJ2Jhc2UnLCdsaW5rJywnc3R5bGUnLCdzY3JpcHQnXS5mb3JFYWNoKHR5cGU9Pnt1cGRhdGVFbGVtZW50cyh0eXBlLHRhZ3NbdHlwZV18fFtdKTt9KTt9KTt9O30iLCJcInVzZSBzdHJpY3RcIjt2YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQzPXJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ9cmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMucmVuZGVyPXJlbmRlcjtleHBvcnRzLnJlbmRlckVycm9yPXJlbmRlckVycm9yO2V4cG9ydHMuZGVmYXVsdD1leHBvcnRzLmVtaXR0ZXI9ZXhwb3J0cy5yb3V0ZXI9ZXhwb3J0cy52ZXJzaW9uPXZvaWQgMDt2YXIgX2V4dGVuZHMyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kc1wiKSk7dmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIikpO3ZhciBfcm91dGVyPXJlcXVpcmUoXCJuZXh0L3JvdXRlclwiKTt2YXIgX3F1ZXJ5c3RyaW5nPXJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTt2YXIgX3JlYWN0PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTt2YXIgX3JlYWN0RG9tPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LWRvbVwiKSk7dmFyIF9oZWFkTWFuYWdlckNvbnRleHQ9cmVxdWlyZShcIi4uL25leHQtc2VydmVyL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dFwiKTt2YXIgX21pdHQ9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vbmV4dC1zZXJ2ZXIvbGliL21pdHRcIikpO3ZhciBfcm91dGVyQ29udGV4dD1yZXF1aXJlKFwiLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0XCIpO3ZhciBfaXNEeW5hbWljPXJlcXVpcmUoXCIuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWNcIik7dmFyIGVudkNvbmZpZz1faW50ZXJvcFJlcXVpcmVXaWxkY2FyZDMocmVxdWlyZShcIi4uL25leHQtc2VydmVyL2xpYi9ydW50aW1lLWNvbmZpZ1wiKSk7dmFyIF91dGlscz1yZXF1aXJlKFwiLi4vbmV4dC1zZXJ2ZXIvbGliL3V0aWxzXCIpO3ZhciBfaGVhZE1hbmFnZXI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9oZWFkLW1hbmFnZXJcIikpO3ZhciBfcGFnZUxvYWRlcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BhZ2UtbG9hZGVyXCIpKTt2YXIgX3BlcmZvcm1hbmNlUmVsYXllcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BlcmZvcm1hbmNlLXJlbGF5ZXJcIikpOy8qIGdsb2JhbCBsb2NhdGlvbiAqLyAvLy8gPHJlZmVyZW5jZSB0eXBlcz1cInJlYWN0LWRvbS9leHBlcmltZW50YWxcIiAvPlxuaWYoISgnZmluYWxseSdpbiBQcm9taXNlLnByb3RvdHlwZSkpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRlbmQtbmF0aXZlXG5Qcm9taXNlLnByb3RvdHlwZS5maW5hbGx5PXJlcXVpcmUoJ25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvZmluYWxseS1wb2x5ZmlsbC5taW4nKTt9dmFyIGRhdGE9SlNPTi5wYXJzZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19ORVhUX0RBVEFfXycpLnRleHRDb250ZW50KTt3aW5kb3cuX19ORVhUX0RBVEFfXz1kYXRhO3ZhciB2ZXJzaW9uPVwiOS40LjFcIjtleHBvcnRzLnZlcnNpb249dmVyc2lvbjt2YXJ7cHJvcHMsZXJyLHBhZ2UscXVlcnksYnVpbGRJZCxhc3NldFByZWZpeCxydW50aW1lQ29uZmlnLGR5bmFtaWNJZHMsaXNGYWxsYmFja309ZGF0YTt2YXIgcHJlZml4PWFzc2V0UHJlZml4fHwnJzsvLyBXaXRoIGR5bmFtaWMgYXNzZXRQcmVmaXggaXQncyBubyBsb25nZXIgcG9zc2libGUgdG8gc2V0IGFzc2V0UHJlZml4IGF0IHRoZSBidWlsZCB0aW1lXG4vLyBTbywgdGhpcyBpcyBob3cgd2UgZG8gaXQgaW4gdGhlIGNsaWVudCBzaWRlIGF0IHJ1bnRpbWVcbl9fd2VicGFja19wdWJsaWNfcGF0aF9fPXByZWZpeCtcIi9fbmV4dC9cIjsvL2VzbGludC1kaXNhYmxlLWxpbmVcbi8vIEluaXRpYWxpemUgbmV4dC9jb25maWcgd2l0aCB0aGUgZW52aXJvbm1lbnQgY29uZmlndXJhdGlvblxuZW52Q29uZmlnLnNldENvbmZpZyh7c2VydmVyUnVudGltZUNvbmZpZzp7fSxwdWJsaWNSdW50aW1lQ29uZmlnOnJ1bnRpbWVDb25maWd8fHt9fSk7dmFyIGFzUGF0aD0oMCxfdXRpbHMuZ2V0VVJMKSgpO3ZhciBwYWdlTG9hZGVyPW5ldyBfcGFnZUxvYWRlci5kZWZhdWx0KGJ1aWxkSWQscHJlZml4KTt2YXIgcmVnaXN0ZXI9KF9yZWYpPT57dmFyW3IsZl09X3JlZjtyZXR1cm4gcGFnZUxvYWRlci5yZWdpc3RlclBhZ2UocixmKTt9O2lmKHdpbmRvdy5fX05FWFRfUCl7d2luZG93Ll9fTkVYVF9QLm1hcChyZWdpc3Rlcik7fXdpbmRvdy5fX05FWFRfUD1bXTt3aW5kb3cuX19ORVhUX1AucHVzaD1yZWdpc3Rlcjt2YXIgdXBkYXRlSGVhZD0oMCxfaGVhZE1hbmFnZXIuZGVmYXVsdCkoKTt2YXIgYXBwRWxlbWVudD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19uZXh0Jyk7dmFyIGxhc3RBcHBQcm9wczt2YXIgd2VicGFja0hNUjt2YXIgcm91dGVyO2V4cG9ydHMucm91dGVyPXJvdXRlcjt2YXIgRXJyb3JDb21wb25lbnQ7dmFyIENvbXBvbmVudDt2YXIgQXBwLG9uUGVyZkVudHJ5O2NsYXNzIENvbnRhaW5lciBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudHtjb21wb25lbnREaWRDYXRjaChlcnIsaW5mbyl7dGhpcy5wcm9wcy5mbihlcnIsaW5mbyk7fWNvbXBvbmVudERpZE1vdW50KCl7dGhpcy5zY3JvbGxUb0hhc2goKTtpZihwcm9jZXNzLmVudi5fX05FWFRfUExVR0lOUyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT4oMCxfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZDIuZGVmYXVsdCkocmVxdWlyZSgnbmV4dC1wbHVnaW4tbG9hZGVyP21pZGRsZXdhcmU9dW5zdGFibGUtcG9zdC1oeWRyYXRpb24hJykpKS50aGVuKG1vZD0+e3JldHVybiBtb2QuZGVmYXVsdCgpO30pLmNhdGNoKGVycj0+e2NvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhbGxpbmcgcG9zdC1oeWRyYXRpb24gZm9yIHBsdWdpbnMnLGVycik7fSk7fS8vIFdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgcm91dGVyIHN0YXRlIGlmOlxuLy8gLSB0aGUgcGFnZSB3YXMgKGF1dG8pIGV4cG9ydGVkIGFuZCBoYXMgYSBxdWVyeSBzdHJpbmcgb3Igc2VhcmNoIChoYXNoKVxuLy8gLSBpdCB3YXMgYXV0byBleHBvcnRlZCBhbmQgaXMgYSBkeW5hbWljIHJvdXRlICh0byBwcm92aWRlIHBhcmFtcylcbi8vIC0gaWYgaXQgaXMgYSBjbGllbnQtc2lkZSBza2VsZXRvbiAoZmFsbGJhY2sgcmVuZGVyKVxuaWYocm91dGVyLmlzU3NyJiYoaXNGYWxsYmFja3x8ZGF0YS5uZXh0RXhwb3J0JiYoKDAsX2lzRHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocm91dGVyLnBhdGhuYW1lKXx8bG9jYXRpb24uc2VhcmNoKXx8cHJvcHMmJnByb3BzLl9fTl9TU0cmJmxvY2F0aW9uLnNlYXJjaCkpey8vIHVwZGF0ZSBxdWVyeSBvbiBtb3VudCBmb3IgZXhwb3J0ZWQgcGFnZXNcbnJvdXRlci5yZXBsYWNlKHJvdXRlci5wYXRobmFtZSsnPycrKDAsX3F1ZXJ5c3RyaW5nLnN0cmluZ2lmeSkoKDAsX2V4dGVuZHMyLmRlZmF1bHQpKCgwLF9leHRlbmRzMi5kZWZhdWx0KSh7fSxyb3V0ZXIucXVlcnkpLCgwLF9xdWVyeXN0cmluZy5wYXJzZSkobG9jYXRpb24uc2VhcmNoLnN1YnN0cigxKSkpKSxhc1BhdGgsey8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanNcbi8vIGNsaWVudC1zaWRlIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuXG4vLyBJdCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuX2g6MSwvLyBGYWxsYmFjayBwYWdlcyBtdXN0IHRyaWdnZXIgdGhlIGRhdGEgZmV0Y2gsIHNvIHRoZSB0cmFuc2l0aW9uIGlzXG4vLyBub3Qgc2hhbGxvdy5cbi8vIE90aGVyIHBhZ2VzIChzdHJpY3RseSB1cGRhdGluZyBxdWVyeSkgaGFwcGVucyBzaGFsbG93bHksIGFzIGRhdGFcbi8vIHJlcXVpcmVtZW50cyB3b3VsZCBhbHJlYWR5IGJlIHByZXNlbnQuXG5zaGFsbG93OiFpc0ZhbGxiYWNrfSk7fWlmKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpe3dpbmRvdy5fX05FWFRfSFlEUkFURUQ9dHJ1ZTtpZih3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0NCKXt3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0NCKCk7fX19Y29tcG9uZW50RGlkVXBkYXRlKCl7dGhpcy5zY3JvbGxUb0hhc2goKTt9c2Nyb2xsVG9IYXNoKCl7dmFye2hhc2h9PWxvY2F0aW9uO2hhc2g9aGFzaCYmaGFzaC5zdWJzdHJpbmcoMSk7aWYoIWhhc2gpcmV0dXJuO3ZhciBlbD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKTtpZighZWwpcmV0dXJuOy8vIElmIHdlIGNhbGwgc2Nyb2xsSW50b1ZpZXcoKSBpbiBoZXJlIHdpdGhvdXQgYSBzZXRUaW1lb3V0XG4vLyBpdCB3b24ndCBzY3JvbGwgcHJvcGVybHkuXG5zZXRUaW1lb3V0KCgpPT5lbC5zY3JvbGxJbnRvVmlldygpLDApO31yZW5kZXIoKXtpZihwcm9jZXNzLmVudi5OT0RFX0VOVj09PSdwcm9kdWN0aW9uJyl7cmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47fWlmKHByb2Nlc3MuZW52Lk5PREVfRU5WIT09J3Byb2R1Y3Rpb24nKXt2YXJ7UmVhY3REZXZPdmVybGF5fT1yZXF1aXJlKCdAbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvY2xpZW50Jyk7cmV0dXJuLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVhY3REZXZPdmVybGF5LG51bGwsdGhpcy5wcm9wcy5jaGlsZHJlbik7fX19dmFyIGVtaXR0ZXI9KDAsX21pdHQuZGVmYXVsdCkoKTtleHBvcnRzLmVtaXR0ZXI9ZW1pdHRlcjt2YXIgX2RlZmF1bHQ9YXN5bmMgZnVuY3Rpb24gX2RlZmF1bHQoX3RlbXApe3Zhcnt3ZWJwYWNrSE1SOnBhc3NlZFdlYnBhY2tITVJ9PV90ZW1wPT09dm9pZCAwP3t9Ol90ZW1wOy8vIFRoaXMgbWFrZXMgc3VyZSB0aGlzIHNwZWNpZmljIGxpbmVzIGFyZSByZW1vdmVkIGluIHByb2R1Y3Rpb25cbmlmKHByb2Nlc3MuZW52Lk5PREVfRU5WPT09J2RldmVsb3BtZW50Jyl7d2VicGFja0hNUj1wYXNzZWRXZWJwYWNrSE1SO312YXJ7cGFnZTphcHAsbW9kfT1hd2FpdCBwYWdlTG9hZGVyLmxvYWRQYWdlU2NyaXB0KCcvX2FwcCcpO0FwcD1hcHA7aWYobW9kJiZtb2QucmVwb3J0V2ViVml0YWxzKXtvblBlcmZFbnRyeT0oX3JlZjIpPT57dmFye2lkLG5hbWUsc3RhcnRUaW1lLHZhbHVlLGR1cmF0aW9uLGVudHJ5VHlwZSxlbnRyaWVzfT1fcmVmMjsvLyBDb21iaW5lcyB0aW1lc3RhbXAgd2l0aCByYW5kb20gbnVtYmVyIGZvciB1bmlxdWUgSURcbnZhciB1bmlxdWVJRD1EYXRlLm5vdygpK1wiLVwiKyhNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKDllMTItMSkpKzFlMTIpO3ZhciBwZXJmU3RhcnRFbnRyeTtpZihlbnRyaWVzJiZlbnRyaWVzLmxlbmd0aCl7cGVyZlN0YXJ0RW50cnk9ZW50cmllc1swXS5zdGFydFRpbWU7fW1vZC5yZXBvcnRXZWJWaXRhbHMoe2lkOmlkfHx1bmlxdWVJRCxuYW1lLHN0YXJ0VGltZTpzdGFydFRpbWV8fHBlcmZTdGFydEVudHJ5LHZhbHVlOnZhbHVlPT1udWxsP2R1cmF0aW9uOnZhbHVlLGxhYmVsOmVudHJ5VHlwZT09PSdtYXJrJ3x8ZW50cnlUeXBlPT09J21lYXN1cmUnPydjdXN0b20nOid3ZWItdml0YWwnfSk7fTt9dmFyIGluaXRpYWxFcnI9ZXJyO3RyeXs7KHtwYWdlOkNvbXBvbmVudH09YXdhaXQgcGFnZUxvYWRlci5sb2FkUGFnZShwYWdlKSk7aWYocHJvY2Vzcy5lbnYuTk9ERV9FTlYhPT0ncHJvZHVjdGlvbicpe3Zhcntpc1ZhbGlkRWxlbWVudFR5cGV9PXJlcXVpcmUoJ3JlYWN0LWlzJyk7aWYoIWlzVmFsaWRFbGVtZW50VHlwZShDb21wb25lbnQpKXt0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFxcXCJcIitwYWdlK1wiXFxcIlwiKTt9fX1jYXRjaChlcnJvcil7Ly8gVGhpcyBjYXRjaGVzIGVycm9ycyBsaWtlIHRocm93aW5nIGluIHRoZSB0b3AgbGV2ZWwgb2YgYSBtb2R1bGVcbmluaXRpYWxFcnI9ZXJyb3I7fWlmKHByb2Nlc3MuZW52Lk5PREVfRU5WPT09J2RldmVsb3BtZW50Jyl7dmFye2dldE5vZGVFcnJvcn09cmVxdWlyZSgnQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2NsaWVudCcpOy8vIFNlcnZlci1zaWRlIHJ1bnRpbWUgZXJyb3JzIG5lZWQgdG8gYmUgcmUtdGhyb3duIG9uIHRoZSBjbGllbnQtc2lkZSBzb1xuLy8gdGhhdCB0aGUgb3ZlcmxheSBpcyByZW5kZXJlZC5cbmlmKGluaXRpYWxFcnIpe2lmKGluaXRpYWxFcnI9PT1lcnIpe3NldFRpbWVvdXQoKCk9Pnt2YXIgZXJyb3I7dHJ5ey8vIEdlbmVyYXRlIGEgbmV3IGVycm9yIG9iamVjdC4gV2UgYHRocm93YCBpdCBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcbi8vIHdpbGwgc2V0IHRoZSBgc3RhY2tgIHdoZW4gdGhyb3duLCBhbmQgd2Ugd2FudCB0byBlbnN1cmUgb3VycyBpc1xuLy8gbm90IG92ZXJyaWRkZW4gd2hlbiB3ZSByZS10aHJvdyBpdCBiZWxvdy5cbnRocm93IG5ldyBFcnJvcihpbml0aWFsRXJyLm1lc3NhZ2UpO31jYXRjaChlKXtlcnJvcj1lO31lcnJvci5uYW1lPWluaXRpYWxFcnIubmFtZTtlcnJvci5zdGFjaz1pbml0aWFsRXJyLnN0YWNrO3ZhciBub2RlPWdldE5vZGVFcnJvcihlcnJvcik7dGhyb3cgbm9kZTt9KTt9Ly8gV2UgcmVwbGFjZWQgdGhlIHNlcnZlci1zaWRlIGVycm9yIHdpdGggYSBjbGllbnQtc2lkZSBlcnJvciwgYW5kIHNob3VsZFxuLy8gbm8gbG9uZ2VyIHJld3JpdGUgdGhlIHN0YWNrIHRyYWNlIHRvIGEgTm9kZSBlcnJvci5cbmVsc2V7c2V0VGltZW91dCgoKT0+e3Rocm93IGluaXRpYWxFcnI7fSk7fX19aWYod2luZG93Ll9fTkVYVF9QUkVMT0FEUkVBRFkpe2F3YWl0IHdpbmRvdy5fX05FWFRfUFJFTE9BRFJFQURZKGR5bmFtaWNJZHMpO31leHBvcnRzLnJvdXRlcj1yb3V0ZXI9KDAsX3JvdXRlci5jcmVhdGVSb3V0ZXIpKHBhZ2UscXVlcnksYXNQYXRoLHtpbml0aWFsUHJvcHM6cHJvcHMscGFnZUxvYWRlcixBcHAsQ29tcG9uZW50LHdyYXBBcHAsZXJyOmluaXRpYWxFcnIsaXNGYWxsYmFjayxzdWJzY3JpcHRpb246KF9yZWYzLEFwcCk9Pnt2YXJ7Q29tcG9uZW50LHByb3BzLGVycn09X3JlZjM7cmVuZGVyKHtBcHAsQ29tcG9uZW50LHByb3BzLGVycn0pO319KTsvLyBjYWxsIGluaXQtY2xpZW50IG1pZGRsZXdhcmVcbmlmKHByb2Nlc3MuZW52Ll9fTkVYVF9QTFVHSU5TKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PigwLF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkMi5kZWZhdWx0KShyZXF1aXJlKCduZXh0LXBsdWdpbi1sb2FkZXI/bWlkZGxld2FyZT1vbi1pbml0LWNsaWVudCEnKSkpLnRoZW4obW9kPT57cmV0dXJuIG1vZC5kZWZhdWx0KHtyb3V0ZXJ9KTt9KS5jYXRjaChlcnI9Pntjb25zb2xlLmVycm9yKCdFcnJvciBjYWxsaW5nIGNsaWVudC1pbml0IGZvciBwbHVnaW5zJyxlcnIpO30pO312YXIgcmVuZGVyQ3R4PXtBcHAsQ29tcG9uZW50LHByb3BzLGVycjppbml0aWFsRXJyfTtpZihwcm9jZXNzLmVudi5OT0RFX0VOVj09PSdwcm9kdWN0aW9uJyl7cmVuZGVyKHJlbmRlckN0eCk7cmV0dXJuIGVtaXR0ZXI7fWlmKHByb2Nlc3MuZW52Lk5PREVfRU5WIT09J3Byb2R1Y3Rpb24nKXtyZXR1cm57ZW1pdHRlcixyZW5kZXIscmVuZGVyQ3R4fTt9fTtleHBvcnRzLmRlZmF1bHQ9X2RlZmF1bHQ7YXN5bmMgZnVuY3Rpb24gcmVuZGVyKHByb3BzKXtpZihwcm9wcy5lcnIpe2F3YWl0IHJlbmRlckVycm9yKHByb3BzKTtyZXR1cm47fXRyeXthd2FpdCBkb1JlbmRlcihwcm9wcyk7fWNhdGNoKGVycil7aWYocHJvY2Vzcy5lbnYuTk9ERV9FTlY9PT0nZGV2ZWxvcG1lbnQnKXsvLyBFbnN1cmUgdGhpcyBlcnJvciBpcyBkaXNwbGF5ZWQgaW4gdGhlIG92ZXJsYXkgaW4gZGV2ZWxvcG1lbnRcbnNldFRpbWVvdXQoKCk9Pnt0aHJvdyBlcnI7fSk7fWF3YWl0IHJlbmRlckVycm9yKCgwLF9leHRlbmRzMi5kZWZhdWx0KSgoMCxfZXh0ZW5kczIuZGVmYXVsdCkoe30scHJvcHMpLHt9LHtlcnJ9KSk7fX0vLyBUaGlzIG1ldGhvZCBoYW5kbGVzIGFsbCBydW50aW1lIGFuZCBkZWJ1ZyBlcnJvcnMuXG4vLyA0MDQgYW5kIDUwMCBlcnJvcnMgYXJlIHNwZWNpYWwga2luZCBvZiBlcnJvcnNcbi8vIGFuZCB0aGV5IGFyZSBzdGlsbCBoYW5kbGUgdmlhIHRoZSBtYWluIHJlbmRlciBtZXRob2QuXG5mdW5jdGlvbiByZW5kZXJFcnJvcihwcm9wcyl7dmFye0FwcCxlcnJ9PXByb3BzOy8vIEluIGRldmVsb3BtZW50IHJ1bnRpbWUgZXJyb3JzIGFyZSBjYXVnaHQgYnkgb3VyIG92ZXJsYXlcbi8vIEluIHByb2R1Y3Rpb24gd2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG5pZihwcm9jZXNzLmVudi5OT0RFX0VOViE9PSdwcm9kdWN0aW9uJyl7Ly8gQSBOZXh0LmpzIHJlbmRlcmluZyBydW50aW1lIGVycm9yIGlzIGFsd2F5cyB1bnJlY292ZXJhYmxlXG4vLyBGSVhNRTogbGV0J3MgbWFrZSB0aGlzIHJlY292ZXJhYmxlIChlcnJvciBpbiBHSVAgY2xpZW50LXRyYW5zaXRpb24pXG53ZWJwYWNrSE1SLm9uVW5yZWNvdmVyYWJsZUVycm9yKCk7Ly8gV2UgbmVlZCB0byByZW5kZXIgYW4gZW1wdHkgPEFwcD4gc28gdGhhdCB0aGUgYDxSZWFjdERldk92ZXJsYXk+YCBjYW5cbi8vIHJlbmRlciBpdHNlbGYuXG5yZXR1cm4gZG9SZW5kZXIoe0FwcDooKT0+bnVsbCxwcm9wczp7fSxDb21wb25lbnQ6KCk9Pm51bGwsZXJyOm51bGx9KTt9aWYocHJvY2Vzcy5lbnYuX19ORVhUX1BMVUdJTlMpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+KDAsX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQyLmRlZmF1bHQpKHJlcXVpcmUoJ25leHQtcGx1Z2luLWxvYWRlcj9taWRkbGV3YXJlPW9uLWVycm9yLWNsaWVudCEnKSkpLnRoZW4obW9kPT57cmV0dXJuIG1vZC5kZWZhdWx0KHtlcnJ9KTt9KS5jYXRjaChlcnI9Pntjb25zb2xlLmVycm9yKCdlcnJvciBjYWxsaW5nIG9uLWVycm9yLWNsaWVudCBmb3IgcGx1Z2lucycsZXJyKTt9KTt9Ly8gTWFrZSBzdXJlIHdlIGxvZyB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUsIG90aGVyd2lzZSB1c2VycyBjYW4ndCB0cmFjayBkb3duIGlzc3Vlcy5cbmNvbnNvbGUuZXJyb3IoZXJyKTtyZXR1cm4gcGFnZUxvYWRlci5sb2FkUGFnZSgnL19lcnJvcicpLnRoZW4oKF9yZWY0KT0+e3ZhcntwYWdlOkVycm9yQ29tcG9uZW50fT1fcmVmNDsvLyBJbiBwcm9kdWN0aW9uIHdlIGRvIGEgbm9ybWFsIHJlbmRlciB3aXRoIHRoZSBgRXJyb3JDb21wb25lbnRgIGFzIGNvbXBvbmVudC5cbi8vIElmIHdlJ3ZlIGdvdHRlbiBoZXJlIHVwb24gaW5pdGlhbCByZW5kZXIsIHdlIGNhbiB1c2UgdGhlIHByb3BzIGZyb20gdGhlIHNlcnZlci5cbi8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byBjYWxsIGBnZXRJbml0aWFsUHJvcHNgIG9uIGBBcHBgIGJlZm9yZSBtb3VudGluZy5cbnZhciBBcHBUcmVlPXdyYXBBcHAoQXBwKTt2YXIgYXBwQ3R4PXtDb21wb25lbnQ6RXJyb3JDb21wb25lbnQsQXBwVHJlZSxyb3V0ZXIsY3R4OntlcnIscGF0aG5hbWU6cGFnZSxxdWVyeSxhc1BhdGgsQXBwVHJlZX19O3JldHVybiBQcm9taXNlLnJlc29sdmUocHJvcHMucHJvcHM/cHJvcHMucHJvcHM6KDAsX3V0aWxzLmxvYWRHZXRJbml0aWFsUHJvcHMpKEFwcCxhcHBDdHgpKS50aGVuKGluaXRQcm9wcz0+ZG9SZW5kZXIoKDAsX2V4dGVuZHMyLmRlZmF1bHQpKCgwLF9leHRlbmRzMi5kZWZhdWx0KSh7fSxwcm9wcykse30se2VycixDb21wb25lbnQ6RXJyb3JDb21wb25lbnQscHJvcHM6aW5pdFByb3BzfSkpKTt9KTt9Ly8gSWYgaHlkcmF0ZSBkb2VzIG5vdCBleGlzdCwgZWcgaW4gcHJlYWN0LlxudmFyIGlzSW5pdGlhbFJlbmRlcj10eXBlb2YgX3JlYWN0RG9tLmRlZmF1bHQuaHlkcmF0ZT09PSdmdW5jdGlvbic7dmFyIHJlYWN0Um9vdD1udWxsO2Z1bmN0aW9uIHJlbmRlclJlYWN0RWxlbWVudChyZWFjdEVsLGRvbUVsKXtpZihwcm9jZXNzLmVudi5fX05FWFRfUkVBQ1RfTU9ERSE9PSdsZWdhY3knKXtpZighcmVhY3RSb290KXt2YXIgb3B0cz17aHlkcmF0ZTp0cnVlfTtyZWFjdFJvb3Q9cHJvY2Vzcy5lbnYuX19ORVhUX1JFQUNUX01PREU9PT0nY29uY3VycmVudCc/X3JlYWN0RG9tLmRlZmF1bHQudW5zdGFibGVfY3JlYXRlUm9vdChkb21FbCxvcHRzKTpfcmVhY3REb20uZGVmYXVsdC51bnN0YWJsZV9jcmVhdGVCbG9ja2luZ1Jvb3QoZG9tRWwsb3B0cyk7fXJlYWN0Um9vdC5yZW5kZXIocmVhY3RFbCk7fWVsc2V7Ly8gbWFyayBzdGFydCBvZiBoeWRyYXRlL3JlbmRlclxuaWYoX3V0aWxzLlNUKXtwZXJmb3JtYW5jZS5tYXJrKCdiZWZvcmVSZW5kZXInKTt9Ly8gVGhlIGNoZWNrIGZvciBgLmh5ZHJhdGVgIGlzIHRoZXJlIHRvIHN1cHBvcnQgUmVhY3QgYWx0ZXJuYXRpdmVzIGxpa2UgcHJlYWN0XG5pZihpc0luaXRpYWxSZW5kZXIpe19yZWFjdERvbS5kZWZhdWx0Lmh5ZHJhdGUocmVhY3RFbCxkb21FbCxtYXJrSHlkcmF0ZUNvbXBsZXRlKTtpc0luaXRpYWxSZW5kZXI9ZmFsc2U7aWYob25QZXJmRW50cnkmJl91dGlscy5TVCl7KDAsX3BlcmZvcm1hbmNlUmVsYXllci5kZWZhdWx0KShvblBlcmZFbnRyeSk7fX1lbHNle19yZWFjdERvbS5kZWZhdWx0LnJlbmRlcihyZWFjdEVsLGRvbUVsLG1hcmtSZW5kZXJDb21wbGV0ZSk7fX19ZnVuY3Rpb24gbWFya0h5ZHJhdGVDb21wbGV0ZSgpe2lmKCFfdXRpbHMuU1QpcmV0dXJuO3BlcmZvcm1hbmNlLm1hcmsoJ2FmdGVySHlkcmF0ZScpOy8vIG1hcmsgZW5kIG9mIGh5ZHJhdGlvblxucGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1iZWZvcmUtaHlkcmF0aW9uJywnbmF2aWdhdGlvblN0YXJ0JywnYmVmb3JlUmVuZGVyJyk7cGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1oeWRyYXRpb24nLCdiZWZvcmVSZW5kZXInLCdhZnRlckh5ZHJhdGUnKTtpZihvblBlcmZFbnRyeSl7cGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1oeWRyYXRpb24nKS5mb3JFYWNoKG9uUGVyZkVudHJ5KTt9Y2xlYXJNYXJrcygpO31mdW5jdGlvbiBtYXJrUmVuZGVyQ29tcGxldGUoKXtpZighX3V0aWxzLlNUKXJldHVybjtwZXJmb3JtYW5jZS5tYXJrKCdhZnRlclJlbmRlcicpOy8vIG1hcmsgZW5kIG9mIHJlbmRlclxudmFyIG5hdlN0YXJ0RW50cmllcz1wZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKCdyb3V0ZUNoYW5nZScsJ21hcmsnKTtpZighbmF2U3RhcnRFbnRyaWVzLmxlbmd0aCl7cmV0dXJuO31wZXJmb3JtYW5jZS5tZWFzdXJlKCdOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXInLG5hdlN0YXJ0RW50cmllc1swXS5uYW1lLCdiZWZvcmVSZW5kZXInKTtwZXJmb3JtYW5jZS5tZWFzdXJlKCdOZXh0LmpzLXJlbmRlcicsJ2JlZm9yZVJlbmRlcicsJ2FmdGVyUmVuZGVyJyk7aWYob25QZXJmRW50cnkpe3BlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoJ05leHQuanMtcmVuZGVyJykuZm9yRWFjaChvblBlcmZFbnRyeSk7cGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJykuZm9yRWFjaChvblBlcmZFbnRyeSk7fWNsZWFyTWFya3MoKTtbJ05leHQuanMtcm91dGUtY2hhbmdlLXRvLXJlbmRlcicsJ05leHQuanMtcmVuZGVyJ10uZm9yRWFjaChtZWFzdXJlPT5wZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKG1lYXN1cmUpKTt9ZnVuY3Rpb24gY2xlYXJNYXJrcygpeztbJ2JlZm9yZVJlbmRlcicsJ2FmdGVySHlkcmF0ZScsJ2FmdGVyUmVuZGVyJywncm91dGVDaGFuZ2UnXS5mb3JFYWNoKG1hcms9PnBlcmZvcm1hbmNlLmNsZWFyTWFya3MobWFyaykpO31mdW5jdGlvbiBBcHBDb250YWluZXIoX3JlZjUpe3ZhcntjaGlsZHJlbn09X3JlZjU7cmV0dXJuLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29udGFpbmVyLHtmbjplcnJvcj0+cmVuZGVyRXJyb3Ioe0FwcCxlcnI6ZXJyb3J9KS5jYXRjaChlcnI9PmNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbmRlcmluZyBwYWdlOiAnLGVycikpfSwvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcm91dGVyQ29udGV4dC5Sb3V0ZXJDb250ZXh0LlByb3ZpZGVyLHt2YWx1ZTooMCxfcm91dGVyLm1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZSkocm91dGVyKX0sLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hlYWRNYW5hZ2VyQ29udGV4dC5IZWFkTWFuYWdlckNvbnRleHQuUHJvdmlkZXIse3ZhbHVlOnVwZGF0ZUhlYWR9LGNoaWxkcmVuKSkpO312YXIgd3JhcEFwcD1BcHA9PnByb3BzPT57dmFyIGFwcFByb3BzPSgwLF9leHRlbmRzMi5kZWZhdWx0KSgoMCxfZXh0ZW5kczIuZGVmYXVsdCkoe30scHJvcHMpLHt9LHtDb21wb25lbnQsZXJyLHJvdXRlcn0pO3JldHVybi8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcENvbnRhaW5lcixudWxsLC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcCxhcHBQcm9wcykpO307YXN5bmMgZnVuY3Rpb24gZG9SZW5kZXIoX3JlZjYpe3ZhcntBcHAsQ29tcG9uZW50LHByb3BzLGVycn09X3JlZjY7Ly8gVXN1YWwgZ2V0SW5pdGlhbFByb3BzIGZldGNoaW5nIGlzIGhhbmRsZWQgaW4gbmV4dC9yb3V0ZXJcbi8vIHRoaXMgaXMgZm9yIHdoZW4gRXJyb3JDb21wb25lbnQgZ2V0cyByZXBsYWNlZCBieSBDb21wb25lbnQgYnkgSE1SXG5pZighcHJvcHMmJkNvbXBvbmVudCYmQ29tcG9uZW50IT09RXJyb3JDb21wb25lbnQmJmxhc3RBcHBQcm9wcy5Db21wb25lbnQ9PT1FcnJvckNvbXBvbmVudCl7dmFye3BhdGhuYW1lLHF1ZXJ5Ol9xdWVyeSxhc1BhdGg6X2FzUGF0aH09cm91dGVyO3ZhciBBcHBUcmVlPXdyYXBBcHAoQXBwKTt2YXIgYXBwQ3R4PXtyb3V0ZXIsQXBwVHJlZSxDb21wb25lbnQ6RXJyb3JDb21wb25lbnQsY3R4OntlcnIscGF0aG5hbWUscXVlcnk6X3F1ZXJ5LGFzUGF0aDpfYXNQYXRoLEFwcFRyZWV9fTtwcm9wcz1hd2FpdCgwLF91dGlscy5sb2FkR2V0SW5pdGlhbFByb3BzKShBcHAsYXBwQ3R4KTt9Q29tcG9uZW50PUNvbXBvbmVudHx8bGFzdEFwcFByb3BzLkNvbXBvbmVudDtwcm9wcz1wcm9wc3x8bGFzdEFwcFByb3BzLnByb3BzO3ZhciBhcHBQcm9wcz0oMCxfZXh0ZW5kczIuZGVmYXVsdCkoKDAsX2V4dGVuZHMyLmRlZmF1bHQpKHt9LHByb3BzKSx7fSx7Q29tcG9uZW50LGVycixyb3V0ZXJ9KTsvLyBsYXN0QXBwUHJvcHMgaGFzIHRvIGJlIHNldCBiZWZvcmUgUmVhY3REb20ucmVuZGVyIHRvIGFjY291bnQgZm9yIFJlYWN0RG9tIHRocm93aW5nIGFuIGVycm9yLlxubGFzdEFwcFByb3BzPWFwcFByb3BzO2VtaXR0ZXIuZW1pdCgnYmVmb3JlLXJlYWN0ZG9tLXJlbmRlcicse0NvbXBvbmVudCxFcnJvckNvbXBvbmVudCxhcHBQcm9wc30pO3ZhciBlbGVtPS8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcENvbnRhaW5lcixudWxsLC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcCxhcHBQcm9wcykpOy8vIFdlIGNhdGNoIHJ1bnRpbWUgZXJyb3JzIHVzaW5nIGNvbXBvbmVudERpZENhdGNoIHdoaWNoIHdpbGwgdHJpZ2dlciByZW5kZXJFcnJvclxucmVuZGVyUmVhY3RFbGVtZW50KHByb2Nlc3MuZW52Ll9fTkVYVF9TVFJJQ1RfTU9ERT8vKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5TdHJpY3RNb2RlLG51bGwsZWxlbSk6ZWxlbSxhcHBFbGVtZW50KTtlbWl0dGVyLmVtaXQoJ2FmdGVyLXJlYWN0ZG9tLXJlbmRlcicse0NvbXBvbmVudCxFcnJvckNvbXBvbmVudCxhcHBQcm9wc30pO30iLCJcInVzZSBzdHJpY3RcIjt2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdD1yZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7dmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkPXJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7dmFyIG5leHQ9X2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vXCIpKTt2YXIgX2V2ZW50U291cmNlUG9seWZpbGw9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9kZXYvZXZlbnQtc291cmNlLXBvbHlmaWxsXCIpKTt2YXIgX29uRGVtYW5kRW50cmllc0NsaWVudD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Rldi9vbi1kZW1hbmQtZW50cmllcy1jbGllbnRcIikpO3ZhciBfd2VicGFja0hvdE1pZGRsZXdhcmVDbGllbnQ9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9kZXYvd2VicGFjay1ob3QtbWlkZGxld2FyZS1jbGllbnRcIikpO3ZhciBfZGV2QnVpbGRXYXRjaGVyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZGV2L2Rldi1idWlsZC13YXRjaGVyXCIpKTt2YXIgX3ByZXJlbmRlckluZGljYXRvcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Rldi9wcmVyZW5kZXItaW5kaWNhdG9yXCIpKTt2YXIgX2ZvdWM9cmVxdWlyZShcIi4vZGV2L2ZvdWNcIik7LyogZ2xvYmFscyBpbXBvcnQoJy4vZGV2L25vb3AnKTsgKi8gLy8gVGVtcG9yYXJ5IHdvcmthcm91bmQgZm9yIHRoZSBpc3N1ZSBkZXNjcmliZWQgaGVyZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96ZWl0L25leHQuanMvaXNzdWVzLzM3NzUjaXNzdWVjb21tZW50LTQwNzQzODEyM1xuLy8gVGhlIHJ1bnRpbWVDaHVuayBkb2Vzbid0IGhhdmUgZHluYW1pYyBpbXBvcnQgaGFuZGxpbmcgY29kZSB3aGVuIHRoZXJlIGhhc24ndCBiZWVuIGEgZHluYW1pYyBpbXBvcnRcbi8vIFRoZSBydW50aW1lQ2h1bmsgY2FuJ3QgaG90IHJlbG9hZCBpdHNlbGYgY3VycmVudGx5IHRvIGNvcnJlY3QgaXQgd2hlbiBhZGRpbmcgcGFnZXMgdXNpbmcgb24tZGVtYW5kLWVudHJpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbmltcG9ydCgnLi9kZXYvbm9vcCcpOzsvLyBTdXBwb3J0IEV2ZW50U291cmNlIG9uIEludGVybmV0IEV4cGxvcmVyIDExXG5pZighd2luZG93LkV2ZW50U291cmNlKXt3aW5kb3cuRXZlbnRTb3VyY2U9X2V2ZW50U291cmNlUG9seWZpbGwuZGVmYXVsdDt9dmFye19fTkVYVF9EQVRBX186e2Fzc2V0UHJlZml4fX09d2luZG93O3ZhciBwcmVmaXg9YXNzZXRQcmVmaXh8fCcnO3ZhciB3ZWJwYWNrSE1SPSgwLF93ZWJwYWNrSG90TWlkZGxld2FyZUNsaWVudC5kZWZhdWx0KSh7YXNzZXRQcmVmaXg6cHJlZml4fSk7d2luZG93Lm5leHQ9bmV4dDsoMCxuZXh0LmRlZmF1bHQpKHt3ZWJwYWNrSE1SfSkudGhlbigoX3JlZik9Pnt2YXJ7ZW1pdHRlcixyZW5kZXJDdHgscmVuZGVyfT1fcmVmOygwLF9vbkRlbWFuZEVudHJpZXNDbGllbnQuZGVmYXVsdCkoe2Fzc2V0UHJlZml4OnByZWZpeH0pO2lmKHByb2Nlc3MuZW52Ll9fTkVYVF9CVUlMRF9JTkRJQ0FUT1IpKDAsX2RldkJ1aWxkV2F0Y2hlci5kZWZhdWx0KSgpO2lmKHByb2Nlc3MuZW52Ll9fTkVYVF9QUkVSRU5ERVJfSU5ESUNBVE9SJiYvLyBkaXNhYmxlIGJ5IGRlZmF1bHQgaW4gZWxlY3Ryb25cbiEodHlwZW9mIHByb2Nlc3MhPT0ndW5kZWZpbmVkJyYmJ2VsZWN0cm9uJ2luIHByb2Nlc3MudmVyc2lvbnMpKXsoMCxfcHJlcmVuZGVySW5kaWNhdG9yLmRlZmF1bHQpKCk7fS8vIGRlbGF5IHJlbmRlcmluZyB1bnRpbCBhZnRlciBzdHlsZXMgaGF2ZSBiZWVuIGFwcGxpZWQgaW4gZGV2ZWxvcG1lbnRcbigwLF9mb3VjLmRpc3BsYXlDb250ZW50KSgoKT0+e3JlbmRlcihyZW5kZXJDdHgpO30pO3ZhciBsYXN0U2Nyb2xsO2VtaXR0ZXIub24oJ2JlZm9yZS1yZWFjdGRvbS1yZW5kZXInLChfcmVmMik9Pnt2YXJ7Q29tcG9uZW50LEVycm9yQ29tcG9uZW50fT1fcmVmMjsvLyBSZW1lbWJlciBzY3JvbGwgd2hlbiBFcnJvckNvbXBvbmVudCBpcyBiZWluZyByZW5kZXJlZCB0byBsYXRlciByZXN0b3JlIGl0XG5pZighbGFzdFNjcm9sbCYmQ29tcG9uZW50PT09RXJyb3JDb21wb25lbnQpe3ZhcntwYWdlWE9mZnNldCxwYWdlWU9mZnNldH09d2luZG93O2xhc3RTY3JvbGw9e3g6cGFnZVhPZmZzZXQseTpwYWdlWU9mZnNldH07fX0pO2VtaXR0ZXIub24oJ2FmdGVyLXJlYWN0ZG9tLXJlbmRlcicsKF9yZWYzKT0+e3ZhcntDb21wb25lbnQsRXJyb3JDb21wb25lbnR9PV9yZWYzO2lmKGxhc3RTY3JvbGwmJkNvbXBvbmVudCE9PUVycm9yQ29tcG9uZW50KXsvLyBSZXN0b3JlIHNjcm9sbCBhZnRlciBFcnJvckNvbXBvbmVudCB3YXMgcmVwbGFjZWQgd2l0aCBhIHBhZ2UgY29tcG9uZW50IGJ5IEhNUlxudmFye3gseX09bGFzdFNjcm9sbDt3aW5kb3cuc2Nyb2xsKHgseSk7bGFzdFNjcm9sbD1udWxsO319KTt9KS5jYXRjaChlcnI9Pntjb25zb2xlLmVycm9yKCdFcnJvciB3YXMgbm90IGNhdWdodCcsZXJyKTt9KTsiLCJcInVzZSBzdHJpY3RcIjt2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdD1yZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0cy5kZWZhdWx0PXZvaWQgMDt2YXIgX3VybD1yZXF1aXJlKFwidXJsXCIpO3ZhciBfbWl0dD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9uZXh0LXNlcnZlci9saWIvbWl0dFwiKSk7dmFyIF9pc0R5bmFtaWM9cmVxdWlyZShcIi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljXCIpO3ZhciBfcm91dGVNYXRjaGVyPXJlcXVpcmUoXCIuLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlclwiKTt2YXIgX3JvdXRlUmVnZXg9cmVxdWlyZShcIi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yb3V0ZS1yZWdleFwiKTt2YXIgX3JvdXRlcj1yZXF1aXJlKFwiLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlclwiKTtmdW5jdGlvbiBoYXNSZWwocmVsLGxpbmspe3RyeXtsaW5rPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtyZXR1cm4gbGluay5yZWxMaXN0LnN1cHBvcnRzKHJlbCk7fWNhdGNoKF91bnVzZWQpe319dmFyIHJlbFByZWZldGNoPWhhc1JlbCgncHJlbG9hZCcpJiYhaGFzUmVsKCdwcmVmZXRjaCcpPy8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI2ZlYXQ9bGluay1yZWwtcHJlbG9hZFxuLy8gbWFjT1MgYW5kIGlPUyAoU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgcHJlZmV0Y2gpXG4ncHJlbG9hZCc6Ly8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD1saW5rLXJlbC1wcmVmZXRjaFxuLy8gSUUgMTEsIEVkZ2UgMTIrLCBuZWFybHkgYWxsIGV2ZXJncmVlblxuJ3ByZWZldGNoJzt2YXIgaGFzTm9Nb2R1bGU9KCdub01vZHVsZSdpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSk7LyoqIEBwYXJhbSB7c3RyaW5nfSByb3V0ZSAqL2Z1bmN0aW9uIG5vcm1hbGl6ZVJvdXRlKHJvdXRlKXtpZihyb3V0ZVswXSE9PScvJyl7dGhyb3cgbmV3IEVycm9yKFwiUm91dGUgbmFtZSBzaG91bGQgc3RhcnQgd2l0aCBhIFxcXCIvXFxcIiwgZ290IFxcXCJcIityb3V0ZStcIlxcXCJcIik7fXJvdXRlPXJvdXRlLnJlcGxhY2UoL1xcL2luZGV4JC8sJy8nKTtpZihyb3V0ZT09PScvJylyZXR1cm4gcm91dGU7cmV0dXJuIHJvdXRlLnJlcGxhY2UoL1xcLyQvLCcnKTt9ZnVuY3Rpb24gYXBwZW5kTGluayhocmVmLHJlbCxhcyl7cmV0dXJuIG5ldyBQcm9taXNlKChyZXMscmVqLGxpbmspPT57bGluaz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7bGluay5jcm9zc09yaWdpbj1wcm9jZXNzLmNyb3NzT3JpZ2luO2xpbmsuaHJlZj1ocmVmO2xpbmsucmVsPXJlbDtpZihhcylsaW5rLmFzPWFzO2xpbmsub25sb2FkPXJlcztsaW5rLm9uZXJyb3I9cmVqO2RvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGluayk7fSk7fWNsYXNzIFBhZ2VMb2FkZXJ7Y29uc3RydWN0b3IoYnVpbGRJZCxhc3NldFByZWZpeCl7dGhpcy5idWlsZElkPWJ1aWxkSWQ7dGhpcy5hc3NldFByZWZpeD1hc3NldFByZWZpeDt0aGlzLnBhZ2VDYWNoZT17fTt0aGlzLnBhZ2VSZWdpc3RlckV2ZW50cz0oMCxfbWl0dC5kZWZhdWx0KSgpO3RoaXMubG9hZGluZ1JvdXRlcz17fTtpZihwcm9jZXNzLmVudi5fX05FWFRfR1JBTlVMQVJfQ0hVTktTKXt0aGlzLnByb21pc2VkQnVpbGRNYW5pZmVzdD1uZXcgUHJvbWlzZShyZXNvbHZlPT57aWYod2luZG93Ll9fQlVJTERfTUFOSUZFU1Qpe3Jlc29sdmUod2luZG93Ll9fQlVJTERfTUFOSUZFU1QpO31lbHNle3dpbmRvdy5fX0JVSUxEX01BTklGRVNUX0NCPSgpPT57cmVzb2x2ZSh3aW5kb3cuX19CVUlMRF9NQU5JRkVTVCk7fTt9fSk7fS8qKiBAdHlwZSB7UHJvbWlzZTxTZXQ8c3RyaW5nPj59ICovdGhpcy5wcm9taXNlZFNzZ01hbmlmZXN0PW5ldyBQcm9taXNlKHJlc29sdmU9PntpZih3aW5kb3cuX19TU0dfTUFOSUZFU1Qpe3Jlc29sdmUod2luZG93Ll9fU1NHX01BTklGRVNUKTt9ZWxzZXt3aW5kb3cuX19TU0dfTUFOSUZFU1RfQ0I9KCk9PntyZXNvbHZlKHdpbmRvdy5fX1NTR19NQU5JRkVTVCk7fTt9fSk7fS8vIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZGVwZW5kZW5jaWVzIGZvciBhIHBhcnRpY3VsYXIgcm91dGVcbmdldERlcGVuZGVuY2llcyhyb3V0ZSl7cmV0dXJuIHRoaXMucHJvbWlzZWRCdWlsZE1hbmlmZXN0LnRoZW4obWFuPT5tYW5bcm91dGVdJiZtYW5bcm91dGVdLm1hcCh1cmw9PnRoaXMuYXNzZXRQcmVmaXgrXCIvX25leHQvXCIrZW5jb2RlVVJJKHVybCkpfHxbXSk7fS8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZiB0aGUgcm91dGUgaHJlZiAoZmlsZS1zeXN0ZW0gcGF0aClcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFzUGF0aCB0aGUgVVJMIGFzIHNob3duIGluIGJyb3dzZXIgKHZpcnR1YWwgcGF0aCk7IHVzZWQgZm9yIGR5bmFtaWMgcm91dGVzXG4gICAqL2dldERhdGFIcmVmKGhyZWYsYXNQYXRoKXt2YXIgZ2V0SHJlZkZvclNsdWc9LyoqIEB0eXBlIHN0cmluZyAqL3BhdGg9PntwYXRoPSgwLF9yb3V0ZXIuZGVsQmFzZVBhdGgpKHBhdGgpO3JldHVybiB0aGlzLmFzc2V0UHJlZml4K1wiL19uZXh0L2RhdGEvXCIrdGhpcy5idWlsZElkKyhwYXRoPT09Jy8nPycvaW5kZXgnOnBhdGgpK1wiLmpzb25cIjt9O3ZhcntwYXRobmFtZTpocmVmUGF0aG5hbWUscXVlcnl9PSgwLF91cmwucGFyc2UpKGhyZWYsdHJ1ZSk7dmFye3BhdGhuYW1lOmFzUGF0aG5hbWV9PSgwLF91cmwucGFyc2UpKGFzUGF0aCk7dmFyIHJvdXRlPW5vcm1hbGl6ZVJvdXRlKGhyZWZQYXRobmFtZSk7dmFyIGlzRHluYW1pYz0oMCxfaXNEeW5hbWljLmlzRHluYW1pY1JvdXRlKShyb3V0ZSksaW50ZXJwb2xhdGVkUm91dGU7aWYoaXNEeW5hbWljKXt2YXIgZHluYW1pY1JlZ2V4PSgwLF9yb3V0ZVJlZ2V4LmdldFJvdXRlUmVnZXgpKHJvdXRlKTt2YXIgZHluYW1pY0dyb3Vwcz1keW5hbWljUmVnZXguZ3JvdXBzO3ZhciBkeW5hbWljTWF0Y2hlcz0vLyBUcnkgdG8gbWF0Y2ggdGhlIGR5bmFtaWMgcm91dGUgYWdhaW5zdCB0aGUgYXNQYXRoXG4oMCxfcm91dGVNYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikoZHluYW1pY1JlZ2V4KShhc1BhdGhuYW1lKXx8Ly8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBocmVmXG4vLyBUT0RPOiBzaG91bGQgdGhpcyB0YWtlIHByaW9yaXR5OyBhbHNvIG5lZWQgdG8gY2hhbmdlIGluIHRoZSByb3V0ZXIuXG5xdWVyeTtpbnRlcnBvbGF0ZWRSb3V0ZT1yb3V0ZTtpZighT2JqZWN0LmtleXMoZHluYW1pY0dyb3VwcykuZXZlcnkocGFyYW09Pnt2YXIgdmFsdWU9ZHluYW1pY01hdGNoZXNbcGFyYW1dO3ZhciByZXBlYXQ9ZHluYW1pY0dyb3Vwc1twYXJhbV0ucmVwZWF0Oy8vIHN1cHBvcnQgc2luZ2xlLWxldmVsIGNhdGNoLWFsbFxuLy8gVE9ETzogbW9yZSByb2J1c3QgaGFuZGxpbmcgZm9yIHVzZXItZXJyb3IgKHBhc3NpbmcgYC9gKVxuaWYocmVwZWF0JiYhQXJyYXkuaXNBcnJheSh2YWx1ZSkpdmFsdWU9W3ZhbHVlXTtyZXR1cm4gcGFyYW0gaW4gZHluYW1pY01hdGNoZXMmJigvLyBJbnRlcnBvbGF0ZSBncm91cCBpbnRvIGRhdGEgVVJMIGlmIHByZXNlbnRcbmludGVycG9sYXRlZFJvdXRlPWludGVycG9sYXRlZFJvdXRlLnJlcGxhY2UoXCJbXCIrKHJlcGVhdD8nLi4uJzonJykrcGFyYW0rXCJdXCIscmVwZWF0P3ZhbHVlLm1hcChlbmNvZGVVUklDb21wb25lbnQpLmpvaW4oJy8nKTplbmNvZGVVUklDb21wb25lbnQodmFsdWUpKSk7fSkpe2ludGVycG9sYXRlZFJvdXRlPScnOy8vIGRpZCBub3Qgc2F0aXNmeSBhbGwgcmVxdWlyZW1lbnRzXG4vLyBuLmIuIFdlIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugd2UgaGFuZGxlIHdhcm5pbmcgZm9yIHRoaXMgY2FzZSBpblxuLy8gZGV2ZWxvcG1lbnQgaW4gdGhlIGA8TGluaz5gIGNvbXBvbmVudCBkaXJlY3RseS5cbn19cmV0dXJuIGlzRHluYW1pYz9pbnRlcnBvbGF0ZWRSb3V0ZSYmZ2V0SHJlZkZvclNsdWcoaW50ZXJwb2xhdGVkUm91dGUpOmdldEhyZWZGb3JTbHVnKHJvdXRlKTt9LyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmIHRoZSByb3V0ZSBocmVmIChmaWxlLXN5c3RlbSBwYXRoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXNQYXRoIHRoZSBVUkwgYXMgc2hvd24gaW4gYnJvd3NlciAodmlydHVhbCBwYXRoKTsgdXNlZCBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICovcHJlZmV0Y2hEYXRhKGhyZWYsYXNQYXRoKXt2YXJ7cGF0aG5hbWU6aHJlZlBhdGhuYW1lfT0oMCxfdXJsLnBhcnNlKShocmVmLHRydWUpO3ZhciByb3V0ZT1ub3JtYWxpemVSb3V0ZShocmVmUGF0aG5hbWUpO3JldHVybiB0aGlzLnByb21pc2VkU3NnTWFuaWZlc3QudGhlbigocyxfZGF0YUhyZWYpPT4vLyBDaGVjayBpZiB0aGUgcm91dGUgcmVxdWlyZXMgYSBkYXRhIGZpbGVcbnMuaGFzKHJvdXRlKSYmKC8vIFRyeSB0byBnZW5lcmF0ZSBkYXRhIGhyZWYsIG5vb3Agd2hlbiBmYWxzeVxuX2RhdGFIcmVmPXRoaXMuZ2V0RGF0YUhyZWYoaHJlZixhc1BhdGgpKSYmLy8gbm9vcCB3aGVuIGRhdGEgaGFzIGFscmVhZHkgYmVlbiBwcmVmZXRjaGVkIChkZWR1cGUpXG4hZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImxpbmtbcmVsPVxcXCJcIityZWxQcmVmZXRjaCtcIlxcXCJdW2hyZWZePVxcXCJcIitfZGF0YUhyZWYrXCJcXFwiXVwiKSYmLy8gSW5qZWN0IHRoZSBgPGxpbmsgcmVsPXByZWZldGNoPmAgdGFnIGZvciBhYm92ZSBjb21wdXRlZCBgaHJlZmAuXG5hcHBlbmRMaW5rKF9kYXRhSHJlZixyZWxQcmVmZXRjaCwnZmV0Y2gnKSk7fWxvYWRQYWdlKHJvdXRlKXtyZXR1cm4gdGhpcy5sb2FkUGFnZVNjcmlwdChyb3V0ZSk7fWxvYWRQYWdlU2NyaXB0KHJvdXRlKXtyb3V0ZT1ub3JtYWxpemVSb3V0ZShyb3V0ZSk7cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9Pnt2YXIgZmlyZT0oX3JlZik9Pnt2YXJ7ZXJyb3IscGFnZSxtb2R9PV9yZWY7dGhpcy5wYWdlUmVnaXN0ZXJFdmVudHMub2ZmKHJvdXRlLGZpcmUpO2RlbGV0ZSB0aGlzLmxvYWRpbmdSb3V0ZXNbcm91dGVdO2lmKGVycm9yKXtyZWplY3QoZXJyb3IpO31lbHNle3Jlc29sdmUoe3BhZ2UsbW9kfSk7fX07Ly8gSWYgdGhlcmUncyBhIGNhY2hlZCB2ZXJzaW9uIG9mIHRoZSBwYWdlLCBsZXQncyB1c2UgaXQuXG52YXIgY2FjaGVkUGFnZT10aGlzLnBhZ2VDYWNoZVtyb3V0ZV07aWYoY2FjaGVkUGFnZSl7dmFye2Vycm9yLHBhZ2UsbW9kfT1jYWNoZWRQYWdlO2Vycm9yP3JlamVjdChlcnJvcik6cmVzb2x2ZSh7cGFnZSxtb2R9KTtyZXR1cm47fS8vIFJlZ2lzdGVyIGEgbGlzdGVuZXIgdG8gZ2V0IHRoZSBwYWdlXG50aGlzLnBhZ2VSZWdpc3RlckV2ZW50cy5vbihyb3V0ZSxmaXJlKTsvLyBJZiB0aGUgcGFnZSBpcyBsb2FkaW5nIHZpYSBTU1IsIHdlIG5lZWQgdG8gd2FpdCBmb3IgaXRcbi8vIHJhdGhlciBkb3dubG9hZGluZyBpdCBhZ2Fpbi5cbmlmKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJzY3JpcHRbZGF0YS1uZXh0LXBhZ2U9XFxcIlwiK3JvdXRlK1wiXFxcIl1cIikpe3JldHVybjt9aWYoIXRoaXMubG9hZGluZ1JvdXRlc1tyb3V0ZV0pe3RoaXMubG9hZGluZ1JvdXRlc1tyb3V0ZV09dHJ1ZTtpZihwcm9jZXNzLmVudi5fX05FWFRfR1JBTlVMQVJfQ0hVTktTKXt0aGlzLmdldERlcGVuZGVuY2llcyhyb3V0ZSkudGhlbihkZXBzPT57ZGVwcy5mb3JFYWNoKGQ9PntpZigvXFwuanMkLy50ZXN0KGQpJiYhZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInNjcmlwdFtzcmNePVxcXCJcIitkK1wiXFxcIl1cIikpe3RoaXMubG9hZFNjcmlwdChkLHJvdXRlLGZhbHNlKTt9aWYoL1xcLmNzcyQvLnRlc3QoZCkmJiFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibGlua1tyZWw9c3R5bGVzaGVldF1baHJlZl49XFxcIlwiK2QrXCJcXFwiXVwiKSl7YXBwZW5kTGluayhkLCdzdHlsZXNoZWV0JykuY2F0Y2goKCk9PnsvLyBGSVhNRTogaGFuZGxlIGZhaWx1cmVcbi8vIFJpZ2h0IG5vdywgdGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudCBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uLlxufSk7fX0pO3RoaXMubG9hZFJvdXRlKHJvdXRlKTt9KTt9ZWxzZXt0aGlzLmxvYWRSb3V0ZShyb3V0ZSk7fX19KTt9bG9hZFJvdXRlKHJvdXRlKXtyb3V0ZT1ub3JtYWxpemVSb3V0ZShyb3V0ZSk7dmFyIHNjcmlwdFJvdXRlPXJvdXRlPT09Jy8nPycvaW5kZXguanMnOnJvdXRlK1wiLmpzXCI7dmFyIHVybD10aGlzLmFzc2V0UHJlZml4K1wiL19uZXh0L3N0YXRpYy9cIitlbmNvZGVVUklDb21wb25lbnQodGhpcy5idWlsZElkKStcIi9wYWdlc1wiK2VuY29kZVVSSShzY3JpcHRSb3V0ZSk7dGhpcy5sb2FkU2NyaXB0KHVybCxyb3V0ZSx0cnVlKTt9bG9hZFNjcmlwdCh1cmwscm91dGUsaXNQYWdlKXt2YXIgc2NyaXB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO2lmKHByb2Nlc3MuZW52Ll9fTkVYVF9NT0RFUk5fQlVJTEQmJmhhc05vTW9kdWxlKXtzY3JpcHQudHlwZT0nbW9kdWxlJzsvLyBPbmx5IHBhZ2UgYnVuZGxlIHNjcmlwdHMgbmVlZCB0byBoYXZlIC5tb2R1bGUgYWRkZWQgdG8gdXJsLFxuLy8gZGVwZW5kZW5jaWVzIGFscmVhZHkgaGF2ZSBpdCBhZGRlZCBkdXJpbmcgYnVpbGQgbWFuaWZlc3QgY3JlYXRpb25cbmlmKGlzUGFnZSl1cmw9dXJsLnJlcGxhY2UoL1xcLmpzJC8sJy5tb2R1bGUuanMnKTt9c2NyaXB0LmNyb3NzT3JpZ2luPXByb2Nlc3MuY3Jvc3NPcmlnaW47c2NyaXB0LnNyYz11cmw7c2NyaXB0Lm9uZXJyb3I9KCk9Pnt2YXIgZXJyb3I9bmV3IEVycm9yKFwiRXJyb3IgbG9hZGluZyBzY3JpcHQgXCIrdXJsKTtlcnJvci5jb2RlPSdQQUdFX0xPQURfRVJST1InO3RoaXMucGFnZVJlZ2lzdGVyRXZlbnRzLmVtaXQocm91dGUse2Vycm9yfSk7fTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7fS8vIFRoaXMgbWV0aG9kIGlmIGNhbGxlZCBieSB0aGUgcm91dGUgY29kZS5cbnJlZ2lzdGVyUGFnZShyb3V0ZSxyZWdGbil7dmFyIHJlZ2lzdGVyPSgpPT57dHJ5e3ZhciBtb2Q9cmVnRm4oKTt2YXIgcGFnZURhdGE9e3BhZ2U6bW9kLmRlZmF1bHR8fG1vZCxtb2R9O3RoaXMucGFnZUNhY2hlW3JvdXRlXT1wYWdlRGF0YTt0aGlzLnBhZ2VSZWdpc3RlckV2ZW50cy5lbWl0KHJvdXRlLHBhZ2VEYXRhKTt9Y2F0Y2goZXJyb3Ipe3RoaXMucGFnZUNhY2hlW3JvdXRlXT17ZXJyb3J9O3RoaXMucGFnZVJlZ2lzdGVyRXZlbnRzLmVtaXQocm91dGUse2Vycm9yfSk7fX07aWYocHJvY2Vzcy5lbnYuTk9ERV9FTlYhPT0ncHJvZHVjdGlvbicpey8vIFdhaXQgZm9yIHdlYnBhY2sgdG8gYmVjb21lIGlkbGUgaWYgaXQncyBub3QuXG4vLyBNb3JlIGluZm86IGh0dHBzOi8vZ2l0aHViLmNvbS96ZWl0L25leHQuanMvcHVsbC8xNTExXG5pZihtb2R1bGUuaG90JiZtb2R1bGUuaG90LnN0YXR1cygpIT09J2lkbGUnKXtjb25zb2xlLmxvZyhcIldhaXRpbmcgZm9yIHdlYnBhY2sgdG8gYmVjb21lIFxcXCJpZGxlXFxcIiB0byBpbml0aWFsaXplIHRoZSBwYWdlOiBcXFwiXCIrcm91dGUrXCJcXFwiXCIpO3ZhciBjaGVjaz1zdGF0dXM9PntpZihzdGF0dXM9PT0naWRsZScpe21vZHVsZS5ob3QucmVtb3ZlU3RhdHVzSGFuZGxlcihjaGVjayk7cmVnaXN0ZXIoKTt9fTttb2R1bGUuaG90LnN0YXR1cyhjaGVjayk7cmV0dXJuO319cmVnaXN0ZXIoKTt9LyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb3V0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlcGVuZGVuY3ldXG4gICAqL3ByZWZldGNoKHJvdXRlLGlzRGVwZW5kZW5jeSl7Ly8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvcXVpY2tsaW5rL2Jsb2IvNDUzYTY2MWZhMWZhOTQwZTJkMmUwNDQ0NTIzOThlMzhjNjdhOThmYi9zcmMvaW5kZXgubWpzI0wxMTUtTDExOFxuLy8gTGljZW5zZTogQXBhY2hlIDIuMFxudmFyIGNuO2lmKGNuPW5hdmlnYXRvci5jb25uZWN0aW9uKXsvLyBEb24ndCBwcmVmZXRjaCBpZiB1c2luZyAyRyBvciBpZiBTYXZlLURhdGEgaXMgZW5hYmxlZC5cbmlmKGNuLnNhdmVEYXRhfHwvMmcvLnRlc3QoY24uZWZmZWN0aXZlVHlwZSkpcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO30vKiogQHR5cGUge3N0cmluZ30gKi92YXIgdXJsO2lmKGlzRGVwZW5kZW5jeSl7dXJsPXJvdXRlO31lbHNle3JvdXRlPW5vcm1hbGl6ZVJvdXRlKHJvdXRlKTt2YXIgc2NyaXB0Um91dGU9KHJvdXRlPT09Jy8nPycvaW5kZXgnOnJvdXRlKStcIi5qc1wiO2lmKHByb2Nlc3MuZW52Ll9fTkVYVF9NT0RFUk5fQlVJTEQmJmhhc05vTW9kdWxlKXtzY3JpcHRSb3V0ZT1zY3JpcHRSb3V0ZS5yZXBsYWNlKC9cXC5qcyQvLCcubW9kdWxlLmpzJyk7fXVybD10aGlzLmFzc2V0UHJlZml4K1wiL19uZXh0L3N0YXRpYy9cIitlbmNvZGVVUklDb21wb25lbnQodGhpcy5idWlsZElkKStcIi9wYWdlc1wiK2VuY29kZVVSSShzY3JpcHRSb3V0ZSk7fXJldHVybiBQcm9taXNlLmFsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibGlua1tyZWw9XFxcIlwiK3JlbFByZWZldGNoK1wiXFxcIl1baHJlZl49XFxcIlwiK3VybCtcIlxcXCJdLCBzY3JpcHRbZGF0YS1uZXh0LXBhZ2U9XFxcIlwiK3JvdXRlK1wiXFxcIl1cIik/W106W2FwcGVuZExpbmsodXJsLHJlbFByZWZldGNoLHVybC5tYXRjaCgvXFwuY3NzJC8pPydzdHlsZSc6J3NjcmlwdCcpLHByb2Nlc3MuZW52Ll9fTkVYVF9HUkFOVUxBUl9DSFVOS1MmJiFpc0RlcGVuZGVuY3kmJnRoaXMuZ2V0RGVwZW5kZW5jaWVzKHJvdXRlKS50aGVuKHVybHM9PlByb21pc2UuYWxsKHVybHMubWFwKHVybD0+dGhpcy5wcmVmZXRjaCh1cmwsdHJ1ZSkpKSldKS50aGVuKC8vIGRvIG5vdCByZXR1cm4gYW55IGRhdGFcbigpPT57fSwvLyBzd2FsbG93IHByZWZldGNoIGVycm9yc1xuKCk9Pnt9KTt9fWV4cG9ydHMuZGVmYXVsdD1QYWdlTG9hZGVyOyIsIlwidXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMuZGVmYXVsdD12b2lkIDA7dmFyIF93ZWJWaXRhbHM9cmVxdWlyZShcIndlYi12aXRhbHNcIik7dmFyIF9kZWZhdWx0PW9uUGVyZkVudHJ5PT57KDAsX3dlYlZpdGFscy5nZXRDTFMpKG9uUGVyZkVudHJ5KTsoMCxfd2ViVml0YWxzLmdldEZJRCkob25QZXJmRW50cnkpOygwLF93ZWJWaXRhbHMuZ2V0RkNQKShvblBlcmZFbnRyeSk7KDAsX3dlYlZpdGFscy5nZXRMQ1ApKG9uUGVyZkVudHJ5KTsoMCxfd2ViVml0YWxzLmdldFRURkIpKG9uUGVyZkVudHJ5KTt9O2V4cG9ydHMuZGVmYXVsdD1fZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjt2YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ9cmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZFwiKTt2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdD1yZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0cy51c2VSb3V0ZXI9dXNlUm91dGVyO2V4cG9ydHMubWFrZVB1YmxpY1JvdXRlckluc3RhbmNlPW1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZTtleHBvcnRzLmNyZWF0ZVJvdXRlcj1leHBvcnRzLndpdGhSb3V0ZXI9ZXhwb3J0cy5kZWZhdWx0PXZvaWQgMDt2YXIgX3JlYWN0PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTt2YXIgX3JvdXRlcjI9X2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyXCIpKTtleHBvcnRzLlJvdXRlcj1fcm91dGVyMi5kZWZhdWx0O2V4cG9ydHMuTmV4dFJvdXRlcj1fcm91dGVyMi5OZXh0Um91dGVyO3ZhciBfcm91dGVyQ29udGV4dD1yZXF1aXJlKFwiLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0XCIpO3ZhciBfd2l0aFJvdXRlcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3dpdGgtcm91dGVyXCIpKTtleHBvcnRzLndpdGhSb3V0ZXI9X3dpdGhSb3V0ZXIuZGVmYXVsdDsvKiBnbG9iYWwgd2luZG93ICovdmFyIHNpbmdsZXRvblJvdXRlcj17cm91dGVyOm51bGwsLy8gaG9sZHMgdGhlIGFjdHVhbCByb3V0ZXIgaW5zdGFuY2VcbnJlYWR5Q2FsbGJhY2tzOltdLHJlYWR5KGNiKXtpZih0aGlzLnJvdXRlcilyZXR1cm4gY2IoKTtpZih0eXBlb2Ygd2luZG93IT09J3VuZGVmaW5lZCcpe3RoaXMucmVhZHlDYWxsYmFja3MucHVzaChjYik7fX19Oy8vIENyZWF0ZSBwdWJsaWMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBvZiB0aGUgcm91dGVyIGluIHRoZSBzaW5nbGV0b25Sb3V0ZXJcbnZhciB1cmxQcm9wZXJ0eUZpZWxkcz1bJ3BhdGhuYW1lJywncm91dGUnLCdxdWVyeScsJ2FzUGF0aCcsJ2NvbXBvbmVudHMnLCdpc0ZhbGxiYWNrJywnYmFzZVBhdGgnXTt2YXIgcm91dGVyRXZlbnRzPVsncm91dGVDaGFuZ2VTdGFydCcsJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywncm91dGVDaGFuZ2VFcnJvcicsJ2hhc2hDaGFuZ2VTdGFydCcsJ2hhc2hDaGFuZ2VDb21wbGV0ZSddO3ZhciBjb3JlTWV0aG9kRmllbGRzPVsncHVzaCcsJ3JlcGxhY2UnLCdyZWxvYWQnLCdiYWNrJywncHJlZmV0Y2gnLCdiZWZvcmVQb3BTdGF0ZSddOy8vIEV2ZW50cyBpcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiB0aGUgcm91dGVyLCB0aGUgcm91dGVyIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbml0aWFsaXplZCB0byB1c2UgaXRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsJ2V2ZW50cycse2dldCgpe3JldHVybiBfcm91dGVyMi5kZWZhdWx0LmV2ZW50czt9fSk7dXJsUHJvcGVydHlGaWVsZHMuZm9yRWFjaChmaWVsZD0+ey8vIEhlcmUgd2UgbmVlZCB0byB1c2UgT2JqZWN0LmRlZmluZVByb3BlcnR5IGJlY2F1c2UsIHdlIG5lZWQgdG8gcmV0dXJuXG4vLyB0aGUgcHJvcGVydHkgYXNzaWduZWQgdG8gdGhlIGFjdHVhbCByb3V0ZXJcbi8vIFRoZSB2YWx1ZSBtaWdodCBnZXQgY2hhbmdlZCBhcyB3ZSBjaGFuZ2Ugcm91dGVzIGFuZCB0aGlzIGlzIHRoZVxuLy8gcHJvcGVyIHdheSB0byBhY2Nlc3MgaXRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsZmllbGQse2dldCgpe3ZhciByb3V0ZXI9Z2V0Um91dGVyKCk7cmV0dXJuIHJvdXRlcltmaWVsZF07fX0pO30pO2NvcmVNZXRob2RGaWVsZHMuZm9yRWFjaChmaWVsZD0+ey8vIFdlIGRvbid0IHJlYWxseSBrbm93IHRoZSB0eXBlcyBoZXJlLCBzbyB3ZSBhZGQgdGhlbSBsYXRlciBpbnN0ZWFkXG47c2luZ2xldG9uUm91dGVyW2ZpZWxkXT1mdW5jdGlvbigpe3ZhciByb3V0ZXI9Z2V0Um91dGVyKCk7cmV0dXJuIHJvdXRlcltmaWVsZF0oLi4uYXJndW1lbnRzKTt9O30pO3JvdXRlckV2ZW50cy5mb3JFYWNoKGV2ZW50PT57c2luZ2xldG9uUm91dGVyLnJlYWR5KCgpPT57X3JvdXRlcjIuZGVmYXVsdC5ldmVudHMub24oZXZlbnQsZnVuY3Rpb24oKXt2YXIgZXZlbnRGaWVsZD1cIm9uXCIrZXZlbnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZXZlbnQuc3Vic3RyaW5nKDEpO3ZhciBfc2luZ2xldG9uUm91dGVyPXNpbmdsZXRvblJvdXRlcjtpZihfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKXt0cnl7X3NpbmdsZXRvblJvdXRlcltldmVudEZpZWxkXSguLi5hcmd1bWVudHMpO31jYXRjaChlcnIpey8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG5jb25zb2xlLmVycm9yKFwiRXJyb3Igd2hlbiBydW5uaW5nIHRoZSBSb3V0ZXIgZXZlbnQ6IFwiK2V2ZW50RmllbGQpOy8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG5jb25zb2xlLmVycm9yKGVyci5tZXNzYWdlK1wiXFxuXCIrZXJyLnN0YWNrKTt9fX0pO30pO30pO2Z1bmN0aW9uIGdldFJvdXRlcigpe2lmKCFzaW5nbGV0b25Sb3V0ZXIucm91dGVyKXt2YXIgbWVzc2FnZT0nTm8gcm91dGVyIGluc3RhbmNlIGZvdW5kLlxcbicrJ1lvdSBzaG91bGQgb25seSB1c2UgXCJuZXh0L3JvdXRlclwiIGluc2lkZSB0aGUgY2xpZW50IHNpZGUgb2YgeW91ciBhcHAuXFxuJzt0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7fXJldHVybiBzaW5nbGV0b25Sb3V0ZXIucm91dGVyO30vLyBFeHBvcnQgdGhlIHNpbmdsZXRvblJvdXRlciBhbmQgdGhpcyBpcyB0aGUgcHVibGljIEFQSS5cbnZhciBfZGVmYXVsdD1zaW5nbGV0b25Sb3V0ZXI7Ly8gUmVleHBvcnQgdGhlIHdpdGhSb3V0ZSBIT0NcbmV4cG9ydHMuZGVmYXVsdD1fZGVmYXVsdDtmdW5jdGlvbiB1c2VSb3V0ZXIoKXtyZXR1cm4gX3JlYWN0LmRlZmF1bHQudXNlQ29udGV4dChfcm91dGVyQ29udGV4dC5Sb3V0ZXJDb250ZXh0KTt9Ly8gSU5URVJOQUwgQVBJU1xuLy8gLS0tLS0tLS0tLS0tLVxuLy8gKGRvIG5vdCB1c2UgZm9sbG93aW5nIGV4cG9ydHMgaW5zaWRlIHRoZSBhcHApXG4vLyBDcmVhdGUgYSByb3V0ZXIgYW5kIGFzc2lnbiBpdCBhcyB0aGUgc2luZ2xldG9uIGluc3RhbmNlLlxuLy8gVGhpcyBpcyB1c2VkIGluIGNsaWVudCBzaWRlIHdoZW4gd2UgYXJlIGluaXRpbGl6aW5nIHRoZSBhcHAuXG4vLyBUaGlzIHNob3VsZCAqKm5vdCoqIHVzZSBpbnNpZGUgdGhlIHNlcnZlci5cbnZhciBjcmVhdGVSb3V0ZXI9ZnVuY3Rpb24gY3JlYXRlUm91dGVyKCl7Zm9yKHZhciBfbGVuPWFyZ3VtZW50cy5sZW5ndGgsYXJncz1uZXcgQXJyYXkoX2xlbiksX2tleT0wO19rZXk8X2xlbjtfa2V5Kyspe2FyZ3NbX2tleV09YXJndW1lbnRzW19rZXldO31zaW5nbGV0b25Sb3V0ZXIucm91dGVyPW5ldyBfcm91dGVyMi5kZWZhdWx0KC4uLmFyZ3MpO3NpbmdsZXRvblJvdXRlci5yZWFkeUNhbGxiYWNrcy5mb3JFYWNoKGNiPT5jYigpKTtzaW5nbGV0b25Sb3V0ZXIucmVhZHlDYWxsYmFja3M9W107cmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXI7fTsvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBgd2l0aFJvdXRlcmAgcm91dGVyIGluc3RhbmNlXG5leHBvcnRzLmNyZWF0ZVJvdXRlcj1jcmVhdGVSb3V0ZXI7ZnVuY3Rpb24gbWFrZVB1YmxpY1JvdXRlckluc3RhbmNlKHJvdXRlcil7dmFyIF9yb3V0ZXI9cm91dGVyO3ZhciBpbnN0YW5jZT17fTtmb3IodmFyIHByb3BlcnR5IG9mIHVybFByb3BlcnR5RmllbGRzKXtpZih0eXBlb2YgX3JvdXRlcltwcm9wZXJ0eV09PT0nb2JqZWN0Jyl7aW5zdGFuY2VbcHJvcGVydHldPU9iamVjdC5hc3NpZ24oe30sX3JvdXRlcltwcm9wZXJ0eV0pOy8vIG1ha2VzIHN1cmUgcXVlcnkgaXMgbm90IHN0YXRlZnVsXG5jb250aW51ZTt9aW5zdGFuY2VbcHJvcGVydHldPV9yb3V0ZXJbcHJvcGVydHldO30vLyBFdmVudHMgaXMgYSBzdGF0aWMgcHJvcGVydHkgb24gdGhlIHJvdXRlciwgdGhlIHJvdXRlciBkb2Vzbid0IGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gdXNlIGl0XG5pbnN0YW5jZS5ldmVudHM9X3JvdXRlcjIuZGVmYXVsdC5ldmVudHM7Y29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKGZpZWxkPT57aW5zdGFuY2VbZmllbGRdPWZ1bmN0aW9uKCl7cmV0dXJuIF9yb3V0ZXJbZmllbGRdKC4uLmFyZ3VtZW50cyk7fTt9KTtyZXR1cm4gaW5zdGFuY2U7fSIsIlwidXNlIHN0cmljdFwiO3ZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0PXJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLmRlZmF1bHQ9d2l0aFJvdXRlcjt2YXIgX3JlYWN0PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTt2YXIgX3JvdXRlcj1yZXF1aXJlKFwiLi9yb3V0ZXJcIik7ZnVuY3Rpb24gd2l0aFJvdXRlcihDb21wb3NlZENvbXBvbmVudCl7ZnVuY3Rpb24gV2l0aFJvdXRlcldyYXBwZXIocHJvcHMpe3JldHVybi8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbXBvc2VkQ29tcG9uZW50LE9iamVjdC5hc3NpZ24oe3JvdXRlcjooMCxfcm91dGVyLnVzZVJvdXRlcikoKX0scHJvcHMpKTt9V2l0aFJvdXRlcldyYXBwZXIuZ2V0SW5pdGlhbFByb3BzPUNvbXBvc2VkQ29tcG9uZW50LmdldEluaXRpYWxQcm9wcy8vIFRoaXMgaXMgbmVlZGVkIHRvIGFsbG93IGNoZWNraW5nIGZvciBjdXN0b20gZ2V0SW5pdGlhbFByb3BzIGluIF9hcHBcbjtXaXRoUm91dGVyV3JhcHBlci5vcmlnR2V0SW5pdGlhbFByb3BzPUNvbXBvc2VkQ29tcG9uZW50Lm9yaWdHZXRJbml0aWFsUHJvcHM7aWYocHJvY2Vzcy5lbnYuTk9ERV9FTlYhPT0ncHJvZHVjdGlvbicpe3ZhciBuYW1lPUNvbXBvc2VkQ29tcG9uZW50LmRpc3BsYXlOYW1lfHxDb21wb3NlZENvbXBvbmVudC5uYW1lfHwnVW5rbm93bic7V2l0aFJvdXRlcldyYXBwZXIuZGlzcGxheU5hbWU9XCJ3aXRoUm91dGVyKFwiK25hbWUrXCIpXCI7fXJldHVybiBXaXRoUm91dGVyV3JhcHBlcjt9IiwibW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgdD17fTtmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKHIpe2lmKHRbcl0pe3JldHVybiB0W3JdLmV4cG9ydHN9dmFyIG49dFtyXT17aTpyLGw6ZmFsc2UsZXhwb3J0czp7fX07ZVtyXS5jYWxsKG4uZXhwb3J0cyxuLG4uZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKTtuLmw9dHJ1ZTtyZXR1cm4gbi5leHBvcnRzfV9fd2VicGFja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO2Z1bmN0aW9uIHN0YXJ0dXAoKXtyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUpfXJldHVybiBzdGFydHVwKCl9KHs4NDk6ZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPSgoe29ubHlGaXJzdDplPWZhbHNlfT17fSk9Pntjb25zdCByPVtcIltcXFxcdTAwMUJcXFxcdTAwOUJdW1tcXFxcXSgpIzs/XSooPzooPzooPzpbYS16QS1aXFxcXGRdKig/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSopKik/XFxcXHUwMDA3KVwiLFwiKD86KD86XFxcXGR7MSw0fSg/OjtcXFxcZHswLDR9KSopP1tcXFxcZEEtUFItVFpjZi1udHFyeT0+PH5dKSlcIl0uam9pbihcInxcIik7cmV0dXJuIG5ldyBSZWdFeHAocixlP3VuZGVmaW5lZDpcImdcIil9KX0sODU1OmZ1bmN0aW9uKGUscix0KXtcInVzZSBzdHJpY3RcIjtjb25zdCBuPXQoODQ5KTtlLmV4cG9ydHM9KGU9PnR5cGVvZiBlPT09XCJzdHJpbmdcIj9lLnJlcGxhY2UobigpLFwiXCIpOmUpfX0pOyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbmV4cG9ydHMuSGVhZE1hbmFnZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZXhwb3J0cy5IZWFkTWFuYWdlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnSGVhZE1hbmFnZXJDb250ZXh0Jztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuLypcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgSmFzb24gTWlsbGVyIChodHRwczovL2phc29uZm9ybWF0LmNvbS8pXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBtaXR0KCkge1xuICAgIGNvbnN0IGFsbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb24odHlwZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgKGFsbFt0eXBlXSB8fCAoYWxsW3R5cGVdID0gW10pKS5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB9LFxuICAgICAgICBvZmYodHlwZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKGFsbFt0eXBlXSkge1xuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG4gICAgICAgICAgICAgICAgYWxsW3R5cGVdLnNwbGljZShhbGxbdHlwZV0uaW5kZXhPZihoYW5kbGVyKSA+Pj4gMCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVtaXQodHlwZSwgLi4uZXZ0cykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgKGFsbFt0eXBlXSB8fCBbXSkuc2xpY2UoKS5tYXAoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKC4uLmV2dHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IG1pdHQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5leHBvcnRzLlJvdXRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBleHBvcnRzLlJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnUm91dGVyQ29udGV4dCc7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IG1pdHRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWl0dFwiKSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgaXNfZHluYW1pY18xID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtZHluYW1pY1wiKTtcbmNvbnN0IHJvdXRlX21hdGNoZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLW1hdGNoZXJcIik7XG5jb25zdCByb3V0ZV9yZWdleF8xID0gcmVxdWlyZShcIi4vdXRpbHMvcm91dGUtcmVnZXhcIik7XG5jb25zdCBiYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgJyc7XG5mdW5jdGlvbiBhZGRCYXNlUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGguaW5kZXhPZihiYXNlUGF0aCkgIT09IDAgPyBiYXNlUGF0aCArIHBhdGggOiBwYXRoO1xufVxuZXhwb3J0cy5hZGRCYXNlUGF0aCA9IGFkZEJhc2VQYXRoO1xuZnVuY3Rpb24gZGVsQmFzZVBhdGgocGF0aCkge1xuICAgIHJldHVybiBwYXRoLmluZGV4T2YoYmFzZVBhdGgpID09PSAwXG4gICAgICAgID8gcGF0aC5zdWJzdHIoYmFzZVBhdGgubGVuZ3RoKSB8fCAnLydcbiAgICAgICAgOiBwYXRoO1xufVxuZXhwb3J0cy5kZWxCYXNlUGF0aCA9IGRlbEJhc2VQYXRoO1xuZnVuY3Rpb24gdG9Sb3V0ZShwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwvJC8sICcnKSB8fCAnLyc7XG59XG5jb25zdCBwcmVwYXJlUm91dGUgPSAocGF0aCkgPT4gdG9Sb3V0ZSghcGF0aCB8fCBwYXRoID09PSAnLycgPyAnL2luZGV4JyA6IHBhdGgpO1xuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShwYXRobmFtZSwgcXVlcnksIGlzU2VydmVyUmVuZGVyLCBjYikge1xuICAgIGxldCBhdHRlbXB0cyA9IGlzU2VydmVyUmVuZGVyID8gMyA6IDE7XG4gICAgZnVuY3Rpb24gZ2V0UmVzcG9uc2UoKSB7XG4gICAgICAgIHJldHVybiBmZXRjaCh1dGlsc18xLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBhZGRCYXNlUGF0aChcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgX19ORVhUX0RBVEFfX1xuICAgICAgICAgICAgYC9fbmV4dC9kYXRhLyR7X19ORVhUX0RBVEFfXy5idWlsZElkfSR7ZGVsQmFzZVBhdGgocGF0aG5hbWUpfS5qc29uYCksXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgICAgICAgICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgICAgICAgICAgLy8gPiBvcHRpb24uXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmV0Y2hfQVBJL1VzaW5nX0ZldGNoXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAgICAgICAgIC8vID4gcmVjZWl2aW5nIGNvb2tpZXMsIGFsd2F5cyBzdXBwbHkgdGhlIGBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ2BcbiAgICAgICAgICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgICAgIH0pLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgaWYgKC0tYXR0ZW1wdHMgPiAwICYmIHJlcy5zdGF0dXMgPj0gNTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0UmVzcG9uc2UoKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgcmV0dXJuIGNiID8gY2IoZGF0YSkgOiBkYXRhO1xuICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIC8vIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzIGNhdXNlZFxuICAgICAgICAvLyBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50byBhbiBpbmZpbml0ZVxuICAgICAgICAvLyBsb29wLlxuICAgICAgICBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBlcnIuY29kZSA9ICdQQUdFX0xPQURfRVJST1InO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbn1cbmNsYXNzIFJvdXRlciB7XG4gICAgY29uc3RydWN0b3IocGF0aG5hbWUsIHF1ZXJ5LCBhcywgeyBpbml0aWFsUHJvcHMsIHBhZ2VMb2FkZXIsIEFwcCwgd3JhcEFwcCwgQ29tcG9uZW50LCBlcnIsIHN1YnNjcmlwdGlvbiwgaXNGYWxsYmFjaywgfSkge1xuICAgICAgICAvLyBTdGF0aWMgRGF0YSBDYWNoZVxuICAgICAgICB0aGlzLnNkYyA9IHt9O1xuICAgICAgICB0aGlzLm9uUG9wU3RhdGUgPSAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFlLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAgICAgICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAgICAgICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgICAgICAgICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgICAgICAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ3JlcGxhY2VTdGF0ZScsIHV0aWxzXzEuZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZSwgcXVlcnkgfSksIHV0aWxzXzEuZ2V0VVJMKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgICAgICAgICAgLy8gY2FuIGJlIGNhdXNlZCBieSBuYXZpZ2F0aW5nIGJhY2sgZnJvbSBhbiBleHRlcm5hbCBzaXRlXG4gICAgICAgICAgICBpZiAoZS5zdGF0ZSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaXNTc3IgJiZcbiAgICAgICAgICAgICAgICBlLnN0YXRlLmFzID09PSB0aGlzLmFzUGF0aCAmJlxuICAgICAgICAgICAgICAgIHVybF8xLnBhcnNlKGUuc3RhdGUudXJsKS5wYXRobmFtZSA9PT0gdGhpcy5wYXRobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAgICAgICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fYnBzICYmICF0aGlzLl9icHMoZS5zdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHVybCwgYXMsIG9wdGlvbnMgfSA9IGUuc3RhdGU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgYXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignYHBvcHN0YXRlYCBldmVudCB0cmlnZ2VyZWQgYnV0IGBldmVudC5zdGF0ZWAgZGlkIG5vdCBoYXZlIGB1cmxgIG9yIGBhc2AgaHR0cHM6Ly9lcnIuc2gvemVpdC9uZXh0LmpzL3BvcHN0YXRlLXN0YXRlLWVtcHR5Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXBsYWNlKHVybCwgYXMsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9nZXRTdGF0aWNEYXRhID0gKGFzUGF0aCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF0aG5hbWUgPSBwcmVwYXJlUm91dGUodXJsXzEucGFyc2UoYXNQYXRoKS5wYXRobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLnNkY1twYXRobmFtZV1cbiAgICAgICAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZSh0aGlzLnNkY1twYXRobmFtZV0pXG4gICAgICAgICAgICAgICAgOiBmZXRjaE5leHREYXRhKHBhdGhuYW1lLCBudWxsLCB0aGlzLmlzU3NyLCBkYXRhID0+ICh0aGlzLnNkY1twYXRobmFtZV0gPSBkYXRhKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2dldFNlcnZlckRhdGEgPSAoYXNQYXRoKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHVybF8xLnBhcnNlKGFzUGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICBwYXRobmFtZSA9IHByZXBhcmVSb3V0ZShwYXRobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YShwYXRobmFtZSwgcXVlcnksIHRoaXMuaXNTc3IpO1xuICAgICAgICB9O1xuICAgICAgICAvLyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGNvbXBvbmVudCBrZXlcbiAgICAgICAgdGhpcy5yb3V0ZSA9IHRvUm91dGUocGF0aG5hbWUpO1xuICAgICAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0ge307XG4gICAgICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGNhdXNlIGlzc3VlcyB3aGVuIHdoZW4gZ29pbmcgYmFjayBhbmRcbiAgICAgICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgICAgICBpZiAocGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdID0ge1xuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBwcm9wczogaW5pdGlhbFByb3BzLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXG4gICAgICAgICAgICAgICAgX19OX1NTUDogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NQLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10gPSB7IENvbXBvbmVudDogQXBwIH07XG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIFJvdXRlci5yb3V0ZXIuZXZlbnRzXG4gICAgICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgICAgIHRoaXMuZXZlbnRzID0gUm91dGVyLmV2ZW50cztcbiAgICAgICAgdGhpcy5wYWdlTG9hZGVyID0gcGFnZUxvYWRlcjtcbiAgICAgICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIC8vIGlmIGF1dG8gcHJlcmVuZGVyZWQgYW5kIGR5bmFtaWMgcm91dGUgd2FpdCB0byB1cGRhdGUgYXNQYXRoXG4gICAgICAgIC8vIHVudGlsIGFmdGVyIG1vdW50IHRvIHByZXZlbnQgaHlkcmF0aW9uIG1pc21hdGNoXG4gICAgICAgIHRoaXMuYXNQYXRoID1cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdGhpcyBpcyB0ZW1wb3JhcmlseSBnbG9iYWwgKGF0dGFjaGVkIHRvIHdpbmRvdylcbiAgICAgICAgICAgIGlzX2R5bmFtaWNfMS5pc0R5bmFtaWNSb3V0ZShwYXRobmFtZSkgJiYgX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0ID8gcGF0aG5hbWUgOiBhcztcbiAgICAgICAgdGhpcy5iYXNlUGF0aCA9IGJhc2VQYXRoO1xuICAgICAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcDtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgICAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICB0aGlzLmlzU3NyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0ZhbGxiYWNrID0gaXNGYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgXCJhc1wiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBkb3VibGUgc2xhc2hlcyBvciBlbHNlIGl0IGNhblxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgYXMgaXQncyBjb25zaWRlcmVkIGludmFsaWRcbiAgICAgICAgICAgIGlmIChhcy5zdWJzdHIoMCwgMikgIT09ICcvLycpIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ3JlcGxhY2VTdGF0ZScsIHV0aWxzXzEuZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZSwgcXVlcnkgfSksIGFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMub25Qb3BTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQGRlcHJlY2F0ZWQgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZXZlbiB0aG91Z2ggaXQncyBhIHByaXZhdGUgbWV0aG9kLlxuICAgIHN0YXRpYyBfcmV3cml0ZVVybEZvck5leHRFeHBvcnQodXJsKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfRVhQT1JUX1RSQUlMSU5HX1NMQVNIKSB7XG4gICAgICAgICAgICBjb25zdCByZXdyaXRlVXJsRm9yTmV4dEV4cG9ydCA9IHJlcXVpcmUoJy4vcmV3cml0ZS11cmwtZm9yLWV4cG9ydCcpXG4gICAgICAgICAgICAgICAgLnJld3JpdGVVcmxGb3JOZXh0RXhwb3J0O1xuICAgICAgICAgICAgcmV0dXJuIHJld3JpdGVVcmxGb3JOZXh0RXhwb3J0KHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZShyb3V0ZSwgbW9kKSB7XG4gICAgICAgIGNvbnN0IENvbXBvbmVudCA9IG1vZC5kZWZhdWx0IHx8IG1vZDtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXBkYXRlIHVuYXZhaWxhYmxlIHJvdXRlOiAke3JvdXRlfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0RhdGEgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7IENvbXBvbmVudCwgX19OX1NTRzogbW9kLl9fTl9TU0csIF9fTl9TU1A6IG1vZC5fX05fU1NQIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gbmV3RGF0YTtcbiAgICAgICAgLy8gcGFnZXMvX2FwcC5qcyB1cGRhdGVkXG4gICAgICAgIGlmIChyb3V0ZSA9PT0gJy9fYXBwJykge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkodGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91dGUgPT09IHRoaXMucm91dGUpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KG5ld0RhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHbyBiYWNrIGluIGhpc3RvcnlcbiAgICAgKi9cbiAgICBiYWNrKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAgICovXG4gICAgcHVzaCh1cmwsIGFzID0gdXJsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdwdXNoU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBgcmVwbGFjZVN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICAgKi9cbiAgICByZXBsYWNlKHVybCwgYXMgPSB1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjaGFuZ2UobWV0aG9kLCBfdXJsLCBfYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5faCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNTc3IgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcbiAgICAgICAgICAgIGlmICh1dGlsc18xLlNUKSB7XG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyaygncm91dGVDaGFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAgICAgICAgICAgLy8gd2UnbGwgZm9ybWF0IHRoZW0gaW50byB0aGUgc3RyaW5nIHZlcnNpb24gaGVyZS5cbiAgICAgICAgICAgIGxldCB1cmwgPSB0eXBlb2YgX3VybCA9PT0gJ29iamVjdCcgPyB1dGlsc18xLmZvcm1hdFdpdGhWYWxpZGF0aW9uKF91cmwpIDogX3VybDtcbiAgICAgICAgICAgIGxldCBhcyA9IHR5cGVvZiBfYXMgPT09ICdvYmplY3QnID8gdXRpbHNfMS5mb3JtYXRXaXRoVmFsaWRhdGlvbihfYXMpIDogX2FzO1xuICAgICAgICAgICAgdXJsID0gYWRkQmFzZVBhdGgodXJsKTtcbiAgICAgICAgICAgIGFzID0gYWRkQmFzZVBhdGgoYXMpO1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBlbmRpbmcgc2xhc2ggdG8gdGhlIHBhdGhzLiBTbywgd2UgY2FuIHNlcnZlIHRoZVxuICAgICAgICAgICAgLy8gXCI8cGFnZT4vaW5kZXguaHRtbFwiIGRpcmVjdGx5IGZvciB0aGUgU1NSIHBhZ2UuXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0VYUE9SVF9UUkFJTElOR19TTEFTSCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJld3JpdGVVcmxGb3JOZXh0RXhwb3J0ID0gcmVxdWlyZSgnLi9yZXdyaXRlLXVybC1mb3ItZXhwb3J0JylcbiAgICAgICAgICAgICAgICAgICAgLnJld3JpdGVVcmxGb3JOZXh0RXhwb3J0O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdGhpcyBpcyB0ZW1wb3JhcmlseSBnbG9iYWwgKGF0dGFjaGVkIHRvIHdpbmRvdylcbiAgICAgICAgICAgICAgICBpZiAoX19ORVhUX0RBVEFfXy5uZXh0RXhwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFzID0gcmV3cml0ZVVybEZvck5leHRFeHBvcnQoYXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWJvcnRDb21wb25lbnRMb2FkKGFzKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG4gICAgICAgICAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzIGNsaWVudC1zaWRlXG4gICAgICAgICAgICAvLyBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LiBJdCBtYXkgY2hhbmdlIGF0XG4gICAgICAgICAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5faCAmJiB0aGlzLm9ubHlBSGFzaENoYW5nZShhcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFzUGF0aCA9IGFzO1xuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZVN0YXJ0JywgYXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaChhcyk7XG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlQ29tcGxldGUnLCBhcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lLCBxdWVyeSwgcHJvdG9jb2wgfSA9IHVybF8xLnBhcnNlKHVybCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIXBhdGhuYW1lIHx8IHByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhyZWYgcGFzc2VkIHRvIHJvdXRlcjogJHt1cmx9IGh0dHBzOi8vZXJyLnNoL3plaXQvbmV4dC5qcy9pbnZhbGlkLWhyZWYtcGFzc2VkYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGFza2VkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBVUkwgd2Ugc2hvdWxkIHJlbG9hZCB0aGUgY3VycmVudCBwYWdlXG4gICAgICAgICAgICAvLyAobm90IGxvY2F0aW9uLnJlbG9hZCgpIGJ1dCByZWxvYWQgZ2V0SW5pdGlhbFByb3BzIGFuZCBvdGhlciBOZXh0LmpzIHN0dWZmcylcbiAgICAgICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAgICAgICAgIC8vIGFzIHRoaXMgc2hvdWxkIG5vdCBnbyBpbnRvIHRoZSBoaXN0b3J5IChUaGF0J3MgaG93IGJyb3dzZXJzIHdvcmspXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgY29tcGFyZSB0aGUgbmV3IGFzUGF0aCB0byB0aGUgY3VycmVudCBhc1BhdGgsIG5vdCB0aGUgdXJsXG4gICAgICAgICAgICBpZiAoIXRoaXMudXJsSXNOZXcoYXMpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gJ3JlcGxhY2VTdGF0ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3V0ZSA9IHRvUm91dGUocGF0aG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgeyBzaGFsbG93ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoaXNfZHluYW1pY18xLmlzRHluYW1pY1JvdXRlKHJvdXRlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWU6IGFzUGF0aG5hbWUgfSA9IHVybF8xLnBhcnNlKGFzKTtcbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gcm91dGVfcmVnZXhfMS5nZXRSb3V0ZVJlZ2V4KHJvdXRlKTtcbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZU1hdGNoID0gcm91dGVfbWF0Y2hlcl8xLmdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdXRlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIocGFyYW0gPT4gIXF1ZXJ5W3BhcmFtXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBNaXNtYXRjaGluZyBcXGBhc1xcYCBhbmQgXFxgaHJlZlxcYCBmYWlsZWQgdG8gbWFudWFsbHkgcHJvdmlkZSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYHRoZSBwYXJhbXM6ICR7bWlzc2luZ1BhcmFtcy5qb2luKCcsICcpfSBpbiB0aGUgXFxgaHJlZlxcYCdzIFxcYHF1ZXJ5XFxgYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihgVGhlIHByb3ZpZGVkIFxcYGFzXFxgIHZhbHVlICgke2FzUGF0aG5hbWV9KSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgXFxgaHJlZlxcYCB2YWx1ZSAoJHtyb3V0ZX0pLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgUmVhZCBtb3JlOiBodHRwczovL2Vyci5zaC96ZWl0L25leHQuanMvaW5jb21wYXRpYmxlLWhyZWYtYXNgKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIHJvdXRlTWF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzKTtcbiAgICAgICAgICAgIC8vIElmIHNoYWxsb3cgaXMgdHJ1ZSBhbmQgdGhlIHJvdXRlIGV4aXN0cyBpbiB0aGUgcm91dGVyIGNhY2hlIHdlIHJldXNlIHRoZSBwcmV2aW91cyByZXN1bHRcbiAgICAgICAgICAgIHRoaXMuZ2V0Um91dGVJbmZvKHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCBzaGFsbG93KS50aGVuKHJvdXRlSW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gcm91dGVJbmZvO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLCBhcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFwcENvbXAgPSB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubmV4dC5pc1ByZXJlbmRlcmVkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcENvbXAuZ2V0SW5pdGlhbFByb3BzID09PSBhcHBDb21wLm9yaWdHZXRJbml0aWFsUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhcm91dGVJbmZvLkNvbXBvbmVudC5nZXRJbml0aWFsUHJvcHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZUluZm8pO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnJvciwgYXMpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywgYXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LiR7bWV0aG9kfSBpcyBub3QgYXZhaWxhYmxlYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgIT09ICdwdXNoU3RhdGUnIHx8IHV0aWxzXzEuZ2V0VVJMKCkgIT09IGFzKSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgICAvLyBQYXNzaW5nIHRoZSBlbXB0eSBzdHJpbmcgaGVyZSBzaG91bGQgYmUgc2FmZSBhZ2FpbnN0IGZ1dHVyZSBjaGFuZ2VzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgICAgICcnLCBhcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Um91dGVJbmZvKHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCBzaGFsbG93ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkUm91dGVJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBzaGFsbG93IHJvdXRlIHRyYW5zaXRpb24gcG9zc2libGVcbiAgICAgICAgLy8gSWYgdGhlIHJvdXRlIGlzIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIHNjcmVlbi5cbiAgICAgICAgaWYgKHNoYWxsb3cgJiYgY2FjaGVkUm91dGVJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZFJvdXRlSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoZXJyLCBsb2FkRXJyb3JGYWlsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSAnUEFHRV9MT0FEX0VSUk9SJyB8fCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAgICAgICAgICAgICAgIC8vICAxLiBQYWdlIGRvZXNuJ3QgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIC8vICAyLiBQYWdlIGRvZXMgZXhpc3QgaW4gYSBkaWZmZXJlbnQgem9uZVxuICAgICAgICAgICAgICAgICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuICAgICAgICAgICAgICAgICAgICAvLyBTbywgZG9pbmcgYSBoYXJkIHJlbG9hZCBpcyB0aGUgcHJvcGVyIHdheSB0byBkZWFsIHdpdGggdGhpcy5cbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhcztcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAgICAgICAgICAgICAgIC8vIFNvLCB3ZSBuZWVkIHRvIG1hcmsgaXQgYXMgYSBjYW5jZWxsZWQgZXJyb3IgYW5kIHN0b3AgdGhlIHJvdXRpbmcgbG9naWMuXG4gICAgICAgICAgICAgICAgICAgIGVyci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIFRPRE86IGZpeCB0aGUgY29udHJvbCBmbG93IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBlcnJvcjogZXJyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIFRPRE86IGZpeCB0aGUgY29udHJvbCBmbG93IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBlcnJvcjogZXJyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuZmV0Y2hDb21wb25lbnQoJy9fZXJyb3InKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHBhZ2U6IENvbXBvbmVudCB9ID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSB7IENvbXBvbmVudCwgZXJyIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4ocHJvcHMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5lcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJvdXRlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBnaXBFcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6ICcsIGdpcEVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocm91dGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGhhbmRsZUVycm9yKGVyciwgdHJ1ZSkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhY2hlZFJvdXRlSW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGNhY2hlZFJvdXRlSW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZldGNoQ29tcG9uZW50KHJvdXRlKS50aGVuKHJlcyA9PiByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxuICAgICAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1AsXG4gICAgICAgICAgICB9KSwgcmVqZWN0KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyb3V0ZUluZm8pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgQ29tcG9uZW50LCBfX05fU1NHLCBfX05fU1NQIH0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJHtwYXRobmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXREYXRhKCgpID0+IF9fTl9TU0dcbiAgICAgICAgICAgICAgICA/IHRoaXMuX2dldFN0YXRpY0RhdGEoYXMpXG4gICAgICAgICAgICAgICAgOiBfX05fU1NQXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5fZ2V0U2VydmVyRGF0YShhcylcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4ocHJvcHMgPT4ge1xuICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdXRlSW5mbztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGhhbmRsZUVycm9yKTtcbiAgICB9XG4gICAgc2V0KHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCBkYXRhKSB7XG4gICAgICAgIHRoaXMuaXNGYWxsYmFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJvdXRlID0gcm91dGU7XG4gICAgICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLmFzUGF0aCA9IGFzO1xuICAgICAgICB0aGlzLm5vdGlmeShkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgICAqIEBwYXJhbSBjYiBjYWxsYmFjayB0byBiZSBleGVjdXRlZFxuICAgICAqL1xuICAgIGJlZm9yZVBvcFN0YXRlKGNiKSB7XG4gICAgICAgIHRoaXMuX2JwcyA9IGNiO1xuICAgIH1cbiAgICBvbmx5QUhhc2hDaGFuZ2UoYXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFzUGF0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdCgnIycpO1xuICAgICAgICBjb25zdCBbbmV3VXJsTm9IYXNoLCBuZXdIYXNoXSA9IGFzLnNwbGl0KCcjJyk7XG4gICAgICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgICAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgICAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgICAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgICAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaDtcbiAgICB9XG4gICAgc2Nyb2xsVG9IYXNoKGFzKSB7XG4gICAgICAgIGNvbnN0IFssIGhhc2hdID0gYXMuc3BsaXQoJyMnKTtcbiAgICAgICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlXG4gICAgICAgIGlmIChoYXNoID09PSAnJykge1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXG4gICAgICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKTtcbiAgICAgICAgaWYgKGlkRWwpIHtcbiAgICAgICAgICAgIGlkRWwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGVsZW1lbnQgd2l0aCB0aGUgaWQsIHdlIGNoZWNrIHRoZSBgbmFtZWAgcHJvcGVydHlcbiAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGhhc2gpWzBdO1xuICAgICAgICBpZiAobmFtZUVsKSB7XG4gICAgICAgICAgICBuYW1lRWwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cmxJc05ldyhhc1BhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNQYXRoICE9PSBhc1BhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZWZldGNoIHBhZ2UgY29kZSwgeW91IG1heSB3YWl0IGZvciB0aGUgZGF0YSBkdXJpbmcgcGFnZSByZW5kZXJpbmcuXG4gICAgICogVGhpcyBmZWF0dXJlIG9ubHkgd29ya3MgaW4gcHJvZHVjdGlvbiFcbiAgICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgICAqIEBwYXJhbSBhc1BhdGggdGhlIGFzIHBhdGggb2YgdGhlIHByZWZldGNoZWQgcGFnZVxuICAgICAqL1xuICAgIHByZWZldGNoKHVybCwgYXNQYXRoID0gdXJsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHByb3RvY29sIH0gPSB1cmxfMS5wYXJzZSh1cmwpO1xuICAgICAgICAgICAgaWYgKCFwYXRobmFtZSB8fCBwcm90b2NvbCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBocmVmIHBhc3NlZCB0byByb3V0ZXI6ICR7dXJsfSBodHRwczovL2Vyci5zaC96ZWl0L25leHQuanMvaW52YWxpZC1ocmVmLXBhc3NlZGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcmVmZXRjaCBpcyBub3Qgc3VwcG9ydGVkIGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSBpdCB3b3VsZCB0cmlnZ2VyIG9uLWRlbWFuZC1lbnRyaWVzXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gZGVsQmFzZVBhdGgodG9Sb3V0ZShwYXRobmFtZSkpO1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5wcmVmZXRjaERhdGEodXJsLCBkZWxCYXNlUGF0aChhc1BhdGgpKSxcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXJbb3B0aW9ucy5wcmlvcml0eSA/ICdsb2FkUGFnZScgOiAncHJlZmV0Y2gnXShyb3V0ZSksXG4gICAgICAgICAgICBdKS50aGVuKCgpID0+IHJlc29sdmUoKSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoQ29tcG9uZW50KHJvdXRlKSB7XG4gICAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gKHRoaXMuY2xjID0gKCkgPT4ge1xuICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJvdXRlID0gZGVsQmFzZVBhdGgocm91dGUpO1xuICAgICAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpO1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCIke3JvdXRlfVwiYCk7XG4gICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50UmVzdWx0O1xuICAgIH1cbiAgICBfZ2V0RGF0YShmbikge1xuICAgICAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xjID0gY2FuY2VsO1xuICAgICAgICByZXR1cm4gZm4oKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkJyk7XG4gICAgICAgICAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCBjdHgpIHtcbiAgICAgICAgY29uc3QgeyBDb21wb25lbnQ6IEFwcCB9ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddO1xuICAgICAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHApO1xuICAgICAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWU7XG4gICAgICAgIHJldHVybiB1dGlsc18xLmxvYWRHZXRJbml0aWFsUHJvcHMoQXBwLCB7XG4gICAgICAgICAgICBBcHBUcmVlLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgICAgY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWJvcnRDb21wb25lbnRMb2FkKGFzKSB7XG4gICAgICAgIGlmICh0aGlzLmNsYykge1xuICAgICAgICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcignUm91dGUgQ2FuY2VsbGVkJyk7XG4gICAgICAgICAgICBlLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlLCBhcyk7XG4gICAgICAgICAgICB0aGlzLmNsYygpO1xuICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vdGlmeShkYXRhKSB7XG4gICAgICAgIHRoaXMuc3ViKGRhdGEsIHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlcjtcblJvdXRlci5ldmVudHMgPSBtaXR0XzEuZGVmYXVsdCgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBJZGVudGlmeSAvW3BhcmFtXS8gaW4gcm91dGUgc3RyaW5nXG5jb25zdCBURVNUX1JPVVRFID0gL1xcL1xcW1teL10rP1xcXSg/PVxcL3wkKS87XG5mdW5jdGlvbiBpc0R5bmFtaWNSb3V0ZShyb3V0ZSkge1xuICAgIHJldHVybiBURVNUX1JPVVRFLnRlc3Qocm91dGUpO1xufVxuZXhwb3J0cy5pc0R5bmFtaWNSb3V0ZSA9IGlzRHluYW1pY1JvdXRlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkge1xuICAgIGNvbnN0IHsgcmUsIGdyb3VwcyB9ID0gcm91dGVSZWdleDtcbiAgICByZXR1cm4gKHBhdGhuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSByZS5leGVjKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCFyb3V0ZU1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjb2RlID0gKHBhcmFtKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBkZWNvZGUgcGFyYW0nKTtcbiAgICAgICAgICAgICAgICBlcnIuY29kZSA9ICdERUNPREVfRkFJTEVEJztcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhncm91cHMpLmZvckVhY2goKHNsdWdOYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnID0gZ3JvdXBzW3NsdWdOYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSByb3V0ZU1hdGNoW2cucG9zXTtcbiAgICAgICAgICAgIGlmIChtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbc2x1Z05hbWVdID0gfm0uaW5kZXhPZignLycpXG4gICAgICAgICAgICAgICAgICAgID8gbS5zcGxpdCgnLycpLm1hcChlbnRyeSA9PiBkZWNvZGUoZW50cnkpKVxuICAgICAgICAgICAgICAgICAgICA6IGcucmVwZWF0XG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtkZWNvZGUobSldXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGRlY29kZShtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0Um91dGVNYXRjaGVyID0gZ2V0Um91dGVNYXRjaGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyB0aGlzIGlzbid0IGltcG9ydGluZyB0aGUgZXNjYXBlLXN0cmluZy1yZWdleCBtb2R1bGVcbi8vIHRvIHJlZHVjZSBieXRlc1xuZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKyo/Li1dL2csICdcXFxcJCYnKTtcbn1cbmZ1bmN0aW9uIGdldFJvdXRlUmVnZXgobm9ybWFsaXplZFJvdXRlKSB7XG4gICAgLy8gRXNjYXBlIGFsbCBjaGFyYWN0ZXJzIHRoYXQgY291bGQgYmUgY29uc2lkZXJlZCBSZWdFeFxuICAgIGNvbnN0IGVzY2FwZWRSb3V0ZSA9IGVzY2FwZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZS5yZXBsYWNlKC9cXC8kLywgJycpIHx8ICcvJyk7XG4gICAgY29uc3QgZ3JvdXBzID0ge307XG4gICAgbGV0IGdyb3VwSW5kZXggPSAxO1xuICAgIGNvbnN0IHBhcmFtZXRlcml6ZWRSb3V0ZSA9IGVzY2FwZWRSb3V0ZS5yZXBsYWNlKC9cXC9cXFxcXFxbKFteL10rPylcXFxcXFxdKD89XFwvfCQpL2csIChfLCAkMSkgPT4ge1xuICAgICAgICBjb25zdCBpc0NhdGNoQWxsID0gL14oXFxcXFxcLil7M30vLnRlc3QoJDEpO1xuICAgICAgICBncm91cHNbJDFcbiAgICAgICAgICAgIC8vIFVuLWVzY2FwZSBrZXlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcKFt8XFxcXHt9KClbXFxdXiQrKj8uLV0pL2csICckMScpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxcLnszfS8sICcnKVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICAgIF0gPSB7IHBvczogZ3JvdXBJbmRleCsrLCByZXBlYXQ6IGlzQ2F0Y2hBbGwgfTtcbiAgICAgICAgcmV0dXJuIGlzQ2F0Y2hBbGwgPyAnLyguKz8pJyA6ICcvKFteL10rPyknO1xuICAgIH0pO1xuICAgIGxldCBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZTtcbiAgICAvLyBkZWFkIGNvZGUgZWxpbWluYXRlIGZvciBicm93c2VyIHNpbmNlIGl0J3Mgb25seSBuZWVkZWRcbiAgICAvLyB3aGlsZSBnZW5lcmF0aW5nIHJvdXRlcy1tYW5pZmVzdFxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSA9IGVzY2FwZWRSb3V0ZS5yZXBsYWNlKC9cXC9cXFxcXFxbKFteL10rPylcXFxcXFxdKD89XFwvfCQpL2csIChfLCAkMSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNDYXRjaEFsbCA9IC9eKFxcXFxcXC4pezN9Ly50ZXN0KCQxKTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9ICQxXG4gICAgICAgICAgICAgICAgLy8gVW4tZXNjYXBlIGtleVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcKFt8XFxcXHt9KClbXFxdXiQrKj8uLV0pL2csICckMScpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL15cXC57M30vLCAnJyk7XG4gICAgICAgICAgICByZXR1cm4gaXNDYXRjaEFsbFxuICAgICAgICAgICAgICAgID8gYC8oPzwke2VzY2FwZVJlZ2V4KGtleSl9Pi4rPylgXG4gICAgICAgICAgICAgICAgOiBgLyg/PCR7ZXNjYXBlUmVnZXgoa2V5KX0+W14vXSs/KWA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHJlOiBuZXcgUmVnRXhwKCdeJyArIHBhcmFtZXRlcml6ZWRSb3V0ZSArICcoPzovKT8kJywgJ2knKSwgZ3JvdXBzIH0sIChuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIG5hbWVkUmVnZXg6IGBeJHtuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCxcbiAgICAgICAgfVxuICAgICAgICA6IHt9KSk7XG59XG5leHBvcnRzLmdldFJvdXRlUmVnZXggPSBnZXRSb3V0ZVJlZ2V4O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5sZXQgcnVudGltZUNvbmZpZztcbmV4cG9ydHMuZGVmYXVsdCA9ICgpID0+IHtcbiAgICByZXR1cm4gcnVudGltZUNvbmZpZztcbn07XG5mdW5jdGlvbiBzZXRDb25maWcoY29uZmlnVmFsdWUpIHtcbiAgICBydW50aW1lQ29uZmlnID0gY29uZmlnVmFsdWU7XG59XG5leHBvcnRzLnNldENvbmZpZyA9IHNldENvbmZpZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuLyoqXG4gKiBVdGlsc1xuICovXG5mdW5jdGlvbiBleGVjT25jZShmbikge1xuICAgIGxldCB1c2VkID0gZmFsc2U7XG4gICAgbGV0IHJlc3VsdDtcbiAgICByZXR1cm4gKCguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmICghdXNlZCkge1xuICAgICAgICAgICAgdXNlZCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQgPSBmbiguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxuZXhwb3J0cy5leGVjT25jZSA9IGV4ZWNPbmNlO1xuZnVuY3Rpb24gZ2V0TG9jYXRpb25PcmlnaW4oKSB7XG4gICAgY29uc3QgeyBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3RuYW1lfSR7cG9ydCA/ICc6JyArIHBvcnQgOiAnJ31gO1xufVxuZXhwb3J0cy5nZXRMb2NhdGlvbk9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luO1xuZnVuY3Rpb24gZ2V0VVJMKCkge1xuICAgIGNvbnN0IHsgaHJlZiB9ID0gd2luZG93LmxvY2F0aW9uO1xuICAgIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKCk7XG4gICAgcmV0dXJuIGhyZWYuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpO1xufVxuZXhwb3J0cy5nZXRVUkwgPSBnZXRVUkw7XG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpIHtcbiAgICByZXR1cm4gdHlwZW9mIENvbXBvbmVudCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBDb21wb25lbnRcbiAgICAgICAgOiBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nO1xufVxuZXhwb3J0cy5nZXREaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lO1xuZnVuY3Rpb24gaXNSZXNTZW50KHJlcykge1xuICAgIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50O1xufVxuZXhwb3J0cy5pc1Jlc1NlbnQgPSBpc1Jlc1NlbnQ7XG5hc3luYyBmdW5jdGlvbiBsb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwgY3R4KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICgoX2EgPSBBcHAucHJvdG90eXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShBcHApfS5nZXRJbml0aWFsUHJvcHMoKVwiIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIC0gdmlzaXQgaHR0cHM6Ly9lcnIuc2gvemVpdC9uZXh0LmpzL2dldC1pbml0aWFsLXByb3BzLWFzLWFuLWluc3RhbmNlLW1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHdoZW4gY2FsbGVkIGZyb20gX2FwcCBgY3R4YCBpcyBuZXN0ZWQgaW4gYGN0eGBcbiAgICBjb25zdCByZXMgPSBjdHgucmVzIHx8IChjdHguY3R4ICYmIGN0eC5jdHgucmVzKTtcbiAgICBpZiAoIUFwcC5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICAgICAgaWYgKGN0eC5jdHggJiYgY3R4LkNvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBwYWdlUHJvcHMgZGVmYXVsdFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYWdlUHJvcHM6IGF3YWl0IGxvYWRHZXRJbml0aWFsUHJvcHMoY3R4LkNvbXBvbmVudCwgY3R4LmN0eCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgcHJvcHMgPSBhd2FpdCBBcHAuZ2V0SW5pdGlhbFByb3BzKGN0eCk7XG4gICAgaWYgKHJlcyAmJiBpc1Jlc1NlbnQocmVzKSkge1xuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoQXBwKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3QuIEJ1dCBmb3VuZCBcIiR7cHJvcHN9XCIgaW5zdGVhZC5gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID09PSAwICYmICFjdHguY3R4KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7Z2V0RGlzcGxheU5hbWUoQXBwKX0gcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gXFxgZ2V0SW5pdGlhbFByb3BzXFxgLiBUaGlzIGRlLW9wdGltaXplcyBhbmQgcHJldmVudHMgYXV0b21hdGljIHN0YXRpYyBvcHRpbWl6YXRpb24uIGh0dHBzOi8vZXJyLnNoL3plaXQvbmV4dC5qcy9lbXB0eS1vYmplY3QtZ2V0SW5pdGlhbFByb3BzYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BzO1xufVxuZXhwb3J0cy5sb2FkR2V0SW5pdGlhbFByb3BzID0gbG9hZEdldEluaXRpYWxQcm9wcztcbmV4cG9ydHMudXJsT2JqZWN0S2V5cyA9IFtcbiAgICAnYXV0aCcsXG4gICAgJ2hhc2gnLFxuICAgICdob3N0JyxcbiAgICAnaG9zdG5hbWUnLFxuICAgICdocmVmJyxcbiAgICAncGF0aCcsXG4gICAgJ3BhdGhuYW1lJyxcbiAgICAncG9ydCcsXG4gICAgJ3Byb3RvY29sJyxcbiAgICAncXVlcnknLFxuICAgICdzZWFyY2gnLFxuICAgICdzbGFzaGVzJyxcbl07XG5mdW5jdGlvbiBmb3JtYXRXaXRoVmFsaWRhdGlvbih1cmwsIG9wdGlvbnMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgaWYgKHVybCAhPT0gbnVsbCAmJiB0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModXJsKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9ydHMudXJsT2JqZWN0S2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biBrZXkgcGFzc2VkIHZpYSB1cmxPYmplY3QgaW50byB1cmwuZm9ybWF0OiAke2tleX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXJsXzEuZm9ybWF0KHVybCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmZvcm1hdFdpdGhWYWxpZGF0aW9uID0gZm9ybWF0V2l0aFZhbGlkYXRpb247XG5leHBvcnRzLlNQID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJztcbmV4cG9ydHMuU1QgPSBleHBvcnRzLlNQICYmXG4gICAgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJztcbiIsIi8qIVxyXG4gKiBQbGF0Zm9ybS5qcyA8aHR0cHM6Ly9tdGhzLmJlL3BsYXRmb3JtPlxyXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE2IEJlbmphbWluIFRhbiA8aHR0cHM6Ly9kZW1vbmVhdXguZ2l0aHViLmlvLz5cclxuICogQ29weXJpZ2h0IDIwMTEtMjAxMyBKb2huLURhdmlkIERhbHRvbiA8aHR0cDovL2FsbHlvdWNhbmxlZXQuY29tLz5cclxuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL210aHMuYmUvbWl0PlxyXG4gKi9cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIC8qKiBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIGBPYmplY3RgLiAqL1xyXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcclxuICAgICdmdW5jdGlvbic6IHRydWUsXHJcbiAgICAnb2JqZWN0JzogdHJ1ZVxyXG4gIH07XHJcblxyXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xyXG4gIHZhciByb290ID0gKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdykgfHwgdGhpcztcclxuXHJcbiAgLyoqIEJhY2t1cCBwb3NzaWJsZSBnbG9iYWwgb2JqZWN0LiAqL1xyXG4gIHZhciBvbGRSb290ID0gcm9vdDtcclxuXHJcbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cclxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cztcclxuXHJcbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xyXG4gIHZhciBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xyXG5cclxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlIGFuZCB1c2UgaXQgYXMgYHJvb3RgLiAqL1xyXG4gIHZhciBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcclxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsKSkge1xyXG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVc2VkIGFzIHRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhbiBhcnJheS1saWtlIG9iamVjdC5cclxuICAgKiBTZWUgdGhlIFtFUzYgc3BlY10oaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGgpXHJcbiAgICogZm9yIG1vcmUgZGV0YWlscy5cclxuICAgKi9cclxuICB2YXIgbWF4U2FmZUludGVnZXIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xyXG5cclxuICAvKiogUmVndWxhciBleHByZXNzaW9uIHRvIGRldGVjdCBPcGVyYS4gKi9cclxuICB2YXIgcmVPcGVyYSA9IC9cXGJPcGVyYS87XHJcblxyXG4gIC8qKiBQb3NzaWJsZSBnbG9iYWwgb2JqZWN0LiAqL1xyXG4gIHZhciB0aGlzQmluZGluZyA9IHRoaXM7XHJcblxyXG4gIC8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXHJcbiAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbiAgLyoqIFVzZWQgdG8gY2hlY2sgZm9yIG93biBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdC4gKi9cclxuICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbiAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgaW50ZXJuYWwgYFtbQ2xhc3NdXWAgb2YgdmFsdWVzLiAqL1xyXG4gIHZhciB0b1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xyXG5cclxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FwaXRhbGl6ZXMgYSBzdHJpbmcgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcclxuICAgIHN0cmluZyA9IFN0cmluZyhzdHJpbmcpO1xyXG4gICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0byBjbGVhbiB1cCB0aGUgT1MgbmFtZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9zIFRoZSBPUyBuYW1lIHRvIGNsZWFuIHVwLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0dGVybl0gQSBgUmVnRXhwYCBwYXR0ZXJuIG1hdGNoaW5nIHRoZSBPUyBuYW1lLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxdIEEgbGFiZWwgZm9yIHRoZSBPUy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjbGVhbnVwT1Mob3MsIHBhdHRlcm4sIGxhYmVsKSB7XHJcbiAgICAvLyBQbGF0Zm9ybSB0b2tlbnMgYXJlIGRlZmluZWQgYXQ6XHJcbiAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1Mzc1MDMoVlMuODUpLmFzcHhcclxuICAgIC8vIGh0dHA6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMDgxMTIyMDUzOTUwL2h0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNzUwMyhWUy44NSkuYXNweFxyXG4gICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgICcxMC4wJzogJzEwJyxcclxuICAgICAgJzYuNCc6ICAnMTAgVGVjaG5pY2FsIFByZXZpZXcnLFxyXG4gICAgICAnNi4zJzogICc4LjEnLFxyXG4gICAgICAnNi4yJzogICc4JyxcclxuICAgICAgJzYuMSc6ICAnU2VydmVyIDIwMDggUjIgLyA3JyxcclxuICAgICAgJzYuMCc6ICAnU2VydmVyIDIwMDggLyBWaXN0YScsXHJcbiAgICAgICc1LjInOiAgJ1NlcnZlciAyMDAzIC8gWFAgNjQtYml0JyxcclxuICAgICAgJzUuMSc6ICAnWFAnLFxyXG4gICAgICAnNS4wMSc6ICcyMDAwIFNQMScsXHJcbiAgICAgICc1LjAnOiAgJzIwMDAnLFxyXG4gICAgICAnNC4wJzogICdOVCcsXHJcbiAgICAgICc0LjkwJzogJ01FJ1xyXG4gICAgfTtcclxuICAgIC8vIERldGVjdCBXaW5kb3dzIHZlcnNpb24gZnJvbSBwbGF0Zm9ybSB0b2tlbnMuXHJcbiAgICBpZiAocGF0dGVybiAmJiBsYWJlbCAmJiAvXldpbi9pLnRlc3Qob3MpICYmICEvXldpbmRvd3MgUGhvbmUgL2kudGVzdChvcykgJiZcclxuICAgICAgICAoZGF0YSA9IGRhdGFbL1tcXGQuXSskLy5leGVjKG9zKV0pKSB7XHJcbiAgICAgIG9zID0gJ1dpbmRvd3MgJyArIGRhdGE7XHJcbiAgICB9XHJcbiAgICAvLyBDb3JyZWN0IGNoYXJhY3RlciBjYXNlIGFuZCBjbGVhbnVwIHN0cmluZy5cclxuICAgIG9zID0gU3RyaW5nKG9zKTtcclxuXHJcbiAgICBpZiAocGF0dGVybiAmJiBsYWJlbCkge1xyXG4gICAgICBvcyA9IG9zLnJlcGxhY2UoUmVnRXhwKHBhdHRlcm4sICdpJyksIGxhYmVsKTtcclxuICAgIH1cclxuXHJcbiAgICBvcyA9IGZvcm1hdChcclxuICAgICAgb3MucmVwbGFjZSgvIGNlJC9pLCAnIENFJylcclxuICAgICAgICAucmVwbGFjZSgvXFxiaHB3L2ksICd3ZWInKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXGJNYWNpbnRvc2hcXGIvLCAnTWFjIE9TJylcclxuICAgICAgICAucmVwbGFjZSgvX1Bvd2VyUENcXGIvaSwgJyBPUycpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcYihPUyBYKSBbXiBcXGRdKy9pLCAnJDEnKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXGJNYWMgKE9TIFgpXFxiLywgJyQxJylcclxuICAgICAgICAucmVwbGFjZSgvXFwvKFxcZCkvLCAnICQxJylcclxuICAgICAgICAucmVwbGFjZSgvXy9nLCAnLicpXHJcbiAgICAgICAgLnJlcGxhY2UoLyg/OiBCZVBDfFsgLl0qZmNbIFxcZC5dKykkL2ksICcnKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXGJ4ODZcXC42NFxcYi9naSwgJ3g4Nl82NCcpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcYihXaW5kb3dzIFBob25lKSBPU1xcYi8sICckMScpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcYihDaHJvbWUgT1MgXFx3KykgW1xcZC5dK1xcYi8sICckMScpXHJcbiAgICAgICAgLnNwbGl0KCcgb24gJylbMF1cclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIG9zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW4gaXRlcmF0aW9uIHV0aWxpdHkgZm9yIGFycmF5cyBhbmQgb2JqZWN0cy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZWFjaChvYmplY3QsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICBsZW5ndGggPSBvYmplY3QgPyBvYmplY3QubGVuZ3RoIDogMDtcclxuXHJcbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPiAtMSAmJiBsZW5ndGggPD0gbWF4U2FmZUludGVnZXIpIHtcclxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICBjYWxsYmFjayhvYmplY3RbaW5kZXhdLCBpbmRleCwgb2JqZWN0KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yT3duKG9iamVjdCwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpbSBhbmQgY29uZGl0aW9uYWxseSBjYXBpdGFsaXplIHN0cmluZyB2YWx1ZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBmb3JtYXQuXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCBzdHJpbmcuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZm9ybWF0KHN0cmluZykge1xyXG4gICAgc3RyaW5nID0gdHJpbShzdHJpbmcpO1xyXG4gICAgcmV0dXJuIC9eKD86d2ViT1N8aSg/Ok9TfFApKS8udGVzdChzdHJpbmcpXHJcbiAgICAgID8gc3RyaW5nXHJcbiAgICAgIDogY2FwaXRhbGl6ZShzdHJpbmcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSXRlcmF0ZXMgb3ZlciBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcywgZXhlY3V0aW5nIHRoZSBgY2FsbGJhY2tgIGZvciBlYWNoLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBleGVjdXRlZCBwZXIgb3duIHByb3BlcnR5LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGZvck93bihvYmplY3QsIGNhbGxiYWNrKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XHJcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xyXG4gICAgICAgIGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGludGVybmFsIGBbW0NsYXNzXV1gIG9mIGEgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBgW1tDbGFzc11dYC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBnZXRDbGFzc09mKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbFxyXG4gICAgICA/IGNhcGl0YWxpemUodmFsdWUpXHJcbiAgICAgIDogdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSG9zdCBvYmplY3RzIGNhbiByZXR1cm4gdHlwZSB2YWx1ZXMgdGhhdCBhcmUgZGlmZmVyZW50IGZyb20gdGhlaXIgYWN0dWFsXHJcbiAgICogZGF0YSB0eXBlLiBUaGUgb2JqZWN0cyB3ZSBhcmUgY29uY2VybmVkIHdpdGggdXN1YWxseSByZXR1cm4gbm9uLXByaW1pdGl2ZVxyXG4gICAqIHR5cGVzIG9mIFwib2JqZWN0XCIsIFwiZnVuY3Rpb25cIiwgb3IgXCJ1bmtub3duXCIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvd25lciBvZiB0aGUgcHJvcGVydHkuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byBjaGVjay5cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IHZhbHVlIGlzIGEgbm9uLXByaW1pdGl2ZSwgZWxzZSBgZmFsc2VgLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGlzSG9zdFR5cGUob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG4gICAgdmFyIHR5cGUgPSBvYmplY3QgIT0gbnVsbCA/IHR5cGVvZiBvYmplY3RbcHJvcGVydHldIDogJ251bWJlcic7XHJcbiAgICByZXR1cm4gIS9eKD86Ym9vbGVhbnxudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZCkkLy50ZXN0KHR5cGUpICYmXHJcbiAgICAgICh0eXBlID09ICdvYmplY3QnID8gISFvYmplY3RbcHJvcGVydHldIDogdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQcmVwYXJlcyBhIHN0cmluZyBmb3IgdXNlIGluIGEgYFJlZ0V4cGAgYnkgbWFraW5nIGh5cGhlbnMgYW5kIHNwYWNlcyBvcHRpb25hbC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHF1YWxpZnkuXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHF1YWxpZmllZCBzdHJpbmcuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcXVhbGlmeShzdHJpbmcpIHtcclxuICAgIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKC8oWyAtXSkoPyEkKS9nLCAnJDE/Jyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIGJhcmUtYm9uZXMgYEFycmF5I3JlZHVjZWAgbGlrZSB1dGlsaXR5IGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgKiBAcmV0dXJucyB7Kn0gVGhlIGFjY3VtdWxhdGVkIHJlc3VsdC5cclxuICAgKi9cclxuICBmdW5jdGlvbiByZWR1Y2UoYXJyYXksIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgYWNjdW11bGF0b3IgPSBudWxsO1xyXG4gICAgZWFjaChhcnJheSwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XHJcbiAgICAgIGFjY3VtdWxhdG9yID0gY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgYXJyYXkpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UgZnJvbSBhIHN0cmluZy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRyaW1tZWQgc3RyaW5nLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHRyaW0oc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZSgvXiArfCArJC9nLCAnJyk7XHJcbiAgfVxyXG5cclxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBwbGF0Zm9ybSBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFt1YT1uYXZpZ2F0b3IudXNlckFnZW50XSBUaGUgdXNlciBhZ2VudCBzdHJpbmcgb3JcclxuICAgKiAgY29udGV4dCBvYmplY3QuXHJcbiAgICogQHJldHVybnMge09iamVjdH0gQSBwbGF0Zm9ybSBvYmplY3QuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcGFyc2UodWEpIHtcclxuXHJcbiAgICAvKiogVGhlIGVudmlyb25tZW50IGNvbnRleHQgb2JqZWN0LiAqL1xyXG4gICAgdmFyIGNvbnRleHQgPSByb290O1xyXG5cclxuICAgIC8qKiBVc2VkIHRvIGZsYWcgd2hlbiBhIGN1c3RvbSBjb250ZXh0IGlzIHByb3ZpZGVkLiAqL1xyXG4gICAgdmFyIGlzQ3VzdG9tQ29udGV4dCA9IHVhICYmIHR5cGVvZiB1YSA9PSAnb2JqZWN0JyAmJiBnZXRDbGFzc09mKHVhKSAhPSAnU3RyaW5nJztcclxuXHJcbiAgICAvLyBKdWdnbGUgYXJndW1lbnRzLlxyXG4gICAgaWYgKGlzQ3VzdG9tQ29udGV4dCkge1xyXG4gICAgICBjb250ZXh0ID0gdWE7XHJcbiAgICAgIHVhID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQnJvd3NlciBuYXZpZ2F0b3Igb2JqZWN0LiAqL1xyXG4gICAgdmFyIG5hdiA9IGNvbnRleHQubmF2aWdhdG9yIHx8IHt9O1xyXG5cclxuICAgIC8qKiBCcm93c2VyIHVzZXIgYWdlbnQgc3RyaW5nLiAqL1xyXG4gICAgdmFyIHVzZXJBZ2VudCA9IG5hdi51c2VyQWdlbnQgfHwgJyc7XHJcblxyXG4gICAgdWEgfHwgKHVhID0gdXNlckFnZW50KTtcclxuXHJcbiAgICAvKiogVXNlZCB0byBmbGFnIHdoZW4gYHRoaXNCaW5kaW5nYCBpcyB0aGUgW01vZHVsZVNjb3BlXS4gKi9cclxuICAgIHZhciBpc01vZHVsZVNjb3BlID0gaXNDdXN0b21Db250ZXh0IHx8IHRoaXNCaW5kaW5nID09IG9sZFJvb3Q7XHJcblxyXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGJyb3dzZXIgaXMgbGlrZSBDaHJvbWUuICovXHJcbiAgICB2YXIgbGlrZUNocm9tZSA9IGlzQ3VzdG9tQ29udGV4dFxyXG4gICAgICA/ICEhbmF2Lmxpa2VDaHJvbWVcclxuICAgICAgOiAvXFxiQ2hyb21lXFxiLy50ZXN0KHVhKSAmJiAhL2ludGVybmFsfFxcbi9pLnRlc3QodG9TdHJpbmcudG9TdHJpbmcoKSk7XHJcblxyXG4gICAgLyoqIEludGVybmFsIGBbW0NsYXNzXV1gIHZhbHVlIHNob3J0Y3V0cy4gKi9cclxuICAgIHZhciBvYmplY3RDbGFzcyA9ICdPYmplY3QnLFxyXG4gICAgICAgIGFpclJ1bnRpbWVDbGFzcyA9IGlzQ3VzdG9tQ29udGV4dCA/IG9iamVjdENsYXNzIDogJ1NjcmlwdEJyaWRnaW5nUHJveHlPYmplY3QnLFxyXG4gICAgICAgIGVudmlyb0NsYXNzID0gaXNDdXN0b21Db250ZXh0ID8gb2JqZWN0Q2xhc3MgOiAnRW52aXJvbm1lbnQnLFxyXG4gICAgICAgIGphdmFDbGFzcyA9IChpc0N1c3RvbUNvbnRleHQgJiYgY29udGV4dC5qYXZhKSA/ICdKYXZhUGFja2FnZScgOiBnZXRDbGFzc09mKGNvbnRleHQuamF2YSksXHJcbiAgICAgICAgcGhhbnRvbUNsYXNzID0gaXNDdXN0b21Db250ZXh0ID8gb2JqZWN0Q2xhc3MgOiAnUnVudGltZU9iamVjdCc7XHJcblxyXG4gICAgLyoqIERldGVjdCBKYXZhIGVudmlyb25tZW50cy4gKi9cclxuICAgIHZhciBqYXZhID0gL1xcYkphdmEvLnRlc3QoamF2YUNsYXNzKSAmJiBjb250ZXh0LmphdmE7XHJcblxyXG4gICAgLyoqIERldGVjdCBSaGluby4gKi9cclxuICAgIHZhciByaGlubyA9IGphdmEgJiYgZ2V0Q2xhc3NPZihjb250ZXh0LmVudmlyb25tZW50KSA9PSBlbnZpcm9DbGFzcztcclxuXHJcbiAgICAvKiogQSBjaGFyYWN0ZXIgdG8gcmVwcmVzZW50IGFscGhhLiAqL1xyXG4gICAgdmFyIGFscGhhID0gamF2YSA/ICdhJyA6ICdcXHUwM2IxJztcclxuXHJcbiAgICAvKiogQSBjaGFyYWN0ZXIgdG8gcmVwcmVzZW50IGJldGEuICovXHJcbiAgICB2YXIgYmV0YSA9IGphdmEgPyAnYicgOiAnXFx1MDNiMic7XHJcblxyXG4gICAgLyoqIEJyb3dzZXIgZG9jdW1lbnQgb2JqZWN0LiAqL1xyXG4gICAgdmFyIGRvYyA9IGNvbnRleHQuZG9jdW1lbnQgfHwge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlY3QgT3BlcmEgYnJvd3NlciAoUHJlc3RvLWJhc2VkKS5cclxuICAgICAqIGh0dHA6Ly93d3cuaG93dG9jcmVhdGUuY28udWsvb3BlcmFTdHVmZi9vcGVyYU9iamVjdC5odG1sXHJcbiAgICAgKiBodHRwOi8vZGV2Lm9wZXJhLmNvbS9hcnRpY2xlcy92aWV3L29wZXJhLW1pbmktd2ViLWNvbnRlbnQtYXV0aG9yaW5nLWd1aWRlbGluZXMvI29wZXJhbWluaVxyXG4gICAgICovXHJcbiAgICB2YXIgb3BlcmEgPSBjb250ZXh0Lm9wZXJhbWluaSB8fCBjb250ZXh0Lm9wZXJhO1xyXG5cclxuICAgIC8qKiBPcGVyYSBgW1tDbGFzc11dYC4gKi9cclxuICAgIHZhciBvcGVyYUNsYXNzID0gcmVPcGVyYS50ZXN0KG9wZXJhQ2xhc3MgPSAoaXNDdXN0b21Db250ZXh0ICYmIG9wZXJhKSA/IG9wZXJhWydbW0NsYXNzXV0nXSA6IGdldENsYXNzT2Yob3BlcmEpKVxyXG4gICAgICA/IG9wZXJhQ2xhc3NcclxuICAgICAgOiAob3BlcmEgPSBudWxsKTtcclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gICAgLyoqIFRlbXBvcmFyeSB2YXJpYWJsZSB1c2VkIG92ZXIgdGhlIHNjcmlwdCdzIGxpZmV0aW1lLiAqL1xyXG4gICAgdmFyIGRhdGE7XHJcblxyXG4gICAgLyoqIFRoZSBDUFUgYXJjaGl0ZWN0dXJlLiAqL1xyXG4gICAgdmFyIGFyY2ggPSB1YTtcclxuXHJcbiAgICAvKiogUGxhdGZvcm0gZGVzY3JpcHRpb24gYXJyYXkuICovXHJcbiAgICB2YXIgZGVzY3JpcHRpb24gPSBbXTtcclxuXHJcbiAgICAvKiogUGxhdGZvcm0gYWxwaGEvYmV0YSBpbmRpY2F0b3IuICovXHJcbiAgICB2YXIgcHJlcmVsZWFzZSA9IG51bGw7XHJcblxyXG4gICAgLyoqIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IGVudmlyb25tZW50IGZlYXR1cmVzIHNob3VsZCBiZSB1c2VkIHRvIHJlc29sdmUgdGhlIHBsYXRmb3JtLiAqL1xyXG4gICAgdmFyIHVzZUZlYXR1cmVzID0gdWEgPT0gdXNlckFnZW50O1xyXG5cclxuICAgIC8qKiBUaGUgYnJvd3Nlci9lbnZpcm9ubWVudCB2ZXJzaW9uLiAqL1xyXG4gICAgdmFyIHZlcnNpb24gPSB1c2VGZWF0dXJlcyAmJiBvcGVyYSAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PSAnZnVuY3Rpb24nICYmIG9wZXJhLnZlcnNpb24oKTtcclxuXHJcbiAgICAvKiogQSBmbGFnIHRvIGluZGljYXRlIGlmIHRoZSBPUyBlbmRzIHdpdGggXCIvIFZlcnNpb25cIiAqL1xyXG4gICAgdmFyIGlzU3BlY2lhbENhc2VkT1M7XHJcblxyXG4gICAgLyogRGV0ZWN0YWJsZSBsYXlvdXQgZW5naW5lcyAob3JkZXIgaXMgaW1wb3J0YW50KS4gKi9cclxuICAgIHZhciBsYXlvdXQgPSBnZXRMYXlvdXQoW1xyXG4gICAgICB7ICdsYWJlbCc6ICdFZGdlSFRNTCcsICdwYXR0ZXJuJzogJ0VkZ2UnIH0sXHJcbiAgICAgICdUcmlkZW50JyxcclxuICAgICAgeyAnbGFiZWwnOiAnV2ViS2l0JywgJ3BhdHRlcm4nOiAnQXBwbGVXZWJLaXQnIH0sXHJcbiAgICAgICdpQ2FiJyxcclxuICAgICAgJ1ByZXN0bycsXHJcbiAgICAgICdOZXRGcm9udCcsXHJcbiAgICAgICdUYXNtYW4nLFxyXG4gICAgICAnS0hUTUwnLFxyXG4gICAgICAnR2Vja28nXHJcbiAgICBdKTtcclxuXHJcbiAgICAvKiBEZXRlY3RhYmxlIGJyb3dzZXIgbmFtZXMgKG9yZGVyIGlzIGltcG9ydGFudCkuICovXHJcbiAgICB2YXIgbmFtZSA9IGdldE5hbWUoW1xyXG4gICAgICAnQWRvYmUgQUlSJyxcclxuICAgICAgJ0Fyb3JhJyxcclxuICAgICAgJ0F2YW50IEJyb3dzZXInLFxyXG4gICAgICAnQnJlYWNoJyxcclxuICAgICAgJ0NhbWlubycsXHJcbiAgICAgICdFcGlwaGFueScsXHJcbiAgICAgICdGZW5uZWMnLFxyXG4gICAgICAnRmxvY2snLFxyXG4gICAgICAnR2FsZW9uJyxcclxuICAgICAgJ0dyZWVuQnJvd3NlcicsXHJcbiAgICAgICdpQ2FiJyxcclxuICAgICAgJ0ljZXdlYXNlbCcsXHJcbiAgICAgICdLLU1lbGVvbicsXHJcbiAgICAgICdLb25xdWVyb3InLFxyXG4gICAgICAnTHVuYXNjYXBlJyxcclxuICAgICAgJ01heHRob24nLFxyXG4gICAgICB7ICdsYWJlbCc6ICdNaWNyb3NvZnQgRWRnZScsICdwYXR0ZXJuJzogJ0VkZ2UnIH0sXHJcbiAgICAgICdNaWRvcmknLFxyXG4gICAgICAnTm9vayBCcm93c2VyJyxcclxuICAgICAgJ1BhbGVNb29uJyxcclxuICAgICAgJ1BoYW50b21KUycsXHJcbiAgICAgICdSYXZlbicsXHJcbiAgICAgICdSZWtvbnEnLFxyXG4gICAgICAnUm9ja01lbHQnLFxyXG4gICAgICAnU2VhTW9ua2V5JyxcclxuICAgICAgeyAnbGFiZWwnOiAnU2lsaycsICdwYXR0ZXJuJzogJyg/OkNsb3VkOXxTaWxrLUFjY2VsZXJhdGVkKScgfSxcclxuICAgICAgJ1NsZWlwbmlyJyxcclxuICAgICAgJ1NsaW1Ccm93c2VyJyxcclxuICAgICAgeyAnbGFiZWwnOiAnU1JXYXJlIElyb24nLCAncGF0dGVybic6ICdJcm9uJyB9LFxyXG4gICAgICAnU3VucmlzZScsXHJcbiAgICAgICdTd2lmdGZveCcsXHJcbiAgICAgICdXZWJQb3NpdGl2ZScsXHJcbiAgICAgICdPcGVyYSBNaW5pJyxcclxuICAgICAgeyAnbGFiZWwnOiAnT3BlcmEgTWluaScsICdwYXR0ZXJuJzogJ09QaU9TJyB9LFxyXG4gICAgICAnT3BlcmEnLFxyXG4gICAgICB7ICdsYWJlbCc6ICdPcGVyYScsICdwYXR0ZXJuJzogJ09QUicgfSxcclxuICAgICAgJ0Nocm9tZScsXHJcbiAgICAgIHsgJ2xhYmVsJzogJ0Nocm9tZSBNb2JpbGUnLCAncGF0dGVybic6ICcoPzpDcmlPU3xDck1vKScgfSxcclxuICAgICAgeyAnbGFiZWwnOiAnRmlyZWZveCcsICdwYXR0ZXJuJzogJyg/OkZpcmVmb3h8TWluZWZpZWxkKScgfSxcclxuICAgICAgeyAnbGFiZWwnOiAnRmlyZWZveCBmb3IgaU9TJywgJ3BhdHRlcm4nOiAnRnhpT1MnIH0sXHJcbiAgICAgIHsgJ2xhYmVsJzogJ0lFJywgJ3BhdHRlcm4nOiAnSUVNb2JpbGUnIH0sXHJcbiAgICAgIHsgJ2xhYmVsJzogJ0lFJywgJ3BhdHRlcm4nOiAnTVNJRScgfSxcclxuICAgICAgJ1NhZmFyaSdcclxuICAgIF0pO1xyXG5cclxuICAgIC8qIERldGVjdGFibGUgcHJvZHVjdHMgKG9yZGVyIGlzIGltcG9ydGFudCkuICovXHJcbiAgICB2YXIgcHJvZHVjdCA9IGdldFByb2R1Y3QoW1xyXG4gICAgICB7ICdsYWJlbCc6ICdCbGFja0JlcnJ5JywgJ3BhdHRlcm4nOiAnQkIxMCcgfSxcclxuICAgICAgJ0JsYWNrQmVycnknLFxyXG4gICAgICB7ICdsYWJlbCc6ICdHYWxheHkgUycsICdwYXR0ZXJuJzogJ0dULUk5MDAwJyB9LFxyXG4gICAgICB7ICdsYWJlbCc6ICdHYWxheHkgUzInLCAncGF0dGVybic6ICdHVC1JOTEwMCcgfSxcclxuICAgICAgeyAnbGFiZWwnOiAnR2FsYXh5IFMzJywgJ3BhdHRlcm4nOiAnR1QtSTkzMDAnIH0sXHJcbiAgICAgIHsgJ2xhYmVsJzogJ0dhbGF4eSBTNCcsICdwYXR0ZXJuJzogJ0dULUk5NTAwJyB9LFxyXG4gICAgICAnR29vZ2xlIFRWJyxcclxuICAgICAgJ0x1bWlhJyxcclxuICAgICAgJ2lQYWQnLFxyXG4gICAgICAnaVBvZCcsXHJcbiAgICAgICdpUGhvbmUnLFxyXG4gICAgICAnS2luZGxlJyxcclxuICAgICAgeyAnbGFiZWwnOiAnS2luZGxlIEZpcmUnLCAncGF0dGVybic6ICcoPzpDbG91ZDl8U2lsay1BY2NlbGVyYXRlZCknIH0sXHJcbiAgICAgICdOZXh1cycsXHJcbiAgICAgICdOb29rJyxcclxuICAgICAgJ1BsYXlCb29rJyxcclxuICAgICAgJ1BsYXlTdGF0aW9uIDMnLFxyXG4gICAgICAnUGxheVN0YXRpb24gNCcsXHJcbiAgICAgICdQbGF5U3RhdGlvbiBWaXRhJyxcclxuICAgICAgJ1RvdWNoUGFkJyxcclxuICAgICAgJ1RyYW5zZm9ybWVyJyxcclxuICAgICAgeyAnbGFiZWwnOiAnV2lpIFUnLCAncGF0dGVybic6ICdXaWlVJyB9LFxyXG4gICAgICAnV2lpJyxcclxuICAgICAgJ1hib3ggT25lJyxcclxuICAgICAgeyAnbGFiZWwnOiAnWGJveCAzNjAnLCAncGF0dGVybic6ICdYYm94JyB9LFxyXG4gICAgICAnWG9vbSdcclxuICAgIF0pO1xyXG5cclxuICAgIC8qIERldGVjdGFibGUgbWFudWZhY3R1cmVycy4gKi9cclxuICAgIHZhciBtYW51ZmFjdHVyZXIgPSBnZXRNYW51ZmFjdHVyZXIoe1xyXG4gICAgICAnQXBwbGUnOiB7ICdpUGFkJzogMSwgJ2lQaG9uZSc6IDEsICdpUG9kJzogMSB9LFxyXG4gICAgICAnQXJjaG9zJzoge30sXHJcbiAgICAgICdBbWF6b24nOiB7ICdLaW5kbGUnOiAxLCAnS2luZGxlIEZpcmUnOiAxIH0sXHJcbiAgICAgICdBc3VzJzogeyAnVHJhbnNmb3JtZXInOiAxIH0sXHJcbiAgICAgICdCYXJuZXMgJiBOb2JsZSc6IHsgJ05vb2snOiAxIH0sXHJcbiAgICAgICdCbGFja0JlcnJ5JzogeyAnUGxheUJvb2snOiAxIH0sXHJcbiAgICAgICdHb29nbGUnOiB7ICdHb29nbGUgVFYnOiAxLCAnTmV4dXMnOiAxIH0sXHJcbiAgICAgICdIUCc6IHsgJ1RvdWNoUGFkJzogMSB9LFxyXG4gICAgICAnSFRDJzoge30sXHJcbiAgICAgICdMRyc6IHt9LFxyXG4gICAgICAnTWljcm9zb2Z0JzogeyAnWGJveCc6IDEsICdYYm94IE9uZSc6IDEgfSxcclxuICAgICAgJ01vdG9yb2xhJzogeyAnWG9vbSc6IDEgfSxcclxuICAgICAgJ05pbnRlbmRvJzogeyAnV2lpIFUnOiAxLCAgJ1dpaSc6IDEgfSxcclxuICAgICAgJ05va2lhJzogeyAnTHVtaWEnOiAxIH0sXHJcbiAgICAgICdTYW1zdW5nJzogeyAnR2FsYXh5IFMnOiAxLCAnR2FsYXh5IFMyJzogMSwgJ0dhbGF4eSBTMyc6IDEsICdHYWxheHkgUzQnOiAxIH0sXHJcbiAgICAgICdTb255JzogeyAnUGxheVN0YXRpb24gNCc6IDEsICdQbGF5U3RhdGlvbiAzJzogMSwgJ1BsYXlTdGF0aW9uIFZpdGEnOiAxIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qIERldGVjdGFibGUgb3BlcmF0aW5nIHN5c3RlbXMgKG9yZGVyIGlzIGltcG9ydGFudCkuICovXHJcbiAgICB2YXIgb3MgPSBnZXRPUyhbXHJcbiAgICAgICdXaW5kb3dzIFBob25lJyxcclxuICAgICAgJ0FuZHJvaWQnLFxyXG4gICAgICAnQ2VudE9TJyxcclxuICAgICAgeyAnbGFiZWwnOiAnQ2hyb21lIE9TJywgJ3BhdHRlcm4nOiAnQ3JPUycgfSxcclxuICAgICAgJ0RlYmlhbicsXHJcbiAgICAgICdGZWRvcmEnLFxyXG4gICAgICAnRnJlZUJTRCcsXHJcbiAgICAgICdHZW50b28nLFxyXG4gICAgICAnSGFpa3UnLFxyXG4gICAgICAnS3VidW50dScsXHJcbiAgICAgICdMaW51eCBNaW50JyxcclxuICAgICAgJ09wZW5CU0QnLFxyXG4gICAgICAnUmVkIEhhdCcsXHJcbiAgICAgICdTdVNFJyxcclxuICAgICAgJ1VidW50dScsXHJcbiAgICAgICdYdWJ1bnR1JyxcclxuICAgICAgJ0N5Z3dpbicsXHJcbiAgICAgICdTeW1iaWFuIE9TJyxcclxuICAgICAgJ2hwd09TJyxcclxuICAgICAgJ3dlYk9TICcsXHJcbiAgICAgICd3ZWJPUycsXHJcbiAgICAgICdUYWJsZXQgT1MnLFxyXG4gICAgICAnTGludXgnLFxyXG4gICAgICAnTWFjIE9TIFgnLFxyXG4gICAgICAnTWFjaW50b3NoJyxcclxuICAgICAgJ01hYycsXHJcbiAgICAgICdXaW5kb3dzIDk4OycsXHJcbiAgICAgICdXaW5kb3dzICdcclxuICAgIF0pO1xyXG5cclxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBpY2tzIHRoZSBsYXlvdXQgZW5naW5lIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBhcnJheSBvZiBndWVzc2VzLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgbGF5b3V0IGVuZ2luZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0TGF5b3V0KGd1ZXNzZXMpIHtcclxuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIGd1ZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBSZWdFeHAoJ1xcXFxiJyArIChcclxuICAgICAgICAgIGd1ZXNzLnBhdHRlcm4gfHwgcXVhbGlmeShndWVzcylcclxuICAgICAgICApICsgJ1xcXFxiJywgJ2knKS5leGVjKHVhKSAmJiAoZ3Vlc3MubGFiZWwgfHwgZ3Vlc3MpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBpY2tzIHRoZSBtYW51ZmFjdHVyZXIgZnJvbSBhbiBhcnJheSBvZiBndWVzc2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBndWVzc2VzIEFuIG9iamVjdCBvZiBndWVzc2VzLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgbWFudWZhY3R1cmVyLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRNYW51ZmFjdHVyZXIoZ3Vlc3Nlcykge1xyXG4gICAgICByZXR1cm4gcmVkdWNlKGd1ZXNzZXMsIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xyXG4gICAgICAgIC8vIExvb2t1cCB0aGUgbWFudWZhY3R1cmVyIGJ5IHByb2R1Y3Qgb3Igc2NhbiB0aGUgVUEgZm9yIHRoZSBtYW51ZmFjdHVyZXIuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCAoXHJcbiAgICAgICAgICB2YWx1ZVtwcm9kdWN0XSB8fFxyXG4gICAgICAgICAgdmFsdWVbL15bYS16XSsoPzogK1thLXpdK1xcYikqL2kuZXhlYyhwcm9kdWN0KV0gfHxcclxuICAgICAgICAgIFJlZ0V4cCgnXFxcXGInICsgcXVhbGlmeShrZXkpICsgJyg/OlxcXFxifFxcXFx3KlxcXFxkKScsICdpJykuZXhlYyh1YSlcclxuICAgICAgICApICYmIGtleTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQaWNrcyB0aGUgYnJvd3NlciBuYW1lIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBhcnJheSBvZiBndWVzc2VzLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgYnJvd3NlciBuYW1lLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXROYW1lKGd1ZXNzZXMpIHtcclxuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIGd1ZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBSZWdFeHAoJ1xcXFxiJyArIChcclxuICAgICAgICAgIGd1ZXNzLnBhdHRlcm4gfHwgcXVhbGlmeShndWVzcylcclxuICAgICAgICApICsgJ1xcXFxiJywgJ2knKS5leGVjKHVhKSAmJiAoZ3Vlc3MubGFiZWwgfHwgZ3Vlc3MpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBpY2tzIHRoZSBPUyBuYW1lIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBhcnJheSBvZiBndWVzc2VzLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgT1MgbmFtZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0T1MoZ3Vlc3Nlcykge1xyXG4gICAgICByZXR1cm4gcmVkdWNlKGd1ZXNzZXMsIGZ1bmN0aW9uKHJlc3VsdCwgZ3Vlc3MpIHtcclxuICAgICAgICB2YXIgcGF0dGVybiA9IGd1ZXNzLnBhdHRlcm4gfHwgcXVhbGlmeShndWVzcyk7XHJcbiAgICAgICAgaWYgKCFyZXN1bHQgJiYgKHJlc3VsdCA9XHJcbiAgICAgICAgICAgICAgUmVnRXhwKCdcXFxcYicgKyBwYXR0ZXJuICsgJyg/Oi9bXFxcXGQuXSt8WyBcXFxcdy5dKiknLCAnaScpLmV4ZWModWEpXHJcbiAgICAgICAgICAgICkpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IGNsZWFudXBPUyhyZXN1bHQsIHBhdHRlcm4sIGd1ZXNzLmxhYmVsIHx8IGd1ZXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQaWNrcyB0aGUgcHJvZHVjdCBuYW1lIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBhcnJheSBvZiBndWVzc2VzLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgcHJvZHVjdCBuYW1lLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRQcm9kdWN0KGd1ZXNzZXMpIHtcclxuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIGd1ZXNzKSB7XHJcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBndWVzcy5wYXR0ZXJuIHx8IHF1YWxpZnkoZ3Vlc3MpO1xyXG4gICAgICAgIGlmICghcmVzdWx0ICYmIChyZXN1bHQgPVxyXG4gICAgICAgICAgICAgIFJlZ0V4cCgnXFxcXGInICsgcGF0dGVybiArICcgKlxcXFxkK1suXFxcXHdfXSonLCAnaScpLmV4ZWModWEpIHx8XHJcbiAgICAgICAgICAgICAgUmVnRXhwKCdcXFxcYicgKyBwYXR0ZXJuICsgJyg/OjsgKig/OlthLXpdK1tfLV0pP1thLXpdK1xcXFxkK3xbXiAoKTstXSopJywgJ2knKS5leGVjKHVhKVxyXG4gICAgICAgICAgICApKSB7XHJcbiAgICAgICAgICAvLyBTcGxpdCBieSBmb3J3YXJkIHNsYXNoIGFuZCBhcHBlbmQgcHJvZHVjdCB2ZXJzaW9uIGlmIG5lZWRlZC5cclxuICAgICAgICAgIGlmICgocmVzdWx0ID0gU3RyaW5nKChndWVzcy5sYWJlbCAmJiAhUmVnRXhwKHBhdHRlcm4sICdpJykudGVzdChndWVzcy5sYWJlbCkpID8gZ3Vlc3MubGFiZWwgOiByZXN1bHQpLnNwbGl0KCcvJykpWzFdICYmICEvW1xcZC5dKy8udGVzdChyZXN1bHRbMF0pKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFswXSArPSAnICcgKyByZXN1bHRbMV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBDb3JyZWN0IGNoYXJhY3RlciBjYXNlIGFuZCBjbGVhbnVwIHN0cmluZy5cclxuICAgICAgICAgIGd1ZXNzID0gZ3Vlc3MubGFiZWwgfHwgZ3Vlc3M7XHJcbiAgICAgICAgICByZXN1bHQgPSBmb3JtYXQocmVzdWx0WzBdXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKFJlZ0V4cChwYXR0ZXJuLCAnaScpLCBndWVzcylcclxuICAgICAgICAgICAgLnJlcGxhY2UoUmVnRXhwKCc7ICooPzonICsgZ3Vlc3MgKyAnW18tXSk/JywgJ2knKSwgJyAnKVxyXG4gICAgICAgICAgICAucmVwbGFjZShSZWdFeHAoJygnICsgZ3Vlc3MgKyAnKVstXy5dPyhcXFxcdyknLCAnaScpLCAnJDEgJDInKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzb2x2ZXMgdGhlIHZlcnNpb24gdXNpbmcgYW4gYXJyYXkgb2YgVUEgcGF0dGVybnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdHRlcm5zIEFuIGFycmF5IG9mIFVBIHBhdHRlcm5zLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgdmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0VmVyc2lvbihwYXR0ZXJucykge1xyXG4gICAgICByZXR1cm4gcmVkdWNlKHBhdHRlcm5zLCBmdW5jdGlvbihyZXN1bHQsIHBhdHRlcm4pIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IChSZWdFeHAocGF0dGVybiArXHJcbiAgICAgICAgICAnKD86LVtcXFxcZC5dKy98KD86IGZvciBbXFxcXHctXSspP1sgLy1dKShbXFxcXGQuXStbXiAoKTsvXy1dKiknLCAnaScpLmV4ZWModWEpIHx8IDApWzFdIHx8IG51bGw7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgcGxhdGZvcm0uZGVzY3JpcHRpb25gIHdoZW4gdGhlIHBsYXRmb3JtIG9iamVjdCBpcyBjb2VyY2VkIHRvIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBuYW1lIHRvU3RyaW5nXHJcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgYHBsYXRmb3JtLmRlc2NyaXB0aW9uYCBpZiBhdmFpbGFibGUsIGVsc2UgYW4gZW1wdHkgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b1N0cmluZ1BsYXRmb3JtKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5kZXNjcmlwdGlvbiB8fCAnJztcclxuICAgIH1cclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gICAgLy8gQ29udmVydCBsYXlvdXQgdG8gYW4gYXJyYXkgc28gd2UgY2FuIGFkZCBleHRyYSBkZXRhaWxzLlxyXG4gICAgbGF5b3V0ICYmIChsYXlvdXQgPSBbbGF5b3V0XSk7XHJcblxyXG4gICAgLy8gRGV0ZWN0IHByb2R1Y3QgbmFtZXMgdGhhdCBjb250YWluIHRoZWlyIG1hbnVmYWN0dXJlcidzIG5hbWUuXHJcbiAgICBpZiAobWFudWZhY3R1cmVyICYmICFwcm9kdWN0KSB7XHJcbiAgICAgIHByb2R1Y3QgPSBnZXRQcm9kdWN0KFttYW51ZmFjdHVyZXJdKTtcclxuICAgIH1cclxuICAgIC8vIENsZWFuIHVwIEdvb2dsZSBUVi5cclxuICAgIGlmICgoZGF0YSA9IC9cXGJHb29nbGUgVFZcXGIvLmV4ZWMocHJvZHVjdCkpKSB7XHJcbiAgICAgIHByb2R1Y3QgPSBkYXRhWzBdO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IHNpbXVsYXRvcnMuXHJcbiAgICBpZiAoL1xcYlNpbXVsYXRvclxcYi9pLnRlc3QodWEpKSB7XHJcbiAgICAgIHByb2R1Y3QgPSAocHJvZHVjdCA/IHByb2R1Y3QgKyAnICcgOiAnJykgKyAnU2ltdWxhdG9yJztcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBPcGVyYSBNaW5pIDgrIHJ1bm5pbmcgaW4gVHVyYm8vVW5jb21wcmVzc2VkIG1vZGUgb24gaU9TLlxyXG4gICAgaWYgKG5hbWUgPT0gJ09wZXJhIE1pbmknICYmIC9cXGJPUGlPU1xcYi8udGVzdCh1YSkpIHtcclxuICAgICAgZGVzY3JpcHRpb24ucHVzaCgncnVubmluZyBpbiBUdXJiby9VbmNvbXByZXNzZWQgbW9kZScpO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IElFIE1vYmlsZSAxMS5cclxuICAgIGlmIChuYW1lID09ICdJRScgJiYgL1xcYmxpa2UgaVBob25lIE9TXFxiLy50ZXN0KHVhKSkge1xyXG4gICAgICBkYXRhID0gcGFyc2UodWEucmVwbGFjZSgvbGlrZSBpUGhvbmUgT1MvLCAnJykpO1xyXG4gICAgICBtYW51ZmFjdHVyZXIgPSBkYXRhLm1hbnVmYWN0dXJlcjtcclxuICAgICAgcHJvZHVjdCA9IGRhdGEucHJvZHVjdDtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBpT1MuXHJcbiAgICBlbHNlIGlmICgvXmlQLy50ZXN0KHByb2R1Y3QpKSB7XHJcbiAgICAgIG5hbWUgfHwgKG5hbWUgPSAnU2FmYXJpJyk7XHJcbiAgICAgIG9zID0gJ2lPUycgKyAoKGRhdGEgPSAvIE9TIChbXFxkX10rKS9pLmV4ZWModWEpKVxyXG4gICAgICAgID8gJyAnICsgZGF0YVsxXS5yZXBsYWNlKC9fL2csICcuJylcclxuICAgICAgICA6ICcnKTtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBLdWJ1bnR1LlxyXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnS29ucXVlcm9yJyAmJiAhL2J1bnR1L2kudGVzdChvcykpIHtcclxuICAgICAgb3MgPSAnS3VidW50dSc7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgQW5kcm9pZCBicm93c2Vycy5cclxuICAgIGVsc2UgaWYgKChtYW51ZmFjdHVyZXIgJiYgbWFudWZhY3R1cmVyICE9ICdHb29nbGUnICYmXHJcbiAgICAgICAgKCgvQ2hyb21lLy50ZXN0KG5hbWUpICYmICEvXFxiTW9iaWxlIFNhZmFyaVxcYi9pLnRlc3QodWEpKSB8fCAvXFxiVml0YVxcYi8udGVzdChwcm9kdWN0KSkpIHx8XHJcbiAgICAgICAgKC9cXGJBbmRyb2lkXFxiLy50ZXN0KG9zKSAmJiAvXkNocm9tZS8udGVzdChuYW1lKSAmJiAvXFxiVmVyc2lvblxcLy9pLnRlc3QodWEpKSkge1xyXG4gICAgICBuYW1lID0gJ0FuZHJvaWQgQnJvd3Nlcic7XHJcbiAgICAgIG9zID0gL1xcYkFuZHJvaWRcXGIvLnRlc3Qob3MpID8gb3MgOiAnQW5kcm9pZCc7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgU2lsayBkZXNrdG9wL2FjY2VsZXJhdGVkIG1vZGVzLlxyXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnU2lsaycpIHtcclxuICAgICAgaWYgKCEvXFxiTW9iaS9pLnRlc3QodWEpKSB7XHJcbiAgICAgICAgb3MgPSAnQW5kcm9pZCc7XHJcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKC9BY2NlbGVyYXRlZCAqPSAqdHJ1ZS9pLnRlc3QodWEpKSB7XHJcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnYWNjZWxlcmF0ZWQnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IFBhbGVNb29uIGlkZW50aWZ5aW5nIGFzIEZpcmVmb3guXHJcbiAgICBlbHNlIGlmIChuYW1lID09ICdQYWxlTW9vbicgJiYgKGRhdGEgPSAvXFxiRmlyZWZveFxcLyhbXFxkLl0rKVxcYi8uZXhlYyh1YSkpKSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2goJ2lkZW50aWZ5aW5nIGFzIEZpcmVmb3ggJyArIGRhdGFbMV0pO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IEZpcmVmb3ggT1MgYW5kIHByb2R1Y3RzIHJ1bm5pbmcgRmlyZWZveC5cclxuICAgIGVsc2UgaWYgKG5hbWUgPT0gJ0ZpcmVmb3gnICYmIChkYXRhID0gL1xcYihNb2JpbGV8VGFibGV0fFRWKVxcYi9pLmV4ZWModWEpKSkge1xyXG4gICAgICBvcyB8fCAob3MgPSAnRmlyZWZveCBPUycpO1xyXG4gICAgICBwcm9kdWN0IHx8IChwcm9kdWN0ID0gZGF0YVsxXSk7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgZmFsc2UgcG9zaXRpdmVzIGZvciBGaXJlZm94L1NhZmFyaS5cclxuICAgIGVsc2UgaWYgKCFuYW1lIHx8IChkYXRhID0gIS9cXGJNaW5lZmllbGRcXGIvaS50ZXN0KHVhKSAmJiAvXFxiKD86RmlyZWZveHxTYWZhcmkpXFxiLy5leGVjKG5hbWUpKSkge1xyXG4gICAgICAvLyBFc2NhcGUgdGhlIGAvYCBmb3IgRmlyZWZveCAxLlxyXG4gICAgICBpZiAobmFtZSAmJiAhcHJvZHVjdCAmJiAvW1xcLyxdfF5bXihdKz9cXCkvLnRlc3QodWEuc2xpY2UodWEuaW5kZXhPZihkYXRhICsgJy8nKSArIDgpKSkge1xyXG4gICAgICAgIC8vIENsZWFyIG5hbWUgb2YgZmFsc2UgcG9zaXRpdmVzLlxyXG4gICAgICAgIG5hbWUgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFJlYXNzaWduIGEgZ2VuZXJpYyBuYW1lLlxyXG4gICAgICBpZiAoKGRhdGEgPSBwcm9kdWN0IHx8IG1hbnVmYWN0dXJlciB8fCBvcykgJiZcclxuICAgICAgICAgIChwcm9kdWN0IHx8IG1hbnVmYWN0dXJlciB8fCAvXFxiKD86QW5kcm9pZHxTeW1iaWFuIE9TfFRhYmxldCBPU3x3ZWJPUylcXGIvLnRlc3Qob3MpKSkge1xyXG4gICAgICAgIG5hbWUgPSAvW2Etel0rKD86IEhhdCk/L2kuZXhlYygvXFxiQW5kcm9pZFxcYi8udGVzdChvcykgPyBvcyA6IGRhdGEpICsgJyBCcm93c2VyJztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IG5vbi1PcGVyYSAoUHJlc3RvLWJhc2VkKSB2ZXJzaW9ucyAob3JkZXIgaXMgaW1wb3J0YW50KS5cclxuICAgIGlmICghdmVyc2lvbikge1xyXG4gICAgICB2ZXJzaW9uID0gZ2V0VmVyc2lvbihbXHJcbiAgICAgICAgJyg/OkNsb3VkOXxDcmlPU3xDck1vfEVkZ2V8RnhpT1N8SUVNb2JpbGV8SXJvbnxPcGVyYSA/TWluaXxPUGlPU3xPUFJ8UmF2ZW58U2lsayg/IS9bXFxcXGQuXSskKSknLFxyXG4gICAgICAgICdWZXJzaW9uJyxcclxuICAgICAgICBxdWFsaWZ5KG5hbWUpLFxyXG4gICAgICAgICcoPzpGaXJlZm94fE1pbmVmaWVsZHxOZXRGcm9udCknXHJcbiAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IHN0dWJib3JuIGxheW91dCBlbmdpbmVzLlxyXG4gICAgaWYgKChkYXRhID1cclxuICAgICAgICAgIGxheW91dCA9PSAnaUNhYicgJiYgcGFyc2VGbG9hdCh2ZXJzaW9uKSA+IDMgJiYgJ1dlYktpdCcgfHxcclxuICAgICAgICAgIC9cXGJPcGVyYVxcYi8udGVzdChuYW1lKSAmJiAoL1xcYk9QUlxcYi8udGVzdCh1YSkgPyAnQmxpbmsnIDogJ1ByZXN0bycpIHx8XHJcbiAgICAgICAgICAvXFxiKD86TWlkb3JpfE5vb2t8U2FmYXJpKVxcYi9pLnRlc3QodWEpICYmICEvXig/OlRyaWRlbnR8RWRnZUhUTUwpJC8udGVzdChsYXlvdXQpICYmICdXZWJLaXQnIHx8XHJcbiAgICAgICAgICAhbGF5b3V0ICYmIC9cXGJNU0lFXFxiL2kudGVzdCh1YSkgJiYgKG9zID09ICdNYWMgT1MnID8gJ1Rhc21hbicgOiAnVHJpZGVudCcpIHx8XHJcbiAgICAgICAgICBsYXlvdXQgPT0gJ1dlYktpdCcgJiYgL1xcYlBsYXlTdGF0aW9uXFxiKD8hIFZpdGFcXGIpL2kudGVzdChuYW1lKSAmJiAnTmV0RnJvbnQnXHJcbiAgICAgICAgKSkge1xyXG4gICAgICBsYXlvdXQgPSBbZGF0YV07XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgV2luZG93cyBQaG9uZSA3IGRlc2t0b3AgbW9kZS5cclxuICAgIGlmIChuYW1lID09ICdJRScgJiYgKGRhdGEgPSAoLzsgKig/OlhCTFdQfFp1bmVXUCkoXFxkKykvaS5leGVjKHVhKSB8fCAwKVsxXSkpIHtcclxuICAgICAgbmFtZSArPSAnIE1vYmlsZSc7XHJcbiAgICAgIG9zID0gJ1dpbmRvd3MgUGhvbmUgJyArICgvXFwrJC8udGVzdChkYXRhKSA/IGRhdGEgOiBkYXRhICsgJy54Jyk7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJ2Rlc2t0b3AgbW9kZScpO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IFdpbmRvd3MgUGhvbmUgOC54IGRlc2t0b3AgbW9kZS5cclxuICAgIGVsc2UgaWYgKC9cXGJXUERlc2t0b3BcXGIvaS50ZXN0KHVhKSkge1xyXG4gICAgICBuYW1lID0gJ0lFIE1vYmlsZSc7XHJcbiAgICAgIG9zID0gJ1dpbmRvd3MgUGhvbmUgOC54JztcclxuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XHJcbiAgICAgIHZlcnNpb24gfHwgKHZlcnNpb24gPSAoL1xcYnJ2OihbXFxkLl0rKS8uZXhlYyh1YSkgfHwgMClbMV0pO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IElFIDExLlxyXG4gICAgZWxzZSBpZiAobmFtZSAhPSAnSUUnICYmIGxheW91dCA9PSAnVHJpZGVudCcgJiYgKGRhdGEgPSAvXFxicnY6KFtcXGQuXSspLy5leGVjKHVhKSkpIHtcclxuICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICBkZXNjcmlwdGlvbi5wdXNoKCdpZGVudGlmeWluZyBhcyAnICsgbmFtZSArICh2ZXJzaW9uID8gJyAnICsgdmVyc2lvbiA6ICcnKSk7XHJcbiAgICAgIH1cclxuICAgICAgbmFtZSA9ICdJRSc7XHJcbiAgICAgIHZlcnNpb24gPSBkYXRhWzFdO1xyXG4gICAgfVxyXG4gICAgLy8gTGV2ZXJhZ2UgZW52aXJvbm1lbnQgZmVhdHVyZXMuXHJcbiAgICBpZiAodXNlRmVhdHVyZXMpIHtcclxuICAgICAgLy8gRGV0ZWN0IHNlcnZlci1zaWRlIGVudmlyb25tZW50cy5cclxuICAgICAgLy8gUmhpbm8gaGFzIGEgZ2xvYmFsIGZ1bmN0aW9uIHdoaWxlIG90aGVycyBoYXZlIGEgZ2xvYmFsIG9iamVjdC5cclxuICAgICAgaWYgKGlzSG9zdFR5cGUoY29udGV4dCwgJ2dsb2JhbCcpKSB7XHJcbiAgICAgICAgaWYgKGphdmEpIHtcclxuICAgICAgICAgIGRhdGEgPSBqYXZhLmxhbmcuU3lzdGVtO1xyXG4gICAgICAgICAgYXJjaCA9IGRhdGEuZ2V0UHJvcGVydHkoJ29zLmFyY2gnKTtcclxuICAgICAgICAgIG9zID0gb3MgfHwgZGF0YS5nZXRQcm9wZXJ0eSgnb3MubmFtZScpICsgJyAnICsgZGF0YS5nZXRQcm9wZXJ0eSgnb3MudmVyc2lvbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNNb2R1bGVTY29wZSAmJiBpc0hvc3RUeXBlKGNvbnRleHQsICdzeXN0ZW0nKSAmJiAoZGF0YSA9IFtjb250ZXh0LnN5c3RlbV0pWzBdKSB7XHJcbiAgICAgICAgICBvcyB8fCAob3MgPSBkYXRhWzBdLm9zIHx8IG51bGwpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZGF0YVsxXSA9IGNvbnRleHQucmVxdWlyZSgncmluZ28vZW5naW5lJykudmVyc2lvbjtcclxuICAgICAgICAgICAgdmVyc2lvbiA9IGRhdGFbMV0uam9pbignLicpO1xyXG4gICAgICAgICAgICBuYW1lID0gJ1JpbmdvSlMnO1xyXG4gICAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhWzBdLmdsb2JhbC5zeXN0ZW0gPT0gY29udGV4dC5zeXN0ZW0pIHtcclxuICAgICAgICAgICAgICBuYW1lID0gJ05hcndoYWwnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgICAgdHlwZW9mIGNvbnRleHQucHJvY2VzcyA9PSAnb2JqZWN0JyAmJiAhY29udGV4dC5wcm9jZXNzLmJyb3dzZXIgJiZcclxuICAgICAgICAgIChkYXRhID0gY29udGV4dC5wcm9jZXNzKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgbmFtZSA9ICdOb2RlLmpzJztcclxuICAgICAgICAgIGFyY2ggPSBkYXRhLmFyY2g7XHJcbiAgICAgICAgICBvcyA9IGRhdGEucGxhdGZvcm07XHJcbiAgICAgICAgICB2ZXJzaW9uID0gL1tcXGQuXSsvLmV4ZWMoZGF0YS52ZXJzaW9uKVswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmhpbm8pIHtcclxuICAgICAgICAgIG5hbWUgPSAnUmhpbm8nO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBEZXRlY3QgQWRvYmUgQUlSLlxyXG4gICAgICBlbHNlIGlmIChnZXRDbGFzc09mKChkYXRhID0gY29udGV4dC5ydW50aW1lKSkgPT0gYWlyUnVudGltZUNsYXNzKSB7XHJcbiAgICAgICAgbmFtZSA9ICdBZG9iZSBBSVInO1xyXG4gICAgICAgIG9zID0gZGF0YS5mbGFzaC5zeXN0ZW0uQ2FwYWJpbGl0aWVzLm9zO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIERldGVjdCBQaGFudG9tSlMuXHJcbiAgICAgIGVsc2UgaWYgKGdldENsYXNzT2YoKGRhdGEgPSBjb250ZXh0LnBoYW50b20pKSA9PSBwaGFudG9tQ2xhc3MpIHtcclxuICAgICAgICBuYW1lID0gJ1BoYW50b21KUyc7XHJcbiAgICAgICAgdmVyc2lvbiA9IChkYXRhID0gZGF0YS52ZXJzaW9uIHx8IG51bGwpICYmIChkYXRhLm1ham9yICsgJy4nICsgZGF0YS5taW5vciArICcuJyArIGRhdGEucGF0Y2gpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIERldGVjdCBJRSBjb21wYXRpYmlsaXR5IG1vZGVzLlxyXG4gICAgICBlbHNlIGlmICh0eXBlb2YgZG9jLmRvY3VtZW50TW9kZSA9PSAnbnVtYmVyJyAmJiAoZGF0YSA9IC9cXGJUcmlkZW50XFwvKFxcZCspL2kuZXhlYyh1YSkpKSB7XHJcbiAgICAgICAgLy8gV2UncmUgaW4gY29tcGF0aWJpbGl0eSBtb2RlIHdoZW4gdGhlIFRyaWRlbnQgdmVyc2lvbiArIDQgZG9lc24ndFxyXG4gICAgICAgIC8vIGVxdWFsIHRoZSBkb2N1bWVudCBtb2RlLlxyXG4gICAgICAgIHZlcnNpb24gPSBbdmVyc2lvbiwgZG9jLmRvY3VtZW50TW9kZV07XHJcbiAgICAgICAgaWYgKChkYXRhID0gK2RhdGFbMV0gKyA0KSAhPSB2ZXJzaW9uWzFdKSB7XHJcbiAgICAgICAgICBkZXNjcmlwdGlvbi5wdXNoKCdJRSAnICsgdmVyc2lvblsxXSArICcgbW9kZScpO1xyXG4gICAgICAgICAgbGF5b3V0ICYmIChsYXlvdXRbMV0gPSAnJyk7XHJcbiAgICAgICAgICB2ZXJzaW9uWzFdID0gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmVyc2lvbiA9IG5hbWUgPT0gJ0lFJyA/IFN0cmluZyh2ZXJzaW9uWzFdLnRvRml4ZWQoMSkpIDogdmVyc2lvblswXTtcclxuICAgICAgfVxyXG4gICAgICBvcyA9IG9zICYmIGZvcm1hdChvcyk7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgcHJlcmVsZWFzZSBwaGFzZXMuXHJcbiAgICBpZiAodmVyc2lvbiAmJiAoZGF0YSA9XHJcbiAgICAgICAgICAvKD86W2FiXXxkcHxwcmV8W2FiXVxcZCtwcmUpKD86XFxkK1xcKz8pPyQvaS5leGVjKHZlcnNpb24pIHx8XHJcbiAgICAgICAgICAvKD86YWxwaGF8YmV0YSkoPzogP1xcZCk/L2kuZXhlYyh1YSArICc7JyArICh1c2VGZWF0dXJlcyAmJiBuYXYuYXBwTWlub3JWZXJzaW9uKSkgfHxcclxuICAgICAgICAgIC9cXGJNaW5lZmllbGRcXGIvaS50ZXN0KHVhKSAmJiAnYSdcclxuICAgICAgICApKSB7XHJcbiAgICAgIHByZXJlbGVhc2UgPSAvYi9pLnRlc3QoZGF0YSkgPyAnYmV0YScgOiAnYWxwaGEnO1xyXG4gICAgICB2ZXJzaW9uID0gdmVyc2lvbi5yZXBsYWNlKFJlZ0V4cChkYXRhICsgJ1xcXFwrPyQnKSwgJycpICtcclxuICAgICAgICAocHJlcmVsZWFzZSA9PSAnYmV0YScgPyBiZXRhIDogYWxwaGEpICsgKC9cXGQrXFwrPy8uZXhlYyhkYXRhKSB8fCAnJyk7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgRmlyZWZveCBNb2JpbGUuXHJcbiAgICBpZiAobmFtZSA9PSAnRmVubmVjJyB8fCBuYW1lID09ICdGaXJlZm94JyAmJiAvXFxiKD86QW5kcm9pZHxGaXJlZm94IE9TKVxcYi8udGVzdChvcykpIHtcclxuICAgICAgbmFtZSA9ICdGaXJlZm94IE1vYmlsZSc7XHJcbiAgICB9XHJcbiAgICAvLyBPYnNjdXJlIE1heHRob24ncyB1bnJlbGlhYmxlIHZlcnNpb24uXHJcbiAgICBlbHNlIGlmIChuYW1lID09ICdNYXh0aG9uJyAmJiB2ZXJzaW9uKSB7XHJcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnJlcGxhY2UoL1xcLltcXGQuXSsvLCAnLngnKTtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBYYm94IDM2MCBhbmQgWGJveCBPbmUuXHJcbiAgICBlbHNlIGlmICgvXFxiWGJveFxcYi9pLnRlc3QocHJvZHVjdCkpIHtcclxuICAgICAgb3MgPSBudWxsO1xyXG4gICAgICBpZiAocHJvZHVjdCA9PSAnWGJveCAzNjAnICYmIC9cXGJJRU1vYmlsZVxcYi8udGVzdCh1YSkpIHtcclxuICAgICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdtb2JpbGUgbW9kZScpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBBZGQgbW9iaWxlIHBvc3RmaXguXHJcbiAgICBlbHNlIGlmICgoL14oPzpDaHJvbWV8SUV8T3BlcmEpJC8udGVzdChuYW1lKSB8fCBuYW1lICYmICFwcm9kdWN0ICYmICEvQnJvd3NlcnxNb2JpLy50ZXN0KG5hbWUpKSAmJlxyXG4gICAgICAgIChvcyA9PSAnV2luZG93cyBDRScgfHwgL01vYmkvaS50ZXN0KHVhKSkpIHtcclxuICAgICAgbmFtZSArPSAnIE1vYmlsZSc7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgSUUgcGxhdGZvcm0gcHJldmlldy5cclxuICAgIGVsc2UgaWYgKG5hbWUgPT0gJ0lFJyAmJiB1c2VGZWF0dXJlcyAmJiBjb250ZXh0LmV4dGVybmFsID09PSBudWxsKSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJ3BsYXRmb3JtIHByZXZpZXcnKTtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBCbGFja0JlcnJ5IE9TIHZlcnNpb24uXHJcbiAgICAvLyBodHRwOi8vZG9jcy5ibGFja2JlcnJ5LmNvbS9lbi9kZXZlbG9wZXJzL2RlbGl2ZXJhYmxlcy8xODE2OS9IVFRQX2hlYWRlcnNfc2VudF9ieV9CQl9Ccm93c2VyXzEyMzQ5MTFfMTEuanNwXHJcbiAgICBlbHNlIGlmICgoL1xcYkJsYWNrQmVycnlcXGIvLnRlc3QocHJvZHVjdCkgfHwgL1xcYkJCMTBcXGIvLnRlc3QodWEpKSAmJiAoZGF0YSA9XHJcbiAgICAgICAgICAoUmVnRXhwKHByb2R1Y3QucmVwbGFjZSgvICsvZywgJyAqJykgKyAnLyhbLlxcXFxkXSspJywgJ2knKS5leGVjKHVhKSB8fCAwKVsxXSB8fFxyXG4gICAgICAgICAgdmVyc2lvblxyXG4gICAgICAgICkpIHtcclxuICAgICAgZGF0YSA9IFtkYXRhLCAvQkIxMC8udGVzdCh1YSldO1xyXG4gICAgICBvcyA9IChkYXRhWzFdID8gKHByb2R1Y3QgPSBudWxsLCBtYW51ZmFjdHVyZXIgPSAnQmxhY2tCZXJyeScpIDogJ0RldmljZSBTb2Z0d2FyZScpICsgJyAnICsgZGF0YVswXTtcclxuICAgICAgdmVyc2lvbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgT3BlcmEgaWRlbnRpZnlpbmcvbWFza2luZyBpdHNlbGYgYXMgYW5vdGhlciBicm93c2VyLlxyXG4gICAgLy8gaHR0cDovL3d3dy5vcGVyYS5jb20vc3VwcG9ydC9rYi92aWV3Lzg0My9cclxuICAgIGVsc2UgaWYgKHRoaXMgIT0gZm9yT3duICYmIHByb2R1Y3QgIT0gJ1dpaScgJiYgKFxyXG4gICAgICAgICAgKHVzZUZlYXR1cmVzICYmIG9wZXJhKSB8fFxyXG4gICAgICAgICAgKC9PcGVyYS8udGVzdChuYW1lKSAmJiAvXFxiKD86TVNJRXxGaXJlZm94KVxcYi9pLnRlc3QodWEpKSB8fFxyXG4gICAgICAgICAgKG5hbWUgPT0gJ0ZpcmVmb3gnICYmIC9cXGJPUyBYICg/OlxcZCtcXC4pezIsfS8udGVzdChvcykpIHx8XHJcbiAgICAgICAgICAobmFtZSA9PSAnSUUnICYmIChcclxuICAgICAgICAgICAgKG9zICYmICEvXldpbi8udGVzdChvcykgJiYgdmVyc2lvbiA+IDUuNSkgfHxcclxuICAgICAgICAgICAgL1xcYldpbmRvd3MgWFBcXGIvLnRlc3Qob3MpICYmIHZlcnNpb24gPiA4IHx8XHJcbiAgICAgICAgICAgIHZlcnNpb24gPT0gOCAmJiAhL1xcYlRyaWRlbnRcXGIvLnRlc3QodWEpXHJcbiAgICAgICAgICApKVxyXG4gICAgICAgICkgJiYgIXJlT3BlcmEudGVzdCgoZGF0YSA9IHBhcnNlLmNhbGwoZm9yT3duLCB1YS5yZXBsYWNlKHJlT3BlcmEsICcnKSArICc7JykpKSAmJiBkYXRhLm5hbWUpIHtcclxuICAgICAgLy8gV2hlbiBcImlkZW50aWZ5aW5nXCIsIHRoZSBVQSBjb250YWlucyBib3RoIE9wZXJhIGFuZCB0aGUgb3RoZXIgYnJvd3NlcidzIG5hbWUuXHJcbiAgICAgIGRhdGEgPSAnaW5nIGFzICcgKyBkYXRhLm5hbWUgKyAoKGRhdGEgPSBkYXRhLnZlcnNpb24pID8gJyAnICsgZGF0YSA6ICcnKTtcclxuICAgICAgaWYgKHJlT3BlcmEudGVzdChuYW1lKSkge1xyXG4gICAgICAgIGlmICgvXFxiSUVcXGIvLnRlc3QoZGF0YSkgJiYgb3MgPT0gJ01hYyBPUycpIHtcclxuICAgICAgICAgIG9zID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YSA9ICdpZGVudGlmeScgKyBkYXRhO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFdoZW4gXCJtYXNraW5nXCIsIHRoZSBVQSBjb250YWlucyBvbmx5IHRoZSBvdGhlciBicm93c2VyJ3MgbmFtZS5cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgZGF0YSA9ICdtYXNrJyArIGRhdGE7XHJcbiAgICAgICAgaWYgKG9wZXJhQ2xhc3MpIHtcclxuICAgICAgICAgIG5hbWUgPSBmb3JtYXQob3BlcmFDbGFzcy5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEgJDInKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5hbWUgPSAnT3BlcmEnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoL1xcYklFXFxiLy50ZXN0KGRhdGEpKSB7XHJcbiAgICAgICAgICBvcyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdXNlRmVhdHVyZXMpIHtcclxuICAgICAgICAgIHZlcnNpb24gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBsYXlvdXQgPSBbJ1ByZXN0byddO1xyXG4gICAgICBkZXNjcmlwdGlvbi5wdXNoKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IFdlYktpdCBOaWdodGx5IGFuZCBhcHByb3hpbWF0ZSBDaHJvbWUvU2FmYXJpIHZlcnNpb25zLlxyXG4gICAgaWYgKChkYXRhID0gKC9cXGJBcHBsZVdlYktpdFxcLyhbXFxkLl0rXFwrPykvaS5leGVjKHVhKSB8fCAwKVsxXSkpIHtcclxuICAgICAgLy8gQ29ycmVjdCBidWlsZCBudW1iZXIgZm9yIG51bWVyaWMgY29tcGFyaXNvbi5cclxuICAgICAgLy8gKGUuZy4gXCI1MzIuNVwiIGJlY29tZXMgXCI1MzIuMDVcIilcclxuICAgICAgZGF0YSA9IFtwYXJzZUZsb2F0KGRhdGEucmVwbGFjZSgvXFwuKFxcZCkkLywgJy4wJDEnKSksIGRhdGFdO1xyXG4gICAgICAvLyBOaWdodGx5IGJ1aWxkcyBhcmUgcG9zdGZpeGVkIHdpdGggYSBcIitcIi5cclxuICAgICAgaWYgKG5hbWUgPT0gJ1NhZmFyaScgJiYgZGF0YVsxXS5zbGljZSgtMSkgPT0gJysnKSB7XHJcbiAgICAgICAgbmFtZSA9ICdXZWJLaXQgTmlnaHRseSc7XHJcbiAgICAgICAgcHJlcmVsZWFzZSA9ICdhbHBoYSc7XHJcbiAgICAgICAgdmVyc2lvbiA9IGRhdGFbMV0uc2xpY2UoMCwgLTEpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIENsZWFyIGluY29ycmVjdCBicm93c2VyIHZlcnNpb25zLlxyXG4gICAgICBlbHNlIGlmICh2ZXJzaW9uID09IGRhdGFbMV0gfHxcclxuICAgICAgICAgIHZlcnNpb24gPT0gKGRhdGFbMl0gPSAoL1xcYlNhZmFyaVxcLyhbXFxkLl0rXFwrPykvaS5leGVjKHVhKSB8fCAwKVsxXSkpIHtcclxuICAgICAgICB2ZXJzaW9uID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICAvLyBVc2UgdGhlIGZ1bGwgQ2hyb21lIHZlcnNpb24gd2hlbiBhdmFpbGFibGUuXHJcbiAgICAgIGRhdGFbMV0gPSAoL1xcYkNocm9tZVxcLyhbXFxkLl0rKS9pLmV4ZWModWEpIHx8IDApWzFdO1xyXG4gICAgICAvLyBEZXRlY3QgQmxpbmsgbGF5b3V0IGVuZ2luZS5cclxuICAgICAgaWYgKGRhdGFbMF0gPT0gNTM3LjM2ICYmIGRhdGFbMl0gPT0gNTM3LjM2ICYmIHBhcnNlRmxvYXQoZGF0YVsxXSkgPj0gMjggJiYgbGF5b3V0ID09ICdXZWJLaXQnKSB7XHJcbiAgICAgICAgbGF5b3V0ID0gWydCbGluayddO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIERldGVjdCBKYXZhU2NyaXB0Q29yZS5cclxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82NzY4NDc0L2hvdy1jYW4taS1kZXRlY3Qtd2hpY2gtamF2YXNjcmlwdC1lbmdpbmUtdjgtb3ItanNjLWlzLXVzZWQtYXQtcnVudGltZS1pbi1hbmRyb2lcclxuICAgICAgaWYgKCF1c2VGZWF0dXJlcyB8fCAoIWxpa2VDaHJvbWUgJiYgIWRhdGFbMV0pKSB7XHJcbiAgICAgICAgbGF5b3V0ICYmIChsYXlvdXRbMV0gPSAnbGlrZSBTYWZhcmknKTtcclxuICAgICAgICBkYXRhID0gKGRhdGEgPSBkYXRhWzBdLCBkYXRhIDwgNDAwID8gMSA6IGRhdGEgPCA1MDAgPyAyIDogZGF0YSA8IDUyNiA/IDMgOiBkYXRhIDwgNTMzID8gNCA6IGRhdGEgPCA1MzQgPyAnNCsnIDogZGF0YSA8IDUzNSA/IDUgOiBkYXRhIDwgNTM3ID8gNiA6IGRhdGEgPCA1MzggPyA3IDogZGF0YSA8IDYwMSA/IDggOiAnOCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxheW91dCAmJiAobGF5b3V0WzFdID0gJ2xpa2UgQ2hyb21lJyk7XHJcbiAgICAgICAgZGF0YSA9IGRhdGFbMV0gfHwgKGRhdGEgPSBkYXRhWzBdLCBkYXRhIDwgNTMwID8gMSA6IGRhdGEgPCA1MzIgPyAyIDogZGF0YSA8IDUzMi4wNSA/IDMgOiBkYXRhIDwgNTMzID8gNCA6IGRhdGEgPCA1MzQuMDMgPyA1IDogZGF0YSA8IDUzNC4wNyA/IDYgOiBkYXRhIDwgNTM0LjEwID8gNyA6IGRhdGEgPCA1MzQuMTMgPyA4IDogZGF0YSA8IDUzNC4xNiA/IDkgOiBkYXRhIDwgNTM0LjI0ID8gMTAgOiBkYXRhIDwgNTM0LjMwID8gMTEgOiBkYXRhIDwgNTM1LjAxID8gMTIgOiBkYXRhIDwgNTM1LjAyID8gJzEzKycgOiBkYXRhIDwgNTM1LjA3ID8gMTUgOiBkYXRhIDwgNTM1LjExID8gMTYgOiBkYXRhIDwgNTM1LjE5ID8gMTcgOiBkYXRhIDwgNTM2LjA1ID8gMTggOiBkYXRhIDwgNTM2LjEwID8gMTkgOiBkYXRhIDwgNTM3LjAxID8gMjAgOiBkYXRhIDwgNTM3LjExID8gJzIxKycgOiBkYXRhIDwgNTM3LjEzID8gMjMgOiBkYXRhIDwgNTM3LjE4ID8gMjQgOiBkYXRhIDwgNTM3LjI0ID8gMjUgOiBkYXRhIDwgNTM3LjM2ID8gMjYgOiBsYXlvdXQgIT0gJ0JsaW5rJyA/ICcyNycgOiAnMjgnKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBBZGQgdGhlIHBvc3RmaXggb2YgXCIueFwiIG9yIFwiK1wiIGZvciBhcHByb3hpbWF0ZSB2ZXJzaW9ucy5cclxuICAgICAgbGF5b3V0ICYmIChsYXlvdXRbMV0gKz0gJyAnICsgKGRhdGEgKz0gdHlwZW9mIGRhdGEgPT0gJ251bWJlcicgPyAnLngnIDogL1suK10vLnRlc3QoZGF0YSkgPyAnJyA6ICcrJykpO1xyXG4gICAgICAvLyBPYnNjdXJlIHZlcnNpb24gZm9yIHNvbWUgU2FmYXJpIDEtMiByZWxlYXNlcy5cclxuICAgICAgaWYgKG5hbWUgPT0gJ1NhZmFyaScgJiYgKCF2ZXJzaW9uIHx8IHBhcnNlSW50KHZlcnNpb24pID4gNDUpKSB7XHJcbiAgICAgICAgdmVyc2lvbiA9IGRhdGE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIERldGVjdCBPcGVyYSBkZXNrdG9wIG1vZGVzLlxyXG4gICAgaWYgKG5hbWUgPT0gJ09wZXJhJyAmJiAgKGRhdGEgPSAvXFxiemJvdnx6dmF2JC8uZXhlYyhvcykpKSB7XHJcbiAgICAgIG5hbWUgKz0gJyAnO1xyXG4gICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdkZXNrdG9wIG1vZGUnKTtcclxuICAgICAgaWYgKGRhdGEgPT0gJ3p2YXYnKSB7XHJcbiAgICAgICAgbmFtZSArPSAnTWluaSc7XHJcbiAgICAgICAgdmVyc2lvbiA9IG51bGw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbmFtZSArPSAnTW9iaWxlJztcclxuICAgICAgfVxyXG4gICAgICBvcyA9IG9zLnJlcGxhY2UoUmVnRXhwKCcgKicgKyBkYXRhICsgJyQnKSwgJycpO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IENocm9tZSBkZXNrdG9wIG1vZGUuXHJcbiAgICBlbHNlIGlmIChuYW1lID09ICdTYWZhcmknICYmIC9cXGJDaHJvbWVcXGIvLmV4ZWMobGF5b3V0ICYmIGxheW91dFsxXSkpIHtcclxuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XHJcbiAgICAgIG5hbWUgPSAnQ2hyb21lIE1vYmlsZSc7XHJcbiAgICAgIHZlcnNpb24gPSBudWxsO1xyXG5cclxuICAgICAgaWYgKC9cXGJPUyBYXFxiLy50ZXN0KG9zKSkge1xyXG4gICAgICAgIG1hbnVmYWN0dXJlciA9ICdBcHBsZSc7XHJcbiAgICAgICAgb3MgPSAnaU9TIDQuMysnO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9zID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gU3RyaXAgaW5jb3JyZWN0IE9TIHZlcnNpb25zLlxyXG4gICAgaWYgKHZlcnNpb24gJiYgdmVyc2lvbi5pbmRleE9mKChkYXRhID0gL1tcXGQuXSskLy5leGVjKG9zKSkpID09IDAgJiZcclxuICAgICAgICB1YS5pbmRleE9mKCcvJyArIGRhdGEgKyAnLScpID4gLTEpIHtcclxuICAgICAgb3MgPSB0cmltKG9zLnJlcGxhY2UoZGF0YSwgJycpKTtcclxuICAgIH1cclxuICAgIC8vIEFkZCBsYXlvdXQgZW5naW5lLlxyXG4gICAgaWYgKGxheW91dCAmJiAhL1xcYig/OkF2YW50fE5vb2spXFxiLy50ZXN0KG5hbWUpICYmIChcclxuICAgICAgICAvQnJvd3NlcnxMdW5hc2NhcGV8TWF4dGhvbi8udGVzdChuYW1lKSB8fFxyXG4gICAgICAgIG5hbWUgIT0gJ1NhZmFyaScgJiYgL15pT1MvLnRlc3Qob3MpICYmIC9cXGJTYWZhcmlcXGIvLnRlc3QobGF5b3V0WzFdKSB8fFxyXG4gICAgICAgIC9eKD86QWRvYmV8QXJvcmF8QnJlYWNofE1pZG9yaXxPcGVyYXxQaGFudG9tfFJla29ucXxSb2NrfFNsZWlwbmlyfFdlYikvLnRlc3QobmFtZSkgJiYgbGF5b3V0WzFdKSkge1xyXG4gICAgICAvLyBEb24ndCBhZGQgbGF5b3V0IGRldGFpbHMgdG8gZGVzY3JpcHRpb24gaWYgdGhleSBhcmUgZmFsc2V5LlxyXG4gICAgICAoZGF0YSA9IGxheW91dFtsYXlvdXQubGVuZ3RoIC0gMV0pICYmIGRlc2NyaXB0aW9uLnB1c2goZGF0YSk7XHJcbiAgICB9XHJcbiAgICAvLyBDb21iaW5lIGNvbnRleHR1YWwgaW5mb3JtYXRpb24uXHJcbiAgICBpZiAoZGVzY3JpcHRpb24ubGVuZ3RoKSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uID0gWycoJyArIGRlc2NyaXB0aW9uLmpvaW4oJzsgJykgKyAnKSddO1xyXG4gICAgfVxyXG4gICAgLy8gQXBwZW5kIG1hbnVmYWN0dXJlciB0byBkZXNjcmlwdGlvbi5cclxuICAgIGlmIChtYW51ZmFjdHVyZXIgJiYgcHJvZHVjdCAmJiBwcm9kdWN0LmluZGV4T2YobWFudWZhY3R1cmVyKSA8IDApIHtcclxuICAgICAgZGVzY3JpcHRpb24ucHVzaCgnb24gJyArIG1hbnVmYWN0dXJlcik7XHJcbiAgICB9XHJcbiAgICAvLyBBcHBlbmQgcHJvZHVjdCB0byBkZXNjcmlwdGlvbi5cclxuICAgIGlmIChwcm9kdWN0KSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2goKC9eb24gLy50ZXN0KGRlc2NyaXB0aW9uW2Rlc2NyaXB0aW9uLmxlbmd0aCAtIDFdKSA/ICcnIDogJ29uICcpICsgcHJvZHVjdCk7XHJcbiAgICB9XHJcbiAgICAvLyBQYXJzZSB0aGUgT1MgaW50byBhbiBvYmplY3QuXHJcbiAgICBpZiAob3MpIHtcclxuICAgICAgZGF0YSA9IC8gKFtcXGQuK10rKSQvLmV4ZWMob3MpO1xyXG4gICAgICBpc1NwZWNpYWxDYXNlZE9TID0gZGF0YSAmJiBvcy5jaGFyQXQob3MubGVuZ3RoIC0gZGF0YVswXS5sZW5ndGggLSAxKSA9PSAnLyc7XHJcbiAgICAgIG9zID0ge1xyXG4gICAgICAgICdhcmNoaXRlY3R1cmUnOiAzMixcclxuICAgICAgICAnZmFtaWx5JzogKGRhdGEgJiYgIWlzU3BlY2lhbENhc2VkT1MpID8gb3MucmVwbGFjZShkYXRhWzBdLCAnJykgOiBvcyxcclxuICAgICAgICAndmVyc2lvbic6IGRhdGEgPyBkYXRhWzFdIDogbnVsbCxcclxuICAgICAgICAndG9TdHJpbmcnOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciB2ZXJzaW9uID0gdGhpcy52ZXJzaW9uO1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmFtaWx5ICsgKCh2ZXJzaW9uICYmICFpc1NwZWNpYWxDYXNlZE9TKSA/ICcgJyArIHZlcnNpb24gOiAnJykgKyAodGhpcy5hcmNoaXRlY3R1cmUgPT0gNjQgPyAnIDY0LWJpdCcgOiAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gQWRkIGJyb3dzZXIvT1MgYXJjaGl0ZWN0dXJlLlxyXG4gICAgaWYgKChkYXRhID0gL1xcYig/OkFNRHxJQXxXaW58V09XfHg4Nl98eCk2NFxcYi9pLmV4ZWMoYXJjaCkpICYmICEvXFxiaTY4NlxcYi9pLnRlc3QoYXJjaCkpIHtcclxuICAgICAgaWYgKG9zKSB7XHJcbiAgICAgICAgb3MuYXJjaGl0ZWN0dXJlID0gNjQ7XHJcbiAgICAgICAgb3MuZmFtaWx5ID0gb3MuZmFtaWx5LnJlcGxhY2UoUmVnRXhwKCcgKicgKyBkYXRhKSwgJycpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChcclxuICAgICAgICAgIG5hbWUgJiYgKC9cXGJXT1c2NFxcYi9pLnRlc3QodWEpIHx8XHJcbiAgICAgICAgICAodXNlRmVhdHVyZXMgJiYgL1xcdyg/Ojg2fDMyKSQvLnRlc3QobmF2LmNwdUNsYXNzIHx8IG5hdi5wbGF0Zm9ybSkgJiYgIS9cXGJXaW42NDsgeDY0XFxiL2kudGVzdCh1YSkpKVxyXG4gICAgICApIHtcclxuICAgICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCczMi1iaXQnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ2hyb21lIDM5IGFuZCBhYm92ZSBvbiBPUyBYIGlzIGFsd2F5cyA2NC1iaXQuXHJcbiAgICBlbHNlIGlmIChcclxuICAgICAgICBvcyAmJiAvXk9TIFgvLnRlc3Qob3MuZmFtaWx5KSAmJlxyXG4gICAgICAgIG5hbWUgPT0gJ0Nocm9tZScgJiYgcGFyc2VGbG9hdCh2ZXJzaW9uKSA+PSAzOVxyXG4gICAgKSB7XHJcbiAgICAgIG9zLmFyY2hpdGVjdHVyZSA9IDY0O1xyXG4gICAgfVxyXG5cclxuICAgIHVhIHx8ICh1YSA9IG51bGwpO1xyXG5cclxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwbGF0Zm9ybSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG5hbWUgcGxhdGZvcm1cclxuICAgICAqIEB0eXBlIE9iamVjdFxyXG4gICAgICovXHJcbiAgICB2YXIgcGxhdGZvcm0gPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwbGF0Zm9ybSBkZXNjcmlwdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXHJcbiAgICAgKi9cclxuICAgIHBsYXRmb3JtLmRlc2NyaXB0aW9uID0gdWE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgYnJvd3NlcidzIGxheW91dCBlbmdpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS5sYXlvdXQgPSBsYXlvdXQgJiYgbGF5b3V0WzBdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHByb2R1Y3QncyBtYW51ZmFjdHVyZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS5tYW51ZmFjdHVyZXIgPSBtYW51ZmFjdHVyZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgYnJvd3Nlci9lbnZpcm9ubWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXHJcbiAgICAgKi9cclxuICAgIHBsYXRmb3JtLm5hbWUgPSBuYW1lO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFscGhhL2JldGEgcmVsZWFzZSBpbmRpY2F0b3IuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS5wcmVyZWxlYXNlID0gcHJlcmVsZWFzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9kdWN0IGhvc3RpbmcgdGhlIGJyb3dzZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS5wcm9kdWN0ID0gcHJvZHVjdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBicm93c2VyJ3MgdXNlciBhZ2VudCBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS51YSA9IHVhO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJyb3dzZXIvZW52aXJvbm1lbnQgdmVyc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXHJcbiAgICAgKi9cclxuICAgIHBsYXRmb3JtLnZlcnNpb24gPSBuYW1lICYmIHZlcnNpb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgb3BlcmF0aW5nIHN5c3RlbS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgICAqIEB0eXBlIE9iamVjdFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS5vcyA9IG9zIHx8IHtcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUaGUgQ1BVIGFyY2hpdGVjdHVyZSB0aGUgT1MgaXMgYnVpbHQgZm9yLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm0ub3NcclxuICAgICAgICogQHR5cGUgbnVtYmVyfG51bGxcclxuICAgICAgICovXHJcbiAgICAgICdhcmNoaXRlY3R1cmUnOiBudWxsLFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoZSBmYW1pbHkgb2YgdGhlIE9TLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBDb21tb24gdmFsdWVzIGluY2x1ZGU6XHJcbiAgICAgICAqIFwiV2luZG93c1wiLCBcIldpbmRvd3MgU2VydmVyIDIwMDggUjIgLyA3XCIsIFwiV2luZG93cyBTZXJ2ZXIgMjAwOCAvIFZpc3RhXCIsXHJcbiAgICAgICAqIFwiV2luZG93cyBYUFwiLCBcIk9TIFhcIiwgXCJVYnVudHVcIiwgXCJEZWJpYW5cIiwgXCJGZWRvcmFcIiwgXCJSZWQgSGF0XCIsIFwiU3VTRVwiLFxyXG4gICAgICAgKiBcIkFuZHJvaWRcIiwgXCJpT1NcIiBhbmQgXCJXaW5kb3dzIFBob25lXCJcclxuICAgICAgICpcclxuICAgICAgICogQG1lbWJlck9mIHBsYXRmb3JtLm9zXHJcbiAgICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXHJcbiAgICAgICAqL1xyXG4gICAgICAnZmFtaWx5JzogbnVsbCxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgT1MuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybS5vc1xyXG4gICAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICAgKi9cclxuICAgICAgJ3ZlcnNpb24nOiBudWxsLFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFJldHVybnMgdGhlIE9TIHN0cmluZy5cclxuICAgICAgICpcclxuICAgICAgICogQG1lbWJlck9mIHBsYXRmb3JtLm9zXHJcbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBPUyBzdHJpbmcuXHJcbiAgICAgICAqL1xyXG4gICAgICAndG9TdHJpbmcnOiBmdW5jdGlvbigpIHsgcmV0dXJuICdudWxsJzsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwbGF0Zm9ybS5wYXJzZSA9IHBhcnNlO1xyXG4gICAgcGxhdGZvcm0udG9TdHJpbmcgPSB0b1N0cmluZ1BsYXRmb3JtO1xyXG5cclxuICAgIGlmIChwbGF0Zm9ybS52ZXJzaW9uKSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQodmVyc2lvbik7XHJcbiAgICB9XHJcbiAgICBpZiAocGxhdGZvcm0ubmFtZSkge1xyXG4gICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KG5hbWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9zICYmIG5hbWUgJiYgIShvcyA9PSBTdHJpbmcob3MpLnNwbGl0KCcgJylbMF0gJiYgKG9zID09IG5hbWUuc3BsaXQoJyAnKVswXSB8fCBwcm9kdWN0KSkpIHtcclxuICAgICAgZGVzY3JpcHRpb24ucHVzaChwcm9kdWN0ID8gJygnICsgb3MgKyAnKScgOiAnb24gJyArIG9zKTtcclxuICAgIH1cclxuICAgIGlmIChkZXNjcmlwdGlvbi5sZW5ndGgpIHtcclxuICAgICAgcGxhdGZvcm0uZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbi5qb2luKCcgJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGxhdGZvcm07XHJcbiAgfVxyXG5cclxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgLy8gRXhwb3J0IHBsYXRmb3JtLlxyXG4gIHZhciBwbGF0Zm9ybSA9IHBhcnNlKCk7XHJcblxyXG4gIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlIHRoZSBmb2xsb3dpbmc6XHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAvLyBFeHBvc2UgcGxhdGZvcm0gb24gdGhlIGdsb2JhbCBvYmplY3QgdG8gcHJldmVudCBlcnJvcnMgd2hlbiBwbGF0Zm9ybSBpc1xyXG4gICAgLy8gbG9hZGVkIGJ5IGEgc2NyaXB0IHRhZyBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EIGxvYWRlci5cclxuICAgIC8vIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICByb290LnBsYXRmb3JtID0gcGxhdGZvcm07XHJcblxyXG4gICAgLy8gRGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28gcGxhdGZvcm0gY2FuIGJlIGFsaWFzZWQgdGhyb3VnaCBwYXRoIG1hcHBpbmcuXHJcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBwbGF0Zm9ybTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvLyBDaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBhbiBgZXhwb3J0c2Agb2JqZWN0LlxyXG4gIGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcclxuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgc3VwcG9ydC5cclxuICAgIGZvck93bihwbGF0Zm9ybSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG4gICAgICBmcmVlRXhwb3J0c1trZXldID0gdmFsdWU7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICAvLyBFeHBvcnQgdG8gdGhlIGdsb2JhbCBvYmplY3QuXHJcbiAgICByb290LnBsYXRmb3JtID0gcGxhdGZvcm07XHJcbiAgfVxyXG59LmNhbGwodGhpcykpO1xyXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkbGwtcmVmZXJlbmNlIGRsbF9iOTM4MGM1NGI2YWViODZlNTFlNyAqLyBcImRsbC1yZWZlcmVuY2UgZGxsX2I5MzgwYzU0YjZhZWI4NmU1MWU3XCIpKShcIi4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qc1wiKTsiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSAvLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG5cbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XG5leHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZGxsLXJlZmVyZW5jZSBkbGxfYjkzODBjNTRiNmFlYjg2ZTUxZTcgKi8gXCJkbGwtcmVmZXJlbmNlIGRsbF9iOTM4MGM1NGI2YWViODZlNTFlN1wiKSkoXCIuL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qc1wiKTsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xufVxuIiwidmFyIFVOS05PV05fRlVOQ1RJT04gPSAnPHVua25vd24+Jztcbi8qKlxuICogVGhpcyBwYXJzZXMgdGhlIGRpZmZlcmVudCBzdGFjayB0cmFjZXMgYW5kIHB1dHMgdGhlbSBpbnRvIG9uZSBmb3JtYXRcbiAqIFRoaXMgYm9ycm93cyBoZWF2aWx5IGZyb20gVHJhY2VLaXQgKGh0dHBzOi8vZ2l0aHViLmNvbS9jc25vdmVyL1RyYWNlS2l0KVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0YWNrU3RyaW5nKSB7XG4gIHZhciBsaW5lcyA9IHN0YWNrU3RyaW5nLnNwbGl0KCdcXG4nKTtcbiAgcmV0dXJuIGxpbmVzLnJlZHVjZShmdW5jdGlvbiAoc3RhY2ssIGxpbmUpIHtcbiAgICB2YXIgcGFyc2VSZXN1bHQgPSBwYXJzZUNocm9tZShsaW5lKSB8fCBwYXJzZVdpbmpzKGxpbmUpIHx8IHBhcnNlR2Vja28obGluZSkgfHwgcGFyc2VOb2RlKGxpbmUpIHx8IHBhcnNlSlNDKGxpbmUpO1xuXG4gICAgaWYgKHBhcnNlUmVzdWx0KSB7XG4gICAgICBzdGFjay5wdXNoKHBhcnNlUmVzdWx0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH0sIFtdKTtcbn1cbnZhciBjaHJvbWVSZSA9IC9eXFxzKmF0ICguKj8pID9cXCgoKD86ZmlsZXxodHRwcz98YmxvYnxjaHJvbWUtZXh0ZW5zaW9ufG5hdGl2ZXxldmFsfHdlYnBhY2t8PGFub255bW91cz58XFwvfFthLXpdOlxcXFx8XFxcXFxcXFwpLio/KSg/OjooXFxkKykpPyg/OjooXFxkKykpP1xcKT9cXHMqJC9pO1xudmFyIGNocm9tZUV2YWxSZSA9IC9cXCgoXFxTKikoPzo6KFxcZCspKSg/OjooXFxkKykpXFwpLztcblxuZnVuY3Rpb24gcGFyc2VDaHJvbWUobGluZSkge1xuICB2YXIgcGFydHMgPSBjaHJvbWVSZS5leGVjKGxpbmUpO1xuXG4gIGlmICghcGFydHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBpc05hdGl2ZSA9IHBhcnRzWzJdICYmIHBhcnRzWzJdLmluZGV4T2YoJ25hdGl2ZScpID09PSAwOyAvLyBzdGFydCBvZiBsaW5lXG5cbiAgdmFyIGlzRXZhbCA9IHBhcnRzWzJdICYmIHBhcnRzWzJdLmluZGV4T2YoJ2V2YWwnKSA9PT0gMDsgLy8gc3RhcnQgb2YgbGluZVxuXG4gIHZhciBzdWJtYXRjaCA9IGNocm9tZUV2YWxSZS5leGVjKHBhcnRzWzJdKTtcblxuICBpZiAoaXNFdmFsICYmIHN1Ym1hdGNoICE9IG51bGwpIHtcbiAgICAvLyB0aHJvdyBvdXQgZXZhbCBsaW5lL2NvbHVtbiBhbmQgdXNlIHRvcC1tb3N0IGxpbmUvY29sdW1uIG51bWJlclxuICAgIHBhcnRzWzJdID0gc3VibWF0Y2hbMV07IC8vIHVybFxuXG4gICAgcGFydHNbM10gPSBzdWJtYXRjaFsyXTsgLy8gbGluZVxuXG4gICAgcGFydHNbNF0gPSBzdWJtYXRjaFszXTsgLy8gY29sdW1uXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZpbGU6ICFpc05hdGl2ZSA/IHBhcnRzWzJdIDogbnVsbCxcbiAgICBtZXRob2ROYW1lOiBwYXJ0c1sxXSB8fCBVTktOT1dOX0ZVTkNUSU9OLFxuICAgIGFyZ3VtZW50czogaXNOYXRpdmUgPyBbcGFydHNbMl1dIDogW10sXG4gICAgbGluZU51bWJlcjogcGFydHNbM10gPyArcGFydHNbM10gOiBudWxsLFxuICAgIGNvbHVtbjogcGFydHNbNF0gPyArcGFydHNbNF0gOiBudWxsXG4gIH07XG59XG5cbnZhciB3aW5qc1JlID0gL15cXHMqYXQgKD86KCg/OlxcW29iamVjdCBvYmplY3RcXF0pPy4rKSApP1xcKD8oKD86ZmlsZXxtcy1hcHB4fGh0dHBzP3x3ZWJwYWNrfGJsb2IpOi4qPyk6KFxcZCspKD86OihcXGQrKSk/XFwpP1xccyokL2k7XG5cbmZ1bmN0aW9uIHBhcnNlV2luanMobGluZSkge1xuICB2YXIgcGFydHMgPSB3aW5qc1JlLmV4ZWMobGluZSk7XG5cbiAgaWYgKCFwYXJ0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmaWxlOiBwYXJ0c1syXSxcbiAgICBtZXRob2ROYW1lOiBwYXJ0c1sxXSB8fCBVTktOT1dOX0ZVTkNUSU9OLFxuICAgIGFyZ3VtZW50czogW10sXG4gICAgbGluZU51bWJlcjogK3BhcnRzWzNdLFxuICAgIGNvbHVtbjogcGFydHNbNF0gPyArcGFydHNbNF0gOiBudWxsXG4gIH07XG59XG5cbnZhciBnZWNrb1JlID0gL15cXHMqKC4qPykoPzpcXCgoLio/KVxcKSk/KD86XnxAKSgoPzpmaWxlfGh0dHBzP3xibG9ifGNocm9tZXx3ZWJwYWNrfHJlc291cmNlfFxcW25hdGl2ZSkuKj98W15AXSpidW5kbGUpKD86OihcXGQrKSk/KD86OihcXGQrKSk/XFxzKiQvaTtcbnZhciBnZWNrb0V2YWxSZSA9IC8oXFxTKykgbGluZSAoXFxkKykoPzogPiBldmFsIGxpbmUgXFxkKykqID4gZXZhbC9pO1xuXG5mdW5jdGlvbiBwYXJzZUdlY2tvKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gZ2Vja29SZS5leGVjKGxpbmUpO1xuXG4gIGlmICghcGFydHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBpc0V2YWwgPSBwYXJ0c1szXSAmJiBwYXJ0c1szXS5pbmRleE9mKCcgPiBldmFsJykgPiAtMTtcbiAgdmFyIHN1Ym1hdGNoID0gZ2Vja29FdmFsUmUuZXhlYyhwYXJ0c1szXSk7XG5cbiAgaWYgKGlzRXZhbCAmJiBzdWJtYXRjaCAhPSBudWxsKSB7XG4gICAgLy8gdGhyb3cgb3V0IGV2YWwgbGluZS9jb2x1bW4gYW5kIHVzZSB0b3AtbW9zdCBsaW5lIG51bWJlclxuICAgIHBhcnRzWzNdID0gc3VibWF0Y2hbMV07XG4gICAgcGFydHNbNF0gPSBzdWJtYXRjaFsyXTtcbiAgICBwYXJ0c1s1XSA9IG51bGw7IC8vIG5vIGNvbHVtbiB3aGVuIGV2YWxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZmlsZTogcGFydHNbM10sXG4gICAgbWV0aG9kTmFtZTogcGFydHNbMV0gfHwgVU5LTk9XTl9GVU5DVElPTixcbiAgICBhcmd1bWVudHM6IHBhcnRzWzJdID8gcGFydHNbMl0uc3BsaXQoJywnKSA6IFtdLFxuICAgIGxpbmVOdW1iZXI6IHBhcnRzWzRdID8gK3BhcnRzWzRdIDogbnVsbCxcbiAgICBjb2x1bW46IHBhcnRzWzVdID8gK3BhcnRzWzVdIDogbnVsbFxuICB9O1xufVxuXG52YXIgamF2YVNjcmlwdENvcmVSZSA9IC9eXFxzKig/OihbXkBdKikoPzpcXCgoLio/KVxcKSk/QCk/KFxcUy4qPyk6KFxcZCspKD86OihcXGQrKSk/XFxzKiQvaTtcblxuZnVuY3Rpb24gcGFyc2VKU0MobGluZSkge1xuICB2YXIgcGFydHMgPSBqYXZhU2NyaXB0Q29yZVJlLmV4ZWMobGluZSk7XG5cbiAgaWYgKCFwYXJ0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmaWxlOiBwYXJ0c1szXSxcbiAgICBtZXRob2ROYW1lOiBwYXJ0c1sxXSB8fCBVTktOT1dOX0ZVTkNUSU9OLFxuICAgIGFyZ3VtZW50czogW10sXG4gICAgbGluZU51bWJlcjogK3BhcnRzWzRdLFxuICAgIGNvbHVtbjogcGFydHNbNV0gPyArcGFydHNbNV0gOiBudWxsXG4gIH07XG59XG5cbnZhciBub2RlUmUgPSAvXlxccyphdCAoPzooKD86XFxbb2JqZWN0IG9iamVjdFxcXSk/W15cXFxcL10rKD86IFxcW2FzIFxcUytcXF0pPykgKT9cXCg/KC4qPyk6KFxcZCspKD86OihcXGQrKSk/XFwpP1xccyokL2k7XG5cbmZ1bmN0aW9uIHBhcnNlTm9kZShsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IG5vZGVSZS5leGVjKGxpbmUpO1xuXG4gIGlmICghcGFydHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZmlsZTogcGFydHNbMl0sXG4gICAgbWV0aG9kTmFtZTogcGFydHNbMV0gfHwgVU5LTk9XTl9GVU5DVElPTixcbiAgICBhcmd1bWVudHM6IFtdLFxuICAgIGxpbmVOdW1iZXI6ICtwYXJ0c1szXSxcbiAgICBjb2x1bW46IHBhcnRzWzRdID8gK3BhcnRzWzRdIDogbnVsbFxuICB9O1xufVxuXG5leHBvcnQgeyBwYXJzZSB9O1xuIiwidmFyIHQsbixlPWZ1bmN0aW9uKCl7cmV0dXJuXCJcIi5jb25jYXQoRGF0ZS5ub3coKSxcIi1cIikuY29uY2F0KE1hdGguZmxvb3IoODk5OTk5OTk5OTk5OSpNYXRoLnJhbmRvbSgpKSsxZTEyKX0saT1mdW5jdGlvbih0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06LTE7cmV0dXJue25hbWU6dCx2YWx1ZTpuLGRlbHRhOjAsZW50cmllczpbXSxpZDplKCksaXNGaW5hbDohMX19LGE9ZnVuY3Rpb24odCxuKXt0cnl7aWYoUGVyZm9ybWFuY2VPYnNlcnZlci5zdXBwb3J0ZWRFbnRyeVR5cGVzLmluY2x1ZGVzKHQpKXt2YXIgZT1uZXcgUGVyZm9ybWFuY2VPYnNlcnZlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0RW50cmllcygpLm1hcChuKX0pKTtyZXR1cm4gZS5vYnNlcnZlKHt0eXBlOnQsYnVmZmVyZWQ6ITB9KSxlfX1jYXRjaCh0KXt9fSxyPSExLG89ITEscz1mdW5jdGlvbih0KXtyPSF0LnBlcnNpc3RlZH0sdT1mdW5jdGlvbigpe2FkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLHMpLGFkZEV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIiwoZnVuY3Rpb24oKXt9KSl9LGM9ZnVuY3Rpb24odCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXTtvfHwodSgpLG89ITApLGFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsKGZ1bmN0aW9uKG4pe3ZhciBlPW4udGltZVN0YW1wO1wiaGlkZGVuXCI9PT1kb2N1bWVudC52aXNpYmlsaXR5U3RhdGUmJnQoe3RpbWVTdGFtcDplLGlzVW5sb2FkaW5nOnJ9KX0pLHtjYXB0dXJlOiEwLG9uY2U6bn0pfSxsPWZ1bmN0aW9uKHQsbixlLGkpe3ZhciBhO3JldHVybiBmdW5jdGlvbigpe2UmJm4uaXNGaW5hbCYmZS5kaXNjb25uZWN0KCksbi52YWx1ZT49MCYmKGl8fG4uaXNGaW5hbHx8XCJoaWRkZW5cIj09PWRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSkmJihuLmRlbHRhPW4udmFsdWUtKGF8fDApLChuLmRlbHRhfHxuLmlzRmluYWx8fHZvaWQgMD09PWEpJiYodChuKSxhPW4udmFsdWUpKX19LHA9ZnVuY3Rpb24odCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXSxlPWkoXCJDTFNcIiwwKSxyPWZ1bmN0aW9uKHQpe3QuaGFkUmVjZW50SW5wdXR8fChlLnZhbHVlKz10LnZhbHVlLGUuZW50cmllcy5wdXNoKHQpLHMoKSl9LG89YShcImxheW91dC1zaGlmdFwiLHIpLHM9bCh0LGUsbyxuKTtjKChmdW5jdGlvbih0KXt2YXIgbj10LmlzVW5sb2FkaW5nO28mJm8udGFrZVJlY29yZHMoKS5tYXAociksbiYmKGUuaXNGaW5hbD0hMCkscygpfSkpfSxkPWZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PVwiaGlkZGVuXCI9PT1kb2N1bWVudC52aXNpYmlsaXR5U3RhdGU/MDoxLzAsYygoZnVuY3Rpb24obil7dmFyIGU9bi50aW1lU3RhbXA7cmV0dXJuIHQ9ZX0pLCEwKSkse2dldCB0aW1lU3RhbXAoKXtyZXR1cm4gdH19fSxtPWZ1bmN0aW9uKHQpe3ZhciBuPWkoXCJGQ1BcIiksZT1kKCkscj1hKFwicGFpbnRcIiwoZnVuY3Rpb24odCl7XCJmaXJzdC1jb250ZW50ZnVsLXBhaW50XCI9PT10Lm5hbWUmJnQuc3RhcnRUaW1lPGUudGltZVN0YW1wJiYobi52YWx1ZT10LnN0YXJ0VGltZSxuLmlzRmluYWw9ITAsbi5lbnRyaWVzLnB1c2godCksbygpKX0pKSxvPWwodCxuLHIpfSx2PWZ1bmN0aW9uKHQpe3ZhciBuPWkoXCJGSURcIiksZT1kKCkscj1mdW5jdGlvbih0KXt0LnN0YXJ0VGltZTxlLnRpbWVTdGFtcCYmKG4udmFsdWU9dC5wcm9jZXNzaW5nU3RhcnQtdC5zdGFydFRpbWUsbi5lbnRyaWVzLnB1c2godCksbi5pc0ZpbmFsPSEwLHMoKSl9LG89YShcImZpcnN0LWlucHV0XCIscikscz1sKHQsbixvKTtjKChmdW5jdGlvbigpe28mJihvLnRha2VSZWNvcmRzKCkubWFwKHIpLG8uZGlzY29ubmVjdCgpKX0pLCEwKSxvfHx3aW5kb3cucGVyZk1ldHJpY3MmJndpbmRvdy5wZXJmTWV0cmljcy5vbkZpcnN0SW5wdXREZWxheSYmd2luZG93LnBlcmZNZXRyaWNzLm9uRmlyc3RJbnB1dERlbGF5KChmdW5jdGlvbih0LGkpe2kudGltZVN0YW1wPGUudGltZVN0YW1wJiYobi52YWx1ZT10LG4uaXNGaW5hbD0hMCxuLmVudHJpZXM9W3tlbnRyeVR5cGU6XCJmaXJzdC1pbnB1dFwiLG5hbWU6aS50eXBlLHRhcmdldDppLnRhcmdldCxjYW5jZWxhYmxlOmkuY2FuY2VsYWJsZSxzdGFydFRpbWU6aS50aW1lU3RhbXAscHJvY2Vzc2luZ1N0YXJ0OmkudGltZVN0YW1wK3R9XSxzKCkpfSkpfSxmPWZ1bmN0aW9uKCl7cmV0dXJuIG58fChuPW5ldyBQcm9taXNlKChmdW5jdGlvbih0KXtyZXR1cm5bXCJzY3JvbGxcIixcImtleWRvd25cIixcInBvaW50ZXJkb3duXCJdLm1hcCgoZnVuY3Rpb24obil7YWRkRXZlbnRMaXN0ZW5lcihuLHQse29uY2U6ITAscGFzc2l2ZTohMCxjYXB0dXJlOiEwfSl9KSl9KSkpLG59LGc9ZnVuY3Rpb24odCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXSxlPWkoXCJMQ1BcIikscj1kKCksbz1mdW5jdGlvbih0KXt2YXIgbj10LnN0YXJ0VGltZTtuPHIudGltZVN0YW1wPyhlLnZhbHVlPW4sZS5lbnRyaWVzLnB1c2godCkpOmUuaXNGaW5hbD0hMCx1KCl9LHM9YShcImxhcmdlc3QtY29udGVudGZ1bC1wYWludFwiLG8pLHU9bCh0LGUscyxuKSxwPWZ1bmN0aW9uKCl7ZS5pc0ZpbmFsfHwocyYmcy50YWtlUmVjb3JkcygpLm1hcChvKSxlLmlzRmluYWw9ITAsdSgpKX07ZigpLnRoZW4ocCksYyhwLCEwKX0saD1mdW5jdGlvbih0KXt2YXIgbixlPWkoXCJUVEZCXCIpO249ZnVuY3Rpb24oKXt0cnl7dmFyIG49cGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5VHlwZShcIm5hdmlnYXRpb25cIilbMF18fGZ1bmN0aW9uKCl7dmFyIHQ9cGVyZm9ybWFuY2UudGltaW5nLG49e2VudHJ5VHlwZTpcIm5hdmlnYXRpb25cIixzdGFydFRpbWU6MH07Zm9yKHZhciBlIGluIHQpXCJuYXZpZ2F0aW9uU3RhcnRcIiE9PWUmJlwidG9KU09OXCIhPT1lJiYobltlXT1NYXRoLm1heCh0W2VdLXQubmF2aWdhdGlvblN0YXJ0LDApKTtyZXR1cm4gbn0oKTtlLnZhbHVlPWUuZGVsdGE9bi5yZXNwb25zZVN0YXJ0LGUuZW50cmllcz1bbl0sZS5pc0ZpbmFsPSEwLHQoZSl9Y2F0Y2godCl7fX0sXCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZT9zZXRUaW1lb3V0KG4sMCk6YWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VzaG93XCIsbil9O2V4cG9ydHtwIGFzIGdldENMUyxtIGFzIGdldEZDUCx2IGFzIGdldEZJRCxnIGFzIGdldExDUCxoIGFzIGdldFRURkJ9O1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwidHJ5e3NlbGZbXCJ3b3JrYm94OndpbmRvdzo1LjEuM1wiXSYmXygpfWNhdGNoKG4pe31mdW5jdGlvbiBuKG4sdCl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihyKXt2YXIgaT1uZXcgTWVzc2FnZUNoYW5uZWw7aS5wb3J0MS5vbm1lc3NhZ2U9ZnVuY3Rpb24obil7cihuLmRhdGEpfSxuLnBvc3RNZXNzYWdlKHQsW2kucG9ydDJdKX0pKX1mdW5jdGlvbiB0KG4sdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBpPXRbcl07aS5lbnVtZXJhYmxlPWkuZW51bWVyYWJsZXx8ITEsaS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLGkua2V5LGkpfX10cnl7c2VsZltcIndvcmtib3g6Y29yZTo1LjEuM1wiXSYmXygpfWNhdGNoKG4pe312YXIgcj1mdW5jdGlvbigpe3ZhciBuPXRoaXM7dGhpcy5wcm9taXNlPW5ldyBQcm9taXNlKChmdW5jdGlvbih0LHIpe24ucmVzb2x2ZT10LG4ucmVqZWN0PXJ9KSl9O2Z1bmN0aW9uIGkobix0KXt2YXIgcj1sb2NhdGlvbi5ocmVmO3JldHVybiBuZXcgVVJMKG4scikuaHJlZj09PW5ldyBVUkwodCxyKS5ocmVmfXZhciBlPWZ1bmN0aW9uKG4sdCl7dGhpcy50eXBlPW4sT2JqZWN0LmFzc2lnbih0aGlzLHQpfTtmdW5jdGlvbiBvKG4sdCxyKXtyZXR1cm4gcj90P3Qobik6bjoobiYmbi50aGVufHwobj1Qcm9taXNlLnJlc29sdmUobikpLHQ/bi50aGVuKHQpOm4pfWZ1bmN0aW9uIHUoKXt9dmFyIGE9ZnVuY3Rpb24odSl7dmFyIGEsZjtmdW5jdGlvbiBzKG4sdCl7dmFyIGEsYztyZXR1cm4gdm9pZCAwPT09dCYmKHQ9e30pLChhPXUuY2FsbCh0aGlzKXx8dGhpcykudD17fSxhLmk9MCxhLm89bmV3IHIsYS51PW5ldyByLGEucz1uZXcgcixhLnY9MCxhLmg9bmV3IFNldCxhLmw9ZnVuY3Rpb24oKXt2YXIgbj1hLmcsdD1uLmluc3RhbGxpbmc7YS5pPjB8fCFpKHQuc2NyaXB0VVJMLGEubSl8fHBlcmZvcm1hbmNlLm5vdygpPmEudis2ZTQ/KGEuUD10LG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZvdW5kXCIsYS5sKSk6KGEucD10LGEuaC5hZGQodCksYS5vLnJlc29sdmUodCkpLCsrYS5pLHQuYWRkRXZlbnRMaXN0ZW5lcihcInN0YXRlY2hhbmdlXCIsYS5rKX0sYS5rPWZ1bmN0aW9uKG4pe3ZhciB0PWEuZyxyPW4udGFyZ2V0LGk9ci5zdGF0ZSxvPXI9PT1hLlAsdT1vP1wiZXh0ZXJuYWxcIjpcIlwiLGM9e3N3OnIsb3JpZ2luYWxFdmVudDpufTshbyYmYS5qJiYoYy5pc1VwZGF0ZT0hMCksYS5kaXNwYXRjaEV2ZW50KG5ldyBlKHUraSxjKSksXCJpbnN0YWxsZWRcIj09PWk/YS5PPXNlbGYuc2V0VGltZW91dCgoZnVuY3Rpb24oKXtcImluc3RhbGxlZFwiPT09aSYmdC53YWl0aW5nPT09ciYmYS5kaXNwYXRjaEV2ZW50KG5ldyBlKHUrXCJ3YWl0aW5nXCIsYykpfSksMjAwKTpcImFjdGl2YXRpbmdcIj09PWkmJihjbGVhclRpbWVvdXQoYS5PKSxvfHxhLnUucmVzb2x2ZShyKSl9LGEuUj1mdW5jdGlvbihuKXt2YXIgdD1hLnA7dD09PW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXImJihhLmRpc3BhdGNoRXZlbnQobmV3IGUoXCJjb250cm9sbGluZ1wiLHtzdzp0LG9yaWdpbmFsRXZlbnQ6bixpc1VwZGF0ZTphLmp9KSksYS5zLnJlc29sdmUodCkpfSxhLlM9KGM9ZnVuY3Rpb24obil7dmFyIHQ9bi5kYXRhLHI9bi5zb3VyY2U7cmV0dXJuIG8oYS5nZXRTVygpLChmdW5jdGlvbigpe2EuaC5oYXMocikmJmEuZGlzcGF0Y2hFdmVudChuZXcgZShcIm1lc3NhZ2VcIix7ZGF0YTp0LHN3OnIsb3JpZ2luYWxFdmVudDpufSkpfSkpfSxmdW5jdGlvbigpe2Zvcih2YXIgbj1bXSx0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyluW3RdPWFyZ3VtZW50c1t0XTt0cnl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShjLmFwcGx5KHRoaXMsbikpfWNhdGNoKG4pe3JldHVybiBQcm9taXNlLnJlamVjdChuKX19KSxhLm09bixhLnQ9dCxuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGEuUyksYX1mPXUsKGE9cykucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZi5wcm90b3R5cGUpLGEucHJvdG90eXBlLmNvbnN0cnVjdG9yPWEsYS5fX3Byb3RvX189Zjt2YXIgdixoLHcsbD1zLnByb3RvdHlwZTtyZXR1cm4gbC5yZWdpc3Rlcj1mdW5jdGlvbihuKXt2YXIgdD0odm9pZCAwPT09bj97fTpuKS5pbW1lZGlhdGUscj12b2lkIDAhPT10JiZ0O3RyeXt2YXIgdT10aGlzO3JldHVybiBmdW5jdGlvbihuLHQpe3ZhciByPW4oKTtpZihyJiZyLnRoZW4pcmV0dXJuIHIudGhlbih0KTtyZXR1cm4gdChyKX0oKGZ1bmN0aW9uKCl7aWYoIXImJlwiY29tcGxldGVcIiE9PWRvY3VtZW50LnJlYWR5U3RhdGUpcmV0dXJuIGMobmV3IFByb21pc2UoKGZ1bmN0aW9uKG4pe3JldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixuKX0pKSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gdS5qPUJvb2xlYW4obmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlciksdS5VPXUuQigpLG8odS5MKCksKGZ1bmN0aW9uKG4pe3UuZz1uLHUuVSYmKHUucD11LlUsdS51LnJlc29sdmUodS5VKSx1LnMucmVzb2x2ZSh1LlUpLHUuVS5hZGRFdmVudExpc3RlbmVyKFwic3RhdGVjaGFuZ2VcIix1Lmsse29uY2U6ITB9KSk7dmFyIHQ9dS5nLndhaXRpbmc7cmV0dXJuIHQmJmkodC5zY3JpcHRVUkwsdS5tKSYmKHUucD10LFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7dS5kaXNwYXRjaEV2ZW50KG5ldyBlKFwid2FpdGluZ1wiLHtzdzp0LHdhc1dhaXRpbmdCZWZvcmVSZWdpc3RlcjohMH0pKX0pKS50aGVuKChmdW5jdGlvbigpe30pKSksdS5wJiYodS5vLnJlc29sdmUodS5wKSx1LmguYWRkKHUucCkpLHUuZy5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZm91bmRcIix1LmwpLG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250cm9sbGVyY2hhbmdlXCIsdS5SLHtvbmNlOiEwfSksdS5nfSkpfSkpfWNhdGNoKG4pe3JldHVybiBQcm9taXNlLnJlamVjdChuKX19LGwudXBkYXRlPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiB0aGlzLmc/Yyh0aGlzLmcudXBkYXRlKCkpOnZvaWQgMH1jYXRjaChuKXtyZXR1cm4gUHJvbWlzZS5yZWplY3Qobil9fSxsLmdldFNXPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiB2b2lkIDAhPT10aGlzLnA/dGhpcy5wOnRoaXMuby5wcm9taXNlfWNhdGNoKG4pe3JldHVybiBQcm9taXNlLnJlamVjdChuKX19LGwubWVzc2FnZVNXPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4gbyh0aGlzLmdldFNXKCksKGZ1bmN0aW9uKHIpe3JldHVybiBuKHIsdCl9KSl9Y2F0Y2gobil7cmV0dXJuIFByb21pc2UucmVqZWN0KG4pfX0sbC5CPWZ1bmN0aW9uKCl7dmFyIG49bmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcjtyZXR1cm4gbiYmaShuLnNjcmlwdFVSTCx0aGlzLm0pP246dm9pZCAwfSxsLkw9ZnVuY3Rpb24oKXt0cnl7dmFyIG49dGhpcztyZXR1cm4gZnVuY3Rpb24obix0KXt0cnl7dmFyIHI9bigpfWNhdGNoKG4pe3JldHVybiB0KG4pfWlmKHImJnIudGhlbilyZXR1cm4gci50aGVuKHZvaWQgMCx0KTtyZXR1cm4gcn0oKGZ1bmN0aW9uKCl7cmV0dXJuIG8obmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVnaXN0ZXIobi5tLG4udCksKGZ1bmN0aW9uKHQpe3JldHVybiBuLnY9cGVyZm9ybWFuY2Uubm93KCksdH0pKX0pLChmdW5jdGlvbihuKXt0aHJvdyBufSkpfWNhdGNoKG4pe3JldHVybiBQcm9taXNlLnJlamVjdChuKX19LHY9cywoaD1be2tleTpcImFjdGl2ZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnUucHJvbWlzZX19LHtrZXk6XCJjb250cm9sbGluZ1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnMucHJvbWlzZX19XSkmJnQodi5wcm90b3R5cGUsaCksdyYmdCh2LHcpLHN9KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gbigpe3RoaXMuTT1uZXcgTWFwfXZhciB0PW4ucHJvdG90eXBlO3JldHVybiB0LmFkZEV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24obix0KXt0aGlzLl8obikuYWRkKHQpfSx0LnJlbW92ZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24obix0KXt0aGlzLl8obikuZGVsZXRlKHQpfSx0LmRpc3BhdGNoRXZlbnQ9ZnVuY3Rpb24obil7bi50YXJnZXQ9dGhpczt2YXIgdD10aGlzLl8obi50eXBlKSxyPUFycmF5LmlzQXJyYXkodCksaT0wO2Zvcih0PXI/dDp0W1N5bWJvbC5pdGVyYXRvcl0oKTs7KXt2YXIgZTtpZihyKXtpZihpPj10Lmxlbmd0aClicmVhaztlPXRbaSsrXX1lbHNle2lmKChpPXQubmV4dCgpKS5kb25lKWJyZWFrO2U9aS52YWx1ZX1lKG4pfX0sdC5fPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLk0uaGFzKG4pfHx0aGlzLk0uc2V0KG4sbmV3IFNldCksdGhpcy5NLmdldChuKX0sbn0oKSk7ZnVuY3Rpb24gYyhuLHQpe2lmKCF0KXJldHVybiBuJiZuLnRoZW4/bi50aGVuKHUpOlByb21pc2UucmVzb2x2ZSgpfWV4cG9ydHthIGFzIFdvcmtib3gsbiBhcyBtZXNzYWdlU1d9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29ya2JveC13aW5kb3cucHJvZC5lczUubWpzLm1hcFxuIiwibW9kdWxlLmV4cG9ydHMgPSBkbGxfYjkzODBjNTRiNmFlYjg2ZTUxZTc7Il0sInNvdXJjZVJvb3QiOiIifQ==